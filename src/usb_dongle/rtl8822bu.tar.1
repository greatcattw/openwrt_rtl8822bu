= (int *)wrqu;
	int selector;

	if (rtw_is_drv_stopped(padapter) || (pdata == NULL)) {
		ret = -EINVAL;
		goto exit;
	}

	selector = *pdata;
	if (selector < 3 && selector >= 0) {
		padapter->pid[selector] = *(pdata + 1);
#ifdef CONFIG_GLOBAL_UI_PID
		ui_pid[selector] = *(pdata + 1);
#endif
		RTW_INFO("%s set pid[%d]=%d\n", __FUNCTION__, selector , padapter->pid[selector]);
	} else
		RTW_INFO("%s selector %d error\n", __FUNCTION__, selector);

exit:

	return ret;

}

static int rtw_wps_start(struct net_device *dev,
			 struct iw_request_info *info,
			 union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct iw_point *pdata = &wrqu->data;
	u32   u32wps_start = 0;
	unsigned int uintRet = 0;

	if (RTW_CANNOT_RUN(padapter) || (NULL == pdata)) {
		ret = -EINVAL;
		goto exit;
	}

	uintRet = copy_from_user((void *) &u32wps_start, pdata->pointer, 4);
	if (u32wps_start == 0)
		u32wps_start = *extra;

	RTW_INFO("[%s] wps_start = %d\n", __FUNCTION__, u32wps_start);

	if (u32wps_start == 1)   /* WPS Start */
		rtw_led_control(padapter, LED_CTL_START_WPS);
	else if (u32wps_start == 2)   /* WPS Stop because of wps success */
		rtw_led_control(padapter, LED_CTL_STOP_WPS);
	else if (u32wps_start == 3)   /* WPS Stop because of wps fail */
		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);

exit:

	return ret;

}

#ifdef CONFIG_P2P
static int rtw_wext_p2p_enable(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
	enum P2P_ROLE init_role = P2P_ROLE_DISABLE;

	if (*extra == '0')
		init_role = P2P_ROLE_DISABLE;
	else if (*extra == '1')
		init_role = P2P_ROLE_DEVICE;
	else if (*extra == '2')
		init_role = P2P_ROLE_CLIENT;
	else if (*extra == '3')
		init_role = P2P_ROLE_GO;

	if (_FAIL == rtw_p2p_enable(padapter, init_role)) {
		ret = -EFAULT;
		goto exit;
	}

	/* set channel/bandwidth */
	if (init_role != P2P_ROLE_DISABLE) {
		u8 channel, ch_offset;
		u16 bwmode;

		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN)) {
			/*	Stay at the listen state and wait for discovery. */
			channel = pwdinfo->listen_channel;
			pwdinfo->operating_channel = pwdinfo->listen_channel;
			ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
			bwmode = CHANNEL_WIDTH_20;
		}
#ifdef CONFIG_CONCURRENT_MODE
		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {

			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval);

			channel = rtw_mi_get_union_chan(padapter);
			ch_offset = rtw_mi_get_union_offset(padapter);
			bwmode = rtw_mi_get_union_bw(padapter);

			pwdinfo->operating_channel = channel;
		}
#endif
		else {
			pwdinfo->operating_channel = pmlmeext->cur_channel;

			channel = pwdinfo->operating_channel;
			ch_offset = pmlmeext->cur_ch_offset;
			bwmode = pmlmeext->cur_bwmode;
		}

		set_channel_bwmode(padapter, channel, ch_offset, bwmode);
	}

exit:
	return ret;

}

static int rtw_p2p_set_go_nego_ssid(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] ssid = %s, len = %zu\n", __FUNCTION__, extra, strlen(extra));
	_rtw_memcpy(pwdinfo->nego_ssid, extra, strlen(extra));
	pwdinfo->nego_ssidlen = strlen(extra);

	return ret;

}


static int rtw_p2p_set_intent(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	int							ret = 0;
	_adapter						*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info			*pwdinfo = &(padapter->wdinfo);
	u8							intent = pwdinfo->intent;

	extra[wrqu->data.length] = 0x00;

	intent = rtw_atoi(extra);

	if (intent <= 15)
		pwdinfo->intent = intent;
	else
		ret = -1;

	RTW_INFO("[%s] intent = %d\n", __FUNCTION__, intent);

	return ret;

}

static int rtw_p2p_set_listen_ch(struct net_device *dev,
				 struct iw_request_info *info,
				 union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
	u8	listen_ch = pwdinfo->listen_channel;	/*	Listen channel number */

	extra[wrqu->data.length] = 0x00;
	listen_ch = rtw_atoi(extra);

	if ((listen_ch == 1) || (listen_ch == 6) || (listen_ch == 11)) {
		pwdinfo->listen_channel = listen_ch;
		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
	} else
		ret = -1;

	RTW_INFO("[%s] listen_ch = %d\n", __FUNCTION__, pwdinfo->listen_channel);

	return ret;

}

static int rtw_p2p_set_op_ch(struct net_device *dev,
			     struct iw_request_info *info,
			     union iwreq_data *wrqu, char *extra)
{
	/*	Commented by Albert 20110524
	 *	This function is used to set the operating channel if the driver will become the group owner */

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
	u8	op_ch = pwdinfo->operating_channel;	/*	Operating channel number */

	extra[wrqu->data.length] = 0x00;

	op_ch = (u8) rtw_atoi(extra);
	if (op_ch > 0)
		pwdinfo->operating_channel = op_ch;
	else
		ret = -1;

	RTW_INFO("[%s] op_ch = %d\n", __FUNCTION__, pwdinfo->operating_channel);

	return ret;

}


static int rtw_p2p_profilefound(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);

	/*	Comment by Albert 2010/10/13 */
	/*	Input data format: */
	/*	Ex:  0 */
	/*	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
	/*	0 => Reflush the profile record list. */
	/*	1 => Add the profile list */
	/*	XX:XX:XX:XX:XX:XX => peer's MAC Address ( ex: 00:E0:4C:00:00:01 ) */
	/*	YY => SSID Length */
	/*	SSID => SSID for persistence group */

	RTW_INFO("[%s] In value = %s, len = %d\n", __FUNCTION__, extra, wrqu->data.length - 1);


	/*	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function. */
	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
		if (extra[0] == '0') {
			/*	Remove all the profile information of wifidirect_info structure. */
			_rtw_memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
			pwdinfo->profileindex = 0;
		} else {
			if (pwdinfo->profileindex >= P2P_MAX_PERSISTENT_GROUP_NUM)
				ret = -1;
			else {
				int jj, kk;

				/*	Add this profile information into pwdinfo->profileinfo */
				/*	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
				for (jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3)
					pwdinfo->profileinfo[pwdinfo->profileindex].peermac[jj] = key_2char2num(extra[kk], extra[kk + 1]);

				/* pwdinfo->profileinfo[pwdinfo->profileindex].ssidlen = ( extra[18] - '0' ) * 10 + ( extra[19] - '0' ); */
				/* _rtw_memcpy( pwdinfo->profileinfo[pwdinfo->profileindex].ssid, &extra[20], pwdinfo->profileinfo[pwdinfo->profileindex].ssidlen ); */
				pwdinfo->profileindex++;
			}
		}
	}

	return ret;

}

static int rtw_p2p_setDN(struct net_device *dev,
			 struct iw_request_info *info,
			 union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);


	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);
	_rtw_memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
	_rtw_memcpy(pwdinfo->device_name, extra, wrqu->data.length - 1);
	pwdinfo->device_name_len = wrqu->data.length - 1;

	return ret;

}


static int rtw_p2p_get_status(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	if (padapter->bShowGetP2PState) {
		RTW_INFO("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
	}

	/*	Commented by Albert 2010/10/12 */
	/*	Because of the output size limitation, I had removed the "Role" information. */
	/*	About the "Role" information, we will use the new private IOCTL to get the "Role" information. */
	sprintf(extra, "\n\nStatus=%.2d\n", rtw_p2p_state(pwdinfo));
	wrqu->data.length = strlen(extra);

	return ret;

}

/*	Commented by Albert 20110520
 *	This function will return the config method description
 *	This config method description will show us which config method the remote P2P device is intented to use
 *	by sending the provisioning discovery request frame. */

static int rtw_p2p_get_req_cm(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	sprintf(extra, "\n\nCM=%s\n", pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
	wrqu->data.length = strlen(extra);
	return ret;

}


static int rtw_p2p_get_role(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
		pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
		pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);

	sprintf(extra, "\n\nRole=%.2d\n", rtw_p2p_role(pwdinfo));
	wrqu->data.length = strlen(extra);
	return ret;

}


static int rtw_p2p_get_peer_ifaddr(struct net_device *dev,
				   struct iw_request_info *info,
				   union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);


	RTW_INFO("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
		pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
		pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);

	sprintf(extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
		pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
		pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
	wrqu->data.length = strlen(extra);
	return ret;

}

static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)

{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
		pwdinfo->rx_prov_disc_info.peerDevAddr[0], pwdinfo->rx_prov_disc_info.peerDevAddr[1],
		pwdinfo->rx_prov_disc_info.peerDevAddr[2], pwdinfo->rx_prov_disc_info.peerDevAddr[3],
		pwdinfo->rx_prov_disc_info.peerDevAddr[4], pwdinfo->rx_prov_disc_info.peerDevAddr[5]);
	sprintf(extra, "\n%.2X%.2X%.2X%.2X%.2X%.2X",
		pwdinfo->rx_prov_disc_info.peerDevAddr[0], pwdinfo->rx_prov_disc_info.peerDevAddr[1],
		pwdinfo->rx_prov_disc_info.peerDevAddr[2], pwdinfo->rx_prov_disc_info.peerDevAddr[3],
		pwdinfo->rx_prov_disc_info.peerDevAddr[4], pwdinfo->rx_prov_disc_info.peerDevAddr[5]);
	wrqu->data.length = strlen(extra);
	return ret;

}

static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra)

{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
		pwdinfo->p2p_peer_device_addr[0], pwdinfo->p2p_peer_device_addr[1],
		pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
		pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
	sprintf(extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
		pwdinfo->p2p_peer_device_addr[0], pwdinfo->p2p_peer_device_addr[1],
		pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
		pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
	wrqu->data.length = strlen(extra);
	return ret;

}

static int rtw_p2p_get_groupid(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)

{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	sprintf(extra, "\n%.2X:%.2X:%.2X:%.2X:%.2X:%.2X %s",
		pwdinfo->groupid_info.go_device_addr[0], pwdinfo->groupid_info.go_device_addr[1],
		pwdinfo->groupid_info.go_device_addr[2], pwdinfo->groupid_info.go_device_addr[3],
		pwdinfo->groupid_info.go_device_addr[4], pwdinfo->groupid_info.go_device_addr[5],
		pwdinfo->groupid_info.ssid);
	wrqu->data.length = strlen(extra);
	return ret;

}

static int rtw_p2p_get_op_ch(struct net_device *dev,
			     struct iw_request_info *info,
			     union iwreq_data *wrqu, char *extra)

{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);


	RTW_INFO("[%s] Op_ch = %02x\n", __FUNCTION__, pwdinfo->operating_channel);

	sprintf(extra, "\n\nOp_ch=%.2d\n", pwdinfo->operating_channel);
	wrqu->data.length = strlen(extra);
	return ret;

}

static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
					struct iw_request_info *info,
			union iwreq_data *wrqu, char *extra, char *subcmd)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 peerMAC[ETH_ALEN] = { 0x00 };
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	_irqL irqL;
	_list *plist, *phead;
	_queue *queue = &(pmlmepriv->scanned_queue);
	struct wlan_network *pnetwork = NULL;
	u8 blnMatch = 0;
	u16	attr_content = 0;
	uint attr_contentlen = 0;
	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };

	/*	Commented by Albert 20110727 */
	/*	The input data is the MAC address which the application wants to know its WPS config method. */
	/*	After knowing its WPS config method, the application can decide the config method for provisioning discovery. */
	/*	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, subcmd);

	macstr2num(peerMAC, subcmd);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
			u8 *wpsie;
			uint	wpsie_len = 0;

			/*	The mac address is matched. */

			wpsie = rtw_get_wps_ie_from_scan_queue(&pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0]);
			if (wpsie) {
				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_CONF_METHOD, (u8 *)&attr_content, &attr_contentlen);
				if (attr_contentlen) {
					attr_content = be16_to_cpu(attr_content);
					sprintf(attr_content_str, "\n\nM=%.4d", attr_content);
					blnMatch = 1;
				}
			}

			break;
		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (!blnMatch)
		sprintf(attr_content_str, "\n\nM=0000");

	wrqu->data.length = strlen(attr_content_str);
	_rtw_memcpy(extra, attr_content_str, wrqu->data.length);

	return ret;

}

#ifdef CONFIG_WFD
static int rtw_p2p_get_peer_wfd_port(struct net_device *dev,
				     struct iw_request_info *info,
				     union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] p2p_state = %d\n", __FUNCTION__, rtw_p2p_state(pwdinfo));

	sprintf(extra, "\n\nPort=%d\n", pwdinfo->wfd_info->peer_rtsp_ctrlport);
	RTW_INFO("[%s] remote port = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_rtsp_ctrlport);

	wrqu->data.length = strlen(extra);
	return ret;

}

static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	sprintf(extra, "\n\nwfd_pc=%d\n", pwdinfo->wfd_info->wfd_pc);
	RTW_INFO("[%s] wfd_pc = %d\n", __FUNCTION__, pwdinfo->wfd_info->wfd_pc);

	wrqu->data.length = strlen(extra);
	pwdinfo->wfd_info->wfd_pc = _FALSE;	/*	Reset the WFD preferred connection to P2P */
	return ret;

}

static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);

	sprintf(extra, "\n\nwfd_sa=%d\n", pwdinfo->wfd_info->peer_session_avail);
	RTW_INFO("[%s] wfd_sa = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_session_avail);

	wrqu->data.length = strlen(extra);
	pwdinfo->wfd_info->peer_session_avail = _TRUE;	/*	Reset the WFD session available */
	return ret;

}
#endif /* CONFIG_WFD */

static int rtw_p2p_get_go_device_address(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra, char *subcmd)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 peerMAC[ETH_ALEN] = { 0x00 };
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	_irqL irqL;
	_list *plist, *phead;
	_queue *queue	= &(pmlmepriv->scanned_queue);
	struct wlan_network *pnetwork = NULL;
	u8 blnMatch = 0;
	u8 *p2pie;
	uint p2pielen = 0, attr_contentlen = 0;
	u8 attr_content[100] = { 0x00 };
	u8 go_devadd_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };

	/*	Commented by Albert 20121209 */
	/*	The input data is the GO's interface address which the application wants to know its device address. */
	/*	Format: iwpriv wlanx p2p_get2 go_devadd=00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, subcmd);

	macstr2num(peerMAC, subcmd);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
			/*	Commented by Albert 2011/05/18 */
			/*	Match the device address located in the P2P IE */
			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */

			p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
			if (p2pie) {
				while (p2pie) {
					/*	The P2P Device ID attribute is included in the Beacon frame. */
					/*	The P2P Device Info attribute is included in the probe response frame. */

					_rtw_memset(attr_content, 0x00, 100);
					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
						/*	Handle the P2P Device ID attribute of Beacon first */
						blnMatch = 1;
						break;

					} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
						/*	Handle the P2P Device Info attribute of probe response */
						blnMatch = 1;
						break;
					}

					/* Get the next P2P IE */
					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, BSS_EX_TLV_IES_LEN(&pnetwork->network) - (p2pie + p2pielen - BSS_EX_TLV_IES(&pnetwork->network)), NULL, &p2pielen);
				}
			}
		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (!blnMatch)
		sprintf(go_devadd_str, "\n\ndev_add=NULL");
	else {
		sprintf(go_devadd_str, "\n\ndev_add=%.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
			attr_content[0], attr_content[1], attr_content[2], attr_content[3], attr_content[4], attr_content[5]);
	}

	wrqu->data.length = strlen(go_devadd_str);
	_rtw_memcpy(extra, go_devadd_str, wrqu->data.length);

	return ret;

}

static int rtw_p2p_get_device_type(struct net_device *dev,
				   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra, char *subcmd)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 peerMAC[ETH_ALEN] = { 0x00 };
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	_irqL irqL;
	_list *plist, *phead;
	_queue *queue = &(pmlmepriv->scanned_queue);
	struct wlan_network *pnetwork = NULL;
	u8 blnMatch = 0;
	u8 dev_type[8] = { 0x00 };
	uint dev_type_len = 0;
	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    /* +9 is for the str "dev_type=", we have to clear it at wrqu->data.pointer */

	/*	Commented by Albert 20121209 */
	/*	The input data is the MAC address which the application wants to know its device type. */
	/*	Such user interface could know the device type. */
	/*	Format: iwpriv wlanx p2p_get2 dev_type=00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, subcmd);

	macstr2num(peerMAC, subcmd);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
			u8 *wpsie;
			uint	wpsie_len = 0;

			/*	The mac address is matched. */

			wpsie = rtw_get_wps_ie_from_scan_queue(&pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0]);
			if (wpsie) {
				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_PRIMARY_DEV_TYPE, dev_type, &dev_type_len);
				if (dev_type_len) {
					u16	type = 0;

					_rtw_memcpy(&type, dev_type, 2);
					type = be16_to_cpu(type);
					sprintf(dev_type_str, "\n\nN=%.2d", type);
					blnMatch = 1;
				}
			}
			break;
		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (!blnMatch)
		sprintf(dev_type_str, "\n\nN=00");

	wrqu->data.length = strlen(dev_type_str);
	_rtw_memcpy(extra, dev_type_str, wrqu->data.length);

	return ret;

}

static int rtw_p2p_get_device_name(struct net_device *dev,
				   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra, char *subcmd)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 peerMAC[ETH_ALEN] = { 0x00 };
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	_irqL irqL;
	_list *plist, *phead;
	_queue *queue = &(pmlmepriv->scanned_queue);
	struct wlan_network *pnetwork = NULL;
	u8 blnMatch = 0;
	u8 dev_name[WPS_MAX_DEVICE_NAME_LEN] = { 0x00 };
	uint dev_len = 0;
	u8 dev_name_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };

	/*	Commented by Albert 20121225 */
	/*	The input data is the MAC address which the application wants to know its device name. */
	/*	Such user interface could show peer device's device name instead of ssid. */
	/*	Format: iwpriv wlanx p2p_get2 devN=00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, subcmd);

	macstr2num(peerMAC, subcmd);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
			u8 *wpsie;
			uint	wpsie_len = 0;

			/*	The mac address is matched. */

			wpsie = rtw_get_wps_ie_from_scan_queue(&pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0]);
			if (wpsie) {
				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_DEVICE_NAME, dev_name, &dev_len);
				if (dev_len) {
					sprintf(dev_name_str, "\n\nN=%s", dev_name);
					blnMatch = 1;
				}
			}
			break;
		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (!blnMatch)
		sprintf(dev_name_str, "\n\nN=0000");

	wrqu->data.length = strlen(dev_name_str);
	_rtw_memcpy(extra, dev_name_str, wrqu->data.length);

	return ret;

}

static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra, char *subcmd)
{

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 peerMAC[ETH_ALEN] = { 0x00 };
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	_irqL irqL;
	_list *plist, *phead;
	_queue *queue	= &(pmlmepriv->scanned_queue);
	struct wlan_network *pnetwork = NULL;
	u8 blnMatch = 0;
	u8 *p2pie;
	uint p2pielen = 0, attr_contentlen = 0;
	u8 attr_content[2] = { 0x00 };
	u8 inv_proc_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };

	/*	Commented by Ouden 20121226 */
	/*	The application wants to know P2P initation procedure is support or not. */
	/*	Format: iwpriv wlanx p2p_get2 InvProc=00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, subcmd);

	macstr2num(peerMAC, subcmd);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
			/*	Commented by Albert 20121226 */
			/*	Match the device address located in the P2P IE */
			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */

			p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
			if (p2pie) {
				while (p2pie) {
					/* _rtw_memset( attr_content, 0x00, 2); */
					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_CAPABILITY, attr_content, &attr_contentlen)) {
						/*	Handle the P2P capability attribute */
						blnMatch = 1;
						break;

					}

					/* Get the next P2P IE */
					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, BSS_EX_TLV_IES_LEN(&pnetwork->network) - (p2pie + p2pielen - BSS_EX_TLV_IES(&pnetwork->network)), NULL, &p2pielen);
				}
			}
		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (!blnMatch)
		sprintf(inv_proc_str, "\nIP=-1");
	else {
		if ((attr_content[0] & 0x20) == 0x20)
			sprintf(inv_proc_str, "\nIP=1");
		else
			sprintf(inv_proc_str, "\nIP=0");
	}

	wrqu->data.length = strlen(inv_proc_str);
	_rtw_memcpy(extra, inv_proc_str, wrqu->data.length);

	return ret;

}

static int rtw_p2p_connect(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter				*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
	u8					peerMAC[ETH_ALEN] = { 0x00 };
	int					jj, kk;
	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
	_irqL				irqL;
	_list					*plist, *phead;
	_queue				*queue	= &(pmlmepriv->scanned_queue);
	struct	wlan_network	*pnetwork = NULL;
	uint					uintPeerChannel = 0;

	/*	Commented by Albert 20110304 */
	/*	The input data contains two informations. */
	/*	1. First information is the MAC address which wants to formate with */
	/*	2. Second information is the WPS PINCode or "pbc" string for push button method */
	/*	Format: 00:E0:4C:00:00:05 */
	/*	Format: 00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (pwdinfo->p2p_state == P2P_STATE_NONE) {
		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
		return ret;
	}

	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO)
		return -1;

	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
		peerMAC[jj] = key_2char2num(extra[kk], extra[kk + 1]);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
			if (pnetwork->network.Configuration.DSConfig != 0)
				uintPeerChannel = pnetwork->network.Configuration.DSConfig;
			else if (pwdinfo->nego_req_info.peer_ch != 0)
				uintPeerChannel = pnetwork->network.Configuration.DSConfig = pwdinfo->nego_req_info.peer_ch;
			else {
				/* Unexpected case */
				uintPeerChannel = 0;
				RTW_INFO("%s  uintPeerChannel = 0\n", __func__);
			}
			break;
		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (uintPeerChannel) {
#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED))
			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
#endif /* CONFIG_CONCURRENT_MODE */

		_rtw_memset(&pwdinfo->nego_req_info, 0x00, sizeof(struct tx_nego_req_info));
		_rtw_memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));

		pwdinfo->nego_req_info.peer_channel_num[0] = uintPeerChannel;
		_rtw_memcpy(pwdinfo->nego_req_info.peerDevAddr, pnetwork->network.MacAddress, ETH_ALEN);
		pwdinfo->nego_req_info.benable = _TRUE;

		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK) {
			/*	Restore to the listen state if the current p2p state is not nego OK */
			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
		}

		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);

#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED)) {
			u8 union_ch = rtw_mi_get_union_chan(padapter);
			u8 union_bw = rtw_mi_get_union_bw(padapter);
			u8 union_offset = rtw_mi_get_union_offset(padapter);

			set_channel_bwmode(padapter, union_ch, union_offset, union_bw);
			rtw_leave_opch(padapter);
		}
#endif /* CONFIG_CONCURRENT_MODE */

		RTW_INFO("[%s] Start PreTx Procedure!\n", __FUNCTION__);
		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED))
			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_GO_NEGO_TIMEOUT);
		else
			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
#else
		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
#endif /* CONFIG_CONCURRENT_MODE		 */

	} else {
		RTW_INFO("[%s] Not Found in Scanning Queue~\n", __FUNCTION__);
		ret = -1;
	}

	return ret;
}

static int rtw_p2p_invite_req(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter					*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
	int						jj, kk;
	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
	_list						*plist, *phead;
	_queue					*queue	= &(pmlmepriv->scanned_queue);
	struct	wlan_network		*pnetwork = NULL;
	uint						uintPeerChannel = 0;
	u8						attr_content[50] = { 0x00 };
	u8						*p2pie;
	uint						p2pielen = 0, attr_contentlen = 0;
	_irqL					irqL;
	struct tx_invite_req_info	*pinvite_req_info = &pwdinfo->invitereq_info;

	/*	Commented by Albert 20120321 */
	/*	The input data contains two informations. */
	/*	1. First information is the P2P device address which you want to send to.	 */
	/*	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. */
	/*	Command line sample: iwpriv wlan0 p2p_set invite="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy" */
	/*	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (wrqu->data.length <=  37) {
		RTW_INFO("[%s] Wrong format!\n", __FUNCTION__);
		return ret;
	}

	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
		return ret;
	} else {
		/*	Reset the content of struct tx_invite_req_info */
		pinvite_req_info->benable = _FALSE;
		_rtw_memset(pinvite_req_info->go_bssid, 0x00, ETH_ALEN);
		_rtw_memset(pinvite_req_info->go_ssid, 0x00, WLAN_SSID_MAXLEN);
		pinvite_req_info->ssidlen = 0x00;
		pinvite_req_info->operating_ch = pwdinfo->operating_channel;
		_rtw_memset(pinvite_req_info->peer_macaddr, 0x00, ETH_ALEN);
		pinvite_req_info->token = 3;
	}

	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
		pinvite_req_info->peer_macaddr[jj] = key_2char2num(extra[kk], extra[kk + 1]);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);

		/*	Commented by Albert 2011/05/18 */
		/*	Match the device address located in the P2P IE */
		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */

		p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
		if (p2pie) {
			/*	The P2P Device ID attribute is included in the Beacon frame. */
			/*	The P2P Device Info attribute is included in the probe response frame. */

			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
				/*	Handle the P2P Device ID attribute of Beacon first */
				if (_rtw_memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN)) {
					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
					break;
				}
			} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
				/*	Handle the P2P Device Info attribute of probe response */
				if (_rtw_memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN)) {
					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
					break;
				}
			}

		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

#ifdef CONFIG_WFD
	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST) && uintPeerChannel) {
		struct wifi_display_info *pwfd_info = pwdinfo->wfd_info;
		u8 *wfd_ie;
		uint wfd_ielen = 0;

		wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
		if (wfd_ie) {
			u8 *wfd_devinfo;
			uint wfd_devlen;

			RTW_INFO("[%s] Found WFD IE!\n", __FUNCTION__);
			wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
			if (wfd_devinfo) {
				u16	wfd_devinfo_field = 0;

				/*	Commented by Albert 20120319 */
				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
				/*	In big endian format. */
				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
					pwfd_info->peer_session_avail = _TRUE;
				else
					pwfd_info->peer_session_avail = _FALSE;
			}
		}

		if (_FALSE == pwfd_info->peer_session_avail) {
			RTW_INFO("[%s] WFD Session not avaiable!\n", __FUNCTION__);
			goto exit;
		}
	}
#endif /* CONFIG_WFD */

	if (uintPeerChannel) {
#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED))
			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
#endif /* CONFIG_CONCURRENT_MODE */

		/*	Store the GO's bssid */
		for (jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3)
			pinvite_req_info->go_bssid[jj] = key_2char2num(extra[kk], extra[kk + 1]);

		/*	Store the GO's ssid */
		pinvite_req_info->ssidlen = wrqu->data.length - 36;
		_rtw_memcpy(pinvite_req_info->go_ssid, &extra[36], (u32) pinvite_req_info->ssidlen);
		pinvite_req_info->benable = _TRUE;
		pinvite_req_info->peer_ch = uintPeerChannel;

		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INVITE_REQ);

#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED)) {
			u8 union_ch = rtw_mi_get_union_chan(padapter);
			u8 union_bw = rtw_mi_get_union_bw(padapter);
			u8 union_offset = rtw_mi_get_union_offset(padapter);

			set_channel_bwmode(padapter, union_ch, union_offset, union_bw);
			rtw_leave_opch(padapter);

		} else
			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
#else
		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
#endif/*CONFIG_CONCURRENT_MODE*/

		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);

#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED))
			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_INVITE_TIMEOUT);
		else
			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
#else
		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
#endif /* CONFIG_CONCURRENT_MODE		 */


	} else
		RTW_INFO("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);
exit:

	return ret;

}

static int rtw_p2p_set_persistent(struct net_device *dev,
				  struct iw_request_info *info,
				  union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter					*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);

	/*	Commented by Albert 20120328 */
	/*	The input data is 0 or 1 */
	/*	0: disable persistent group functionality */
	/*	1: enable persistent group founctionality */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
		return ret;
	} else {
		if (extra[0] == '0')	/*	Disable the persistent group function. */
			pwdinfo->persistent_supported = _FALSE;
		else if (extra[0] == '1')	/*	Enable the persistent group function. */
			pwdinfo->persistent_supported = _TRUE;
		else
			pwdinfo->persistent_supported = _FALSE;
	}
	printk("[%s] persistent_supported = %d\n", __FUNCTION__, pwdinfo->persistent_supported);

	return ret;

}

static int uuid_str2bin(const char *str, u8 *bin)
{
	const char *pos;
	u8 *opos;

	pos = str;
	opos = bin;

	if (hexstr2bin(pos, opos, 4))
		return -1;
	pos += 8;
	opos += 4;

	if (*pos++ != '-' || hexstr2bin(pos, opos, 2))
		return -1;
	pos += 4;
	opos += 2;

	if (*pos++ != '-' || hexstr2bin(pos, opos, 2))
		return -1;
	pos += 4;
	opos += 2;

	if (*pos++ != '-' || hexstr2bin(pos, opos, 2))
		return -1;
	pos += 4;
	opos += 2;

	if (*pos++ != '-' || hexstr2bin(pos, opos, 6))
		return -1;

	return 0;
}

static int rtw_p2p_set_wps_uuid(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter				*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info			*pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if ((36 == strlen(extra)) && (uuid_str2bin(extra, pwdinfo->uuid) == 0))
		pwdinfo->external_uuid = 1;
	else {
		pwdinfo->external_uuid = 0;
		ret = -EINVAL;
	}

	return ret;

}
#ifdef CONFIG_WFD
static int rtw_p2p_set_pc(struct net_device *dev,
			  struct iw_request_info *info,
			  union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter				*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
	u8					peerMAC[ETH_ALEN] = { 0x00 };
	int					jj, kk;
	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
	_list					*plist, *phead;
	_queue				*queue	= &(pmlmepriv->scanned_queue);
	struct	wlan_network	*pnetwork = NULL;
	u8					attr_content[50] = { 0x00 };
	u8 *p2pie;
	uint					p2pielen = 0, attr_contentlen = 0;
	_irqL				irqL;
	uint					uintPeerChannel = 0;

	struct wifi_display_info	*pwfd_info = pwdinfo->wfd_info;

	/*	Commented by Albert 20120512 */
	/*	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit) */
	/*	Format: 00:E0:4C:00:00:05 */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
		return ret;
	}

	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
		peerMAC[jj] = key_2char2num(extra[kk], extra[kk + 1]);

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);

		/*	Commented by Albert 2011/05/18 */
		/*	Match the device address located in the P2P IE */
		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */

		p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
		if (p2pie) {
			/*	The P2P Device ID attribute is included in the Beacon frame. */
			/*	The P2P Device Info attribute is included in the probe response frame. */
			printk("[%s] Got P2P IE\n", __FUNCTION__);
			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
				/*	Handle the P2P Device ID attribute of Beacon first */
				printk("[%s] P2P_ATTR_DEVICE_ID\n", __FUNCTION__);
				if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN)) {
					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
					break;
				}
			} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
				/*	Handle the P2P Device Info attribute of probe response */
				printk("[%s] P2P_ATTR_DEVICE_INFO\n", __FUNCTION__);
				if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN)) {
					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
					break;
				}
			}

		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
	printk("[%s] channel = %d\n", __FUNCTION__, uintPeerChannel);

	if (uintPeerChannel) {
		u8 *wfd_ie;
		uint wfd_ielen = 0;

		wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
		if (wfd_ie) {
			u8 *wfd_devinfo;
			uint wfd_devlen;

			RTW_INFO("[%s] Found WFD IE!\n", __FUNCTION__);
			wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
			if (wfd_devinfo) {
				u16	wfd_devinfo_field = 0;

				/*	Commented by Albert 20120319 */
				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
				/*	In big endian format. */
				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
				if (wfd_devinfo_field & WFD_DEVINFO_PC_TDLS)
					pwfd_info->wfd_pc = _TRUE;
				else
					pwfd_info->wfd_pc = _FALSE;
			}
		}
	} else
		RTW_INFO("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);

	return ret;

}

static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
				       struct iw_request_info *info,
				       union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter					*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;

	/*	Commented by Albert 20120328 */
	/*	The input data is 0 or 1 */
	/*	0: specify to Miracast source device */
	/*	1 or others: specify to Miracast sink device (display device) */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (extra[0] == '0')	/*	Set to Miracast source device. */
		pwfd_info->wfd_device_type = WFD_DEVINFO_SOURCE;
	else					/*	Set to Miracast sink device. */
		pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;

	return ret;

}

static int rtw_p2p_set_wfd_enable(struct net_device *dev,
				  struct iw_request_info *info,
				  union iwreq_data *wrqu, char *extra)
{
	/*	Commented by Kurt 20121206
	 *	This function is used to set wfd enabled */

	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);

	if (*extra == '0')
		rtw_wfd_enable(padapter, 0);
	else if (*extra == '1')
		rtw_wfd_enable(padapter, 1);

	RTW_INFO("[%s] wfd_enable = %d\n", __FUNCTION__, pwdinfo->wfd_info->wfd_enable);

	return ret;

}

static int rtw_p2p_set_driver_iface(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	/*	Commented by Kurt 20121206
	 *	This function is used to set driver iface is WEXT or CFG80211 */
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);

	if (*extra == '1') {
		pwdinfo->driver_interface = DRIVER_WEXT;
		RTW_INFO("[%s] driver_interface = WEXT\n", __FUNCTION__);
	} else if (*extra == '2') {
		pwdinfo->driver_interface = DRIVER_CFG80211;
		RTW_INFO("[%s] driver_interface = CFG80211\n", __FUNCTION__);
	}

	return ret;

}

/*	To set the WFD session available to enable or disable */
static int rtw_p2p_set_sa(struct net_device *dev,
			  struct iw_request_info *info,
			  union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter					*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (0) {
		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
		return ret;
	} else {
		if (extra[0] == '0')	/*	Disable the session available. */
			pwdinfo->session_available = _FALSE;
		else if (extra[0] == '1')	/*	Enable the session available. */
			pwdinfo->session_available = _TRUE;
		else
			pwdinfo->session_available = _FALSE;
	}
	printk("[%s] session available = %d\n", __FUNCTION__, pwdinfo->session_available);

	return ret;

}
#endif /* CONFIG_WFD */

static int rtw_p2p_prov_disc(struct net_device *dev,
			     struct iw_request_info *info,
			     union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
	_adapter				*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
	u8					peerMAC[ETH_ALEN] = { 0x00 };
	int					jj, kk;
	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
	_list					*plist, *phead;
	_queue				*queue	= &(pmlmepriv->scanned_queue);
	struct	wlan_network	*pnetwork = NULL;
	uint					uintPeerChannel = 0;
	u8					attr_content[100] = { 0x00 };
	u8 *p2pie;
	uint					p2pielen = 0, attr_contentlen = 0;
	_irqL				irqL;

	/*	Commented by Albert 20110301 */
	/*	The input data contains two informations. */
	/*	1. First information is the MAC address which wants to issue the provisioning discovery request frame. */
	/*	2. Second information is the WPS configuration method which wants to discovery */
	/*	Format: 00:E0:4C:00:00:05_display */
	/*	Format: 00:E0:4C:00:00:05_keypad */
	/*	Format: 00:E0:4C:00:00:05_pbc */
	/*	Format: 00:E0:4C:00:00:05_label */

	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);

	if (pwdinfo->p2p_state == P2P_STATE_NONE) {
		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
		return ret;
	} else {
		/*	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
		_rtw_memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
		_rtw_memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
		_rtw_memset(&pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof(NDIS_802_11_SSID));
		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = 0;
		pwdinfo->tx_prov_disc_info.peer_channel_num[1] = 0;
		pwdinfo->tx_prov_disc_info.benable = _FALSE;
	}

	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
		peerMAC[jj] = key_2char2num(extra[kk], extra[kk + 1]);

	if (_rtw_memcmp(&extra[18], "display", 7))
		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
	else if (_rtw_memcmp(&extra[18], "keypad", 7))
		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
	else if (_rtw_memcmp(&extra[18], "pbc", 3))
		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
	else if (_rtw_memcmp(&extra[18], "label", 5))
		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
	else {
		RTW_INFO("[%s] Unknown WPS config methodn", __FUNCTION__);
		return ret ;
	}

	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	phead = get_list_head(queue);
	plist = get_next(phead);

	while (1) {
		if (rtw_end_of_queue_search(phead, plist) == _TRUE)
			break;

		if (uintPeerChannel != 0)
			break;

		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);

		/*	Commented by Albert 2011/05/18 */
		/*	Match the device address located in the P2P IE */
		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */

		p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
		if (p2pie) {
			while (p2pie) {
				/*	The P2P Device ID attribute is included in the Beacon frame. */
				/*	The P2P Device Info attribute is included in the probe response frame. */

				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
					/*	Handle the P2P Device ID attribute of Beacon first */
					if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN)) {
						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
						break;
					}
				} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
					/*	Handle the P2P Device Info attribute of probe response */
					if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN)) {
						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
						break;
					}
				}

				/* Get the next P2P IE */
				p2pie = rtw_get_p2p_ie(p2pie + p2pielen, BSS_EX_TLV_IES_LEN(&pnetwork->network) - (p2pie + p2pielen - BSS_EX_TLV_IES(&pnetwork->network)), NULL, &p2pielen);
			}

		}

		plist = get_next(plist);

	}

	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);

	if (uintPeerChannel) {
#ifdef CONFIG_WFD
		if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
			struct wifi_display_info *pwfd_info = pwdinfo->wfd_info;
			u8 *wfd_ie;
			uint wfd_ielen = 0;

			wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
			if (wfd_ie) {
				u8 *wfd_devinfo;
				uint wfd_devlen;

				RTW_INFO("[%s] Found WFD IE!\n", __FUNCTION__);
				wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
				if (wfd_devinfo) {
					u16	wfd_devinfo_field = 0;

					/*	Commented by Albert 20120319 */
					/*	The first two bytes are the WFD device information field of WFD device information subelement. */
					/*	In big endian format. */
					wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
					if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
						pwfd_info->peer_session_avail = _TRUE;
					else
						pwfd_info->peer_session_avail = _FALSE;
				}
			}

			if (_FALSE == pwfd_info->peer_session_avail) {
				RTW_INFO("[%s] WFD Session not avaiable!\n", __FUNCTION__);
				goto exit;
			}
		}
#endif /* CONFIG_WFD */

		RTW_INFO("[%s] peer channel: %d!\n", __FUNCTION__, uintPeerChannel);
#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED))
			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
#endif /* CONFIG_CONCURRENT_MODE */
		_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, pnetwork->network.MacAddress, ETH_ALEN);
		_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, peerMAC, ETH_ALEN);
		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = (u16) uintPeerChannel;
		pwdinfo->tx_prov_disc_info.benable = _TRUE;
		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);

		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
			_rtw_memcpy(&pwdinfo->tx_prov_disc_info.ssid, &pnetwork->network.Ssid, sizeof(NDIS_802_11_SSID));
		else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
			_rtw_memcpy(pwdinfo->tx_prov_disc_info.ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
			pwdinfo->tx_prov_disc_info.ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
		}

#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED)) {
			u8 union_ch = rtw_mi_get_union_chan(padapter);
			u8 union_bw = rtw_mi_get_union_bw(padapter);
			u8 union_offset = rtw_mi_get_union_offset(padapter);

			set_channel_bwmode(padapter, union_ch, union_offset, union_bw);
			rtw_leave_opch(padapter);

		} else
			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
#else
		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
#endif

		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);

#ifdef CONFIG_CONCURRENT_MODE
		if (rtw_mi_check_status(padapter, MI_LINKED))
			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_PROVISION_TIMEOUT);
		else
			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
#else
		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
#endif /* CONFIG_CONCURRENT_MODE		 */

	} else {
		RTW_INFO("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);
	}
exit:

	return ret;

}

/*	Added by Albert 20110328
 *	This function is used to inform the driver the user had specified the pin code value or pbc
 *	to application. */

static int rtw_p2p_got_wpsinfo(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
	_adapter				*padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);


	RTW_INFO("[%s] data = %s\n", __FUNCTION__, extra);
	/*	Added by Albert 20110328 */
	/*	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo */
	/*	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. */
	/*	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. */
	/*	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC */

	if (*extra == '0')
		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
	else if (*extra == '1')
		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PEER_DISPLAY_PIN;
	else if (*extra == '2')
		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_SELF_DISPLAY_PIN;
	else if (*extra == '3')
		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PBC;
	else
		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;

	return ret;

}

#endif /* CONFIG_P2P */

static int rtw_p2p_set(struct net_device *dev,
		       struct iw_request_info *info,
		       union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
#ifdef CONFIG_P2P
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	RTW_INFO("[%s] extra = %s\n", __FUNCTION__, extra);

	if (_rtw_memcmp(extra, "enable=", 7))
		rtw_wext_p2p_enable(dev, info, wrqu, &extra[7]);
	else if (_rtw_memcmp(extra, "setDN=", 6)) {
		wrqu->data.length -= 6;
		rtw_p2p_setDN(dev, info, wrqu, &extra[6]);
	} else if (_rtw_memcmp(extra, "profilefound=", 13)) {
		wrqu->data.length -= 13;
		rtw_p2p_profilefound(dev, info, wrqu, &extra[13]);
	} else if (_rtw_memcmp(extra, "prov_disc=", 10)) {
		wrqu->data.length -= 10;
		rtw_p2p_prov_disc(dev, info, wrqu, &extra[10]);
	} else if (_rtw_memcmp(extra, "nego=", 5)) {
		wrqu->data.length -= 5;
		rtw_p2p_connect(dev, info, wrqu, &extra[5]);
	} else if (_rtw_memcmp(extra, "intent=", 7)) {
		/*	Commented by Albert 2011/03/23 */
		/*	The wrqu->data.length will include the null character */
		/*	So, we will decrease 7 + 1 */
		wrqu->data.length -= 8;
		rtw_p2p_set_intent(dev, info, wrqu, &extra[7]);
	} else if (_rtw_memcmp(extra, "ssid=", 5)) {
		wrqu->data.length -= 5;
		rtw_p2p_set_go_nego_ssid(dev, info, wrqu, &extra[5]);
	} else if (_rtw_memcmp(extra, "got_wpsinfo=", 12)) {
		wrqu->data.length -= 12;
		rtw_p2p_got_wpsinfo(dev, info, wrqu, &extra[12]);
	} else if (_rtw_memcmp(extra, "listen_ch=", 10)) {
		/*	Commented by Albert 2011/05/24 */
		/*	The wrqu->data.length will include the null character */
		/*	So, we will decrease (10 + 1)	 */
		wrqu->data.length -= 11;
		rtw_p2p_set_listen_ch(dev, info, wrqu, &extra[10]);
	} else if (_rtw_memcmp(extra, "op_ch=", 6)) {
		/*	Commented by Albert 2011/05/24 */
		/*	The wrqu->data.length will include the null character */
		/*	So, we will decrease (6 + 1)	 */
		wrqu->data.length -= 7;
		rtw_p2p_set_op_ch(dev, info, wrqu, &extra[6]);
	} else if (_rtw_memcmp(extra, "invite=", 7)) {
		wrqu->data.length -= 8;
		rtw_p2p_invite_req(dev, info, wrqu, &extra[7]);
	} else if (_rtw_memcmp(extra, "persistent=", 11)) {
		wrqu->data.length -= 11;
		rtw_p2p_set_persistent(dev, info, wrqu, &extra[11]);
	} else if (_rtw_memcmp(extra, "uuid=", 5)) {
		wrqu->data.length -= 5;
		ret = rtw_p2p_set_wps_uuid(dev, info, wrqu, &extra[5]);
	}

#ifdef CONFIG_WFD
	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
		if (_rtw_memcmp(extra, "sa=", 3)) {
			/* sa: WFD Session Available information */
			wrqu->data.length -= 3;
			rtw_p2p_set_sa(dev, info, wrqu, &extra[3]);
		} else if (_rtw_memcmp(extra, "pc=", 3)) {
			/* pc: WFD Preferred Connection */
			wrqu->data.length -= 3;
			rtw_p2p_set_pc(dev, info, wrqu, &extra[3]);
		} else if (_rtw_memcmp(extra, "wfd_type=", 9)) {
			wrqu->data.length -= 9;
			rtw_p2p_set_wfd_device_type(dev, info, wrqu, &extra[9]);
		} else if (_rtw_memcmp(extra, "wfd_enable=", 11)) {
			wrqu->data.length -= 11;
			rtw_p2p_set_wfd_enable(dev, info, wrqu, &extra[11]);
		} else if (_rtw_memcmp(extra, "driver_iface=", 13)) {
			wrqu->data.length -= 13;
			rtw_p2p_set_driver_iface(dev, info, wrqu, &extra[13]);
		}
	}
#endif /* CONFIG_WFD */

#endif /* CONFIG_P2P */

	return ret;

}

static int rtw_p2p_get(struct net_device *dev,
		       struct iw_request_info *info,
		       union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
#ifdef CONFIG_P2P
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	if (padapter->bShowGetP2PState)
		RTW_INFO("[%s] extra = %s\n", __FUNCTION__, (char *) wrqu->data.pointer);

	if (_rtw_memcmp(wrqu->data.pointer, "status", 6))
		rtw_p2p_get_status(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "role", 4))
		rtw_p2p_get_role(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "peer_ifa", 8))
		rtw_p2p_get_peer_ifaddr(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "req_cm", 6))
		rtw_p2p_get_req_cm(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva", 9)) {
		/*	Get the P2P device address when receiving the provision discovery request frame. */
		rtw_p2p_get_peer_devaddr(dev, info, wrqu, extra);
	} else if (_rtw_memcmp(wrqu->data.pointer, "group_id", 8))
		rtw_p2p_get_groupid(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "inv_peer_deva", 13)) {
		/*	Get the P2P device address when receiving the P2P Invitation request frame. */
		rtw_p2p_get_peer_devaddr_by_invitation(dev, info, wrqu, extra);
	} else if (_rtw_memcmp(wrqu->data.pointer, "op_ch", 5))
		rtw_p2p_get_op_ch(dev, info, wrqu, extra);

#ifdef CONFIG_WFD
	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
		if (_rtw_memcmp(wrqu->data.pointer, "peer_port", 9))
			rtw_p2p_get_peer_wfd_port(dev, info, wrqu, extra);
		else if (_rtw_memcmp(wrqu->data.pointer, "wfd_sa", 6))
			rtw_p2p_get_peer_wfd_session_available(dev, info, wrqu, extra);
		else if (_rtw_memcmp(wrqu->data.pointer, "wfd_pc", 6))
			rtw_p2p_get_peer_wfd_preferred_connection(dev, info, wrqu, extra);
	}
#endif /* CONFIG_WFD */

#endif /* CONFIG_P2P */

	return ret;

}

static int rtw_p2p_get2(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wrqu, char *extra)
{

	int ret = 0;

#ifdef CONFIG_P2P

	int length = wrqu->data.length;
	char *buffer = (u8 *)rtw_malloc(length);

	if (buffer == NULL) {
		ret = -ENOMEM;
		goto bad;
	}

	if (copy_from_user(buffer, wrqu->data.pointer, wrqu->data.length)) {
		ret = -EFAULT;
		goto bad;
	}

	RTW_INFO("[%s] buffer = %s\n", __FUNCTION__, buffer);

	if (_rtw_memcmp(buffer, "wpsCM=", 6))
		ret = rtw_p2p_get_wps_configmethod(dev, info, wrqu, extra, &buffer[6]);
	else if (_rtw_memcmp(buffer, "devN=", 5))
		ret = rtw_p2p_get_device_name(dev, info, wrqu, extra, &buffer[5]);
	else if (_rtw_memcmp(buffer, "dev_type=", 9))
		ret = rtw_p2p_get_device_type(dev, info, wrqu, extra, &buffer[9]);
	else if (_rtw_memcmp(buffer, "go_devadd=", 10))
		ret = rtw_p2p_get_go_device_address(dev, info, wrqu, extra, &buffer[10]);
	else if (_rtw_memcmp(buffer, "InvProc=", 8))
		ret = rtw_p2p_get_invitation_procedure(dev, info, wrqu, extra, &buffer[8]);
	else {
		snprintf(extra, sizeof("Command not found."), "Command not found.");
		wrqu->data.length = strlen(extra);
	}

bad:
	if (buffer)
		rtw_mfree(buffer, length);

#endif /* CONFIG_P2P */

	return ret;

}

#ifdef CONFIG_MP_INCLUDED
static int rtw_cta_test_start(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
	_adapter	*padapter = (_adapter *)rtw_netdev_priv(dev);
	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(padapter);

	RTW_INFO("%s %s\n", __func__, extra);
	if (!strcmp(extra, "1"))
		hal_data->in_cta_test = 1;
	else
		hal_data->in_cta_test = 0;

	rtw_hal_rcr_set_chk_bssid(padapter, MLME_ACTION_NONE);

	return ret;
}
#endif
extern int rtw_change_ifname(_adapter *padapter, const char *ifname);
static int rtw_rereg_nd_name(struct net_device *dev,
			     struct iw_request_info *info,
			     union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
	_adapter *padapter = rtw_netdev_priv(dev);
	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
	char new_ifname[IFNAMSIZ];

	if (rereg_priv->old_ifname[0] == 0) {
		char *reg_ifname;
#ifdef CONFIG_CONCURRENT_MODE
		if (padapter->isprimary)
			reg_ifname = padapter->registrypriv.ifname;
		else
#endif
			reg_ifname = padapter->registrypriv.if2name;

		strncpy(rereg_priv->old_ifname, reg_ifname, IFNAMSIZ);
		rereg_priv->old_ifname[IFNAMSIZ - 1] = 0;
	}

	/* RTW_INFO("%s wrqu->data.length:%d\n", __FUNCTION__, wrqu->data.length); */
	if (wrqu->data.length > IFNAMSIZ)
		return -EFAULT;

	if (copy_from_user(new_ifname, wrqu->data.pointer, IFNAMSIZ))
		return -EFAULT;

	if (0 == strcmp(rereg_priv->old_ifname, new_ifname))
		return ret;

	RTW_INFO("%s new_ifname:%s\n", __FUNCTION__, new_ifname);
	rtw_set_rtnl_lock_holder(dvobj, current);
	ret = rtw_change_ifname(padapter, new_ifname);
	rtw_set_rtnl_lock_holder(dvobj, NULL);
	if (0 != ret)
		goto exit;

	if (_rtw_memcmp(rereg_priv->old_ifname, "disable%d", 9) == _TRUE) {
		/* rtw_ips_mode_req(&padapter->pwrctrlpriv, rereg_priv->old_ips_mode); */
	}

	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
	rereg_priv->old_ifname[IFNAMSIZ - 1] = 0;

	if (_rtw_memcmp(new_ifname, "disable%d", 9) == _TRUE) {

		RTW_INFO("%s disable\n", __FUNCTION__);
		/* free network queue for Android's timming issue */
		rtw_free_network_queue(padapter, _TRUE);

		/* the interface is being "disabled", we can do deeper IPS */
		/* rereg_priv->old_ips_mode = rtw_get_ips_mode_req(&padapter->pwrctrlpriv); */
		/* rtw_ips_mode_req(&padapter->pwrctrlpriv, IPS_NORMAL); */
	}
exit:
	return ret;

}

#ifdef CONFIG_IOL
#include <rtw_iol.h>
#endif
#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
#include "../../hal/hal_dm_acs.h"
#endif
#ifdef DBG_CMD_QUEUE
u8 dump_cmd_id = 0;
#endif

static int rtw_dbg_port(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wrqu, char *extra)
{
	_irqL irqL;
	int ret = 0;
	u8 major_cmd, minor_cmd;
	u16 arg;
	u32 extra_arg, *pdata, val32;
	struct sta_info *psta;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
	struct security_priv *psecuritypriv = &padapter->securitypriv;
	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
	struct sta_priv *pstapriv = &padapter->stapriv;


	pdata = (u32 *)&wrqu->data;

	val32 = *pdata;
	arg = (u16)(val32 & 0x0000ffff);
	major_cmd = (u8)(val32 >> 24);
	minor_cmd = (u8)((val32 >> 16) & 0x00ff);

	extra_arg = *(pdata + 1);

	switch (major_cmd) {
	case 0x70: /* read_reg */
		switch (minor_cmd) {
		case 1:
			RTW_INFO("rtw_read8(0x%x)=0x%02x\n", arg, rtw_read8(padapter, arg));
			break;
		case 2:
			RTW_INFO("rtw_read16(0x%x)=0x%04x\n", arg, rtw_read16(padapter, arg));
			break;
		case 4:
			RTW_INFO("rtw_read32(0x%x)=0x%08x\n", arg, rtw_read32(padapter, arg));
			break;
		}
		break;
	case 0x71: /* write_reg */
		switch (minor_cmd) {
		case 1:
			rtw_write8(padapter, arg, extra_arg);
			RTW_INFO("rtw_write8(0x%x)=0x%02x\n", arg, rtw_read8(padapter, arg));
			break;
		case 2:
			rtw_write16(padapter, arg, extra_arg);
			RTW_INFO("rtw_write16(0x%x)=0x%04x\n", arg, rtw_read16(padapter, arg));
			break;
		case 4:
			rtw_write32(padapter, arg, extra_arg);
			RTW_INFO("rtw_write32(0x%x)=0x%08x\n", arg, rtw_read32(padapter, arg));
			break;
		}
		break;
	case 0x72: /* read_bb */
		RTW_INFO("read_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
		break;
	case 0x73: /* write_bb */
		rtw_hal_write_bbreg(padapter, arg, 0xffffffff, extra_arg);
		RTW_INFO("write_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
		break;
	case 0x74: /* read_rf */
		RTW_INFO("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n", minor_cmd, arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
		break;
	case 0x75: /* write_rf */
		rtw_hal_write_rfreg(padapter, minor_cmd, arg, 0xffffffff, extra_arg);
		RTW_INFO("write RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n", minor_cmd, arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
		break;

	case 0x76:
		switch (minor_cmd) {
		case 0x00: /* normal mode, */
			padapter->recvpriv.is_signal_dbg = 0;
			break;
		case 0x01: /* dbg mode */
			padapter->recvpriv.is_signal_dbg = 1;
			extra_arg = extra_arg > 100 ? 100 : extra_arg;
			padapter->recvpriv.signal_strength_dbg = extra_arg;
			break;
		}
		break;
	case 0x78: /* IOL test */
		switch (minor_cmd) {
		#ifdef CONFIG_IOL
		case 0x04: { /* LLT table initialization test */
			u8 page_boundary = 0xf9;
			{
				struct xmit_frame	*xmit_frame;

				xmit_frame = rtw_IOL_accquire_xmit_frame(padapter);
				if (xmit_frame == NULL) {
					ret = -ENOMEM;
					break;
				}

				rtw_IOL_append_LLT_cmd(xmit_frame, page_boundary);


				if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 500, 0))
					ret = -EPERM;
			}
		}
			break;
		case 0x05: { /* blink LED test */
			u16 reg = 0x4c;
			u32 blink_num = 50;
			u32 blink_delay_ms = 200;
			int i;

			{
				struct xmit_frame	*xmit_frame;

				xmit_frame = rtw_IOL_accquire_xmit_frame(padapter);
				if (xmit_frame == NULL) {
					ret = -ENOMEM;
					break;
				}

				for (i = 0; i < blink_num; i++) {
					#ifdef CONFIG_IOL_NEW_GENERATION
					rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x00, 0xff);
					rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
					rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x08, 0xff);
					rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
					#else
					rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x00);
					rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
					rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x08);
					rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
					#endif
				}
				if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, (blink_delay_ms * blink_num * 2) + 200, 0))
					ret = -EPERM;
			}
		}
			break;

		case 0x06: { /* continuous wirte byte test */
			u16 reg = arg;
			u16 start_value = 0;
			u32 write_num = extra_arg;
			int i;
			u8 final;

			{
				struct xmit_frame	*xmit_frame;

				xmit_frame = rtw_IOL_accquire_xmit_frame(padapter);
				if (xmit_frame == NULL) {
					ret = -ENOMEM;
					break;
				}

				for (i = 0; i < write_num; i++) {
					#ifdef CONFIG_IOL_NEW_GENERATION
					rtw_IOL_append_WB_cmd(xmit_frame, reg, i + start_value, 0xFF);
					#else
					rtw_IOL_append_WB_cmd(xmit_frame, reg, i + start_value);
					#endif
				}
				if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000, 0))
					ret = -EPERM;
			}

			final = rtw_read8(padapter, reg);
			if (start_value + write_num - 1 == final)
				RTW_INFO("continuous IOL_CMD_WB_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
			else
				RTW_INFO("continuous IOL_CMD_WB_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
		}
			break;

		case 0x07: { /* continuous wirte word test */
			u16 reg = arg;
			u16 start_value = 200;
			u32 write_num = extra_arg;

			int i;
			u16 final;

			{
				struct xmit_frame	*xmit_frame;

				xmit_frame = rtw_IOL_accquire_xmit_frame(padapter);
				if (xmit_frame == NULL) {
					ret = -ENOMEM;
					break;
				}

				for (i = 0; i < write_num; i++) {
					#ifdef CONFIG_IOL_NEW_GENERATION
					rtw_IOL_append_WW_cmd(xmit_frame, reg, i + start_value, 0xFFFF);
					#else
					rtw_IOL_append_WW_cmd(xmit_frame, reg, i + start_value);
					#endif
				}
				if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000, 0))
					ret = -EPERM;
			}

			final = rtw_read16(padapter, reg);
			if (start_value + write_num - 1 == final)
				RTW_INFO("continuous IOL_CMD_WW_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
			else
				RTW_INFO("continuous IOL_CMD_WW_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
		}
			break;

		case 0x08: { /* continuous wirte dword test */
			u16 reg = arg;
			u32 start_value = 0x110000c7;
			u32 write_num = extra_arg;

			int i;
			u32 final;

			{
				struct xmit_frame	*xmit_frame;

				xmit_frame = rtw_IOL_accquire_xmit_frame(padapter);
				if (xmit_frame == NULL) {
					ret = -ENOMEM;
					break;
				}

				for (i = 0; i < write_num; i++) {
					#ifdef CONFIG_IOL_NEW_GENERATION
					rtw_IOL_append_WD_cmd(xmit_frame, reg, i + start_value, 0xFFFFFFFF);
					#else
					rtw_IOL_append_WD_cmd(xmit_frame, reg, i + start_value);
					#endif
				}
				if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000, 0))
					ret = -EPERM;

			}

			final = rtw_read32(padapter, reg);
			if (start_value + write_num - 1 == final)
				RTW_INFO("continuous IOL_CMD_WD_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
			else
				RTW_INFO("continuous IOL_CMD_WD_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
		}
			break;
		#endif /* CONFIG_IOL */
		}
		break;
	case 0x79: {
		/*
		* dbg 0x79000000 [value], set RESP_TXAGC to + value, value:0~15
		* dbg 0x79010000 [value], set RESP_TXAGC to - value, value:0~15
		*/
		u8 value =  extra_arg & 0x0f;
		u8 sign = minor_cmd;
		u16 write_value = 0;

		RTW_INFO("%s set RESP_TXAGC to %s %u\n", __func__, sign ? "minus" : "plus", value);

		if (sign)
			value = value | 0x10;

		write_value = value | (value << 5);
		rtw_write16(padapter, 0x6d9, write_value);
	}
		break;
	case 0x7a:
		receive_disconnect(padapter, pmlmeinfo->network.MacAddress
				   , WLAN_REASON_EXPIRATION_CHK, _FALSE);
		break;
	case 0x7F:
		switch (minor_cmd) {
		case 0x0:
			RTW_INFO("fwstate=0x%x\n", get_fwstate(pmlmepriv));
			break;
		case 0x01:
			RTW_INFO("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
				psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
				psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
			break;
		case 0x03:
			RTW_INFO("qos_option=%d\n", pmlmepriv->qospriv.qos_option);
#ifdef CONFIG_80211N_HT
			RTW_INFO("ht_option=%d\n", pmlmepriv->htpriv.ht_option);
#endif /* CONFIG_80211N_HT */
			break;
		case 0x04:
			RTW_INFO("cur_ch=%d\n", pmlmeext->cur_channel);
			RTW_INFO("cur_bw=%d\n", pmlmeext->cur_bwmode);
			RTW_INFO("cur_ch_off=%d\n", pmlmeext->cur_ch_offset);

			RTW_INFO("oper_ch=%d\n", rtw_get_oper_ch(padapter));
			RTW_INFO("oper_bw=%d\n", rtw_get_oper_bw(padapter));
			RTW_INFO("oper_ch_offet=%d\n", rtw_get_oper_choffset(padapter));

			break;
		case 0x05:
			psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
			if (psta) {
				RTW_INFO("SSID=%s\n", cur_network->network.Ssid.Ssid);
				RTW_INFO("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->cmn.mac_addr));
				RTW_INFO("cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
				RTW_INFO("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
				RTW_INFO("state=0x%x, aid=%d, macid=%d, raid=%d\n",
					psta->state, psta->cmn.aid, psta->cmn.mac_id, psta->cmn.ra_info.rate_id);
#ifdef CONFIG_80211N_HT
				RTW_INFO("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
				RTW_INFO("bwmode=%d, ch_offset=%d, sgi_20m=%d,sgi_40m=%d\n"
					, psta->cmn.bw_mode, psta->htpriv.ch_offset, psta->htpriv.sgi_20m, psta->htpriv.sgi_40m);
				RTW_INFO("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
				RTW_INFO("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
#endif /* CONFIG_80211N_HT */

				sta_rx_reorder_ctl_dump(RTW_DBGDUMP, psta);
			} else
				RTW_INFO("can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
			break;
		case 0x06: {
				u64 tsf = 0;

				tsf = rtw_hal_get_tsftr_by_port(padapter, extra_arg);
				RTW_INFO(" PORT-%d TSF :%21lld\n", extra_arg, tsf);
		}
			break;
		case 0x07:
			RTW_INFO("bSurpriseRemoved=%s, bDriverStopped=%s\n"
				, rtw_is_surprise_removed(padapter) ? "True" : "False"
				, rtw_is_drv_stopped(padapter) ? "True" : "False");
			break;
		case 0x08: {
			struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
			struct recv_priv  *precvpriv = &padapter->recvpriv;

			RTW_INFO("free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d"
				", free_xmit_extbuf_cnt=%d, free_xframe_ext_cnt=%d"
				 ", free_recvframe_cnt=%d\n",
				pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt,
				pxmitpriv->free_xmit_extbuf_cnt, pxmitpriv->free_xframe_ext_cnt,
				 precvpriv->free_recvframe_cnt);
#ifdef CONFIG_USB_HCI
			RTW_INFO("rx_urb_pending_cn=%d\n", ATOMIC_READ(&(precvpriv->rx_pending_cnt)));
#endif
		}
			break;
		case 0x09: {
			int i;
			_list	*plist, *phead;

#ifdef CONFIG_AP_MODE
			RTW_INFO_DUMP("sta_dz_bitmap:", pstapriv->sta_dz_bitmap, pstapriv->aid_bmp_len);
			RTW_INFO_DUMP("tim_bitmap:", pstapriv->tim_bitmap, pstapriv->aid_bmp_len);
#endif
			_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);

			for (i = 0; i < NUM_STA; i++) {
				phead = &(pstapriv->sta_hash[i]);
				plist = get_next(phead);

				while ((rtw_end_of_queue_search(phead, plist)) == _FALSE) {
					psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);

					plist = get_next(plist);

					if (extra_arg == psta->cmn.aid) {
						RTW_INFO("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->cmn.mac_addr));
						RTW_INFO("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
						RTW_INFO("state=0x%x, aid=%d, macid=%d, raid=%d\n",
							psta->state, psta->cmn.aid, psta->cmn.mac_id, psta->cmn.ra_info.rate_id);
#ifdef CONFIG_80211N_HT
						RTW_INFO("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
						RTW_INFO("bwmode=%d, ch_offset=%d, sgi_20m=%d,sgi_40m=%d\n",
							psta->cmn.bw_mode, psta->htpriv.ch_offset, psta->htpriv.sgi_20m,
							psta->htpriv.sgi_40m);
						RTW_INFO("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
						RTW_INFO("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
#endif /* CONFIG_80211N_HT */

#ifdef CONFIG_AP_MODE
						RTW_INFO("capability=0x%x\n", psta->capability);
						RTW_INFO("flags=0x%x\n", psta->flags);
						RTW_INFO("wpa_psk=0x%x\n", psta->wpa_psk);
						RTW_INFO("wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
						RTW_INFO("wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
						RTW_INFO("qos_info=0x%x\n", psta->qos_info);
#endif
						RTW_INFO("dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);

						sta_rx_reorder_ctl_dump(RTW_DBGDUMP, psta);
					}

				}
			}

			_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);

		}
			break;

		case 0x0b: { /* Enable=1, Disable=0 driver control vrtl_carrier_sense. */
			/* u8 driver_vcs_en; */ /* Enable=1, Disable=0 driver control vrtl_carrier_sense. */
			/* u8 driver_vcs_type; */ /* force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1. */

			if (arg == 0) {
				RTW_INFO("disable driver ctrl vcs\n");
				padapter->driver_vcs_en = 0;
			} else if (arg == 1) {
				RTW_INFO("enable driver ctrl vcs = %d\n", extra_arg);
				padapter->driver_vcs_en = 1;

				if (extra_arg > 2)
					padapter->driver_vcs_type = 1;
				else
					padapter->driver_vcs_type = extra_arg;
			}
		}
			break;
		case 0x0c: { /* dump rx/tx packet */
			if (arg == 0) {
				RTW_INFO("dump rx packet (%d)\n", extra_arg);
				/* pHalData->bDumpRxPkt =extra_arg;						 */
				rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
			} else if (arg == 1) {
				RTW_INFO("dump tx packet (%d)\n", extra_arg);
				rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_TXPKT, &(extra_arg));
			}
		}
			break;
		case 0x0e: {
			if (arg == 0) {
				RTW_INFO("disable driver ctrl rx_ampdu_factor\n");
				padapter->driver_rx_ampdu_factor = 0xFF;
			} else if (arg == 1) {

				RTW_INFO("enable driver ctrl rx_ampdu_factor = %d\n", extra_arg);

				if (extra_arg > 0x03)
					padapter->driver_rx_ampdu_factor = 0xFF;
				else
					padapter->driver_rx_ampdu_factor = extra_arg;
			}
		}
			break;
		#ifdef DBG_CONFIG_ERROR_DETECT
		case 0x0f: {
			if (extra_arg == 0) {
				RTW_INFO("###### silent reset test.......#####\n");
				rtw_hal_sreset_reset(padapter);
			} else {
				HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
				struct sreset_priv *psrtpriv = &pHalData->srestpriv;
				psrtpriv->dbg_trigger_point = extra_arg;
			}

		}
			break;
		case 0x15: {
			struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
			RTW_INFO("==>silent resete cnts:%d\n", pwrpriv->ips_enter_cnts);
		}
			break;

		#endif

		case 0x10: /* driver version display */
			dump_drv_version(RTW_DBGDUMP);
			break;
		case 0x11: { /* dump linked status */
			int pre_mode;
			pre_mode = padapter->bLinkInfoDump;
			/* linked_info_dump(padapter,extra_arg); */
			if (extra_arg == 1 || (extra_arg == 0 && pre_mode == 1)) /* not consider pwr_saving 0: */
				padapter->bLinkInfoDump = extra_arg;

			else if ((extra_arg == 2) || (extra_arg == 0 && pre_mode == 2)) { /* consider power_saving */
				/* RTW_INFO("linked_info_dump =%s\n", (padapter->bLinkInfoDump)?"enable":"disable") */
				linked_info_dump(padapter, extra_arg);
			}



		}
			break;
#ifdef CONFIG_80211N_HT
		case 0x12: { /* set rx_stbc */
			struct registry_priv	*pregpriv = &padapter->registrypriv;
			/* 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g */
			/* default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ */
			if (pregpriv && (extra_arg == 0 || extra_arg == 1 || extra_arg == 2 || extra_arg == 3)) {
				pregpriv->rx_stbc = extra_arg;
				RTW_INFO("set rx_stbc=%d\n", pregpriv->rx_stbc);
			} else
				RTW_INFO("get rx_stbc=%d\n", pregpriv->rx_stbc);

		}
			break;
		case 0x13: { /* set ampdu_enable */
			struct registry_priv	*pregpriv = &padapter->registrypriv;
			/* 0: disable, 0x1:enable */
			if (pregpriv && extra_arg < 2) {
				pregpriv->ampdu_enable = extra_arg;
				RTW_INFO("set ampdu_enable=%d\n", pregpriv->ampdu_enable);
			} else
				RTW_INFO("get ampdu_enable=%d\n", pregpriv->ampdu_enable);

		}
			break;
#endif
		case 0x14: { /* get wifi_spec */
			struct registry_priv	*pregpriv = &padapter->registrypriv;
			RTW_INFO("get wifi_spec=%d\n", pregpriv->wifi_spec);

		}
			break;

#ifdef DBG_FIXED_CHAN
		case 0x17: {
			struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
			printk("===>  Fixed channel to %d\n", extra_arg);
			pmlmeext->fixed_chan = extra_arg;

		}
			break;
#endif
#ifdef CONFIG_80211N_HT
		case 0x19: {
			struct registry_priv	*pregistrypriv = &padapter->registrypriv;
			/* extra_arg : */
			/* BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, */
			/* BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx */
			if (arg == 0) {
				RTW_INFO("driver disable LDPC\n");
				pregistrypriv->ldpc_cap = 0x00;
			} else if (arg == 1) {
				RTW_INFO("driver set LDPC cap = 0x%x\n", extra_arg);
				pregistrypriv->ldpc_cap = (u8)(extra_arg & 0x33);
			}
		}
			break;
		case 0x1a: {
			struct registry_priv	*pregistrypriv = &padapter->registrypriv;
			/* extra_arg : */
			/* BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, */
			/* BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx */
			if (arg == 0) {
				RTW_INFO("driver disable STBC\n");
				pregistrypriv->stbc_cap = 0x00;
			} else if (arg == 1) {
				RTW_INFO("driver set STBC cap = 0x%x\n", extra_arg);
				pregistrypriv->stbc_cap = (u8)(extra_arg & 0x33);
			}
		}
			break;
#endif /* CONFIG_80211N_HT */
		case 0x1b: {
			struct registry_priv	*pregistrypriv = &padapter->registrypriv;

			if (arg == 0) {
				RTW_INFO("disable driver ctrl max_rx_rate, reset to default_rate_set\n");
				init_mlme_default_rate_set(padapter);
#ifdef CONFIG_80211N_HT
				pregistrypriv->ht_enable = (u8)rtw_ht_enable;
#endif /* CONFIG_80211N_HT */
			} else if (arg == 1) {

				int i;
				u8 max_rx_rate;

				RTW_INFO("enable driver ctrl max_rx_rate = 0x%x\n", extra_arg);

				max_rx_rate = (u8)extra_arg;

				if (max_rx_rate < 0xc) { /* max_rx_rate < MSC0->B or G -> disable HT */
#ifdef CONFIG_80211N_HT
					pregistrypriv->ht_enable = 0;
#endif /* CONFIG_80211N_HT */
					for (i = 0; i < NumRates; i++) {
						if (pmlmeext->datarate[i] > max_rx_rate)
							pmlmeext->datarate[i] = 0xff;
					}

				}
#ifdef CONFIG_80211N_HT
				else if (max_rx_rate < 0x1c) { /* mcs0~mcs15 */
					u32 mcs_bitmap = 0x0;

					for (i = 0; i < ((max_rx_rate + 1) - 0xc); i++)
						mcs_bitmap |= BIT(i);

					set_mcs_rate_by_mask(pmlmeext->default_supported_mcs_set, mcs_bitmap);
				}
#endif /* CONFIG_80211N_HT							 */
			}
		}
			break;
		case 0x1c: { /* enable/disable driver control AMPDU Density for peer sta's rx */
			if (arg == 0) {
				RTW_INFO("disable driver ctrl ampdu density\n");
				padapter->driver_ampdu_spacing = 0xFF;
			} else if (arg == 1) {

				RTW_INFO("enable driver ctrl ampdu density = %d\n", extra_arg);

				if (extra_arg > 0x07)
					padapter->driver_ampdu_spacing = 0xFF;
				else
					padapter->driver_ampdu_spacing = extra_arg;
			}
		}
			break;
#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
		case 0x1e: {
			RTW_INFO("===========================================\n");
			rtw_noise_measure_curchan(padapter);
			RTW_INFO("===========================================\n");
		}
			break;
#endif


#if defined(CONFIG_SDIO_HCI) && defined(CONFIG_SDIO_INDIRECT_ACCESS) && defined(DBG_SDIO_INDIRECT_ACCESS)
		case 0x1f:
			{
				int i, j = 0, test_cnts = 0;
				static u8 test_code = 0x5A;
				static u32 data_misatch_cnt = 0, d_acc_err_cnt = 0;

				u32 d_data, i_data;
				u32 imr;

				test_cnts = extra_arg;
				for (i = 0; i < test_cnts; i++) {
					if (RTW_CANNOT_IO(padapter))
						break;

					rtw_write8(padapter, 0x07, test_code);

					d_data = rtw_read32(padapter, 0x04);
					imr =  rtw_read32(padapter, 0x10250014);
					rtw_write32(padapter, 0x10250014, 0);
					rtw_msleep_os(50);

					i_data = rtw_sd_iread32(padapter, 0x04);

					rtw_write32(padapter, 0x10250014, imr);

					if (d_data != i_data) {
						data_misatch_cnt++;
						RTW_ERR("d_data :0x%08x, i_data : 0x%08x\n", d_data, i_data);
					}

					if (test_code != (i_data >> 24)) {
						d_acc_err_cnt++;
						rtw_write8(padapter, 0x07, 0xAA);
						RTW_ERR("test_code :0x%02x, i_data : 0x%08x\n", test_code, i_data);
					}
					if ((j++) == 100) {
						rtw_msleep_os(2000);
						RTW_INFO(" Indirect access testing..........%d/%d\n", i, test_cnts);
						j = 0;
					}

					test_code = ~test_code;
					rtw_msleep_os(50);
				}
				RTW_INFO("========Indirect access test=========\n");
				RTW_INFO(" test_cnts = %d\n", test_cnts);
				RTW_INFO(" direct & indirect read32 data missatch cnts = %d\n", data_misatch_cnt);
				RTW_INFO(" indirect rdata is not equal to wdata cnts = %d\n", d_acc_err_cnt);
				RTW_INFO("========Indirect access test=========\n\n");
				data_misatch_cnt = d_acc_err_cnt = 0;

			}
			break;
#endif
		case 0x20:
			{
				if (arg == 0xAA) {
					u8 page_offset, page_num;

					page_offset = (u8)(extra_arg >> 16);
					page_num = (u8)(extra_arg & 0xFF);
					rtw_dump_rsvd_page(RTW_DBGDUMP, padapter, page_offset, page_num);
				}
#ifdef CONFIG_SUPPORT_FIFO_DUMP
				else {
					u8 fifo_sel;
					u32 addr, size;

					fifo_sel = (u8)(arg & 0x0F);
					addr = (extra_arg >> 16) & 0xFFFF;
					size = extra_arg & 0xFFFF;
					rtw_dump_fifo(RTW_DBGDUMP, padapter, fifo_sel, addr, size);
				}
#endif
			}
			break;

		case 0x23: {
			RTW_INFO("turn %s the bNotifyChannelChange Variable\n", (extra_arg == 1) ? "on" : "off");
			padapter->bNotifyChannelChange = extra_arg;
			break;
		}
		case 0x24: {
#ifdef CONFIG_P2P
			RTW_INFO("turn %s the bShowGetP2PState Variable\n", (extra_arg == 1) ? "on" : "off");
			padapter->bShowGetP2PState = extra_arg;
#endif /* CONFIG_P2P */
			break;
		}
#ifdef CONFIG_GPIO_API
		case 0x25: { /* Get GPIO register */
			/*
			* dbg 0x7f250000 [gpio_num], Get gpio value, gpio_num:0~7
			*/

			u8 value;
			RTW_INFO("Read GPIO Value  extra_arg = %d\n", extra_arg);
			value = rtw_hal_get_gpio(padapter, extra_arg);
			RTW_INFO("Read GPIO Value = %d\n", value);
			break;
		}
		case 0x26: { /* Set GPIO direction */

			/* dbg 0x7f26000x [y], Set gpio direction,
			* x: gpio_num,4~7  y: indicate direction, 0~1
			*/

			int value;
			RTW_INFO("Set GPIO Direction! arg = %d ,extra_arg=%d\n", arg , extra_arg);
			value = rtw_hal_config_gpio(padapter, arg, extra_arg);
			RTW_INFO("Set GPIO Direction %s\n", (value == -1) ? "Fail!!!" : "Success");
			break;
		}
		case 0x27: { /* Set GPIO output direction value */
			/*
			* dbg 0x7f27000x [y], Set gpio output direction value,
			* x: gpio_num,4~7  y: indicate direction, 0~1
			*/

			int value;
			RTW_INFO("Set GPIO Value! arg = %d ,extra_arg=%d\n", arg , extra_arg);
			value = rtw_hal_set_gpio_output_value(padapter, arg, extra_arg);
			RTW_INFO("Set GPIO Value %s\n", (value == -1) ? "Fail!!!" : "Success");
			break;
		}
#endif
#ifdef DBG_CMD_QUEUE
		case 0x28: {
			dump_cmd_id = extra_arg;
			RTW_INFO("dump_cmd_id:%d\n", dump_cmd_id);
		}
			break;
#endif /* DBG_CMD_QUEUE */
		case 0xaa: {
			if ((extra_arg & 0x7F) > 0x3F)
				extra_arg = 0xFF;
			RTW_INFO("chang data rate to :0x%02x\n", extra_arg);
			padapter->fix_rate = extra_arg;
		}
			break;
		case 0xdd: { /* registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg */
			if (extra_arg == 0)
				mac_reg_dump(RTW_DBGDUMP, padapter);
			else if (extra_arg == 1)
				bb_reg_dump(RTW_DBGDUMP, padapter);
			else if (extra_arg == 2)
				rf_reg_dump(RTW_DBGDUMP, padapter);
			else if (extra_arg == 11)
				bb_reg_dump_ex(RTW_DBGDUMP, padapter);
		}
			break;

		case 0xee: {
			RTW_INFO(" === please control /proc  to trun on/off PHYDM func ===\n");
		}
			break;

		case 0xfd:
			rtw_write8(padapter, 0xc50, arg);
			RTW_INFO("wr(0xc50)=0x%x\n", rtw_read8(padapter, 0xc50));
			rtw_write8(padapter, 0xc58, arg);
			RTW_INFO("wr(0xc58)=0x%x\n", rtw_read8(padapter, 0xc58));
			break;
		case 0xfe:
			RTW_INFO("rd(0xc50)=0x%x\n", rtw_read8(padapter, 0xc50));
			RTW_INFO("rd(0xc58)=0x%x\n", rtw_read8(padapter, 0xc58));
			break;
		case 0xff: {
			RTW_INFO("dbg(0x210)=0x%x\n", rtw_read32(padapter, 0x210));
			RTW_INFO("dbg(0x608)=0x%x\n", rtw_read32(padapter, 0x608));
			RTW_INFO("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
			RTW_INFO("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
			RTW_INFO("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));

			RTW_INFO("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));


			RTW_INFO("\n");

			RTW_INFO("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
			RTW_INFO("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));

			RTW_INFO("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));

			RTW_INFO("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));

			RTW_INFO("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
			RTW_INFO("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));

			RTW_INFO("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
			RTW_INFO("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
			RTW_INFO("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
			RTW_INFO("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
		}
			break;
		}
		break;
	default:
		RTW_INFO("error dbg cmd!\n");
		break;
	}


	return ret;

}

static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
{
	uint ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	switch (name) {
	case IEEE_PARAM_WPA_ENABLED:

		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; /* 802.1x */

		/* ret = ieee80211_wpa_enable(ieee, value); */

		switch ((value) & 0xff) {
		case 1: /* WPA */
			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK; /* WPA_PSK */
			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
			break;
		case 2: /* WPA2 */
			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK; /* WPA2_PSK */
			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
			break;
		}


		break;

	case IEEE_PARAM_TKIP_COUNTERMEASURES:
		/* ieee->tkip_countermeasures=value; */
		break;

	case IEEE_PARAM_DROP_UNENCRYPTED: {
		/* HACK:
		 *
		 * wpa_supplicant calls set_wpa_enabled when the driver
		 * is loaded and unloaded, regardless of if WPA is being
		 * used.  No other calls are made which can be used to
		 * determine if encryption will be used or not prior to
		 * association being expected.  If encryption is not being
		 * used, drop_unencrypted is set to false, else true -- we
		 * can use this to determine if the CAP_PRIVACY_ON bit should
		 * be set.
		 */

#if 0
		struct ieee80211_security sec = {
			.flags = SEC_ENABLED,
			.enabled = value,
		};
		ieee->drop_unencrypted = value;
		/* We only change SEC_LEVEL for open mode. Others
		 * are set by ipw_wpa_set_encryption.
		 */
		if (!value) {
			sec.flags |= SEC_LEVEL;
			sec.level = SEC_LEVEL_0;
		} else {
			sec.flags |= SEC_LEVEL;
			sec.level = SEC_LEVEL_1;
		}
		if (ieee->set_security)
			ieee->set_security(ieee->dev, &sec);
#endif
		break;

	}
	case IEEE_PARAM_PRIVACY_INVOKED:

		/* ieee->privacy_invoked=value; */

		break;

	case IEEE_PARAM_AUTH_ALGS:

		ret = wpa_set_auth_algs(dev, value);

		break;

	case IEEE_PARAM_IEEE_802_1X:

		/* ieee->ieee802_1x=value;		 */

		break;

	case IEEE_PARAM_WPAX_SELECT:

		/* added for WPA2 mixed mode */
		/*RTW_WARN("------------------------>wpax value = %x\n", value);*/
		/*
		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
		ieee->wpax_type_set = 1;
		ieee->wpax_type_notify = value;
		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
		*/

		break;

	default:



		ret = -EOPNOTSUPP;


		break;

	}

	return ret;

}

static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	switch (command) {
	case IEEE_MLME_STA_DEAUTH:

		if (!rtw_set_802_11_disassociate(padapter))
			ret = -1;

		break;

	case IEEE_MLME_STA_DISASSOC:

		if (!rtw_set_802_11_disassociate(padapter))
			ret = -1;

		break;

	default:
		ret = -EOPNOTSUPP;
		break;
	}
#ifdef CONFIG_RTW_REPEATER_SON
	rtw_rson_do_disconnect(padapter);
#endif
	return ret;

}

static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
{
	struct ieee_param *param;
	uint ret = 0;

	/* down(&ieee->wx_sem);	 */

	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
		ret = -EINVAL;
		goto out;
	}

	param = (struct ieee_param *)rtw_malloc(p->length);
	if (param == NULL) {
		ret = -ENOMEM;
		goto out;
	}

	if (copy_from_user(param, p->pointer, p->length)) {
		rtw_mfree((u8 *)param, p->length);
		ret = -EFAULT;
		goto out;
	}

	switch (param->cmd) {

	case IEEE_CMD_SET_WPA_PARAM:
		ret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);
		break;

	case IEEE_CMD_SET_WPA_IE:
		/* ret = wpa_set_wpa_ie(dev, param, p->length); */
		ret =  rtw_set_wpa_ie((_adapter *)rtw_netdev_priv(dev), (char *)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
		break;

	case IEEE_CMD_SET_ENCRYPTION:
		ret = wpa_set_encryption(dev, param, p->length);
		break;

	case IEEE_CMD_MLME:
		ret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);
		break;

	default:
		RTW_INFO("Unknown WPA supplicant request: %d\n", param->cmd);
		ret = -EOPNOTSUPP;
		break;

	}

	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
		ret = -EFAULT;

	rtw_mfree((u8 *)param, p->length);

out:

	/* up(&ieee->wx_sem); */

	return ret;

}

#ifdef CONFIG_AP_MODE
static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
{
	int ret = 0;
	u32 wep_key_idx, wep_key_len, wep_total_len;
	NDIS_802_11_WEP	*pwep = NULL;
	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
	struct security_priv *psecuritypriv = &(padapter->securitypriv);
	struct sta_priv *pstapriv = &padapter->stapriv;

	RTW_INFO("%s\n", __FUNCTION__);

	param->u.crypt.err = 0;
	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';

	/* sizeof(struct ieee_param) = 64 bytes; */
	/* if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len) */
	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len) {
		ret =  -EINVAL;
		goto exit;
	}

	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
		if (param->u.crypt.idx >= WEP_KEYS
#ifdef CONFIG_IEEE80211W
		    && param->u.crypt.idx > BIP_MAX_KEYID
#endif /* CONFIG_IEEE80211W */
		   ) {
			ret = -EINVAL;
			goto exit;
		}
	} else {
		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
		if (!psta) {
			/* ret = -EINVAL; */
			RTW_INFO("rtw_set_encryption(), sta has already been removed or never been added\n");
			goto exit;
		}
	}

	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta == NULL)) {
		/* todo:clear default encryption keys */

		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
		psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
		psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
		psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;

		RTW_INFO("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);

		goto exit;
	}


	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta == NULL)) {
		RTW_INFO("r871x_set_encryption, crypt.alg = WEP\n");

		wep_key_idx = param->u.crypt.idx;
		wep_key_len = param->u.crypt.key_len;

		RTW_INFO("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);

		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0)) {
			ret = -EINVAL;
			goto exit;
		}


		if (wep_key_len > 0) {
			wep_key_len = wep_key_len <= 5 ? 5 : 13;
			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
			pwep = (NDIS_802_11_WEP *)rtw_malloc(wep_total_len);
			if (pwep == NULL) {
				RTW_INFO(" r871x_set_encryption: pwep allocate fail !!!\n");
				goto exit;
			}

			_rtw_memset(pwep, 0, wep_total_len);

			pwep->KeyLength = wep_key_len;
			pwep->Length = wep_total_len;

		}

		pwep->KeyIndex = wep_key_idx;

		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);

		if (param->u.crypt.set_tx) {
			RTW_INFO("wep, set_tx=1\n");

			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
			psecuritypriv->dot118021XGrpPrivacy = _WEP40_;

			if (pwep->KeyLength == 13) {
				psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
				psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
			}


			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;

			_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);

			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;

			rtw_ap_set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx, 1);
		} else {
			RTW_INFO("wep, set_tx=0\n");

			/* don't update "psecuritypriv->dot11PrivacyAlgrthm" and  */
			/* "psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam */

			_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);

			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;

			rtw_ap_set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx, 0);
		}

		goto exit;

	}


	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  */ { /* group key */
		if (param->u.crypt.set_tx == 1) {
			if (strcmp(param->u.crypt.alg, "WEP") == 0) {
				RTW_INFO(FUNC_ADPT_FMT" set WEP TX GTK idx:%u, len:%u\n"
					, FUNC_ADPT_ARG(padapter), param->u.crypt.idx, param->u.crypt.key_len);
				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
				if (param->u.crypt.key_len == 13)
					psecuritypriv->dot118021XGrpPrivacy = _WEP104_;

			} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
				RTW_INFO(FUNC_ADPT_FMT" set TKIP TX GTK idx:%u, len:%u\n"
					, FUNC_ADPT_ARG(padapter), param->u.crypt.idx, param->u.crypt.key_len);
				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
				/* set mic key */
				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
				psecuritypriv->busetkipkey = _TRUE;

			} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
				RTW_INFO(FUNC_ADPT_FMT" set CCMP TX GTK idx:%u, len:%u\n"
					, FUNC_ADPT_ARG(padapter), param->u.crypt.idx, param->u.crypt.key_len);
				psecuritypriv->dot118021XGrpPrivacy = _AES_;
				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));

			#ifdef CONFIG_IEEE80211W
			} else if (strcmp(param->u.crypt.alg, "BIP") == 0) {
				RTW_INFO(FUNC_ADPT_FMT" set TX IGTK idx:%u, len:%u\n"
					, FUNC_ADPT_ARG(padapter), param->u.crypt.idx, param->u.crypt.key_len);
				_rtw_memcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
				psecuritypriv->dot11wBIPKeyid = param->u.crypt.idx;
				psecuritypriv->dot11wBIPtxpn.val = RTW_GET_LE64(param->u.crypt.seq);
				psecuritypriv->binstallBIPkey = _TRUE;
				goto exit;
			#endif /* CONFIG_IEEE80211W */

			} else if (strcmp(param->u.crypt.alg, "none") == 0) {
				RTW_INFO(FUNC_ADPT_FMT" clear group key, idx:%u\n"
					, FUNC_ADPT_ARG(padapter), param->u.crypt.idx);
				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
			} else {
				RTW_WARN(FUNC_ADPT_FMT" set group key, not support\n"
					, FUNC_ADPT_ARG(padapter));
				goto exit;
			}

			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
			pbcmc_sta = rtw_get_bcmc_stainfo(padapter);
			if (pbcmc_sta) {
				pbcmc_sta->dot11txpn.val = RTW_GET_LE64(param->u.crypt.seq);
				pbcmc_sta->ieee8021x_blocked = _FALSE;
				pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy; /* rx will use bmc_sta's dot118021XPrivacy			 */
			}
			psecuritypriv->binstallGrpkey = _TRUE;
			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/* !!! */

			rtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
		}

		goto exit;

	}

	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) { /* psk/802_1x */
		if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
			if (param->u.crypt.set_tx == 1) {
				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));

				if (strcmp(param->u.crypt.alg, "WEP") == 0) {
					RTW_INFO(FUNC_ADPT_FMT" set WEP PTK of "MAC_FMT" idx:%u, len:%u\n"
						, FUNC_ADPT_ARG(padapter), MAC_ARG(psta->cmn.mac_addr)
						, param->u.crypt.idx, param->u.crypt.key_len);
					psta->dot118021XPrivacy = _WEP40_;
					if (param->u.crypt.key_len == 13)
						psta->dot118021XPrivacy = _WEP104_;

				} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
					RTW_INFO(FUNC_ADPT_FMT" set TKIP PTK of "MAC_FMT" idx:%u, len:%u\n"
						, FUNC_ADPT_ARG(padapter), MAC_ARG(psta->cmn.mac_addr)
						, param->u.crypt.idx, param->u.crypt.key_len);
					psta->dot118021XPrivacy = _TKIP_;
					/* set mic key */
					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
					psecuritypriv->busetkipkey = _TRUE;

				} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
					RTW_INFO(FUNC_ADPT_FMT" set CCMP PTK of "MAC_FMT" idx:%u, len:%u\n"
						, FUNC_ADPT_ARG(padapter), MAC_ARG(psta->cmn.mac_addr)
						, param->u.crypt.idx, param->u.crypt.key_len);
					psta->dot118021XPrivacy = _AES_;

				} else if (strcmp(param->u.crypt.alg, "none") == 0) {
					RTW_INFO(FUNC_ADPT_FMT" clear pairwise key of "MAC_FMT" idx:%u\n"
						, FUNC_ADPT_ARG(padapter), MAC_ARG(psta->cmn.mac_addr)
						, param->u.crypt.idx);
					psta->dot118021XPrivacy = _NO_PRIVACY_;

				} else {
					RTW_WARN(FUNC_ADPT_FMT" set pairwise key of "MAC_FMT", not support\n"
						, FUNC_ADPT_ARG(padapter), MAC_ARG(psta->cmn.mac_addr));
					goto exit;
				}

				psta->dot11txpn.val = RTW_GET_LE64(param->u.crypt.seq);
				psta->dot11rxpn.val = RTW_GET_LE64(param->u.crypt.seq);
				psta->ieee8021x_blocked = _FALSE;

				if (psta->dot118021XPrivacy != _NO_PRIVACY_) {
					psta->bpairwise_key_installed = _TRUE;

					/* WPA2 key-handshake has completed */
					if (psecuritypriv->ndisauthtype == Ndis802_11AuthModeWPA2PSK)
						psta->state &= (~WIFI_UNDER_KEY_HANDSHAKE);
				}

				rtw_ap_set_pairwise_key(padapter, psta);
			} else {
				RTW_WARN(FUNC_ADPT_FMT" set group key of "MAC_FMT", not support\n"
					, FUNC_ADPT_ARG(padapter), MAC_ARG(psta->cmn.mac_addr));
				goto exit;
			}

		}

	}

exit:

	if (pwep)
		rtw_mfree((u8 *)pwep, wep_total_len);

	return ret;

}

static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct sta_priv *pstapriv = &padapter->stapriv;
	unsigned char *pbuf = param->u.bcn_ie.buf;


	RTW_INFO("%s, len=%d\n", __FUNCTION__, len);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	_rtw_memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);

	if ((pstapriv->max_num_sta > NUM_STA) || (pstapriv->max_num_sta <= 0))
		pstapriv->max_num_sta = NUM_STA;


	if (rtw_check_beacon_data(padapter, pbuf, (len - 12 - 2)) == _SUCCESS) /* 12 = param header, 2:no packed */
		ret = 0;
	else
		ret = -EINVAL;


	return ret;

}

static int rtw_hostapd_sta_flush(struct net_device *dev)
{
	/* _irqL irqL; */
	/* _list	*phead, *plist; */
	int ret = 0;
	/* struct sta_info *psta = NULL; */
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	/* struct sta_priv *pstapriv = &padapter->stapriv; */

	RTW_INFO("%s\n", __FUNCTION__);

	flush_all_cam_entry(padapter);	/* clear CAM */
#ifdef CONFIG_AP_MODE
	ret = rtw_sta_flush(padapter, _TRUE);
#endif
	return ret;

}

static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
{
	int ret = 0;
	struct sta_info *psta = NULL;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct sta_priv *pstapriv = &padapter->stapriv;

	RTW_INFO("rtw_add_sta(aid=%d)=" MAC_FMT "\n", param->u.add_sta.aid, MAC_ARG(param->sta_addr));

	if (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != _TRUE)
		return -EINVAL;

	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
		return -EINVAL;

#if 0
	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
	if (psta) {
		RTW_INFO("rtw_add_sta(), free has been added psta=%p\n", psta);
		/* _enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		 */
		rtw_free_stainfo(padapter,  psta);
		/* _exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL); */

		psta = NULL;
	}
#endif
	/* psta = rtw_alloc_stainfo(pstapriv, param->sta_addr); */
	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
	if (psta) {
		int flags = param->u.add_sta.flags;

		/* RTW_INFO("rtw_add_sta(), init sta's variables, psta=%p\n", psta); */

		psta->cmn.aid = param->u.add_sta.aid;/* aid=1~2007 */

		_rtw_memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);


		/* check wmm cap. */
		if (WLAN_STA_WME & flags)
			psta->qos_option = 1;
		else
			psta->qos_option = 0;

		if (pmlmepriv->qospriv.qos_option == 0)
			psta->qos_option = 0;


#ifdef CONFIG_80211N_HT
		/* chec 802.11n ht cap. */
		if (padapter->registrypriv.ht_enable &&
			is_supported_ht(padapter->registrypriv.wireless_mode) &&
			(WLAN_STA_HT & flags)) {
			psta->htpriv.ht_option = _TRUE;
			psta->qos_option = 1;
			_rtw_memcpy((void *)&psta->htpriv.ht_cap, (void *)&param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
		} else
			psta->htpriv.ht_option = _FALSE;

		if (pmlmepriv->htpriv.ht_option == _FALSE)
			psta->htpriv.ht_option = _FALSE;

#endif


		update_sta_info_apmode(padapter, psta);


	} else
		ret = -ENOMEM;

	return ret;

}

static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
{
	_irqL irqL;
	int ret = 0;
	struct sta_info *psta = NULL;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct sta_priv *pstapriv = &padapter->stapriv;

	RTW_INFO("rtw_del_sta=" MAC_FMT "\n", MAC_ARG(param->sta_addr));

	if (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != _TRUE)
		return -EINVAL;

	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
		return -EINVAL;

	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
	if (psta) {
		u8 updated = _FALSE;

		/* RTW_INFO("free psta=%p, aid=%d\n", psta, psta->cmn.aid); */

		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
		if (rtw_is_list_empty(&psta->asoc_list) == _FALSE) {
			rtw_list_delete(&psta->asoc_list);
			pstapriv->asoc_list_cnt--;
			updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING, _TRUE);

		}
		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);

		associated_clients_update(padapter, updated, STA_INFO_UPDATE_ALL);

		psta = NULL;

	} else {
		RTW_INFO("rtw_del_sta(), sta has already been removed or never been added\n");

		/* ret = -1; */
	}


	return ret;

}

static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	struct sta_info *psta = NULL;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct sta_priv *pstapriv = &padapter->stapriv;
	struct ieee_param_ex *param_ex = (struct ieee_param_ex *)param;
	struct sta_data *psta_data = (struct sta_data *)param_ex->data;

	RTW_INFO("rtw_ioctl_get_sta_info, sta_addr: " MAC_FMT "\n", MAC_ARG(param_ex->sta_addr));

	if (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != _TRUE)
		return -EINVAL;

	if (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&
	    param_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&
	    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff)
		return -EINVAL;

	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
	if (psta) {
#if 0
		struct {
			u16 aid;
			u16 capability;
			int flags;
			u32 sta_set;
			u8 tx_supp_rates[16];
			u32 tx_supp_rates_len;
			struct rtw_ieee80211_ht_cap ht_cap;
			u64	rx_pkts;
			u64	rx_bytes;
			u64	rx_drops;
			u64	tx_pkts;
			u64	tx_bytes;
			u64	tx_drops;
		} get_sta;
#endif
		psta_data->aid = (u16)psta->cmn.aid;
		psta_data->capability = psta->capability;
		psta_data->flags = psta->flags;

		/*
				nonerp_set : BIT(0)
				no_short_slot_time_set : BIT(1)
				no_short_preamble_set : BIT(2)
				no_ht_gf_set : BIT(3)
				no_ht_set : BIT(4)
				ht_20mhz_set : BIT(5)
		*/

		psta_data->sta_set = ((psta->nonerp_set) |
				      (psta->no_short_slot_time_set << 1) |
				      (psta->no_short_preamble_set << 2) |
				      (psta->no_ht_gf_set << 3) |
				      (psta->no_ht_set << 4) |
				      (psta->ht_20mhz_set << 5));

		psta_data->tx_supp_rates_len =  psta->bssratelen;
		_rtw_memcpy(psta_data->tx_supp_rates, psta->bssrateset, psta->bssratelen);
#ifdef CONFIG_80211N_HT
		if(padapter->registrypriv.ht_enable && is_supported_ht(padapter->registrypriv.wireless_mode))
			_rtw_memcpy(&psta_data->ht_cap, &psta->htpriv.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
#endif /* CONFIG_80211N_HT */
		psta_data->rx_pkts = psta->sta_stats.rx_data_pkts;
		psta_data->rx_bytes = psta->sta_stats.rx_bytes;
		psta_data->rx_drops = psta->sta_stats.rx_drops;

		psta_data->tx_pkts = psta->sta_stats.tx_pkts;
		psta_data->tx_bytes = psta->sta_stats.tx_bytes;
		psta_data->tx_drops = psta->sta_stats.tx_drops;


	} else
		ret = -1;

	return ret;

}

static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
{
	int ret = 0;
	struct sta_info *psta = NULL;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct sta_priv *pstapriv = &padapter->stapriv;

	RTW_INFO("rtw_get_sta_wpaie, sta_addr: " MAC_FMT "\n", MAC_ARG(param->sta_addr));

	if (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != _TRUE)
		return -EINVAL;

	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
		return -EINVAL;

	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
	if (psta) {
		if ((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC)) {
			int wpa_ie_len;
			int copy_len;

			wpa_ie_len = psta->wpa_ie[1];

			copy_len = ((wpa_ie_len + 2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)) : (wpa_ie_len + 2);

			param->u.wpa_ie.len = copy_len;

			_rtw_memcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);
		} else {
			/* ret = -1; */
			RTW_INFO("sta's wpa_ie is NONE\n");
		}
	} else
		ret = -1;

	return ret;

}

static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	unsigned char wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
	int ie_len;

	RTW_INFO("%s, len=%d\n", __FUNCTION__, len);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	ie_len = len - 12 - 2; /* 12 = param header, 2:no packed */


	if (pmlmepriv->wps_beacon_ie) {
		rtw_mfree(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len);
		pmlmepriv->wps_beacon_ie = NULL;
	}

	if (ie_len > 0) {
		pmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);
		pmlmepriv->wps_beacon_ie_len = ie_len;
		if (pmlmepriv->wps_beacon_ie == NULL) {
			RTW_INFO("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
			return -EINVAL;
		}

		_rtw_memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);

		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE, 0);

		pmlmeext->bstart_bss = _TRUE;

	}


	return ret;

}

static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	int ie_len;

	RTW_INFO("%s, len=%d\n", __FUNCTION__, len);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	ie_len = len - 12 - 2; /* 12 = param header, 2:no packed */


	if (pmlmepriv->wps_probe_resp_ie) {
		rtw_mfree(pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
		pmlmepriv->wps_probe_resp_ie = NULL;
	}

	if (ie_len > 0) {
		pmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);
		pmlmepriv->wps_probe_resp_ie_len = ie_len;
		if (pmlmepriv->wps_probe_resp_ie == NULL) {
			RTW_INFO("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
			return -EINVAL;
		}
		_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);
	}


	return ret;

}

static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	int ie_len;

	RTW_INFO("%s, len=%d\n", __FUNCTION__, len);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	ie_len = len - 12 - 2; /* 12 = param header, 2:no packed */


	if (pmlmepriv->wps_assoc_resp_ie) {
		rtw_mfree(pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
		pmlmepriv->wps_assoc_resp_ie = NULL;
	}

	if (ie_len > 0) {
		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);
		pmlmepriv->wps_assoc_resp_ie_len = ie_len;
		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
			RTW_INFO("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
			return -EINVAL;
		}

		_rtw_memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);
	}


	return ret;

}

static int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *mlmepriv = &(adapter->mlmepriv);
	struct mlme_ext_priv	*mlmeext = &(adapter->mlmeextpriv);
	struct mlme_ext_info	*mlmeinfo = &(mlmeext->mlmext_info);
	int ie_len;
	u8 *ssid_ie;
	char ssid[NDIS_802_11_LENGTH_SSID + 1];
	sint ssid_len = 0;
	u8 ignore_broadcast_ssid;

	if (check_fwstate(mlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EPERM;

	if (param->u.bcn_ie.reserved[0] != 0xea)
		return -EINVAL;

	mlmeinfo->hidden_ssid_mode = ignore_broadcast_ssid = param->u.bcn_ie.reserved[1];

	ie_len = len - 12 - 2; /* 12 = param header, 2:no packed */
	ssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);

	if (ssid_ie && ssid_len > 0 && ssid_len <= NDIS_802_11_LENGTH_SSID) {
		WLAN_BSSID_EX *pbss_network = &mlmepriv->cur_network.network;
		WLAN_BSSID_EX *pbss_network_ext = &mlmeinfo->network;

		_rtw_memcpy(ssid, ssid_ie + 2, ssid_len);
		ssid[ssid_len] = 0x0;

		if (0)
			RTW_INFO(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
				ssid, ssid_len,
				pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
				pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);

		_rtw_memcpy(pbss_network->Ssid.Ssid, (void *)ssid, ssid_len);
		pbss_network->Ssid.SsidLength = ssid_len;
		_rtw_memcpy(pbss_network_ext->Ssid.Ssid, (void *)ssid, ssid_len);
		pbss_network_ext->Ssid.SsidLength = ssid_len;

		if (0)
			RTW_INFO(FUNC_ADPT_FMT" after ssid:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
				pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
				pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
	}

	RTW_INFO(FUNC_ADPT_FMT" ignore_broadcast_ssid:%d, %s,%d\n", FUNC_ADPT_ARG(adapter),
		ignore_broadcast_ssid, ssid, ssid_len);

	return ret;
}

#if CONFIG_RTW_MACADDR_ACL
static int rtw_ioctl_acl_remove_sta(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
		return -EINVAL;

	ret = rtw_acl_remove_sta(padapter, RTW_ACL_PERIOD_BSS, param->sta_addr);

	return ret;

}

static int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
		return -EINVAL;

	ret = rtw_acl_add_sta(padapter, RTW_ACL_PERIOD_BSS, param->sta_addr);

	return ret;

}

static int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)
{
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);

	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
		return -EINVAL;

	rtw_set_macaddr_acl(padapter, RTW_ACL_PERIOD_BSS, param->u.mlme.command);

	return ret;
}
#endif /* CONFIG_RTW_MACADDR_ACL */

static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
{
	struct ieee_param *param;
	int ret = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	/* RTW_INFO("%s\n", __FUNCTION__); */

	/*
	* this function is expect to call in master mode, which allows no power saving
	* so, we just check hw_init_completed
	*/

	if (!rtw_is_hw_init_completed(padapter)) {
		ret = -EPERM;
		goto out;
	}


	/* if (p->length < sizeof(struct ieee_param) || !p->pointer){ */
	if (!p->pointer) {
		ret = -EINVAL;
		goto out;
	}

	param = (struct ieee_param *)rtw_malloc(p->length);
	if (param == NULL) {
		ret = -ENOMEM;
		goto out;
	}

	if (copy_from_user(param, p->pointer, p->length)) {
		rtw_mfree((u8 *)param, p->length);
		ret = -EFAULT;
		goto out;
	}

	/* RTW_INFO("%s, cmd=%d\n", __FUNCTION__, param->cmd); */

	switch (param->cmd) {
	case RTL871X_HOSTAPD_FLUSH:

		ret = rtw_hostapd_sta_flush(dev);

		break;

	case RTL871X_HOSTAPD_ADD_STA:

		ret = rtw_add_sta(dev, param);

		break;

	case RTL871X_HOSTAPD_REMOVE_STA:

		ret = rtw_del_sta(dev, param);

		break;

	case RTL871X_HOSTAPD_SET_BEACON:

		ret = rtw_set_beacon(dev, param, p->length);

		break;

	case RTL871X_SET_ENCRYPTION:

		ret = rtw_set_encryption(dev, param, p->length);

		break;

	case RTL871X_HOSTAPD_GET_WPAIE_STA:

		ret = rtw_get_sta_wpaie(dev, param);

		break;

	case RTL871X_HOSTAPD_SET_WPS_BEACON:

		ret = rtw_set_wps_beacon(dev, param, p->length);

		break;

	case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:

		ret = rtw_set_wps_probe_resp(dev, param, p->length);

		break;

	case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:

		ret = rtw_set_wps_assoc_resp(dev, param, p->length);

		break;

	case RTL871X_HOSTAPD_SET_HIDDEN_SSID:

		ret = rtw_set_hidden_ssid(dev, param, p->length);

		break;

	case RTL871X_HOSTAPD_GET_INFO_STA:

		ret = rtw_ioctl_get_sta_data(dev, param, p->length);

		break;

#if CONFIG_RTW_MACADDR_ACL
	case RTL871X_HOSTAPD_SET_MACADDR_ACL:
		ret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);
		break;
	case RTL871X_HOSTAPD_ACL_ADD_STA:
		ret = rtw_ioctl_acl_add_sta(dev, param, p->length);
		break;
	case RTL871X_HOSTAPD_ACL_REMOVE_STA:
		ret = rtw_ioctl_acl_remove_sta(dev, param, p->length);
		break;
#endif /* CONFIG_RTW_MACADDR_ACL */

	default:
		RTW_INFO("Unknown hostapd request: %d\n", param->cmd);
		ret = -EOPNOTSUPP;
		break;

	}

	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
		ret = -EFAULT;


	rtw_mfree((u8 *)param, p->length);

out:

	return ret;

}
#endif

static int rtw_wx_set_priv(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *awrq,
			   char *extra)
{

#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
	char *ext_dbg;
#endif

	int ret = 0;
	int len = 0;
	char *ext;
#ifdef CONFIG_ANDROID
	int i;
#endif

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct iw_point *dwrq = (struct iw_point *)awrq;

	if (dwrq->length == 0)
		return -EFAULT;

	len = dwrq->length;
	ext = rtw_vmalloc(len);
	if (!ext)
		return -ENOMEM;

	if (copy_from_user(ext, dwrq->pointer, len)) {
		rtw_vmfree(ext, len);
		return -EFAULT;
	}



#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
	ext_dbg = rtw_vmalloc(len);
	if (!ext_dbg) {
		rtw_vmfree(ext, len);
		return -ENOMEM;
	}

	_rtw_memcpy(ext_dbg, ext, len);
#endif

	/* added for wps2.0 @20110524 */
	if (dwrq->flags == 0x8766 && len > 8) {
		u32 cp_sz;
		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
		u8 *probereq_wpsie = ext;
		int probereq_wpsie_len = len;
		u8 wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};

		if ((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
		    (_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) == _TRUE)) {
			cp_sz = probereq_wpsie_len > MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN : probereq_wpsie_len;

			if (pmlmepriv->wps_probe_req_ie) {
				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
				pmlmepriv->wps_probe_req_ie_len = 0;
				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
				pmlmepriv->wps_probe_req_ie = NULL;
			}

			pmlmepriv->wps_probe_req_ie = rtw_malloc(cp_sz);
			if (pmlmepriv->wps_probe_req_ie == NULL) {
				printk("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
				ret =  -EINVAL;
				goto FREE_EXT;

			}

			_rtw_memcpy(pmlmepriv->wps_probe_req_ie, probereq_wpsie, cp_sz);
			pmlmepriv->wps_probe_req_ie_len = cp_sz;

		}

		goto FREE_EXT;

	}

	if (len >= WEXT_CSCAN_HEADER_SIZE
		&& _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
	) {
		ret = rtw_wx_set_scan(dev, info, awrq, ext);
		goto FREE_EXT;
	}

#ifdef CONFIG_ANDROID
	/* RTW_INFO("rtw_wx_set_priv: %s req=%s\n", dev->name, ext); */

	i = rtw_android_cmdstr_to_num(ext);

	switch (i) {
	case ANDROID_WIFI_CMD_START:
		indicate_wx_custom_event(padapter, "START");
		break;
	case ANDROID_WIFI_CMD_STOP:
		indicate_wx_custom_event(padapter, "STOP");
		break;
	case ANDROID_WIFI_CMD_RSSI: {
		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
		struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;

		if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
			sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
		else
			sprintf(ext, "OK");
	}
		break;
	case ANDROID_WIFI_CMD_LINKSPEED: {
		u16 mbps = rtw_get_cur_max_rate(padapter) / 10;
		sprintf(ext, "LINKSPEED %d", mbps);
	}
		break;
	case ANDROID_WIFI_CMD_MACADDR:
		sprintf(ext, "MACADDR = " MAC_FMT, MAC_ARG(dev->dev_addr));
		break;
	case ANDROID_WIFI_CMD_SCAN_ACTIVE: {
		/* rtw_set_scan_mode(padapter, SCAN_ACTIVE); */
		sprintf(ext, "OK");
	}
		break;
	case ANDROID_WIFI_CMD_SCAN_PASSIVE: {
		/* rtw_set_scan_mode(padapter, SCAN_PASSIVE); */
		sprintf(ext, "OK");
	}
		break;

	case ANDROID_WIFI_CMD_COUNTRY: {
		char country_code[10];
		sscanf(ext, "%*s %s", country_code);
		rtw_set_country(padapter, country_code);
		sprintf(ext, "OK");
	}
		break;
	default:
		#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
		RTW_INFO("%s: %s unknowned req=%s\n", __FUNCTION__,
			dev->name, ext_dbg);
		#endif

		sprintf(ext, "OK");

	}

	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext) + 1))))
		ret = -EFAULT;

#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
	RTW_INFO("%s: %s req=%s rep=%s dwrq->length=%d, strlen(ext)+1=%d\n", __FUNCTION__,
		dev->name, ext_dbg , ext, dwrq->length, (u16)(strlen(ext) + 1));
#endif
#endif /* end of CONFIG_ANDROID */


FREE_EXT:

	rtw_vmfree(ext, len);
	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
	rtw_vmfree(ext_dbg, len);
	#endif

	/* RTW_INFO("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n",  */
	/*		dev->name, ret); */

	return ret;

}
#ifdef CONFIG_WOWLAN
static int rtw_wowlan_ctrl(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra)
{
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wowlan_ioctl_param poidparam;
	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	int ret = 0;
	systime start_time = rtw_get_current_time();
	poidparam.subcode = 0;

	RTW_INFO("+rtw_wowlan_ctrl: %s\n", extra);

	if (!check_fwstate(pmlmepriv, _FW_LINKED) &&
		check_fwstate(pmlmepriv, WIFI_STATION_STATE) &&
		!WOWLAN_IS_STA_MIX_MODE(padapter)) {
#ifdef CONFIG_PNO_SUPPORT
		pwrctrlpriv->wowlan_pno_enable = _TRUE;
#else
		RTW_INFO("[%s] WARNING: Please Connect With AP First!!\n", __func__);
		goto _rtw_wowlan_ctrl_exit_free;
#endif /* CONFIG_PNO_SUPPORT */
	}

	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
		rtw_scan_abort(padapter);

	if (_rtw_memcmp(extra, "enable", 6))


		rtw_suspend_common(padapter);

	else if (_rtw_memcmp(extra, "disable", 7)) {
#ifdef CONFIG_USB_HCI
		RTW_ENABLE_FUNC(padapter, DF_RX_BIT);
		RTW_ENABLE_FUNC(padapter, DF_TX_BIT);
#endif
		rtw_resume_common(padapter);

#ifdef CONFIG_PNO_SUPPORT
		pwrctrlpriv->wowlan_pno_enable = _FALSE;
#endif /* CONFIG_PNO_SUPPORT */

	} else {
		RTW_INFO("[%s] Invalid Parameter.\n", __func__);
		goto _rtw_wowlan_ctrl_exit_free;
	}
	/* mutex_lock(&ioctl_mutex); */
_rtw_wowlan_ctrl_exit_free:
	RTW_INFO("-rtw_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
	RTW_PRINT("%s in %d ms\n", __func__,
		  rtw_get_passing_time_ms(start_time));
	return ret;
}

/*
 * IP filter This pattern if for a frame containing a ip packet:
 * AA:AA:AA:AA:AA:AA:BB:BB:BB:BB:BB:BB:CC:CC:DD:-:-:-:-:-:-:-:-:EE:-:-:FF:FF:FF:FF:GG:GG:GG:GG:HH:HH:II:II
 *
 * A: Ethernet destination address
 * B: Ethernet source address
 * C: Ethernet protocol type
 * D: IP header VER+Hlen, use: 0x45 (4 is for ver 4, 5 is for len 20)
 * E: IP protocol
 * F: IP source address ( 192.168.0.4: C0:A8:00:2C )
 * G: IP destination address ( 192.168.0.4: C0:A8:00:2C )
 * H: Source port (1024: 04:00)
 * I: Destination port (1024: 04:00)
 */

static int rtw_wowlan_set_pattern(struct net_device *dev,
				  struct iw_request_info *info,
				  union iwreq_data *wrqu, char *extra)
{
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	struct wowlan_ioctl_param poidparam;
	int ret = 0;
	u8 input[wrqu->data.length];
	u8 index = 0;

	poidparam.subcode = 0;

	if (!check_fwstate(pmlmepriv, _FW_LINKED) &&
	    check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
		ret = -EFAULT;
		RTW_INFO("Please Connect With AP First!!\n");
		goto _rtw_wowlan_set_pattern_exit;
	}

	if (wrqu->data.length <= 0) {
		ret = -EFAULT;
		RTW_INFO("ERROR: parameter length <= 0\n");
		goto _rtw_wowlan_set_pattern_exit;
	} else {
		/* set pattern */
		if (copy_from_user(input,
				   wrqu->data.pointer, wrqu->data.length))
			return -EFAULT;
		/* leave PS first */
		rtw_ps_deny(padapter, PS_DENY_IOCTL);
		LeaveAllPowerSaveModeDirect(padapter);
		if (strncmp(input, "pattern=", 8) == 0) {
			if (pwrpriv->wowlan_pattern_idx >= MAX_WKFM_CAM_NUM) {
				RTW_INFO("WARNING: priv-pattern is full(idx: %d)\n",
					 pwrpriv->wowlan_pattern_idx);
				RTW_INFO("WARNING: please clean priv-pattern first\n");
				ret = -EINVAL;
				goto _rtw_wowlan_set_pattern_exit;
			} else {
				index = pwrpriv->wowlan_pattern_idx;
				ret = rtw_wowlan_parser_pattern_cmd(input,
					    pwrpriv->patterns[index].content,
					    &pwrpriv->patterns[index].len,
					    pwrpriv->patterns[index].mask);

				if (ret == _TRUE)
					pwrpriv->wowlan_pattern_idx++;
			}
		} else if (strncmp(input, "clean", 5) == 0) {
			poidparam.subcode = WOWLAN_PATTERN_CLEAN;
			rtw_hal_set_hwreg(padapter,
					  HW_VAR_WOWLAN, (u8 *)&poidparam);
		} else if (strncmp(input, "show", 4) == 0) {
			rtw_wow_pattern_cam_dump(padapter);
			rtw_wow_pattern_sw_dump(padapter);
		} else {
			RTW_INFO("ERROR: incorrect parameter!\n");
			ret = -EINVAL;
		}
		rtw_ps_deny_cancel(padapter, PS_DENY_IOCTL);
	}
_rtw_wowlan_set_pattern_exit:
	return ret;
}
#endif /* CONFIG_WOWLAN */

#ifdef CONFIG_AP_WOWLAN
static int rtw_ap_wowlan_ctrl(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct wowlan_ioctl_param poidparam;
	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	struct sta_info	*psta = NULL;
	int ret = 0;
	systime start_time = rtw_get_current_time();
	poidparam.subcode = 0;

	RTW_INFO("+rtw_ap_wowlan_ctrl: %s\n", extra);

	if (!check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
		RTW_INFO("[%s] It is not AP mode!!\n", __func__);
		goto _rtw_ap_wowlan_ctrl_exit_free;
	}

	if (_rtw_memcmp(extra, "enable", 6)) {

		pwrctrlpriv->wowlan_ap_mode = _TRUE;

		rtw_suspend_common(padapter);
	} else if (_rtw_memcmp(extra, "disable", 7)) {
#ifdef CONFIG_USB_HCI
		RTW_ENABLE_FUNC(padapter, DF_RX_BIT);
		RTW_ENABLE_FUNC(padapter, DF_TX_BIT);
#endif
		rtw_resume_common(padapter);
	} else {
		RTW_INFO("[%s] Invalid Parameter.\n", __func__);
		goto _rtw_ap_wowlan_ctrl_exit_free;
	}
	/* mutex_lock(&ioctl_mutex); */
_rtw_ap_wowlan_ctrl_exit_free:
	RTW_INFO("-rtw_ap_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
	RTW_PRINT("%s in %d ms\n", __func__,
		  rtw_get_passing_time_ms(start_time));
_rtw_ap_wowlan_ctrl_exit:
	return ret;
}
#endif /* CONFIG_AP_WOWLAN */

static int rtw_pm_set(struct net_device *dev,
		      struct iw_request_info *info,
		      union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
	unsigned	mode = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	RTW_INFO("[%s] extra = %s\n", __FUNCTION__, extra);

	if (_rtw_memcmp(extra, "lps=", 4)) {
		sscanf(extra + 4, "%u", &mode);
		ret = rtw_pm_set_lps(padapter, mode);
	} else if (_rtw_memcmp(extra, "ips=", 4)) {
		sscanf(extra + 4, "%u", &mode);
		ret = rtw_pm_set_ips(padapter, mode);
	} else if (_rtw_memcmp(extra, "lps_level=", 10)) {
		if (sscanf(extra + 10, "%u", &mode) > 0)
			ret = rtw_pm_set_lps_level(padapter, mode);
#ifdef CONFIG_LPS_1T1R
	} else if (_rtw_memcmp(extra, "lps_1t1r=", 9)) {
		if (sscanf(extra + 9, "%u", &mode) > 0)
			ret = rtw_pm_set_lps_1t1r(padapter, mode);
#endif
	}
#ifdef CONFIG_WOWLAN
	else if (_rtw_memcmp(extra, "wow_lps=", 8)) {
		sscanf(extra + 8, "%u", &mode);
		ret = rtw_pm_set_wow_lps(padapter, mode);
	} else if (_rtw_memcmp(extra, "wow_lps_level=", 14)) {
		if (sscanf(extra + 14, "%u", &mode) > 0)
			ret = rtw_pm_set_wow_lps_level(padapter, mode);
	#ifdef CONFIG_LPS_1T1R
	} else if (_rtw_memcmp(extra, "wow_lps_1t1r=", 13)) {
		if (sscanf(extra + 13, "%u", &mode) > 0)
			ret = rtw_pm_set_wow_lps_1t1r(padapter, mode);
	#endif
	}
#endif /* CONFIG_WOWLAN */
	else
		ret = -EINVAL;

	return ret;
}
#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE

int rtw_vendor_ie_get_raw_data(struct net_device *dev, u32 vendor_ie_num,
							   char *extra, u32 length)
{
	int j;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	u32 vendor_ie_mask = 0;
	char *pstring;

	if (vendor_ie_num >= WLAN_MAX_VENDOR_IE_NUM) {
		RTW_INFO("[%s] only support %d vendor ie\n", __func__ ,
				 WLAN_MAX_VENDOR_IE_NUM);
		return -EFAULT;
	}

	if (pmlmepriv->vendor_ielen[vendor_ie_num] == 0) {
		RTW_INFO("[%s]  Fail, vendor_ie_num: %d is not set\n", __func__,
				 vendor_ie_num);
		return -EFAULT;
	}

	if (length < 2 * pmlmepriv->vendor_ielen[vendor_ie_num] + 5) {
		RTW_INFO("[%s]  Fail, buffer size is too small\n", __func__);
		return -EFAULT;
	}

	vendor_ie_mask = pmlmepriv->vendor_ie_mask[vendor_ie_num];
	_rtw_memset(extra, 0, length);

	pstring = extra;
	pstring += sprintf(pstring, "%d,%x,", vendor_ie_num, vendor_ie_mask);

	for (j = 0; j < pmlmepriv->vendor_ielen[vendor_ie_num]; j++)
		pstring += sprintf(pstring, "%02x", pmlmepriv->vendor_ie[vendor_ie_num][j]);

	length = pstring - extra;
	return length;
}

int rtw_vendor_ie_get_data(struct net_device *dev, int vendor_ie_num, char *extra)
{
	int j;
	char *pstring;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	u32 vendor_ie_mask = 0;
	__u16 length = 0;

	vendor_ie_mask = pmlmepriv->vendor_ie_mask[vendor_ie_num];
	pstring = extra;
	pstring += sprintf(pstring , "\nVendor IE num %d , Mask:%x " , vendor_ie_num , vendor_ie_mask);

	if (vendor_ie_mask & WIFI_BEACON_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[Beacon]");
	if (vendor_ie_mask & WIFI_PROBEREQ_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[Probe Req]");
	if (vendor_ie_mask & WIFI_PROBERESP_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[Probe Resp]");
	if (vendor_ie_mask & WIFI_ASSOCREQ_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[Assoc Req]");
	if (vendor_ie_mask & WIFI_ASSOCRESP_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[Assoc Resp]");
#ifdef CONFIG_P2P
	if (vendor_ie_mask & WIFI_P2P_PROBEREQ_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[P2P_Probe Req]");
	if (vendor_ie_mask & WIFI_P2P_PROBERESP_VENDOR_IE_BIT)
		pstring += sprintf(pstring , "[P2P_Probe Resp]");
#endif

	pstring += sprintf(pstring , "\nVendor IE:\n");
	for (j = 0 ; j < pmlmepriv->vendor_ielen[vendor_ie_num]  ; j++)
		pstring += sprintf(pstring , "%02x" , pmlmepriv->vendor_ie[vendor_ie_num][j]);

	length = pstring - extra;
	return length;

}

int rtw_vendor_ie_get(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
	int ret = 0, vendor_ie_num = 0, cmdlen;
	struct iw_point *p;
	u8 *ptmp;

	p = &wrqu->data;
	cmdlen = p->length;
	if (0 == cmdlen)
		return -EINVAL;

	ptmp = (u8 *)rtw_malloc(cmdlen);
	if (NULL == ptmp)
		return -ENOMEM;

	if (copy_from_user(ptmp, p->pointer, cmdlen)) {
		ret = -EFAULT;
		goto exit;
	}
	ret = sscanf(ptmp , "%d", &vendor_ie_num);
	if (vendor_ie_num > WLAN_MAX_VENDOR_IE_NUM - 1) {
		ret = -EFAULT;
		goto exit;
	}

	wrqu->data.length = rtw_vendor_ie_get_data(dev, vendor_ie_num, extra);

exit:
	rtw_mfree(ptmp, cmdlen);

	return 0;
}

int rtw_vendor_ie_set(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
	int ret = 0, i , len = 0 , totoal_ie_len = 0 , total_ie_len_byte = 0;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
	u32 vendor_ie_mask = 0;
	u32 vendor_ie_num = 0;
	u32 vendor_ie_mask_max = BIT(WLAN_MAX_VENDOR_IE_MASK_MAX) - 1;
	u32 id, elen;

	ret = sscanf(extra, "%d,%x,%*s", &vendor_ie_num , &vendor_ie_mask);
	if (strrchr(extra , ','))
		extra = strrchr(extra , ',') + 1;
	else
		return -EINVAL;
	totoal_ie_len = strlen(extra);
	RTW_INFO("[%s] vendor_ie_num = %d , vendor_ie_mask = 0x%x , vendor_ie = %s , len = %d\n", __func__ , vendor_ie_num , vendor_ie_mask , extra  , totoal_ie_len);

	if (vendor_ie_num  > WLAN_MAX_VENDOR_IE_NUM - 1) {
		RTW_INFO("[%s] Fail, only support %d vendor ie\n", __func__ , WLAN_MAX_VENDOR_IE_NUM);
		return -EFAULT;
	}

	if (totoal_ie_len > WLAN_MAX_VENDOR_IE_LEN) {
		RTW_INFO("[%s] Fail , not support ie length extend %d\n", __func__ , WLAN_MAX_VENDOR_IE_LEN);
		return -EFAULT;
	}

	if (vendor_ie_mask > vendor_ie_mask_max) {
		RTW_INFO("[%s] Fail, not support vendor_ie_mask more than 0x%x\n", __func__ , vendor_ie_mask_max);
		return -EFAULT;
	}

	if (vendor_ie_mask == 0) {
		RTW_INFO("[%s] Clear vendor_ie_num %d group\n", __func__ , vendor_ie_num);
		goto _clear_path;
	}

	if (totoal_ie_len % 2 != 0) {
		RTW_INFO("[%s]  Fail , IE length = %zu is odd\n" , __func__ , strlen(extra));
		return -EFAULT;
	}

	if (totoal_ie_len > 0) {
		for (i = 0  ; i < strlen(extra) ; i += 2) {
			pmlmepriv->vendor_ie[vendor_ie_num][len] = key_2char2num(extra[i] , extra[i + 1]);
			if (len == 0) {
				id = pmlmepriv->vendor_ie[vendor_ie_num][len];
				if (id != WLAN_EID_VENDOR_SPECIFIC) {
					RTW_INFO("[%s] Fail , VENDOR SPECIFIC IE ID \"%x\" was not correct\n", __func__ , id);
					goto _clear_path;
				}
			} else if (len == 1) {
				total_ie_len_byte = (totoal_ie_len / 2) - 2;
				elen = pmlmepriv->vendor_ie[vendor_ie_num][len];
				if (elen != total_ie_len_byte) {
					RTW_INFO("[%s] Fail , Input IE length = \"%d\"(hex:%x) bytes , not match input total IE context length \"%d\" bytes\n", __func__ , elen , elen ,
						 total_ie_len_byte);
					goto _clear_path;
				}
			}
			len++;
		}
		pmlmepriv->vendor_ielen[vendor_ie_num] = len;
	} else
		pmlmepriv->vendor_ielen[vendor_ie_num] = 0;



	if (vendor_ie_mask & WIFI_BEACON_VENDOR_IE_BIT)
		RTW_INFO("[%s] Beacon append vendor ie\n", __func__);
	if (vendor_ie_mask & WIFI_PROBEREQ_VENDOR_IE_BIT)
		RTW_INFO("[%s] Probe Req append vendor ie\n", __func__);
	if (vendor_ie_mask & WIFI_PROBERESP_VENDOR_IE_BIT)
		RTW_INFO("[%s] Probe Resp append vendor ie\n", __func__);
	if (vendor_ie_mask & WIFI_ASSOCREQ_VENDOR_IE_BIT)
		RTW_INFO("[%s] Assoc Req append vendor ie\n", __func__);
	if (vendor_ie_mask & WIFI_ASSOCRESP_VENDOR_IE_BIT)
		RTW_INFO("[%s] Assoc Resp append vendor ie\n", __func__);
#ifdef CONFIG_P2P
	if (vendor_ie_mask & WIFI_P2P_PROBEREQ_VENDOR_IE_BIT)
		RTW_INFO("[%s] P2P Probe Req append vendor ie\n", __func__);
	if (vendor_ie_mask & WIFI_P2P_PROBERESP_VENDOR_IE_BIT)
		RTW_INFO("[%s] P2P Probe Resp append vendor ie\n", __func__);
#endif

	pmlmepriv->vendor_ie_mask[vendor_ie_num] = vendor_ie_mask;

	return ret;

_clear_path:
	_rtw_memset(pmlmepriv->vendor_ie[vendor_ie_num] , 0 , sizeof(u32) * WLAN_MAX_VENDOR_IE_LEN);
	pmlmepriv->vendor_ielen[vendor_ie_num] = 0;
	pmlmepriv->vendor_ie_mask[vendor_ie_num] = 0;
	return -EFAULT;
}
#endif

static int rtw_mp_efuse_get(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wdata, char *extra)
{
	PADAPTER padapter = rtw_netdev_priv(dev);
	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);

	PEFUSE_HAL pEfuseHal;
	struct iw_point *wrqu;

	u8 ips_mode = IPS_NUM; /* init invalid value */
	u8 lps_mode = PS_MODE_NUM; /* init invalid value */
	struct pwrctrl_priv *pwrctrlpriv ;
	u8 *data = NULL;
	u8 *rawdata = NULL;
	char *pch, *ptmp, *token, *tmp[3] = {0x00, 0x00, 0x00};
	u16 i = 0, j = 0, mapLen = 0, addr = 0, cnts = 0;
	u16 max_available_len = 0, raw_cursize = 0, raw_maxsize = 0;
	u16 mask_len;
	u8 mask_buf[64] = "";
	int err;
	char *pextra = NULL;
#ifdef CONFIG_IOL
	u8 org_fw_iol = padapter->registrypriv.fw_iol;/* 0:Disable, 1:enable, 2:by usb speed */
#endif

	wrqu = (struct iw_point *)wdata;
	pwrctrlpriv = adapter_to_pwrctl(padapter);
	pEfuseHal = &pHalData->EfuseHal;

	err = 0;
	data = rtw_zmalloc(EFUSE_BT_MAX_MAP_LEN);
	if (data == NULL) {
		err = -ENOMEM;
		goto exit;
	}
	rawdata = rtw_zmalloc(EFUSE_BT_MAX_MAP_LEN);
	if (rawdata == NULL) {
		err = -ENOMEM;
		goto exit;
	}

	if (copy_from_user(extra, wrqu->pointer, wrqu->length)) {
		err = -EFAULT;
		goto exit;
	}

	*(extra + wrqu->length) = '\0';

#ifdef CONFIG_LPS
	lps_mode = pwrctrlpriv->power_mgnt;/* keep org value */
	rtw_pm_set_lps(padapter, PS_MODE_ACTIVE);
#endif

#ifdef CONFIG_IPS
	ips_mode = pwrctrlpriv->ips_mode;/* keep org value */
	rtw_pm_set_ips(padapter, IPS_NONE);
#endif

	pch = extra;
	RTW_INFO("%s: in=%s\n", __FUNCTION__, extra);

	i = 0;
	/* mac 16 "00e04c871200" rmap,00,2 */
	while ((token = strsep(&pch, ",")) != NULL) {
		if (i > 2)
			break;
		tmp[i] = token;
		i++;
	}
#ifdef CONFIG_IOL
	padapter->registrypriv.fw_iol = 0;/* 0:Disable, 1:enable, 2:by usb speed */
#endif

	if (strcmp(tmp[0], "status") == 0) {
		sprintf(extra, "Load File efuse=%s,Load File MAC=%s"
			, pHalData->efuse_file_status == EFUSE_FILE_FAILED ? "FAIL" : "OK"
			, pHalData->macaddr_file_status == MACADDR_FILE_FAILED ? "FAIL" : "OK"
		       );
		goto exit;
	} else if (strcmp(tmp[0], "drvmap") == 0) {
		static u8 drvmaporder = 0;
		u8 *efuse;
		u32 shift, cnt;
		u32 blksz = 0x200; /* The size of one time show, default 512 */
		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, _FALSE);

		efuse = pHalData->efuse_eeprom_data;

		shift = blksz * drvmaporder;
		efuse += shift;
		cnt = mapLen - shift;

		if (cnt > blksz) {
			cnt = blksz;
			drvmaporder++;
		} else
			drvmaporder = 0;

		sprintf(extra, "\n");
		for (i = 0; i < cnt; i += 16) {
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%02x\t", shift + i);
			for (j = 0; j < 8; j++)
				pextra += sprintf(pextra, "%02X ", efuse[i + j]);
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++)
				pextra += sprintf(pextra, "%02X ", efuse[i + j]);
			pextra += sprintf(pextra, "\n");
		}
		if ((shift + cnt) < mapLen)
			pextra += sprintf(pextra, "\t...more (left:%d/%d)\n", mapLen-(shift + cnt), mapLen);

	} else if (strcmp(tmp[0], "realmap") == 0) {
		static u8 order = 0;
		u8 *efuse;
		u32 shift, cnt;
		u32 blksz = 0x200; /* The size of one time show, default 512 */

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN , (void *)&mapLen, _FALSE);
		efuse = pEfuseHal->fakeEfuseInitMap;
		if (rtw_efuse_mask_map_read(padapter, 0, mapLen, efuse) == _FAIL) {
			RTW_INFO("%s: read realmap Fail!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

#if 0
		RTW_INFO("OFFSET\tVALUE(hex)\n");
		for (i = 0; i < mapLen; i += 16) {
			RTW_INFO("0x%02x\t", i);
			for (j = 0; j < 8; j++)
				RTW_INFO("%02X ", efuse[i + j]);
			RTW_INFO("\t");
			for (; j < 16; j++)
				RTW_INFO("%02X ", efuse[i + j]);
			RTW_INFO("\n");
		}
		RTW_INFO("\n");
#endif

		shift = blksz * order;
		efuse += shift;
		cnt = mapLen - shift;
		if (cnt > blksz) {
			cnt = blksz;
			order++;
		} else
			order = 0;

		sprintf(extra, "\n");
		for (i = 0; i < cnt; i += 16) {
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%02x\t", shift + i);
			for (j = 0; j < 8; j++)
				pextra += sprintf(pextra, "%02X ", efuse[i + j]);
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++)
				pextra += sprintf(pextra, "%02X ", efuse[i + j]);
			pextra += sprintf(pextra, "\n");
		}
		if ((shift + cnt) < mapLen)
			pextra += sprintf(pextra, "\t...more (left:%d/%d)\n", mapLen-(shift + cnt), mapLen);
	} else if (strcmp(tmp[0], "rmap") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			RTW_INFO("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}

		/* rmap addr cnts */
		addr = simple_strtoul(tmp[1], &ptmp, 16);
		RTW_INFO("%s: addr=%x\n", __FUNCTION__, addr);

		cnts = simple_strtoul(tmp[2], &ptmp, 10);
		if (cnts == 0) {
			RTW_INFO("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN , (void *)&max_available_len, _FALSE);
		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EINVAL;
			goto exit;
		}

		if (rtw_efuse_mask_map_read(padapter, addr, cnts, data) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_mask_map_read error!\n", __func__);
			err = -EFAULT;
			goto exit;
		}

		/*		RTW_INFO("%s: data={", __FUNCTION__); */
		*extra = 0;
		pextra = extra;
		for (i = 0; i < cnts; i++) {
			/*			RTW_INFO("0x%02x ", data[i]); */
			pextra += sprintf(pextra, "0x%02X ", data[i]);
		}
		/*		RTW_INFO("}\n"); */
	} else if (strcmp(tmp[0], "realraw") == 0) {
		static u8 raw_order = 0;
		u32 shift, cnt;
		u32 blksz = 0x200; /* The size of one time show, default 512 */

		addr = 0;
		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN , (void *)&mapLen, _FALSE);
		RTW_INFO("Real content len = %d\n",mapLen );

		if (rtw_efuse_access(padapter, _FALSE, addr, mapLen, rawdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access Fail!!\n", __func__);
			err = -EFAULT;
			goto exit;
		}

		_rtw_memset(extra, '\0', strlen(extra));

		shift = blksz * raw_order;
		rawdata += shift;
		cnt = mapLen - shift;
		if (cnt > blksz) {
			cnt = blksz;
			raw_order++;
		} else
			raw_order = 0;

		sprintf(extra, "\n");
		for (i = 0; i < cnt; i += 16) {
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%02x\t", shift + i);
			for (j = 0; j < 8; j++)
				pextra += sprintf(pextra, "%02X ", rawdata[i + j]);
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++)
				pextra += sprintf(pextra, "%02X ", rawdata[i + j]);
			pextra += sprintf(pextra, "\n");
		}
		if ((shift + cnt) < mapLen)
			pextra += sprintf(pextra, "\t...more (left:%d/%d)\n", mapLen-(shift + cnt), mapLen);

	} else if (strcmp(tmp[0], "btrealraw") == 0) {
		static u8 bt_raw_order = 0;
		u32 shift, cnt;
		u32 blksz = 0x200; /* The size of one time show, default 512 */

		addr = 0;
		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&mapLen, _FALSE);
		RTW_INFO("Real content len = %d\n", mapLen);
#ifdef RTW_HALMAC
		if (rtw_efuse_bt_access(padapter, _FALSE, 0, mapLen, rawdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access Fail!!\n", __func__);
			err = -EFAULT;
			goto exit;
		}
#else
		rtw_write8(padapter, 0x35, 0x1);

		if (rtw_efuse_access(padapter, _FALSE, addr, mapLen, rawdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access Fail!!\n", __func__);
			err = -EFAULT;
			goto exit;
		}
#endif
		_rtw_memset(extra, '\0', strlen(extra));

		shift = blksz * bt_raw_order;
		rawdata += shift;
		cnt = mapLen - shift;
		if (cnt > blksz) {
			cnt = blksz;
			bt_raw_order++;
		} else
			bt_raw_order = 0;

		sprintf(extra, "\n");
		for (i = 0; i < cnt; i += 16) {
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%02x\t", shift + i);
			for (j = 0; j < 8; j++)
				pextra += sprintf(pextra, "%02X ", rawdata[i + j]);
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++)
				pextra += sprintf(pextra, "%02X ", rawdata[i + j]);
			pextra += sprintf(pextra, "\n");
		}
		if ((shift + cnt) < mapLen)
			pextra += sprintf(pextra, "\t...more (left:%d/%d)\n", mapLen-(shift + cnt), mapLen);

	} else if (strcmp(tmp[0], "mac") == 0) {
		if (hal_efuse_macaddr_offset(padapter) == -1) {
			err = -EFAULT;
			goto exit;
		}

		addr = hal_efuse_macaddr_offset(padapter);
		cnts = 6;

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);
		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%02x)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}

		if (rtw_efuse_mask_map_read(padapter, addr, cnts, data) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_mask_map_read error!\n", __func__);
			err = -EFAULT;
			goto exit;
		}

		/*		RTW_INFO("%s: MAC address={", __FUNCTION__); */
		*extra = 0;
		pextra = extra;
		for (i = 0; i < cnts; i++) {
			/*			RTW_INFO("%02X", data[i]); */
			pextra += sprintf(pextra, "%02X", data[i]);
			if (i != (cnts - 1)) {
				/*				RTW_INFO(":"); */
				pextra += sprintf(pextra, ":");
			}
		}
		/*		RTW_INFO("}\n"); */
	} else if (strcmp(tmp[0], "vidpid") == 0) {
#ifdef CONFIG_RTL8188E
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_88EU;
#endif
#ifdef CONFIG_PCI_HCI
		addr = EEPROM_VID_88EE;
#endif
#endif /* CONFIG_RTL8188E */

#ifdef CONFIG_RTL8192E
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_8192EU;
#endif
#ifdef CONFIG_PCI_HCI
		addr = EEPROM_VID_8192EE;
#endif
#endif /* CONFIG_RTL8192E */
#ifdef CONFIG_RTL8723B
		addr = EEPROM_VID_8723BU;
#endif /* CONFIG_RTL8192E */

#ifdef CONFIG_RTL8188F
		addr = EEPROM_VID_8188FU;
#endif /* CONFIG_RTL8188F */

#ifdef CONFIG_RTL8188GTV
		addr = EEPROM_VID_8188GTVU;
#endif

#ifdef CONFIG_RTL8703B
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_8703BU;
#endif
#endif /* CONFIG_RTL8703B */

#ifdef CONFIG_RTL8723D
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_8723DU;
#endif /* CONFIG_USB_HCI */
#endif /* CONFIG_RTL8723D */

		cnts = 4;

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);
		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%02x)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}
		if (rtw_efuse_mask_map_read(padapter, addr, cnts, data) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

		/*		RTW_INFO("%s: {VID,PID}={", __FUNCTION__); */
		*extra = 0;
		pextra = extra;
		for (i = 0; i < cnts; i++) {
			/*			RTW_INFO("0x%02x", data[i]); */
			pextra += sprintf(pextra, "0x%02X", data[i]);
			if (i != (cnts - 1)) {
				/*				RTW_INFO(","); */
				pextra += sprintf(pextra, ",");
			}
		}
		/*		RTW_INFO("}\n"); */
	} else if (strcmp(tmp[0], "ableraw") == 0) {
#ifdef RTW_HALMAC
		raw_maxsize = efuse_GetavailableSize(padapter);
#else
		efuse_GetCurrentSize(padapter, &raw_cursize);
		raw_maxsize = efuse_GetMaxSize(padapter);
#endif
		sprintf(extra, "[available raw size]= %d bytes\n", raw_maxsize - raw_cursize);
	} else if (strcmp(tmp[0], "btableraw") == 0) {
		efuse_bt_GetCurrentSize(padapter, &raw_cursize);
		raw_maxsize = efuse_bt_GetMaxSize(padapter);
		sprintf(extra, "[available raw size]= %d bytes\n", raw_maxsize - raw_cursize);
	} else if (strcmp(tmp[0], "btfmap") == 0) {

		BTEfuse_PowerSwitch(padapter, 1, _TRUE);

		mapLen = EFUSE_BT_MAX_MAP_LEN;
		if (rtw_BT_efuse_map_read(padapter, 0, mapLen, pEfuseHal->BTEfuseInitMap) == _FAIL) {
			RTW_INFO("%s: rtw_BT_efuse_map_read Fail!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

		/*		RTW_INFO("OFFSET\tVALUE(hex)\n"); */
		sprintf(extra, "\n");
		for (i = 0; i < 512; i += 16) { /* set 512 because the iwpriv's extra size have limit 0x7FF */
			/*			RTW_INFO("0x%03x\t", i); */
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%03x\t", i);
			for (j = 0; j < 8; j++) {
				/*				RTW_INFO("%02X ", pEfuseHal->BTEfuseInitMap[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
			}
			/*			RTW_INFO("\t"); */
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++) {
				/*				RTW_INFO("%02X ", pEfuseHal->BTEfuseInitMap[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
			}
			/*			RTW_INFO("\n"); */
			pextra += sprintf(pextra, "\n");
		}
		/*		RTW_INFO("\n"); */
	} else if (strcmp(tmp[0], "btbmap") == 0) {
		BTEfuse_PowerSwitch(padapter, 1, _TRUE);

		mapLen = EFUSE_BT_MAX_MAP_LEN;
		if (rtw_BT_efuse_map_read(padapter, 0, mapLen, pEfuseHal->BTEfuseInitMap) == _FAIL) {
			RTW_INFO("%s: rtw_BT_efuse_map_read Fail!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

		/*		RTW_INFO("OFFSET\tVALUE(hex)\n"); */
		sprintf(extra, "\n");
		for (i = 512; i < 1024 ; i += 16) {
			/*			RTW_INFO("0x%03x\t", i); */
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%03x\t", i);
			for (j = 0; j < 8; j++) {
				/*				RTW_INFO("%02X ", data[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
			}
			/*			RTW_INFO("\t"); */
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++) {
				/*				RTW_INFO("%02X ", data[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
			}
			/*			RTW_INFO("\n"); */
			pextra += sprintf(pextra, "\n");
		}
		/*		RTW_INFO("\n"); */
	} else if (strcmp(tmp[0], "btrmap") == 0) {
		u8 BTStatus;

		rtw_write8(padapter, 0xa3, 0x05); /* For 8723AB ,8821S ? */
		BTStatus = rtw_read8(padapter, 0xa0);

		RTW_INFO("%s: Check 0xa0 BT Status =0x%x\n", __FUNCTION__, BTStatus);
		if (BTStatus != 0x04) {
			sprintf(extra, "BT Status not Active ,can't to read BT eFuse\n");
			goto exit;
		}

		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}

		BTEfuse_PowerSwitch(padapter, 1, _TRUE);

		/* rmap addr cnts */
		addr = simple_strtoul(tmp[1], &ptmp, 16);
		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);

		cnts = simple_strtoul(tmp[2], &ptmp, 10);
		if (cnts == 0) {
			RTW_INFO("%s: btrmap Fail!! cnts error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
#ifndef RTW_HALMAC
		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);
		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}
#endif
		if (rtw_BT_efuse_map_read(padapter, addr, cnts, data) == _FAIL) {
			RTW_INFO("%s: rtw_BT_efuse_map_read error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

		*extra = 0;
		pextra = extra;
		/*		RTW_INFO("%s: bt efuse data={", __FUNCTION__); */
		for (i = 0; i < cnts; i++) {
			/*			RTW_INFO("0x%02x ", data[i]); */
			pextra += sprintf(pextra, " 0x%02X ", data[i]);
		}
		/*		RTW_INFO("}\n"); */
		RTW_INFO(FUNC_ADPT_FMT ": BT MAC=[%s]\n", FUNC_ADPT_ARG(padapter), extra);
	} else if (strcmp(tmp[0], "btffake") == 0) {
		/*		RTW_INFO("OFFSET\tVALUE(hex)\n"); */
		sprintf(extra, "\n");
		for (i = 0; i < 512; i += 16) {
			/*			RTW_INFO("0x%03x\t", i); */
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%03x\t", i);
			for (j = 0; j < 8; j++) {
				/*				RTW_INFO("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
			}
			/*			RTW_INFO("\t"); */
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++) {
				/*				RTW_INFO("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
			}
			/*			RTW_INFO("\n"); */
			pextra += sprintf(pextra, "\n");
		}
		/*		RTW_INFO("\n"); */
	} else if (strcmp(tmp[0], "btbfake") == 0) {
		/*		RTW_INFO("OFFSET\tVALUE(hex)\n"); */
		sprintf(extra, "\n");
		for (i = 512; i < 1024; i += 16) {
			/*			RTW_INFO("0x%03x\t", i); */
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%03x\t", i);
			for (j = 0; j < 8; j++) {
				/*				RTW_INFO("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
			}
			/*			RTW_INFO("\t"); */
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++) {
				/*				RTW_INFO("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]); */
				pextra += sprintf(pextra, "%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
			}
			/*			RTW_INFO("\n"); */
			pextra += sprintf(pextra, "\n");
		}
		/*		RTW_INFO("\n"); */
	} else if (strcmp(tmp[0], "wlrfkmap") == 0) {
		static u8 fk_order = 0;
		u8 *efuse;
		u32 shift, cnt;
		u32 blksz = 0x200; /* The size of one time show, default 512 */

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN , (void *)&mapLen, _FALSE);
		efuse = pEfuseHal->fakeEfuseModifiedMap;

		shift = blksz * fk_order;
		efuse += shift;
		cnt = mapLen - shift;
		if (cnt > blksz) {
			cnt = blksz;
			fk_order++;
		} else
			fk_order = 0;

		sprintf(extra, "\n");
		for (i = 0; i < cnt; i += 16) {
			pextra = extra + strlen(extra);
			pextra += sprintf(pextra, "0x%02x\t", shift + i);
			for (j = 0; j < 8; j++)
				pextra += sprintf(pextra, "%02X ", efuse[i + j]);
			pextra += sprintf(pextra, "\t");
			for (; j < 16; j++)
				pextra += sprintf(pextra, "%02X ", efuse[i + j]);
			pextra += sprintf(pextra, "\n");
		}
		if ((shift + cnt) < mapLen)
			pextra += sprintf(pextra, "\t...more\n");

	} else if (strcmp(tmp[0], "wlrfkrmap") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			RTW_INFO("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}
		/* rmap addr cnts */
		addr = simple_strtoul(tmp[1], &ptmp, 16);
		RTW_INFO("%s: addr=%x\n", __FUNCTION__, addr);

		cnts = simple_strtoul(tmp[2], &ptmp, 10);
		if (cnts == 0) {
			RTW_INFO("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);

		/*		RTW_INFO("%s: data={", __FUNCTION__); */
		*extra = 0;
		pextra = extra;
		for (i = 0; i < cnts; i++) {
			RTW_INFO("wlrfkrmap = 0x%02x\n", pEfuseHal->fakeEfuseModifiedMap[addr + i]);
			pextra += sprintf(pextra, "0x%02X ", pEfuseHal->fakeEfuseModifiedMap[addr+i]);
		}
	} else if (strcmp(tmp[0], "btrfkrmap") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			RTW_INFO("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}
		/* rmap addr cnts */
		addr = simple_strtoul(tmp[1], &ptmp, 16);
		RTW_INFO("%s: addr=%x\n", __FUNCTION__, addr);

		cnts = simple_strtoul(tmp[2], &ptmp, 10);
		if (cnts == 0) {
			RTW_INFO("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
			err = -EINVAL;
			goto exit;
		}
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);

		/*		RTW_INFO("%s: data={", __FUNCTION__); */
		*extra = 0;
		pextra = extra;
		for (i = 0; i < cnts; i++) {
			RTW_INFO("wlrfkrmap = 0x%02x\n", pEfuseHal->fakeBTEfuseModifiedMap[addr + i]);
			pextra += sprintf(pextra, "0x%02X ", pEfuseHal->fakeBTEfuseModifiedMap[addr+i]);
		}
	} else if (strcmp(tmp[0], "mask") == 0) {
		*extra = 0;
		mask_len = sizeof(u8) * rtw_get_efuse_mask_arraylen(padapter);
		rtw_efuse_mask_array(padapter, mask_buf);

		if (padapter->registrypriv.bFileMaskEfuse == _TRUE)
			_rtw_memcpy(mask_buf, maskfileBuffer, mask_len);

		sprintf(extra, "\n");
		pextra = extra + strlen(extra);
		for (i = 0; i < mask_len; i++)
			pextra += sprintf(pextra, "0x%02X\n", mask_buf[i]);

	} else if (strcmp(tmp[0], "btmask") == 0) {
		*extra = 0;
		mask_len = sizeof(u8) * rtw_get_bt_efuse_mask_arraylen(padapter);
		rtw_bt_efuse_mask_array(padapter, mask_buf);

		if (padapter->registrypriv.bBTFileMaskEfuse == _TRUE)
			_rtw_memcpy(mask_buf, btmaskfileBuffer, mask_len);

		sprintf(extra, "\n");
		pextra = extra + strlen(extra);
		for (i = 0; i < mask_len; i++)
			pextra += sprintf(pextra, "0x%02X\n", mask_buf[i]);

	} else
		sprintf(extra, "Command not found!");

exit:
	if (data)
		rtw_mfree(data, EFUSE_BT_MAX_MAP_LEN);
	if (rawdata)
		rtw_mfree(rawdata, EFUSE_BT_MAX_MAP_LEN);
	if (!err)
		wrqu->length = strlen(extra);

	if (padapter->registrypriv.mp_mode == 0) {
#ifdef CONFIG_IPS
		rtw_pm_set_ips(padapter, ips_mode);
#endif /* CONFIG_IPS */

#ifdef CONFIG_LPS
		rtw_pm_set_lps(padapter, lps_mode);
#endif /* CONFIG_LPS */
	}

#ifdef CONFIG_IOL
	padapter->registrypriv.fw_iol = org_fw_iol;/* 0:Disable, 1:enable, 2:by usb speed */
#endif
	return err;
}


#ifdef CONFIG_MP_INCLUDED
static int rtw_mp_efuse_set(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wdata, char *extra)
{
	struct iw_point *wrqu;
	PADAPTER padapter;
	struct pwrctrl_priv *pwrctrlpriv ;
	PHAL_DATA_TYPE pHalData;
	PEFUSE_HAL pEfuseHal;
	struct hal_ops *pHalFunc;
	struct mp_priv *pmp_priv;

	u8 ips_mode = IPS_NUM; /* init invalid value */
	u8 lps_mode = PS_MODE_NUM; /* init invalid value */
	u32 i = 0, j = 0, jj, kk;
	u8 *setdata = NULL;
	u8 *ShadowMapBT = NULL;
	u8 *ShadowMapWiFi = NULL;
	u8 *setrawdata = NULL;
	char *pch, *ptmp, *token, *tmp[3] = {0x00, 0x00, 0x00};
	u16 addr = 0xFF, cnts = 0, BTStatus = 0 , max_available_len = 0;
	u16 wifimaplen;
	int err;
	boolean bcmpchk = _TRUE;


	wrqu = (struct iw_point *)wdata;
	padapter = rtw_netdev_priv(dev);
	pwrctrlpriv = adapter_to_pwrctl(padapter);
	pHalData = GET_HAL_DATA(padapter);
	pEfuseHal = &pHalData->EfuseHal;
	pHalFunc = &padapter->hal_func;
	pmp_priv = &padapter->mppriv;

	err = 0;

	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
		return -EFAULT;

	*(extra + wrqu->length) = '\0';

	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN , (void *)&wifimaplen, _FALSE);

	setdata = rtw_zmalloc(1024);
	if (setdata == NULL) {
		err = -ENOMEM;
		goto exit;
	}
	ShadowMapBT = rtw_malloc(EFUSE_BT_MAX_MAP_LEN);
	if (ShadowMapBT == NULL) {
		err = -ENOMEM;
		goto exit;
	}
	ShadowMapWiFi = rtw_malloc(wifimaplen);
	if (ShadowMapWiFi == NULL) {
		err = -ENOMEM;
		goto exit;
	}
	setrawdata = rtw_malloc(EFUSE_MAX_SIZE);
	if (setrawdata == NULL) {
		err = -ENOMEM;
		goto exit;
	}

#ifdef CONFIG_LPS
	lps_mode = pwrctrlpriv->power_mgnt;/* keep org value */
	rtw_pm_set_lps(padapter, PS_MODE_ACTIVE);
#endif

#ifdef CONFIG_IPS
	ips_mode = pwrctrlpriv->ips_mode;/* keep org value */
	rtw_pm_set_ips(padapter, IPS_NONE);
#endif

	pch = extra;
	RTW_INFO("%s: in=%s\n", __FUNCTION__, extra);

	i = 0;
	while ((token = strsep(&pch, ",")) != NULL) {
		if (i > 2)
			break;
		tmp[i] = token;
		i++;
	}

	/* tmp[0],[1],[2] */
	/* wmap,addr,00e04c871200 */
	if (strcmp(tmp[0], "wmap") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}

#ifndef RTW_HALMAC
		/* unknown bug workaround, need to fix later */
		addr = 0x1ff;
		rtw_write8(padapter, EFUSE_CTRL + 1, (addr & 0xff));
		rtw_msleep_os(10);
		rtw_write8(padapter, EFUSE_CTRL + 2, ((addr >> 8) & 0x03));
		rtw_msleep_os(10);
		rtw_write8(padapter, EFUSE_CTRL + 3, 0x72);
		rtw_msleep_os(10);
		rtw_read8(padapter, EFUSE_CTRL);
#endif /* RTW_HALMAC */

		addr = simple_strtoul(tmp[1], &ptmp, 16);
		addr &= 0xFFF;

		cnts = strlen(tmp[2]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: map data=%s\n", __FUNCTION__, tmp[2]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk + 1]);

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);

		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}

		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}
		*extra = 0;
		RTW_INFO("%s: after rtw_efuse_map_write to _rtw_memcmp\n", __func__);
		if (rtw_efuse_mask_map_read(padapter, addr, cnts, ShadowMapWiFi) == _SUCCESS) {
			if (_rtw_memcmp((void *)ShadowMapWiFi , (void *)setdata, cnts)) {
				RTW_INFO("%s: WiFi write map afterf compare success\n", __FUNCTION__);
				sprintf(extra, "WiFi write map compare OK\n");
				err = 0;
				goto exit;
			} else {
				sprintf(extra, "WiFi write map compare FAIL\n");
				RTW_INFO("%s: WiFi write map compare Fail\n", __FUNCTION__);
				err = 0;
				goto exit;
			}
		}
	} else if (strcmp(tmp[0], "wraw") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}

		addr = simple_strtoul(tmp[1], &ptmp, 16);
		addr &= 0xFFF;

		cnts = strlen(tmp[2]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: raw data=%s\n", __FUNCTION__, tmp[2]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk + 1]);

		if (rtw_efuse_access(padapter, _TRUE, addr, cnts, setrawdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}
	} else if (strcmp(tmp[0], "btwraw") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}

		addr = simple_strtoul(tmp[1], &ptmp, 16);
		addr &= 0xFFF;

		cnts = strlen(tmp[2]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: raw data=%s\n", __FUNCTION__, tmp[2]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk + 1]);
#ifdef RTW_HALMAC
		if (rtw_efuse_bt_access(padapter, _TRUE, addr, cnts, setrawdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}
#else
		rtw_write8(padapter, 0x35, 1); /* switch bank 1 (BT)*/
		if (rtw_efuse_access(padapter, _TRUE, addr, cnts, setrawdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_access error!!\n", __FUNCTION__);
			rtw_write8(padapter, 0x35, 0); /* switch bank 0 (WiFi)*/
			err = -EFAULT;
			goto exit;
		}
		rtw_write8(padapter, 0x35, 0); /* switch bank 0 (WiFi)*/
#endif
	} else if (strcmp(tmp[0], "mac") == 0) {
		if (tmp[1] == NULL) {
			err = -EINVAL;
			goto exit;
		}

		/* mac,00e04c871200 */

		if (hal_efuse_macaddr_offset(padapter) == -1) {
			err = -EFAULT;
			goto exit;
		}

		addr = hal_efuse_macaddr_offset(padapter);
		cnts = strlen(tmp[1]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}
		if (cnts > 6) {
			RTW_INFO("%s: error data for mac addr=\"%s\"\n", __FUNCTION__, tmp[1]);
			err = -EFAULT;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: MAC address=%s\n", __FUNCTION__, tmp[1]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk + 1]);

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);

		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}

		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}
	} else if (strcmp(tmp[0], "vidpid") == 0) {
		if (tmp[1] == NULL) {
			err = -EINVAL;
			goto exit;
		}

		/* pidvid,da0b7881		 */
#ifdef CONFIG_RTL8188E
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_88EU;
#endif
#ifdef CONFIG_PCI_HCI
		addr = EEPROM_VID_88EE;
#endif
#endif /* CONFIG_RTL8188E */

#ifdef CONFIG_RTL8192E
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_8192EU;
#endif
#ifdef CONFIG_PCI_HCI
		addr = EEPROM_VID_8192EE;
#endif
#endif /* CONFIG_RTL8188E */

#ifdef CONFIG_RTL8723B
		addr = EEPROM_VID_8723BU;
#endif

#ifdef CONFIG_RTL8188F
		addr = EEPROM_VID_8188FU;
#endif

#ifdef CONFIG_RTL8188GTV
		addr = EEPROM_VID_8188GTVU;
#endif

#ifdef CONFIG_RTL8703B
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_8703BU;
#endif /* CONFIG_USB_HCI */
#endif /* CONFIG_RTL8703B */

#ifdef CONFIG_RTL8723D
#ifdef CONFIG_USB_HCI
		addr = EEPROM_VID_8723DU;
#endif /* CONFIG_USB_HCI */
#endif /* CONFIG_RTL8723D */

		cnts = strlen(tmp[1]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: VID/PID=%s\n", __FUNCTION__, tmp[1]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk + 1]);

		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);
		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}

		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}
	} else if (strcmp(tmp[0], "wldumpfake") == 0) {
		if (wifimaplen > EFUSE_MAX_MAP_LEN)
			cnts = EFUSE_MAX_MAP_LEN;
		else
			cnts = wifimaplen;
		if (rtw_efuse_mask_map_read(padapter, 0, cnts, pEfuseHal->fakeEfuseModifiedMap) == _SUCCESS)
			RTW_INFO("%s: WiFi hw efuse dump to Fake map success\n", __func__);
		else {
			RTW_INFO("%s: WiFi hw efuse dump to Fake map Fail\n", __func__);
			err = -EFAULT;
		}
	} else if (strcmp(tmp[0], "btwmap") == 0) {
		rtw_write8(padapter, 0xa3, 0x05); /* For 8723AB ,8821S ? */
		BTStatus = rtw_read8(padapter, 0xa0);
		RTW_INFO("%s: btwmap before read 0xa0 BT Status =0x%x\n", __FUNCTION__, BTStatus);
		if (BTStatus != 0x04) {
			sprintf(extra, "BT Status not Active ,can't do Write\n");
			goto exit;
		}

		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}

#ifndef RTW_HALMAC
		BTEfuse_PowerSwitch(padapter, 1, _TRUE);
		addr = 0x1ff;
		rtw_write8(padapter, EFUSE_CTRL + 1, (addr & 0xff));
		rtw_msleep_os(10);
		rtw_write8(padapter, EFUSE_CTRL + 2, ((addr >> 8) & 0x03));
		rtw_msleep_os(10);
		rtw_write8(padapter, EFUSE_CTRL + 3, 0x72);
		rtw_msleep_os(10);
		rtw_read8(padapter, EFUSE_CTRL);
		BTEfuse_PowerSwitch(padapter, 1, _FALSE);
#endif /* RTW_HALMAC */

		addr = simple_strtoul(tmp[1], &ptmp, 16);
		addr &= 0xFFF;

		cnts = strlen(tmp[2]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: BT data=%s\n", __FUNCTION__, tmp[2]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk + 1]);
#ifndef RTW_HALMAC
		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_MAP_LEN, (void *)&max_available_len, _FALSE);
		if ((addr + cnts) > max_available_len) {
			RTW_INFO("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
			err = -EFAULT;
			goto exit;
		}
#endif
		if (rtw_BT_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
			RTW_INFO("%s: rtw_BT_efuse_map_write error!!\n", __FUNCTION__);
			sprintf(extra, "BT write FAIL !!!\n");
			err = -EFAULT;
			goto exit;
		}
		*extra = 0;
		RTW_INFO("%s: after rtw_BT_efuse_map_write to _rtw_memcmp\n", __FUNCTION__);
		if ((rtw_BT_efuse_map_read(padapter, addr, cnts, ShadowMapBT) == _SUCCESS)) {
			if (_rtw_memcmp((void *)ShadowMapBT , (void *)setdata, cnts)) {
				RTW_INFO("%s: BT write map compare OK BTStatus=0x%x\n", __FUNCTION__, BTStatus);
				sprintf(extra, "BT write map compare OK");
				err = 0;
				goto exit;
			} else {
				sprintf(extra, "BT write map compare FAIL");
				RTW_INFO("%s: BT write map compare FAIL BTStatus=0x%x\n", __FUNCTION__, BTStatus);
				err = 0;
				goto exit;
			}
		}
	} else if (strcmp(tmp[0], "btwfake") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}
		if (pmp_priv->bprocess_mp_mode != _TRUE) {
			RTW_INFO("%s: btwfake not to be exec, please first to mp_start\n", __FUNCTION__);
			sprintf(extra, "Error, btwfake cant to be exec, please first to mp_start !!!!\n");
			err = 0;
			goto exit;
		}
		addr = simple_strtoul(tmp[1], &ptmp, 16);
		addr &= 0xFFF;

		cnts = strlen(tmp[2]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: BT tmp data=%s\n", __FUNCTION__, tmp[2]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			pEfuseHal->fakeBTEfuseModifiedMap[addr + jj] = key_2char2num(tmp[2][kk], tmp[2][kk + 1]);
	} else if (strcmp(tmp[0], "btdumpfake") == 0) {
		if (rtw_BT_efuse_map_read(padapter, 0, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _SUCCESS)
			RTW_INFO("%s: BT read all map success\n", __FUNCTION__);
		else {
			RTW_INFO("%s: BT read all map Fail!\n", __FUNCTION__);
			err = -EFAULT;
		}
	} else if (strcmp(tmp[0], "btfk2map") == 0) {

		if (padapter->registrypriv.bBTFileMaskEfuse != _TRUE && pmp_priv->bloadBTefusemap == _TRUE) {
			RTW_INFO("%s: File BT eFuse mask file not to be loaded\n", __FUNCTION__);
			sprintf(extra, "Not load BT eFuse mask file yet, Please advance to use [ efuse_bt_mask ], now remove the Adapter.!!!!\n");
			rtw_set_surprise_removed(padapter);
			err = 0;
			goto exit;
		}

		rtw_write8(padapter, 0xa3, 0x05);
		BTStatus = rtw_read8(padapter, 0xa0);
		RTW_INFO("%s: btwmap before read 0xa0 BT Status =0x%x\n", __FUNCTION__, BTStatus);
		if (BTStatus != 0x04) {
			sprintf(extra, "BT Status not Active Write FAIL\n");
			goto exit;
		}
		if (pmp_priv->bprocess_mp_mode != _TRUE) {
			RTW_INFO("%s: btfk2map not to be exec, please first to mp_start\n", __FUNCTION__);
			sprintf(extra, "Error, btfk2map cant to be exec, please first to mp_start !!!!\n");
			err = 0;
			goto exit;
		}
#ifndef RTW_HALMAC
		BTEfuse_PowerSwitch(padapter, 1, _TRUE);
		addr = 0x1ff;
		rtw_write8(padapter, EFUSE_CTRL + 1, (addr & 0xff));
		rtw_msleep_os(10);
		rtw_write8(padapter, EFUSE_CTRL + 2, ((addr >> 8) & 0x03));
		rtw_msleep_os(10);
		rtw_write8(padapter, EFUSE_CTRL + 3, 0x72);
		rtw_msleep_os(10);
		rtw_read8(padapter, EFUSE_CTRL);
		BTEfuse_PowerSwitch(padapter, 1, _FALSE);
#endif /* RTW_HALMAC */
		_rtw_memcpy(pEfuseHal->BTEfuseModifiedMap, pEfuseHal->fakeBTEfuseModifiedMap, EFUSE_BT_MAX_MAP_LEN);

		if (rtw_BT_efuse_map_write(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _FAIL) {
			RTW_INFO("%s: rtw_BT_efuse_map_write error!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

		RTW_INFO("pEfuseHal->fakeBTEfuseModifiedMap OFFSET\tVALUE(hex)\n");
		for (i = 0; i < EFUSE_BT_MAX_MAP_LEN; i += 16) {
			printk("0x%02x\t", i);
			for (j = 0; j < 8; j++)
				printk("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i + j]);
			printk("\t");

			for (; j < 16; j++)
				printk("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i + j]);
			printk("\n");
		}
		printk("\n");
#if 1
		err = -EFAULT;
		RTW_INFO("%s: rtw_BT_efuse_map_read _rtw_memcmp\n", __FUNCTION__);
		if ((rtw_BT_efuse_map_read(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseInitMap) == _SUCCESS)) {
			if (_rtw_memcmp((void *)pEfuseHal->fakeBTEfuseModifiedMap, (void *)pEfuseHal->fakeBTEfuseInitMap, EFUSE_BT_MAX_MAP_LEN)) {
				sprintf(extra, "BT write map compare OK");
				RTW_INFO("%s: BT write map afterf compare success BTStatus=0x%x\n", __FUNCTION__, BTStatus);
				err = 0;
				goto exit;
			} else {
				sprintf(extra, "BT write map compare FAIL");
				if (rtw_BT_efuse_map_write(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _FAIL)
					RTW_INFO("%s: rtw_BT_efuse_map_write compare error,retry = %d!\n", __FUNCTION__, i);

				if (rtw_BT_efuse_map_read(padapter, EFUSE_BT, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseInitMap) == _SUCCESS) {
					RTW_INFO("pEfuseHal->fakeBTEfuseInitMap OFFSET\tVALUE(hex)\n");

					for (i = 0; i < EFUSE_BT_MAX_MAP_LEN; i += 16) {
						printk("0x%02x\t", i);
						for (j = 0; j < 8; j++)
							printk("%02X ", pEfuseHal->fakeBTEfuseInitMap[i + j]);
						printk("\t");
						for (; j < 16; j++)
							printk("%02X ", pEfuseHal->fakeBTEfuseInitMap[i + j]);
						printk("\n");
					}
					printk("\n");
				}
				RTW_INFO("%s: BT write map afterf compare not match to write efuse try write Map again , BTStatus=0x%x\n", __FUNCTION__, BTStatus);
				goto exit;
			}
		}
#endif

	} else if (strcmp(tmp[0], "wlfk2map") == 0) {
		*extra = 0;

		if (padapter->registrypriv.bFileMaskEfuse != _TRUE && pmp_priv->bloadefusemap == _TRUE) {
			RTW_INFO("%s: File eFuse mask file not to be loaded\n", __FUNCTION__);
			sprintf(extra, "Not load eFuse mask file yet, Please use the efuse_mask CMD, now remove the interface !!!!\n");
			rtw_set_surprise_removed(padapter);
			err = 0;
			goto exit;
		}

		if (pmp_priv->bprocess_mp_mode != _TRUE) {
			RTW_INFO("%s: wlfk2map not to be exec, please first to mp_start\n", __FUNCTION__);
			sprintf(extra, "Error, wlfk2map cant to be exec, please first to mp_start !!!!\n");
			err = 0;
			goto exit;
		}
		if (wifimaplen > EFUSE_MAX_MAP_LEN)
			cnts = EFUSE_MAX_MAP_LEN;
		else
			cnts = wifimaplen;
		if (rtw_efuse_map_write(padapter, 0x00, cnts, pEfuseHal->fakeEfuseModifiedMap) == _FAIL) {
			RTW_INFO("%s: rtw_efuse_map_write fakeEfuseModifiedMap error!\n", __FUNCTION__);
			err = -EFAULT;
			goto exit;
		}

		if (rtw_efuse_mask_map_read(padapter, 0x00, wifimaplen, ShadowMapWiFi) == _SUCCESS) {
			addr = 0x00;
			err = _TRUE;

			for (i = 0; i < cnts; i++) {
				if (padapter->registrypriv.boffefusemask == 0) {
					if (padapter->registrypriv.bFileMaskEfuse == _TRUE) {
						if (rtw_file_efuse_IsMasked(padapter, addr + i, maskfileBuffer) == _TRUE)	/*use file efuse mask. */
							bcmpchk = _FALSE;
					} else {
						if (efuse_IsMasked(padapter, addr + i) == _TRUE)
							bcmpchk = _FALSE;
					}
				}

				if (bcmpchk == _TRUE) {
					RTW_INFO("compare readMapWiFi[0x%02x] = %x, ModifiedMap = %x\n", addr + i, ShadowMapWiFi[ addr + i], pEfuseHal->fakeEfuseModifiedMap[addr + i]);
					if (_rtw_memcmp((void *) &ShadowMapWiFi[addr + i], (void *)&pEfuseHal->fakeEfuseModifiedMap[addr + i], 1) == _FALSE){
						err = _FALSE;
						break;
					}
				}
				bcmpchk = _TRUE;
			}
		}

		if (err) {
			RTW_INFO("%s: WiFi write map afterf compare OK\n", __FUNCTION__);
			sprintf(extra, "WiFi write map compare OK\n");
			err = 0;
			goto exit;
		} else {
			sprintf(extra, "WiFi write map compare FAIL\n");
			RTW_INFO("%s: WiFi write map compare Fail\n", __FUNCTION__);
			err = 0;
			goto exit;
		}
	} else if (strcmp(tmp[0], "wlwfake") == 0) {
		if ((tmp[1] == NULL) || (tmp[2] == NULL)) {
			err = -EINVAL;
			goto exit;
		}
		if (pmp_priv->bprocess_mp_mode != _TRUE) {
			RTW_INFO("%s: wlwfake not to be exec, please first to mp_start\n", __FUNCTION__);
			sprintf(extra, "Error, wlwfake cant to be exec, please first to mp_start !!!!\n");
			err = 0;
			goto exit;
		}
		addr = simple_strtoul(tmp[1], &ptmp, 16);
		addr &= 0xFFF;

		cnts = strlen(tmp[2]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: map tmp data=%s\n", __FUNCTION__, tmp[2]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			pEfuseHal->fakeEfuseModifiedMap[addr + jj] = key_2char2num(tmp[2][kk], tmp[2][kk + 1]);
		_rtw_memset(extra, '\0', strlen(extra));
		sprintf(extra, "wlwfake OK\n");

	}
	else if (strcmp(tmp[0], "wfakemac") == 0) {
		if (tmp[1] == NULL) {
			err = -EINVAL;
			goto exit;
		}
		if (pmp_priv->bprocess_mp_mode != _TRUE) {
			RTW_INFO("%s: wfakemac not to be exec, please first to mp_start\n", __FUNCTION__);
			sprintf(extra, "Error, wfakemac cant to be exec, please first to mp_start !!!!\n");
			err = 0;
			goto exit;
		}
		/* wfakemac,00e04c871200 */
		if (hal_efuse_macaddr_offset(padapter) == -1) {
			err = -EFAULT;
			goto exit;
		}

		addr = hal_efuse_macaddr_offset(padapter);
		cnts = strlen(tmp[1]);
		if (cnts % 2) {
			err = -EINVAL;
			goto exit;
		}
		cnts /= 2;
		if (cnts == 0) {
			err = -EINVAL;
			goto exit;
		}
		if (cnts > 6) {
			RTW_INFO("%s: error data for mac addr=\"%s\"\n", __FUNCTION__, tmp[1]);
			err = -EFAULT;
			goto exit;
		}

		RTW_INFO("%s: addr=0x%X\n", __FUNCTION__, addr);
		RTW_INFO("%s: cnts=%d\n", __FUNCTION__, cnts);
		RTW_INFO("%s: MAC address=%s\n", __FUNCTION__, tmp[1]);

		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
			pEfuseHal->fakeEfuseModifiedMap[addr + jj] = key_2char2num(tmp[1][kk], tmp[1][kk + 1]);

		_rtw_memset(extra, '\0', strlen(extra));
		sprintf(extra, "write mac addr to fake map OK\n");
	} else if(strcmp(tmp[0], "update") == 0) {
		RTW_INFO("To Use new eFuse map\n");
		/*step read efuse/eeprom data and get mac_addr*/
		rtw_hal_read_chip_info(padapter);
		/* set mac addr*/
		rtw_macaddr_cfg(adapter_mac_addr(padapter), get_hal_mac_addr(padapter));
		_rtw_memcpy(padapter->pnetdev->dev_addr, get_hal_mac_addr(padapter), ETH_ALEN); /* set mac addr to net_device */

#ifdef CONFIG_P2P
		rtw_init_wifidirect_addrs(padapter, adapter_mac_addr(padapter), adapter_mac_addr(padapter));
#endif
#ifdef CONFIG_MI_WITH_MBSSID_CAM
		rtw_hal_change_macaddr_mbid(padapter, adapter_mac_addr(padapter));
#else
		rtw_hal_set_hwreg(padapter, HW_VAR_MAC_ADDR, adapter_mac_addr(padapter)); /* set mac addr to mac register */
#endif
		/*pHalFunc->hal_deinit(padapter);*/
		if (pHalFunc->hal_init(padapter) == _FAIL) {
			err = -EINVAL;
			goto exit;
		}
		_rtw_memset(extra, '\0', strlen(extra));
		sprintf(extra, "eFuse Update OK\n");
	} else if (strcmp(tmp[0], "analyze") == 0) {

		rtw_efuse_analyze(padapter, EFUSE_WIFI, 0);
		_rtw_memset(extra, '\0', strlen(extra));
		sprintf(extra, "eFuse Analyze OK,please to check kernel log\n");
	}
exit:
	if (setdata)
		rtw_mfree(setdata, 1024);
	if (ShadowMapBT)
		rtw_mfree(ShadowMapBT, EFUSE_BT_MAX_MAP_LEN);
	if (ShadowMapWiFi)
		rtw_mfree(ShadowMapWiFi, wifimaplen);
	if (setrawdata)
		rtw_mfree(setrawdata, EFUSE_MAX_SIZE);

	wrqu->length = strlen(extra);

	if (padapter->registrypriv.mp_mode == 0) {
#ifdef CONFIG_IPS
		rtw_pm_set_ips(padapter, ips_mode);
#endif /* CONFIG_IPS */

#ifdef CONFIG_LPS
		rtw_pm_set_lps(padapter, lps_mode);
#endif /* CONFIG_LPS */
	}

	return err;
}

#ifdef CONFIG_RTW_CUSTOMER_STR
static int rtw_mp_customer_str(
	struct net_device *dev,
	struct iw_request_info *info,
	union iwreq_data *wrqu, char *extra)
{
	_adapter *adapter = rtw_netdev_priv(dev);
	u32 len;
	u8 *pbuf = NULL, *pch;
	char *ptmp;
	u8 param[RTW_CUSTOMER_STR_LEN];
	u8 count = 0;
	u8 tmp;
	u8 i;
	u32 pos;
	u8 ret;
	u8 read = 0;

	if (adapter->registrypriv.mp_mode != 1
		|| !adapter->registrypriv.mp_customer_str)
		return -EFAULT;

	len = wrqu->data.length + 1;

	pbuf = (u8 *)rtw_zmalloc(len);
	if (pbuf == NULL) {
		RTW_WARN("%s: no memory!\n", __func__);
		return -ENOMEM;
	}

	if (copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length)) {
		rtw_mfree(pbuf, len);
		RTW_WARN("%s: copy from user fail!\n", __func__);
		return -EFAULT;
	}
	RTW_INFO("%s: string=\"%s\"\n", __func__, pbuf);

	ptmp = (char *)pbuf;
	pch = strsep(&ptmp, ",");
	if ((pch == NULL) || (strlen(pch) == 0)) {
		rtw_mfree(pbuf, len);
		RTW_INFO("%s: parameter error(no cmd)!\n", __func__);
		return -EFAULT;
	}

	_rtw_memset(param, 0xFF, RTW_CUSTOMER_STR_LEN);

	if (strcmp(pch, "read") == 0) {
		read = 1;
		ret = rtw_hal_customer_str_read(adapter, param);

	} else if (strcmp(pch, "write") == 0) {
		do {
			pch = strsep(&ptmp, ":");
			if ((pch == NULL) || (strlen(pch) == 0))
				break;
			if (strlen(pch) != 2
				|| IsHexDigit(*pch) == _FALSE
				|| IsHexDigit(*(pch + 1)) == _FALSE
				|| sscanf(pch, "%hhx", &tmp) != 1
			) {
				RTW_WARN("%s: invalid 8-bit hex!\n", __func__);
				rtw_mfree(pbuf, len);
				return -EFAULT;
			}

			param[count++] = tmp;

		} while (count < RTW_CUSTOMER_STR_LEN);

		if (count == 0) {
			rtw_mfree(pbuf, len);
			RTW_WARN("%s: no input!\n", __func__);
			return -EFAULT;
		}
		ret = rtw_hal_customer_str_write(adapter, param);
	} else {
		rtw_mfree(pbuf, len);
		RTW_INFO("%s: parameter error(unknown cmd)!\n", __func__);
		return -EFAULT;
	}

	pos = sprintf(extra, "%s: ", read ? "read" : "write");
	if (read == 0 || ret == _SUCCESS) {
		for (i = 0; i < RTW_CUSTOMER_STR_LEN; i++)
			pos += sprintf(extra + pos, "%02x:", param[i]);
		extra[pos] = 0;
		pos--;
	}
	pos += sprintf(extra + pos, " %s", ret == _SUCCESS ? "OK" : "FAIL");

	wrqu->data.length = strlen(extra) + 1;

	rtw_mfree(pbuf, len);
	return 0;
}
#endif /* CONFIG_RTW_CUSTOMER_STR */

static int rtw_priv_mp_set(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wdata, char *extra)
{

	struct iw_point *wrqu = (struct iw_point *)wdata;
	u32 subcmd = wrqu->flags;
	PADAPTER padapter = rtw_netdev_priv(dev);
	int status = 0;

#ifdef CONFIG_CONCURRENT_MODE
	if (!is_primary_adapter(padapter)) {
		RTW_INFO("MP mode only primary Adapter support\n");
		return -EIO;
	}
#endif

	RTW_INFO("%s mutx in %d\n", __func__, subcmd);
	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->ioctrl_mutex), NULL);
	switch (subcmd) {
	case CTA_TEST:
		RTW_INFO("set CTA_TEST\n");
		status = rtw_cta_test_start(dev, info, wdata, extra);
		break;
	case MP_DISABLE_BT_COEXIST:
		RTW_INFO("set case MP_DISABLE_BT_COEXIST\n");
		status = rtw_mp_disable_bt_coexist(dev, info, wdata, extra);
		break;
	case MP_IQK:
		RTW_INFO("set MP_IQK\n");
		status = rtw_mp_iqk(dev, info, wrqu, extra);
		break;
	case MP_LCK:
		RTW_INFO("set MP_LCK\n");
		status = rtw_mp_lck(dev, info, wrqu, extra);
	break;

	default:
		status = -EIO;
	}
	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->ioctrl_mutex), NULL);
	RTW_INFO("%s mutx done %d\n", __func__, subcmd);

	return status;
}

static int rtw_priv_mp_get(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wdata, char *extra)
{

	struct iw_point *wrqu = (struct iw_point *)wdata;
	u32 subcmd = wrqu->flags;
	PADAPTER padapter = rtw_netdev_priv(dev);
	int status = 0;

#ifdef CONFIG_CONCURRENT_MODE
	if (!is_primary_adapter(padapter)) {
		RTW_INFO("MP mode only primary Adapter support\n");
		return -EIO;
	}
#endif

	RTW_INFO("%s mutx in %d\n", __func__, subcmd);
	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->ioctrl_mutex), NULL);

	switch (subcmd) {
	case MP_START:
		RTW_INFO("set case mp_start\n");
		status = rtw_mp_start(dev, info, wrqu, extra);
		break;
	case MP_STOP:
		RTW_INFO("set case mp_stop\n");
		status = rtw_mp_stop(dev, info, wrqu, extra);
		break;
	case MP_BANDWIDTH:
		RTW_INFO("set case mp_bandwidth\n");
		status = rtw_mp_bandwidth(dev, info, wrqu, extra);
		break;
	case MP_RESET_STATS:
		RTW_INFO("set case MP_RESET_STATS\n");
		status = rtw_mp_reset_stats(dev, info, wrqu, extra);
		break;
	case MP_SetRFPathSwh:
		RTW_INFO("set MP_SetRFPathSwitch\n");
		status = rtw_mp_SetRFPath(dev, info, wrqu, extra);
		break;
	case WRITE_REG:
		status = rtw_mp_write_reg(dev, info, wrqu, extra);
		break;
	case WRITE_RF:
		status = rtw_mp_write_rf(dev, info, wrqu, extra);
		break;
	case MP_PHYPARA:
		RTW_INFO("mp_get  MP_PHYPARA\n");
		status = rtw_mp_phypara(dev, info, wrqu, extra);
		break;
	case MP_CHANNEL:
		RTW_INFO("set case mp_channel\n");
		status = rtw_mp_channel(dev , info, wrqu, extra);
		break;
	case  MP_CHL_OFFSET:
		RTW_INFO("set case mp_ch_offset\n");
		status = rtw_mp_ch_offset(dev , info, wrqu, extra);
		break;
	case READ_REG:
		RTW_INFO("mp_get  READ_REG\n");
		status = rtw_mp_read_reg(dev, info, wrqu, extra);
		break;
	case READ_RF:
		RTW_INFO("mp_get  READ_RF\n");
		status = rtw_mp_read_rf(dev, info, wrqu, extra);
		break;
	case MP_RATE:
		RTW_INFO("set case mp_rate\n");
		status = rtw_mp_rate(dev, info, wrqu, extra);
		break;
	case MP_TXPOWER:
		RTW_INFO("set case MP_TXPOWER\n");
		status = rtw_mp_txpower(dev, info, wrqu, extra);
		break;
	case MP_ANT_TX:
		RTW_INFO("set case MP_ANT_TX\n");
		status = rtw_mp_ant_tx(dev, info, wrqu, extra);
		break;
	case MP_ANT_RX:
		RTW_INFO("set case MP_ANT_RX\n");
		status = rtw_mp_ant_rx(dev, info, wrqu, extra);
		break;
	case MP_QUERY:
		status = rtw_mp_trx_query(dev, info, wrqu, extra);
		break;
	case MP_CTX:
		RTW_INFO("set case MP_CTX\n");
		status = rtw_mp_ctx(dev, info, wrqu, extra);
		break;
	case MP_ARX:
		RTW_INFO("set case MP_ARX\n");
		status = rtw_mp_arx(dev, info, wrqu, extra);
		break;
	case MP_DUMP:
		RTW_INFO("set case MP_DUMP\n");
		status = rtw_mp_dump(dev, info, wrqu, extra);
		break;
	case MP_PSD:
		RTW_INFO("set case MP_PSD\n");
		status = rtw_mp_psd(dev, info, wrqu, extra);
		break;
	case MP_THER:
		RTW_INFO("set case MP_THER\n");
		status = rtw_mp_thermal(dev, info, wrqu, extra);
		break;
	case MP_PwrCtlDM:
		RTW_INFO("set MP_PwrCtlDM\n");
		status = rtw_mp_PwrCtlDM(dev, info, wrqu, extra);
		break;
	case MP_QueryDrvStats:
		RTW_INFO("mp_get MP_QueryDrvStats\n");
		status = rtw_mp_QueryDrv(dev, info, wdata, extra);
		break;
	case MP_PWRTRK:
		RTW_INFO("set case MP_PWRTRK\n");
		status = rtw_mp_pwrtrk(dev, info, wrqu, extra);
		break;
#ifdef CONFIG_MP_INCLUDED
	case EFUSE_SET:
		RTW_INFO("set case efuse set\n");
		status = rtw_mp_efuse_set(dev, info, wdata, extra);
		break;
#endif
	case EFUSE_GET:
		RTW_INFO("efuse get EFUSE_GET\n");
		status = rtw_mp_efuse_get(dev, info, wdata, extra);
		break;
	case MP_GET_TXPOWER_INX:
		RTW_INFO("mp_get MP_GET_TXPOWER_INX\n");
		status = rtw_mp_txpower_index(dev, info, wrqu, extra);
		break;
	case MP_GETVER:
		RTW_INFO("mp_get MP_GETVER\n");
		status = rtw_mp_getver(dev, info, wdata, extra);
		break;
	case MP_MON:
		RTW_INFO("mp_get MP_MON\n");
		status = rtw_mp_mon(dev, info, wdata, extra);
		break;
	case EFUSE_BT_MASK:
		RTW_INFO("mp_get EFUSE_BT_MASK\n");
		status = rtw_bt_efuse_mask_file(dev, info, wdata, extra);
		break;
	case EFUSE_MASK:
		RTW_INFO("mp_get EFUSE_MASK\n");
		status = rtw_efuse_mask_file(dev, info, wdata, extra);
		break;
	case  EFUSE_FILE:
		RTW_INFO("mp_get EFUSE_FILE\n");
		status = rtw_efuse_file_map(dev, info, wdata, extra);
		break;
	case  MP_TX:
		RTW_INFO("mp_get MP_TX\n");
		status = rtw_mp_tx(dev, info, wdata, extra);
		break;
	case  MP_RX:
		RTW_INFO("mp_get MP_RX\n");
		status = rtw_mp_rx(dev, info, wdata, extra);
		break;
	case MP_HW_TX_MODE:
		RTW_INFO("mp_get MP_HW_TX_MODE\n");
		status = rtw_mp_hwtx(dev, info, wdata, extra);
		break;
#ifdef CONFIG_RTW_CUSTOMER_STR
	case MP_CUSTOMER_STR:
		RTW_INFO("customer str\n");
		status = rtw_mp_customer_str(dev, info, wdata, extra);
		break;
#endif
	case MP_PWRLMT:
		RTW_INFO("mp_get MP_SETPWRLMT\n");
		status = rtw_mp_pwrlmt(dev, info, wdata, extra);
		break;
	case MP_PWRBYRATE:
		RTW_INFO("mp_get MP_SETPWRBYRATE\n");
		status = rtw_mp_pwrbyrate(dev, info, wdata, extra);
		break;
	case  BT_EFUSE_FILE:
		RTW_INFO("mp_get BT EFUSE_FILE\n");
		status = rtw_bt_efuse_file_map(dev, info, wdata, extra);
		break;
	case MP_SWRFPath:
		RTW_INFO("mp_get MP_SWRFPath\n");
		status = rtw_mp_switch_rf_path(dev, info, wrqu, extra);
		break;
	case MP_LINK:
		RTW_INFO("mp_get MP_LINK\n");
		status = rtw_mp_link(dev, info, wrqu, extra);
		break;
	case MP_DPK_TRK:
		RTW_INFO("mp_get MP_DPK_TRK\n");
		status = rtw_mp_dpk_track(dev, info, wdata, extra);
		break;
	case MP_DPK:
		RTW_INFO("set MP_DPK\n");
		status = rtw_mp_dpk(dev, info, wdata, extra);
		break;
	default:
		status = -EIO;
	}

	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->ioctrl_mutex), NULL);
	RTW_INFO("%s mutx done_%d\n", __func__, subcmd);

	return status;
}
#endif /*#if defined(CONFIG_MP_INCLUDED)*/


#ifdef CONFIG_SDIO_INDIRECT_ACCESS
#define DBG_MP_SDIO_INDIRECT_ACCESS 1
static int rtw_mp_sd_iread(struct net_device *dev
			   , struct iw_request_info *info
			   , struct iw_point *wrqu
			   , char *extra)
{
	char input[16];
	u8 width;
	unsigned long addr;
	u32 ret = 0;
	PADAPTER padapter = rtw_netdev_priv(dev);

	if (wrqu->length > 16) {
		RTW_INFO(FUNC_ADPT_FMT" wrqu->length:%d\n", FUNC_ADPT_ARG(padapter), wrqu->length);
		ret = -EINVAL;
		goto exit;
	}

	if (copy_from_user(input, wrqu->pointer, wrqu->length)) {
		RTW_INFO(FUNC_ADPT_FMT" copy_from_user fail\n", FUNC_ADPT_ARG(padapter));
		ret = -EFAULT;
		goto exit;
	}

	_rtw_memset(extra, 0, wrqu->length);

	if (sscanf(input, "%hhu,%lx", &width, &addr) != 2) {
		RTW_INFO(FUNC_ADPT_FMT" sscanf fail\n", FUNC_ADPT_ARG(padapter));
		ret = -EINVAL;
		goto exit;
	}

	if (addr > 0x3FFF) {
		RTW_INFO(FUNC_ADPT_FMT" addr:0x%lx\n", FUNC_ADPT_ARG(padapter), addr);
		ret = -EINVAL;
		goto exit;
	}

	if (DBG_MP_SDIO_INDIRECT_ACCESS)
		RTW_INFO(FUNC_ADPT_FMT" width:%u, addr:0x%lx\n", FUNC_ADPT_ARG(padapter), width, addr);

	switch (width) {
	case 1:
		sprintf(extra, "0x%02x", rtw_sd_iread8(padapter, addr));
		wrqu->length = strlen(extra);
		break;
	case 2:
		sprintf(extra, "0x%04x", rtw_sd_iread16(padapter, addr));
		wrqu->length = strlen(extra);
		break;
	case 4:
		sprintf(extra, "0x%08x", rtw_sd_iread32(padapter, addr));
		wrqu->length = strlen(extra);
		break;
	default:
		wrqu->length = 0;
		ret = -EINVAL;
		break;
	}

exit:
	return ret;
}

static int rtw_mp_sd_iwrite(struct net_device *dev
			    , struct iw_request_info *info
			    , struct iw_point *wrqu
			    , char *extra)
{
	char width;
	unsigned long addr, data;
	int ret = 0;
	PADAPTER padapter = rtw_netdev_priv(dev);
	char input[32];

	if (wrqu->length > 32) {
		RTW_INFO(FUNC_ADPT_FMT" wrqu->length:%d\n", FUNC_ADPT_ARG(padapter), wrqu->length);
		ret = -EINVAL;
		goto exit;
	}

	if (copy_from_user(input, wrqu->pointer, wrqu->length)) {
		RTW_INFO(FUNC_ADPT_FMT" copy_from_user fail\n", FUNC_ADPT_ARG(padapter));
		ret = -EFAULT;
		goto exit;
	}

	_rtw_memset(extra, 0, wrqu->length);

	if (sscanf(input, "%hhu,%lx,%lx", &width, &addr, &data) != 3) {
		RTW_INFO(FUNC_ADPT_FMT" sscanf fail\n", FUNC_ADPT_ARG(padapter));
		ret = -EINVAL;
		goto exit;
	}

	if (addr > 0x3FFF) {
		RTW_INFO(FUNC_ADPT_FMT" addr:0x%lx\n", FUNC_ADPT_ARG(padapter), addr);
		ret = -EINVAL;
		goto exit;
	}

	if (DBG_MP_SDIO_INDIRECT_ACCESS)
		RTW_INFO(FUNC_ADPT_FMT" width:%u, addr:0x%lx, data:0x%lx\n", FUNC_ADPT_ARG(padapter), width, addr, data);

	switch (width) {
	case 1:
		if (data > 0xFF) {
			ret = -EINVAL;
			break;
		}
		rtw_sd_iwrite8(padapter, addr, data);
		break;
	case 2:
		if (data > 0xFFFF) {
			ret = -EINVAL;
			break;
		}
		rtw_sd_iwrite16(padapter, addr, data);
		break;
	case 4:
		rtw_sd_iwrite32(padapter, addr, data);
		break;
	default:
		wrqu->length = 0;
		ret = -EINVAL;
		break;
	}

exit:
	return ret;
}
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */

static int rtw_priv_set(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wdata, char *extra)
{
	struct iw_point *wrqu = (struct iw_point *)wdata;
	u32 subcmd = wrqu->flags;
	PADAPTER padapter = rtw_netdev_priv(dev);

	if (padapter == NULL)
		return -ENETDOWN;

	if (padapter->bup == _FALSE) {
		RTW_INFO(" %s fail =>(padapter->bup == _FALSE )\n", __FUNCTION__);
		return -ENETDOWN;
	}

	if (RTW_CANNOT_RUN(padapter)) {
		RTW_INFO("%s fail =>(bSurpriseRemoved == _TRUE) || ( bDriverStopped == _TRUE)\n", __func__);
		return -ENETDOWN;
	}

	if (extra == NULL) {
		wrqu->length = 0;
		return -EIO;
	}

	if (subcmd < MP_NULL) {
#ifdef CONFIG_MP_INCLUDED
		rtw_priv_mp_set(dev, info, wdata, extra);
#endif
		return 0;
	}

	switch (subcmd) {
#ifdef CONFIG_WOWLAN
	case MP_WOW_ENABLE:
		RTW_INFO("set case MP_WOW_ENABLE: %s\n", extra);

		rtw_wowlan_ctrl(dev, info, wdata, extra);
		break;
	case MP_WOW_SET_PATTERN:
		RTW_INFO("set case MP_WOW_SET_PATTERN: %s\n", extra);
		rtw_wowlan_set_pattern(dev, info, wdata, extra);
		break;
#endif
#ifdef CONFIG_AP_WOWLAN
	case MP_AP_WOW_ENABLE:
		RTW_INFO("set case MP_AP_WOW_ENABLE: %s\n", extra);
		rtw_ap_wowlan_ctrl(dev, info, wdata, extra);
		break;
#endif
#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
	case VENDOR_IE_SET:
		RTW_INFO("set case VENDOR_IE_SET\n");
		rtw_vendor_ie_set(dev , info , wdata , extra);
		break;
#endif
	default:
		return -EIO;
	}

	return 0;
}


static int rtw_priv_get(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wdata, char *extra)
{
	struct iw_point *wrqu = (struct iw_point *)wdata;
	u32 subcmd = wrqu->flags;
	PADAPTER padapter = rtw_netdev_priv(dev);
	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
	struct dm_struct	*p_dm = &pHalData->odmpriv;
	struct dm_rf_calibration_struct	*p_rf_calibrate_info = &(p_dm->rf_calibrate_info);
	struct dm_iqk_info	*p_iqk_info = &p_dm->IQK_info;
	u32 i = 100;

	if (padapter == NULL)
		return -ENETDOWN;

	if (padapter->bup == _FALSE) {
		RTW_INFO(" %s fail =>(padapter->bup == _FALSE )\n", __FUNCTION__);
		return -ENETDOWN;
	}

	if (RTW_CANNOT_RUN(padapter)) {
		RTW_INFO("%s fail =>(padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE)\n", __func__);
		return -ENETDOWN;
	}

	if (extra == NULL) {
		wrqu->length = 0;
		return -EIO;
	}

	if (subcmd < MP_NULL) {
#ifdef CONFIG_MP_INCLUDED
		while (i > 1) {
			if (p_rf_calibrate_info->is_iqk_in_progress) {
				rtw_msleep_os(10);
			} else {
				p_iqk_info->rfk_forbidden = _TRUE;
				break;
			}
			i--;
		}
		if (subcmd == MP_CHANNEL || subcmd == MP_BANDWIDTH)
			p_iqk_info->rfk_forbidden = _FALSE;
		rtw_priv_mp_get(dev, info, wdata, extra);
		rtw_msleep_os(10); /* delay 5ms for sending pkt before exit adb shell operation */
		p_iqk_info->rfk_forbidden = _FALSE;
#endif
	} else {
			switch (subcmd) {
#if defined(CONFIG_RTL8723B)
			case MP_SetBT:
				RTW_INFO("set MP_SetBT\n");
				rtw_mp_SetBT(dev, info, wdata, extra);
				break;
#endif
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
			case MP_SD_IREAD:
				rtw_mp_sd_iread(dev, info, wrqu, extra);
				break;
			case MP_SD_IWRITE:
				rtw_mp_sd_iwrite(dev, info, wrqu, extra);
				break;
#endif
#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
			case VENDOR_IE_GET:
				RTW_INFO("get case VENDOR_IE_GET\n");
				rtw_vendor_ie_get(dev , info , wdata , extra);
				break;
#endif
			default:
				return -EIO;
			}
		}

	return 0;
}


#ifdef CONFIG_TDLS
static int rtw_wx_tdls_wfd_enable(struct net_device *dev,
				  struct iw_request_info *info,
				  union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_WFD

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (extra[0] == '0')
		rtw_tdls_wfd_enable(padapter, 0);
	else
		rtw_tdls_wfd_enable(padapter, 1);

#endif /* CONFIG_WFD */

	return ret;
}

static int rtw_tdls_weaksec(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	u8 i, j;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (extra[0] == '0')
		padapter->wdinfo.wfd_tdls_weaksec = 0;
	else
		padapter->wdinfo.wfd_tdls_weaksec = 1;

#endif /* CONFIG_TDLS */

	return ret;
}


static int rtw_tdls_enable(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (extra[0] == '0')
		rtw_disable_tdls_func(padapter, _TRUE);
	else if (extra[0] == '1')
		rtw_enable_tdls_func(padapter);
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_setup(struct net_device *dev,
			  struct iw_request_info *info,
			  union iwreq_data *wrqu, char *extra)
{
	int ret = 0;
#ifdef CONFIG_TDLS
	u8 i, j;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_txmgmt txmgmt;
#ifdef CONFIG_WFD
	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
#endif /* CONFIG_WFD */

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (wrqu->data.length - 1 != 17) {
		RTW_INFO("[%s] length:%d != 17\n", __FUNCTION__, (wrqu->data.length - 1));
		return ret;
	}

	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j += 3)
		txmgmt.peer[i] = key_2char2num(*(extra + j), *(extra + j + 1));

#ifdef CONFIG_WFD
	if (_AES_ != padapter->securitypriv.dot11PrivacyAlgrthm) {
		/* Weak Security situation with AP. */
		if (0 == pwdinfo->wfd_tdls_weaksec)	{
			/* Can't send the tdls setup request out!! */
			RTW_INFO("[%s] Current link is not AES, "
				"SKIP sending the tdls setup request!!\n", __FUNCTION__);
		} else
			issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
	} else
#endif /* CONFIG_WFD */
	{
		issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
	}
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_teardown(struct net_device *dev,
			     struct iw_request_info *info,
			     union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	u8 i, j;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct sta_info *ptdls_sta = NULL;
	struct tdls_txmgmt txmgmt;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (wrqu->data.length - 1 != 17 && wrqu->data.length - 1 != 19) {
		RTW_INFO("[%s] length:%d != 17 or 19\n",
			 __FUNCTION__, (wrqu->data.length - 1));
		return ret;
	}

	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
	for (i = 0, j = 0; i < ETH_ALEN; i++, j += 3)
		txmgmt.peer[i] = key_2char2num(*(extra + j), *(extra + j + 1));

	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), txmgmt.peer);

	if (ptdls_sta != NULL) {
		txmgmt.status_code = _RSON_TDLS_TEAR_UN_RSN_;
		if (wrqu->data.length - 1 == 19)
			issue_tdls_teardown(padapter, &txmgmt, _FALSE);
		else
			issue_tdls_teardown(padapter, &txmgmt, _TRUE);
	} else
		RTW_INFO("TDLS peer not found\n");
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_discovery(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_txmgmt	txmgmt;
	int i = 0, j = 0;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j += 3)
		txmgmt.peer[i] = key_2char2num(*(extra + j), *(extra + j + 1));

	issue_tdls_dis_req(padapter, &txmgmt);

#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_ch_switch(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_ch_switch *pchsw_info = &padapter->tdlsinfo.chsw_info;
	u8 i, j;
	struct sta_info *ptdls_sta = NULL;
	u8 take_care_iqk;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (rtw_tdls_is_chsw_allowed(padapter) == _FALSE) {
		RTW_INFO("TDLS channel switch is not allowed\n");
		return ret;
	}

	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j += 3)
		pchsw_info->addr[i] = key_2char2num(*(extra + j), *(extra + j + 1));

	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, pchsw_info->addr);
	if (ptdls_sta == NULL)
		return ret;

	pchsw_info->ch_sw_state |= TDLS_CH_SW_INITIATOR_STATE;

	if (ptdls_sta != NULL) {
		if (pchsw_info->off_ch_num == 0)
			pchsw_info->off_ch_num = 11;
	} else
		RTW_INFO("TDLS peer not found\n");

	rtw_pm_set_lps(padapter, PS_MODE_ACTIVE);

	rtw_hal_get_hwreg(padapter, HW_VAR_CH_SW_NEED_TO_TAKE_CARE_IQK_INFO, &take_care_iqk);
	if (take_care_iqk == _TRUE) {
		u8 central_chnl;
		u8 bw_mode;

		bw_mode = (pchsw_info->ch_offset) ? CHANNEL_WIDTH_40 : CHANNEL_WIDTH_20;
		central_chnl = rtw_get_center_ch(pchsw_info->off_ch_num, bw_mode, pchsw_info->ch_offset);
		if (rtw_hal_ch_sw_iqk_info_search(padapter, central_chnl, bw_mode) >= 0)
			rtw_tdls_cmd(padapter, ptdls_sta->cmn.mac_addr, TDLS_CH_SW_START);
		else
			rtw_tdls_cmd(padapter, ptdls_sta->cmn.mac_addr, TDLS_CH_SW_PREPARE);
	} else
		rtw_tdls_cmd(padapter, ptdls_sta->cmn.mac_addr, TDLS_CH_SW_START);

	/* issue_tdls_ch_switch_req(padapter, ptdls_sta); */
	/* RTW_INFO("issue tdls ch switch req\n"); */

#endif /* CONFIG_TDLS_CH_SW */
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_ch_switch_off(struct net_device *dev,
				  struct iw_request_info *info,
				  union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_ch_switch *pchsw_info = &padapter->tdlsinfo.chsw_info;
	u8 i, j, mac_addr[ETH_ALEN];
	struct sta_info *ptdls_sta = NULL;
	struct tdls_txmgmt txmgmt;

	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	if (rtw_tdls_is_chsw_allowed(padapter) == _FALSE) {
		RTW_INFO("TDLS channel switch is not allowed\n");
		return ret;
	}

	if (wrqu->data.length >= 17) {
		for (i = 0, j = 0 ; i < ETH_ALEN; i++, j += 3)
			mac_addr[i] = key_2char2num(*(extra + j), *(extra + j + 1));
		ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
	}

	if (ptdls_sta == NULL)
		return ret;

	rtw_tdls_cmd(padapter, ptdls_sta->cmn.mac_addr, TDLS_CH_SW_END_TO_BASE_CHNL);

	pchsw_info->ch_sw_state &= ~(TDLS_CH_SW_INITIATOR_STATE |
				     TDLS_CH_SWITCH_ON_STATE |
				     TDLS_PEER_AT_OFF_STATE);
	_rtw_memset(pchsw_info->addr, 0x00, ETH_ALEN);

	ptdls_sta->ch_switch_time = 0;
	ptdls_sta->ch_switch_timeout = 0;
	_cancel_timer_ex(&ptdls_sta->ch_sw_timer);
	_cancel_timer_ex(&ptdls_sta->delay_timer);
	_cancel_timer_ex(&ptdls_sta->stay_on_base_chnl_timer);
	_cancel_timer_ex(&ptdls_sta->ch_sw_monitor_timer);

	rtw_pm_set_lps(padapter, PS_MODE_MAX);
#endif /* CONFIG_TDLS_CH_SW */
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_dump_ch(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;

	RTW_INFO("[%s] dump_stack:%s\n", __FUNCTION__, extra);

	extra[wrqu->data.length] = 0x00;
	ptdlsinfo->chsw_info.dump_stack = rtw_atoi(extra);

	return ret;

#endif
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_off_ch_num(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;

	RTW_INFO("[%s] off_ch_num:%s\n", __FUNCTION__, extra);

	extra[wrqu->data.length] = 0x00;
	ptdlsinfo->chsw_info.off_ch_num = rtw_atoi(extra);

	return ret;

#endif
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_ch_offset(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;

	RTW_INFO("[%s] ch_offset:%s\n", __FUNCTION__, extra);

	extra[wrqu->data.length] = 0x00;
	switch (rtw_atoi(extra)) {
	case SCA:
		ptdlsinfo->chsw_info.ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
		break;

	case SCB:
		ptdlsinfo->chsw_info.ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
		break;

	default:
		ptdlsinfo->chsw_info.ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
		break;
	}

	return ret;

#endif
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_pson(struct net_device *dev,
			 struct iw_request_info *info,
			 union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 i, j, mac_addr[ETH_ALEN];
	struct sta_info *ptdls_sta = NULL;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	for (i = 0, j = 0; i < ETH_ALEN; i++, j += 3)
		mac_addr[i] = key_2char2num(*(extra + j), *(extra + j + 1));

	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);

	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta->cmn.mac_addr, 1, 3, 500);

#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_psoff(struct net_device *dev,
			  struct iw_request_info *info,
			  union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 i, j, mac_addr[ETH_ALEN];
	struct sta_info *ptdls_sta = NULL;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	for (i = 0, j = 0; i < ETH_ALEN; i++, j += 3)
		mac_addr[i] = key_2char2num(*(extra + j), *(extra + j + 1));

	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);

	if (ptdls_sta)
		issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta->cmn.mac_addr, 0, 3, 500);

#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_setip(struct net_device *dev,
			  struct iw_request_info *info,
			  union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_WFD

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
	u8 i = 0, j = 0, k = 0, tag = 0;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);

	while (i < 4) {
		for (j = 0; j < 4; j++) {
			if (*(extra + j + tag) == '.' || *(extra + j + tag) == '\0') {
				if (j == 1)
					pwfd_info->ip_address[i] = convert_ip_addr('0', '0', *(extra + (j - 1) + tag));
				if (j == 2)
					pwfd_info->ip_address[i] = convert_ip_addr('0', *(extra + (j - 2) + tag), *(extra + (j - 1) + tag));
				if (j == 3)
					pwfd_info->ip_address[i] = convert_ip_addr(*(extra + (j - 3) + tag), *(extra + (j - 2) + tag), *(extra + (j - 1) + tag));

				tag += j + 1;
				break;
			}
		}
		i++;
	}

	RTW_INFO("[%s] Set IP = %u.%u.%u.%u\n", __FUNCTION__,
		 ptdlsinfo->wfd_info->ip_address[0],
		 ptdlsinfo->wfd_info->ip_address[1],
		 ptdlsinfo->wfd_info->ip_address[2],
		 ptdlsinfo->wfd_info->ip_address[3]);

#endif /* CONFIG_WFD */
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_getip(struct net_device *dev,
			  struct iw_request_info *info,
			  union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_WFD

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;

	RTW_INFO("[%s]\n", __FUNCTION__);

	sprintf(extra, "\n\n%u.%u.%u.%u\n",
		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);

	RTW_INFO("[%s] IP=%u.%u.%u.%u\n", __FUNCTION__,
		 pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
		 pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);

	wrqu->data.length = strlen(extra);

#endif /* CONFIG_WFD */
#endif /* CONFIG_TDLS */

	return ret;
}

static int rtw_tdls_getport(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wrqu, char *extra)
{

	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_WFD

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;

	RTW_INFO("[%s]\n", __FUNCTION__);

	sprintf(extra, "\n\n%d\n", pwfd_info->peer_rtsp_ctrlport);
	RTW_INFO("[%s] remote port = %d\n",
		 __FUNCTION__, pwfd_info->peer_rtsp_ctrlport);

	wrqu->data.length = strlen(extra);

#endif /* CONFIG_WFD */
#endif /* CONFIG_TDLS */

	return ret;

}

/* WFDTDLS, for sigma test */
static int rtw_tdls_dis_result(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{

	int ret = 0;

#ifdef CONFIG_TDLS
#ifdef CONFIG_WFD

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;

	RTW_INFO("[%s]\n", __FUNCTION__);

	if (ptdlsinfo->dev_discovered == _TRUE) {
		sprintf(extra, "\n\nDis=1\n");
		ptdlsinfo->dev_discovered = _FALSE;
	}

	wrqu->data.length = strlen(extra);

#endif /* CONFIG_WFD */
#endif /* CONFIG_TDLS */

	return ret;

}

/* WFDTDLS, for sigma test */
static int rtw_wfd_tdls_status(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{

	int ret = 0;

#ifdef CONFIG_TDLS

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;

	RTW_INFO("[%s]\n", __FUNCTION__);

	sprintf(extra, "\nlink_established:%d\n"
		"sta_cnt:%d\n"
		"sta_maximum:%d\n"
		"cur_channel:%d\n"
		"tdls_enable:%d"
#ifdef CONFIG_TDLS_CH_SW
		"ch_sw_state:%08x\n"
		"chsw_on:%d\n"
		"off_ch_num:%d\n"
		"cur_time:%d\n"
		"ch_offset:%d\n"
		"delay_swtich_back:%d"
#endif
		,
		ptdlsinfo->link_established, ptdlsinfo->sta_cnt,
		ptdlsinfo->sta_maximum, ptdlsinfo->cur_channel,
		rtw_is_tdls_enabled(padapter)
#ifdef CONFIG_TDLS_CH_SW
		,
		ptdlsinfo->chsw_info.ch_sw_state,
		ATOMIC_READ(&padapter->tdlsinfo.chsw_info.chsw_on),
		ptdlsinfo->chsw_info.off_ch_num,
		ptdlsinfo->chsw_info.cur_time,
		ptdlsinfo->chsw_info.ch_offset,
		ptdlsinfo->chsw_info.delay_switch_back
#endif
	       );

	wrqu->data.length = strlen(extra);

#endif /* CONFIG_TDLS */

	return ret;

}

static int rtw_tdls_getsta(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra)
{

	int ret = 0;
#ifdef CONFIG_TDLS
	u8 i, j;
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	u8 addr[ETH_ALEN] = {0};
	char charmac[17];
	struct sta_info *ptdls_sta = NULL;

	RTW_INFO("[%s] %s %d\n", __FUNCTION__,
		 (char *)wrqu->data.pointer, wrqu->data.length - 1);

	if (copy_from_user(charmac, wrqu->data.pointer + 9, 17)) {
		ret = -EFAULT;
		goto exit;
	}

	RTW_INFO("[%s] %d, charmac:%s\n", __FUNCTION__, __LINE__, charmac);
	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j += 3)
		addr[i] = key_2char2num(*(charmac + j), *(charmac + j + 1));

	RTW_INFO("[%s] %d, charmac:%s, addr:"MAC_FMT"\n",
		 __FUNCTION__, __LINE__, charmac, MAC_ARG(addr));
	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, addr);
	if (ptdls_sta) {
		sprintf(extra, "\n\ntdls_sta_state=0x%08x\n", ptdls_sta->tdls_sta_state);
		RTW_INFO("\n\ntdls_sta_state=%d\n", ptdls_sta->tdls_sta_state);
	} else {
		sprintf(extra, "\n\nNot found this sta\n");
		RTW_INFO("\n\nNot found this sta\n");
	}
	wrqu->data.length = strlen(extra);

exit:
#endif /* CONFIG_TDLS */
	return ret;

}

static int rtw_tdls_get_best_ch(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
#ifdef CONFIG_FIND_BEST_CHANNEL
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct rf_ctl_t *rfctl = adapter_to_rfctl(padapter);
	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;

	for (i = 0; i < rfctl->max_chan_nums && rfctl->channel_set[i].ChannelNum != 0; i++) {
		if (rfctl->channel_set[i].ChannelNum == 1)
			index_24G = i;
		if (rfctl->channel_set[i].ChannelNum == 36)
			index_5G = i;
	}

	for (i = 0; i < rfctl->max_chan_nums && rfctl->channel_set[i].ChannelNum != 0; i++) {
		/* 2.4G */
		if (rfctl->channel_set[i].ChannelNum == 6 || rfctl->channel_set[i].ChannelNum == 11) {
			if (rfctl->channel_set[i].rx_count < rfctl->channel_set[index_24G].rx_count) {
				index_24G = i;
				best_channel_24G = rfctl->channel_set[i].ChannelNum;
			}
		}

		/* 5G */
		if (rfctl->channel_set[i].ChannelNum >= 36
		    && rfctl->channel_set[i].ChannelNum < 140) {
			/* Find primary channel */
			if (((rfctl->channel_set[i].ChannelNum - 36) % 8 == 0)
			    && (rfctl->channel_set[i].rx_count < rfctl->channel_set[index_5G].rx_count)) {
				index_5G = i;
				best_channel_5G = rfctl->channel_set[i].ChannelNum;
			}
		}

		if (rfctl->channel_set[i].ChannelNum >= 149
		    && rfctl->channel_set[i].ChannelNum < 165) {
			/* Find primary channel */
			if (((rfctl->channel_set[i].ChannelNum - 149) % 8 == 0)
			    && (rfctl->channel_set[i].rx_count < rfctl->channel_set[index_5G].rx_count)) {
				index_5G = i;
				best_channel_5G = rfctl->channel_set[i].ChannelNum;
			}
		}
#if 1 /* debug */
		RTW_INFO("The rx cnt of channel %3d = %d\n",
			 rfctl->channel_set[i].ChannelNum,
			 rfctl->channel_set[i].rx_count);
#endif
	}

	sprintf(extra, "\nbest_channel_24G = %d\n", best_channel_24G);
	RTW_INFO("best_channel_24G = %d\n", best_channel_24G);

	if (index_5G != 0) {
		sprintf(extra, "best_channel_5G = %d\n", best_channel_5G);
		RTW_INFO("best_channel_5G = %d\n", best_channel_5G);
	}

	wrqu->data.length = strlen(extra);

#endif

	return 0;

}
#endif /*#ifdef CONFIG_TDLS*/
static int rtw_tdls(struct net_device *dev,
		    struct iw_request_info *info,
		    union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);

	RTW_INFO("[%s] extra = %s\n", __FUNCTION__, extra);

	if (hal_chk_wl_func(padapter, WL_FUNC_TDLS) == _FALSE) {
		RTW_INFO("Discard tdls oper since hal doesn't support tdls\n");
		return 0;
	}

	if (rtw_is_tdls_enabled(padapter) == _FALSE) {
		RTW_INFO("TDLS is not enabled\n");
		return 0;
	}

	/* WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now! */

	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
		if (_rtw_memcmp(extra, "wfdenable=", 10)) {
			wrqu->data.length -= 10;
			rtw_wx_tdls_wfd_enable(dev, info, wrqu, &extra[10]);
			return ret;
		}
	}

	if (_rtw_memcmp(extra, "weaksec=", 8)) {
		wrqu->data.length -= 8;
		rtw_tdls_weaksec(dev, info, wrqu, &extra[8]);
		return ret;
	} else if (_rtw_memcmp(extra, "tdlsenable=", 11)) {
		wrqu->data.length -= 11;
		rtw_tdls_enable(dev, info, wrqu, &extra[11]);
		return ret;
	}

	if (_rtw_memcmp(extra, "setup=", 6)) {
		wrqu->data.length -= 6;
		rtw_tdls_setup(dev, info, wrqu, &extra[6]);
	} else if (_rtw_memcmp(extra, "tear=", 5)) {
		wrqu->data.length -= 5;
		rtw_tdls_teardown(dev, info, wrqu, &extra[5]);
	} else if (_rtw_memcmp(extra, "dis=", 4)) {
		wrqu->data.length -= 4;
		rtw_tdls_discovery(dev, info, wrqu, &extra[4]);
	} else if (_rtw_memcmp(extra, "swoff=", 6)) {
		wrqu->data.length -= 6;
		rtw_tdls_ch_switch_off(dev, info, wrqu, &extra[6]);
	} else if (_rtw_memcmp(extra, "sw=", 3)) {
		wrqu->data.length -= 3;
		rtw_tdls_ch_switch(dev, info, wrqu, &extra[3]);
	} else if (_rtw_memcmp(extra, "dumpstack=", 10)) {
		wrqu->data.length -= 10;
		rtw_tdls_dump_ch(dev, info, wrqu, &extra[10]);
	} else if (_rtw_memcmp(extra, "offchnum=", 9)) {
		wrqu->data.length -= 9;
		rtw_tdls_off_ch_num(dev, info, wrqu, &extra[9]);
	} else if (_rtw_memcmp(extra, "choffset=", 9)) {
		wrqu->data.length -= 9;
		rtw_tdls_ch_offset(dev, info, wrqu, &extra[9]);
	} else if (_rtw_memcmp(extra, "pson=", 5)) {
		wrqu->data.length -= 5;
		rtw_tdls_pson(dev, info, wrqu, &extra[5]);
	} else if (_rtw_memcmp(extra, "psoff=", 6)) {
		wrqu->data.length -= 6;
		rtw_tdls_psoff(dev, info, wrqu, &extra[6]);
	}

#ifdef CONFIG_WFD
	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
		if (_rtw_memcmp(extra, "setip=", 6)) {
			wrqu->data.length -= 6;
			rtw_tdls_setip(dev, info, wrqu, &extra[6]);
		} else if (_rtw_memcmp(extra, "tprobe=", 6))
			issue_tunneled_probe_req((_adapter *)rtw_netdev_priv(dev));
	}
#endif /* CONFIG_WFD */

#endif /* CONFIG_TDLS */

	return ret;
}


static int rtw_tdls_get(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wrqu, char *extra)
{
	int ret = 0;

#ifdef CONFIG_TDLS

	RTW_INFO("[%s] extra = %s\n", __FUNCTION__, (char *) wrqu->data.pointer);

	if (_rtw_memcmp(wrqu->data.pointer, "ip", 2))
		rtw_tdls_getip(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "port", 4))
		rtw_tdls_getport(dev, info, wrqu, extra);
	/* WFDTDLS, for sigma test */
	else if (_rtw_memcmp(wrqu->data.pointer, "dis", 3))
		rtw_tdls_dis_result(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "status", 6))
		rtw_wfd_tdls_status(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "tdls_sta=", 9))
		rtw_tdls_getsta(dev, info, wrqu, extra);
	else if (_rtw_memcmp(wrqu->data.pointer, "best_ch", 7))
		rtw_tdls_get_best_ch(dev, info, wrqu, extra);
#endif /* CONFIG_TDLS */

	return ret;
}

#ifdef CONFIG_MAC_LOOPBACK_DRIVER

#if defined(CONFIG_RTL8188E)
#include <rtl8188e_hal.h>
extern void rtl8188e_cal_txdesc_chksum(struct tx_desc *ptxdesc);
#define cal_txdesc_chksum rtl8188e_cal_txdesc_chksum
#ifdef CONFIG_SDIO_HCI || defined(CONFIG_GSPI_HCI)
extern void rtl8188es_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
#define fill_default_txdesc rtl8188es_fill_default_txdesc
#endif /* CONFIG_SDIO_HCI */
#endif /* CONFIG_RTL8188E */
#if defined(CONFIG_RTL8723B)
extern void rtl8723b_cal_txdesc_chksum(struct tx_desc *ptxdesc);
#define cal_txdesc_chksum rtl8723b_cal_txdesc_chksum
extern void rtl8723b_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
#define fill_default_txdesc rtl8723b_fill_default_txdesc
#endif /* CONFIG_RTL8723B */

#if defined(CONFIG_RTL8703B)
/* extern void rtl8703b_cal_txdesc_chksum(struct tx_desc *ptxdesc); */
#define cal_txdesc_chksum rtl8703b_cal_txdesc_chksum
/* extern void rtl8703b_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf); */
#define fill_default_txdesc rtl8703b_fill_default_txdesc
#endif /* CONFIG_RTL8703B */

#if defined(CONFIG_RTL8723D)
/* extern void rtl8723d_cal_txdesc_chksum(struct tx_desc *ptxdesc); */
#define cal_txdesc_chksum rtl8723d_cal_txdesc_chksum
/* extern void rtl8723d_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf); */
#define fill_default_txdesc rtl8723d_fill_default_txdesc
#endif /* CONFIG_RTL8723D */

#if defined(CONFIG_RTL8710B)
#define cal_txdesc_chksum rtl8710b_cal_txdesc_chksum
#define fill_default_txdesc rtl8710b_fill_default_txdesc
#endif /* CONFIG_RTL8710B */

#if defined(CONFIG_RTL8192E)
extern void rtl8192e_cal_txdesc_chksum(struct tx_desc *ptxdesc);
#define cal_txdesc_chksum rtl8192e_cal_txdesc_chksum
#ifdef CONFIG_SDIO_HCI || defined(CONFIG_GSPI_HCI)
extern void rtl8192es_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
#define fill_default_txdesc rtl8192es_fill_default_txdesc
#endif /* CONFIG_SDIO_HCI */
#endif /* CONFIG_RTL8192E */

#if defined(CONFIG_RTL8192F)
/* extern void rtl8192f_cal_txdesc_chksum(struct tx_desc *ptxdesc); */
#define cal_txdesc_chksum rtl8192f_cal_txdesc_chksum
/* extern void rtl8192f_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf); */
#define fill_default_txdesc rtl8192f_fill_default_txdesc
#endif /* CONFIG_RTL8192F */

static s32 initLoopback(PADAPTER padapter)
{
	PLOOPBACKDATA ploopback;


	if (padapter->ploopback == NULL) {
		ploopback = (PLOOPBACKDATA)rtw_zmalloc(sizeof(LOOPBACKDATA));
		if (ploopback == NULL)
			return -ENOMEM;

		_rtw_init_sema(&ploopback->sema, 0);
		ploopback->bstop = _TRUE;
		ploopback->cnt = 0;
		ploopback->size = 300;
		_rtw_memset(ploopback->msg, 0, sizeof(ploopback->msg));

		padapter->ploopback = ploopback;
	}

	return 0;
}

static void freeLoopback(PADAPTER padapter)
{
	PLOOPBACKDATA ploopback;


	ploopback = padapter->ploopback;
	if (ploopback) {
		rtw_mfree((u8 *)ploopback, sizeof(LOOPBACKDATA));
		padapter->ploopback = NULL;
	}
}

static s32 initpseudoadhoc(PADAPTER padapter)
{
	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
	s32 err;

	networkType = Ndis802_11IBSS;
	err = rtw_set_802_11_infrastructure_mode(padapter, networkType, 0);
	if (err == _FALSE)
		return _FAIL;

	err = rtw_setopmode_cmd(padapter, networkType, RTW_CMDF_WAIT_ACK);
	if (err == _FAIL)
		return _FAIL;

	return _SUCCESS;
}

static s32 createpseudoadhoc(PADAPTER padapter)
{
	NDIS_802_11_AUTHENTICATION_MODE authmode;
	struct mlme_priv *pmlmepriv;
	NDIS_802_11_SSID *passoc_ssid;
	WLAN_BSSID_EX *pdev_network;
	u8 *pibss;
	u8 ssid[] = "pseduo_ad-hoc";
	s32 err;
	_irqL irqL;


	pmlmepriv = &padapter->mlmepriv;

	authmode = Ndis802_11AuthModeOpen;
	err = rtw_set_802_11_authentication_mode(padapter, authmode);
	if (err == _FALSE)
		return _FAIL;

	passoc_ssid = &pmlmepriv->assoc_ssid;
	_rtw_memset(passoc_ssid, 0, sizeof(NDIS_802_11_SSID));
	passoc_ssid->SsidLength = sizeof(ssid) - 1;
	_rtw_memcpy(passoc_ssid->Ssid, ssid, passoc_ssid->SsidLength);

	pdev_network = &padapter->registrypriv.dev_network;
	pibss = padapter->registrypriv.dev_network.MacAddress;
	_rtw_memcpy(&pdev_network->Ssid, passoc_ssid, sizeof(NDIS_802_11_SSID));

	rtw_update_registrypriv_dev_network(padapter);
	rtw_generate_random_ibss(pibss);

	_enter_critical_bh(&pmlmepriv->lock, &irqL);
	/*pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;*/
	init_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);

	_exit_critical_bh(&pmlmepriv->lock, &irqL);

#if 0
	err = rtw_create_ibss_cmd(padapter, 0);
	if (err == _FAIL)
		return _FAIL;
#else
	{
		struct wlan_network *pcur_network;
		struct sta_info *psta;

		/* 3  create a new psta */
		pcur_network = &pmlmepriv->cur_network;

		/* clear psta in the cur_network, if any */
		psta = rtw_get_stainfo(&padapter->stapriv, pcur_network->network.MacAddress);
		if (psta)
			rtw_free_stainfo(padapter, psta);

		psta = rtw_alloc_stainfo(&padapter->stapriv, pibss);
		if (psta == NULL)
			return _FAIL;

		/* 3  join psudo AdHoc */
		pcur_network->join_res = 1;
		pcur_network->aid = psta->cmn.aid = 1;
		_rtw_memcpy(&pcur_network->network, pdev_network, get_WLAN_BSSID_EX_sz(pdev_network));

		/* set msr to WIFI_FW_ADHOC_STATE */
		padapter->hw_port = HW_PORT0;
		Set_MSR(padapter, WIFI_FW_ADHOC_STATE);

	}
#endif

	return _SUCCESS;
}

static struct xmit_frame *createloopbackpkt(PADAPTER padapter, u32 size)
{
	struct xmit_priv *pxmitpriv;
	struct xmit_frame *pframe;
	struct xmit_buf *pxmitbuf;
	struct pkt_attrib *pattrib;
	struct tx_desc *desc;
	u8 *pkt_start, *pkt_end, *ptr;
	struct rtw_ieee80211_hdr *hdr;
	s32 bmcast;
	_irqL irqL;


	if ((TXDESC_SIZE + WLANHDR_OFFSET + size) > MAX_XMITBUF_SZ)
		return NULL;

	pxmitpriv = &padapter->xmitpriv;
	pframe = NULL;

	/* 2 1. allocate xmit frame */
	pframe = rtw_alloc_xmitframe(pxmitpriv);
	if (pframe == NULL)
		return NULL;
	pframe->padapter = padapter;

	/* 2 2. allocate xmit buffer */
	_enter_critical_bh(&pxmitpriv->lock, &irqL);
	pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
	_exit_critical_bh(&pxmitpriv->lock, &irqL);
	if (pxmitbuf == NULL) {
		rtw_free_xmitframe(pxmitpriv, pframe);
		return NULL;
	}

	pframe->pxmitbuf = pxmitbuf;
	pframe->buf_addr = pxmitbuf->pbuf;
	pxmitbuf->priv_data = pframe;

	/* 2 3. update_attrib() */
	pattrib = &pframe->attrib;

	/* init xmitframe attribute */
	_rtw_memset(pattrib, 0, sizeof(struct pkt_attrib));

	pattrib->ether_type = 0x8723;
	_rtw_memcpy(pattrib->src, adapter_mac_addr(padapter), ETH_ALEN);
	_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
	_rtw_memset(pattrib->dst, 0xFF, ETH_ALEN);
	_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);

	/*	pattrib->dhcp_pkt = 0;
	 *	pattrib->pktlen = 0; */
	pattrib->ack_policy = 0;
	/*	pattrib->pkt_hdrlen = ETH_HLEN; */
	pattrib->hdrlen = WLAN_HDR_A3_LEN;
	pattrib->subtype = WIFI_DATA;
	pattrib->priority = 0;
	pattrib->qsel = pattrib->priority;
	/*	do_queue_select(padapter, pattrib); */
	pattrib->nr_frags = 1;
	pattrib->encrypt = 0;
	pattrib->bswenc = _FALSE;
	pattrib->qos_en = _FALSE;

	bmcast = IS_MCAST(pattrib->ra);
	if (bmcast)
		pattrib->psta = rtw_get_bcmc_stainfo(padapter);
	else
		pattrib->psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));

	pattrib->mac_id = pattrib->psta->cmn.mac_id;
	pattrib->pktlen = size;
	pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->pktlen;

	/* 2 4. fill TX descriptor */
	desc = (struct tx_desc *)pframe->buf_addr;
	_rtw_memset(desc, 0, TXDESC_SIZE);

	fill_default_txdesc(pframe, (u8 *)desc);

	/* Hw set sequence number */
	((PTXDESC)desc)->hwseq_en = 0; /* HWSEQ_EN, 0:disable, 1:enable
 * ((PTXDESC)desc)->hwseq_sel = 0;  */ /* HWSEQ_SEL */

	((PTXDESC)desc)->disdatafb = 1;

	/* convert to little endian */
	desc->txdw0 = cpu_to_le32(desc->txdw0);
	desc->txdw1 = cpu_to_le32(desc->txdw1);
	desc->txdw2 = cpu_to_le32(desc->txdw2);
	desc->txdw3 = cpu_to_le32(desc->txdw3);
	desc->txdw4 = cpu_to_le32(desc->txdw4);
	desc->txdw5 = cpu_to_le32(desc->txdw5);
	desc->txdw6 = cpu_to_le32(desc->txdw6);
	desc->txdw7 = cpu_to_le32(desc->txdw7);
#ifdef CONFIG_PCI_HCI
	desc->txdw8 = cpu_to_le32(desc->txdw8);
	desc->txdw9 = cpu_to_le32(desc->txdw9);
	desc->txdw10 = cpu_to_le32(desc->txdw10);
	desc->txdw11 = cpu_to_le32(desc->txdw11);
	desc->txdw12 = cpu_to_le32(desc->txdw12);
	desc->txdw13 = cpu_to_le32(desc->txdw13);
	desc->txdw14 = cpu_to_le32(desc->txdw14);
	desc->txdw15 = cpu_to_le32(desc->txdw15);
#endif

	cal_txdesc_chksum(desc);

	/* 2 5. coalesce */
	pkt_start = pframe->buf_addr + TXDESC_SIZE;
	pkt_end = pkt_start + pattrib->last_txcmdsz;

	/* 3 5.1. make wlan header, make_wlanhdr() */
	hdr = (struct rtw_ieee80211_hdr *)pkt_start;
	set_frame_sub_type(&hdr->frame_ctl, pattrib->subtype);
	_rtw_memcpy(hdr->addr1, pattrib->dst, ETH_ALEN); /* DA */
	_rtw_memcpy(hdr->addr2, pattrib->src, ETH_ALEN); /* SA */
	_rtw_memcpy(hdr->addr3, get_bssid(&padapter->mlmepriv), ETH_ALEN); /* RA, BSSID */

	/* 3 5.2. make payload */
	ptr = pkt_start + pattrib->hdrlen;
	get_random_bytes(ptr, pkt_end - ptr);

	pxmitbuf->len = TXDESC_SIZE + pattrib->last_txcmdsz;
	pxmitbuf->ptail += pxmitbuf->len;

	return pframe;
}

static void freeloopbackpkt(PADAPTER padapter, struct xmit_frame *pframe)
{
	struct xmit_priv *pxmitpriv;
	struct xmit_buf *pxmitbuf;


	pxmitpriv = &padapter->xmitpriv;
	pxmitbuf = pframe->pxmitbuf;

	rtw_free_xmitframe(pxmitpriv, pframe);
	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
}

static void printdata(u8 *pbuf, u32 len)
{
	u32 i, val;


	for (i = 0; (i + 4) <= len; i += 4) {
		printk("%08X", *(u32 *)(pbuf + i));
		if ((i + 4) & 0x1F)
			printk(" ");
		else
			printk("\n");
	}

	if (i < len) {
#ifdef CONFIG_BIG_ENDIAN
		for (; i < len, i++)
			printk("%02X", pbuf + i);
#else /* CONFIG_LITTLE_ENDIAN */
#if 0
		val = 0;
		_rtw_memcpy(&val, pbuf + i, len - i);
		printk("%8X", val);
#else
		u8 str[9];
		u8 n;
		val = 0;
		n = len - i;
		_rtw_memcpy(&val, pbuf + i, n);
		sprintf(str, "%08X", val);
		n = (4 - n) * 2;
		printk("%8s", str + n);
#endif
#endif /* CONFIG_LITTLE_ENDIAN */
	}
	printk("\n");
}

static u8 pktcmp(PADAPTER padapter, u8 *txbuf, u32 txsz, u8 *rxbuf, u32 rxsz)
{
	PHAL_DATA_TYPE phal;
	struct recv_stat *prxstat;
	struct recv_stat report;
	PRXREPORT prxreport;
	u32 drvinfosize;
	u32 rxpktsize;
	u8 fcssize;
	u8 ret = _FALSE;

	prxstat = (struct recv_stat *)rxbuf;
	report.rxdw0 = le32_to_cpu(prxstat->rxdw0);
	report.rxdw1 = le32_to_cpu(prxstat->rxdw1);
	report.rxdw2 = le32_to_cpu(prxstat->rxdw2);
	report.rxdw3 = le32_to_cpu(prxstat->rxdw3);
	report.rxdw4 = le32_to_cpu(prxstat->rxdw4);
	report.rxdw5 = le32_to_cpu(prxstat->rxdw5);

	prxreport = (PRXREPORT)&report;
	drvinfosize = prxreport->drvinfosize << 3;
	rxpktsize = prxreport->pktlen;

	phal = GET_HAL_DATA(padapter);
	if (rtw_hal_rcr_check(padapter, RCR_APPFCS))
		fcssize = IEEE80211_FCS_LEN;
	else
		fcssize = 0;

	if ((txsz - TXDESC_SIZE) != (rxpktsize - fcssize)) {
		RTW_INFO("%s: ERROR! size not match tx/rx=%d/%d !\n",
			 __func__, txsz - TXDESC_SIZE, rxpktsize - fcssize);
		ret = _FALSE;
	} else {
		ret = _rtw_memcmp(txbuf + TXDESC_SIZE, \
				  rxbuf + RXDESC_SIZE + drvinfosize, \
				  txsz - TXDESC_SIZE);
		if (ret == _FALSE)
			RTW_INFO("%s: ERROR! pkt content mismatch!\n", __func__);
	}

	if (ret == _FALSE) {
		RTW_INFO("\n%s: TX PKT total=%d, desc=%d, content=%d\n",
			 __func__, txsz, TXDESC_SIZE, txsz - TXDESC_SIZE);
		RTW_INFO("%s: TX DESC size=%d\n", __func__, TXDESC_SIZE);
		printdata(txbuf, TXDESC_SIZE);
		RTW_INFO("%s: TX content size=%d\n", __func__, txsz - TXDESC_SIZE);
		printdata(txbuf + TXDESC_SIZE, txsz - TXDESC_SIZE);

		RTW_INFO("\n%s: RX PKT read=%d offset=%d(%d,%d) content=%d\n",
			__func__, rxsz, RXDESC_SIZE + drvinfosize, RXDESC_SIZE, drvinfosize, rxpktsize);
		if (rxpktsize != 0) {
			RTW_INFO("%s: RX DESC size=%d\n", __func__, RXDESC_SIZE);
			printdata(rxbuf, RXDESC_SIZE);
			RTW_INFO("%s: RX drvinfo size=%d\n", __func__, drvinfosize);
			printdata(rxbuf + RXDESC_SIZE, drvinfosize);
			RTW_INFO("%s: RX content size=%d\n", __func__, rxpktsize);
			printdata(rxbuf + RXDESC_SIZE + drvinfosize, rxpktsize);
		} else {
			RTW_INFO("%s: RX data size=%d\n", __func__, rxsz);
			printdata(rxbuf, rxsz);
		}
	}

	return ret;
}

thread_return lbk_thread(thread_context context)
{
	s32 err;
	PADAPTER padapter;
	PLOOPBACKDATA ploopback;
	struct xmit_frame *pxmitframe;
	u32 cnt, ok, fail, headerlen;
	u32 pktsize;
	u32 ff_hwaddr;


	padapter = (PADAPTER)context;
	ploopback = padapter->ploopback;
	if (ploopback == NULL)
		return -1;
	cnt = 0;
	ok = 0;
	fail = 0;

	daemonize("%s", "RTW_LBK_THREAD");
	allow_signal(SIGTERM);

	do {
		if (ploopback->size == 0) {
			get_random_bytes(&pktsize, 4);
			pktsize = (pktsize % 1535) + 1; /* 1~1535 */
		} else
			pktsize = ploopback->size;

		pxmitframe = createloopbackpkt(padapter, pktsize);
		if (pxmitframe == NULL) {
			sprintf(ploopback->msg, "loopback FAIL! 3. create Packet FAIL!");
			break;
		}

		ploopback->txsize = TXDESC_SIZE + pxmitframe->attrib.last_txcmdsz;
		_rtw_memcpy(ploopback->txbuf, pxmitframe->buf_addr, ploopback->txsize);
		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
		cnt++;
		RTW_INFO("%s: wirte port cnt=%d size=%d\n", __func__, cnt, ploopback->txsize);
		pxmitframe->pxmitbuf->pdata = ploopback->txbuf;
		rtw_write_port(padapter, ff_hwaddr, ploopback->txsize, (u8 *)pxmitframe->pxmitbuf);

		/* wait for rx pkt */
		_rtw_down_sema(&ploopback->sema);

		err = pktcmp(padapter, ploopback->txbuf, ploopback->txsize, ploopback->rxbuf, ploopback->rxsize);
		if (err == _TRUE)
			ok++;
		else
			fail++;

		ploopback->txsize = 0;
		_rtw_memset(ploopback->txbuf, 0, 0x8000);
		ploopback->rxsize = 0;
		_rtw_memset(ploopback->rxbuf, 0, 0x8000);

		freeloopbackpkt(padapter, pxmitframe);
		pxmitframe = NULL;

		flush_signals_thread();

		if ((ploopback->bstop == _TRUE) ||
		    ((ploopback->cnt != 0) && (ploopback->cnt == cnt))) {
			u32 ok_rate, fail_rate, all;
			all = cnt;
			ok_rate = (ok * 100) / all;
			fail_rate = (fail * 100) / all;
			sprintf(ploopback->msg, \
				"loopback result: ok=%d%%(%d/%d),error=%d%%(%d/%d)", \
				ok_rate, ok, all, fail_rate, fail, all);
			break;
		}
	} while (1);

	ploopback->bstop = _TRUE;

	thread_exit(NULL);
	return 0;
}

static void loopbackTest(PADAPTER padapter, u32 cnt, u32 size, u8 *pmsg)
{
	PLOOPBACKDATA ploopback;
	u32 len;
	s32 err;


	ploopback = padapter->ploopback;

	if (ploopback) {
		if (ploopback->bstop == _FALSE) {
			ploopback->bstop = _TRUE;
			_rtw_up_sema(&ploopback->sema);
		}
		len = 0;
		do {
			len = strlen(ploopback->msg);
			if (len)
				break;
			rtw_msleep_os(1);
		} while (1);
		_rtw_memcpy(pmsg, ploopback->msg, len + 1);
		freeLoopback(padapter);

		return;
	}

	/* disable dynamic algorithm	 */
	rtw_phydm_ability_backup(padapter);
	rtw_phydm_func_disable_all(padapter);

	/* create pseudo ad-hoc connection */
	err = initpseudoadhoc(padapter);
	if (err == _FAIL) {
		sprintf(pmsg, "loopback FAIL! 1.1 init ad-hoc FAIL!");
		return;
	}

	err = createpseudoadhoc(padapter);
	if (err == _FAIL) {
		sprintf(pmsg, "loopback FAIL! 1.2 create ad-hoc master FAIL!");
		return;
	}

	err = initLoopback(padapter);
	if (err) {
		sprintf(pmsg, "loopback FAIL! 2. init FAIL! error code=%d", err);
		return;
	}

	ploopback = padapter->ploopback;

	ploopback->bstop = _FALSE;
	ploopback->cnt = cnt;
	ploopback->size = size;
	ploopback->lbkthread = kthread_run(lbk_thread, padapter, "RTW_LBK_THREAD");
	if (IS_ERR(padapter->lbkthread)) {
		freeLoopback(padapter);
		ploopback->lbkthread = NULL;
		sprintf(pmsg, "loopback start FAIL! cnt=%d", cnt);
		return;
	}

	sprintf(pmsg, "loopback start! cnt=%d", cnt);
}
#endif /* CONFIG_MAC_LOOPBACK_DRIVER */

static int rtw_test(
	struct net_device *dev,
	struct iw_request_info *info,
	union iwreq_data *wrqu, char *extra)
{
	u32 len;
	u8 *pbuf, *pch;
	char *ptmp;
	u8 *delim = ",";
	PADAPTER padapter = rtw_netdev_priv(dev);


	RTW_INFO("+%s\n", __func__);
	len = wrqu->data.length;

	pbuf = (u8 *)rtw_zmalloc(len + 1);
	if (pbuf == NULL) {
		RTW_INFO("%s: no memory!\n", __func__);
		return -ENOMEM;
	}

	if (copy_from_user(pbuf, wrqu->data.pointer, len)) {
		rtw_mfree(pbuf, len + 1);
		RTW_INFO("%s: copy from user fail!\n", __func__);
		return -EFAULT;
	}

	pbuf[len] = '\0';

	RTW_INFO("%s: string=\"%s\"\n", __func__, pbuf);

	ptmp = (char *)pbuf;
	pch = strsep(&ptmp, delim);
	if ((pch == NULL) || (strlen(pch) == 0)) {
		rtw_mfree(pbuf, len);
		RTW_INFO("%s: parameter error(level 1)!\n", __func__);
		return -EFAULT;
	}

#ifdef CONFIG_MAC_LOOPBACK_DRIVER
	if (strcmp(pch, "loopback") == 0) {
		s32 cnt = 0;
		u32 size = 64;

		pch = strsep(&ptmp, delim);
		if ((pch == NULL) || (strlen(pch) == 0)) {
			rtw_mfree(pbuf, len);
			RTW_INFO("%s: parameter error(level 2)!\n", __func__);
			return -EFAULT;
		}

		sscanf(pch, "%d", &cnt);
		RTW_INFO("%s: loopback cnt=%d\n", __func__, cnt);

		pch = strsep(&ptmp, delim);
		if ((pch == NULL) || (strlen(pch) == 0)) {
			rtw_mfree(pbuf, len);
			RTW_INFO("%s: parameter error(level 2)!\n", __func__);
			return -EFAULT;
		}

		sscanf(pch, "%d", &size);
		RTW_INFO("%s: loopback size=%d\n", __func__, size);

		loopbackTest(padapter, cnt, size, extra);
		wrqu->data.length = strlen(extra) + 1;

		goto free_buf;
	}
#endif


#ifdef CONFIG_BT_COEXIST
	if (strcmp(pch, "bton") == 0) {
		rtw_btcoex_SetManualControl(padapter, _FALSE);
		goto free_buf;
	} else if (strcmp(pch, "btoff") == 0) {
		rtw_btcoex_SetManualControl(padapter, _TRUE);
		goto free_buf;
	}
#endif

	if (strcmp(pch, "h2c") == 0) {
		u8 param[8];
		u8 count = 0;
		u32 tmp;
		u8 i;
		u32 pos;
		u8 ret;

		do {
			pch = strsep(&ptmp, delim);
			if ((pch == NULL) || (strlen(pch) == 0))
				break;

			sscanf(pch, "%x", &tmp);
			param[count++] = (u8)tmp;
		} while (count < 8);

		if (count == 0) {
			rtw_mfree(pbuf, len);
			RTW_INFO("%s: parameter error(level 2)!\n", __func__);
			return -EFAULT;
		}

		ret = rtw_test_h2c_cmd(padapter, param, count);

		pos = sprintf(extra, "H2C ID=0x%02x content=", param[0]);
		for (i = 1; i < count; i++)
			pos += sprintf(extra + pos, "%02x,", param[i]);
		extra[pos] = 0;
		pos--;
		pos += sprintf(extra + pos, " %s", ret == _FAIL ? "FAIL" : "OK");

		wrqu->data.length = strlen(extra) + 1;

		goto free_buf;
	}

free_buf:
	rtw_mfree(pbuf, len);
	return 0;
}

static iw_handler rtw_handlers[] = {
	NULL,					/* SIOCSIWCOMMIT */
	rtw_wx_get_name,		/* SIOCGIWNAME */
	dummy,					/* SIOCSIWNWID */
	dummy,					/* SIOCGIWNWID */
	rtw_wx_set_freq,		/* SIOCSIWFREQ */
	rtw_wx_get_freq,		/* SIOCGIWFREQ */
	rtw_wx_set_mode,		/* SIOCSIWMODE */
	rtw_wx_get_mode,		/* SIOCGIWMODE */
	dummy,					/* SIOCSIWSENS */
	rtw_wx_get_sens,		/* SIOCGIWSENS */
	NULL,					/* SIOCSIWRANGE */
	rtw_wx_get_range,		/* SIOCGIWRANGE */
	rtw_wx_set_priv,		/* SIOCSIWPRIV */
	NULL,					/* SIOCGIWPRIV */
	NULL,					/* SIOCSIWSTATS */
	NULL,					/* SIOCGIWSTATS */
	dummy,					/* SIOCSIWSPY */
	dummy,					/* SIOCGIWSPY */
	NULL,					/* SIOCGIWTHRSPY */
	NULL,					/* SIOCWIWTHRSPY */
	rtw_wx_set_wap,		/* SIOCSIWAP */
	rtw_wx_get_wap,		/* SIOCGIWAP */
	rtw_wx_set_mlme,		/* request MLME operation; uses struct iw_mlme */
	dummy,					/* SIOCGIWAPLIST -- depricated */
	rtw_wx_set_scan,		/* SIOCSIWSCAN */
	rtw_wx_get_scan,		/* SIOCGIWSCAN */
	rtw_wx_set_essid,		/* SIOCSIWESSID */
	rtw_wx_get_essid,		/* SIOCGIWESSID */
	dummy,					/* SIOCSIWNICKN */
	rtw_wx_get_nick,		/* SIOCGIWNICKN */
	NULL,					/* -- hole -- */
	NULL,					/* -- hole -- */
	rtw_wx_set_rate,		/* SIOCSIWRATE */
	rtw_wx_get_rate,		/* SIOCGIWRATE */
	rtw_wx_set_rts,			/* SIOCSIWRTS */
	rtw_wx_get_rts,			/* SIOCGIWRTS */
	rtw_wx_set_frag,		/* SIOCSIWFRAG */
	rtw_wx_get_frag,		/* SIOCGIWFRAG */
	dummy,					/* SIOCSIWTXPOW */
	dummy,					/* SIOCGIWTXPOW */
	dummy,					/* SIOCSIWRETRY */
	rtw_wx_get_retry,		/* SIOCGIWRETRY */
	rtw_wx_set_enc,			/* SIOCSIWENCODE */
	rtw_wx_get_enc,			/* SIOCGIWENCODE */
	dummy,					/* SIOCSIWPOWER */
	rtw_wx_get_power,		/* SIOCGIWPOWER */
	NULL,					/*---hole---*/
	NULL,					/*---hole---*/
	rtw_wx_set_gen_ie,		/* SIOCSIWGENIE */
	NULL,					/* SIOCGWGENIE */
	rtw_wx_set_auth,		/* SIOCSIWAUTH */
	NULL,					/* SIOCGIWAUTH */
	rtw_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
	NULL,					/* SIOCGIWENCODEEXT */
	rtw_wx_set_pmkid,		/* SIOCSIWPMKSA */
	NULL,					/*---hole---*/
};


static const struct iw_priv_args rtw_private_args[] = {
	{
		SIOCIWFIRSTPRIV + 0x0,
		IW_PRIV_TYPE_CHAR | 0x7FF, 0, "write"
	},
	{
		SIOCIWFIRSTPRIV + 0x1,
		IW_PRIV_TYPE_CHAR | 0x7FF,
		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "read"
	},
	{
		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
	},
	{
		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
	},
	{
		SIOCIWFIRSTPRIV + 0x4,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
	},
	{
		SIOCIWFIRSTPRIV + 0x5,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "setpid"
	},
	{
		SIOCIWFIRSTPRIV + 0x6,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
	},
	/* for PLATFORM_MT53XX	 */
	{
		SIOCIWFIRSTPRIV + 0x7,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
	},
	{
		SIOCIWFIRSTPRIV + 0x8,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_prob_req_ie"
	},
	{
		SIOCIWFIRSTPRIV + 0x9,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
	},

	/* for RTK_DMP_PLATFORM	 */
	{
		SIOCIWFIRSTPRIV + 0xA,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "channel_plan"
	},

	{
		SIOCIWFIRSTPRIV + 0xB,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "dbg"
	},
	{
		SIOCIWFIRSTPRIV + 0xC,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "rfw"
	},
	{
		SIOCIWFIRSTPRIV + 0xD,
		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
	},
#if 0
	{
		SIOCIWFIRSTPRIV + 0xE, 0, 0, "wowlan_ctrl"
	},
#endif
	{
		SIOCIWFIRSTPRIV + 0x10,
		IW_PRIV_TYPE_CHAR | 1024, 0, "p2p_set"
	},
	{
		SIOCIWFIRSTPRIV + 0x11,
		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "p2p_get"
	},
	{
		SIOCIWFIRSTPRIV + 0x12, 0, 0, "NULL"
	},
	{
		SIOCIWFIRSTPRIV + 0x13,
		IW_PRIV_TYPE_CHAR | 64, IW_PRIV_TYPE_CHAR | 64 , "p2p_get2"
	},
	{
		SIOCIWFIRSTPRIV + 0x14,
		IW_PRIV_TYPE_CHAR  | 64, 0, "tdls"
	},
	{
		SIOCIWFIRSTPRIV + 0x15,
		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024 , "tdls_get"
	},
	{
		SIOCIWFIRSTPRIV + 0x16,
		IW_PRIV_TYPE_CHAR | 64, 0, "pm_set"
	},
#ifdef CONFIG_RTW_80211K
	{
		SIOCIWFIRSTPRIV + 0x17,
		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024 , "rrm"
	},
#else
	{SIOCIWFIRSTPRIV + 0x17, IW_PRIV_TYPE_CHAR | 1024 , 0 , "NULL"},
#endif
	{SIOCIWFIRSTPRIV + 0x18, IW_PRIV_TYPE_CHAR | IFNAMSIZ , 0 , "rereg_nd_name"},
#ifdef CONFIG_MP_INCLUDED
	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 1024, 0,  "NULL"},
	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "NULL"},
#else
	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 1024, 0,  "NULL"},
	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get"},
#endif
	{
		SIOCIWFIRSTPRIV + 0x1D,
		IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 0x7FF, "test"
	},

	{ SIOCIWFIRSTPRIV + 0x0E, IW_PRIV_TYPE_CHAR | 1024, 0 , ""},  /* set  */
	{ SIOCIWFIRSTPRIV + 0x0F, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , ""},/* get
 * --- sub-ioctls definitions --- */

#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
	{ VENDOR_IE_SET, IW_PRIV_TYPE_CHAR | 1024 , 0 , "vendor_ie_set" },
	{ VENDOR_IE_GET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "vendor_ie_get" },
#endif
#if defined(CONFIG_RTL8723B)
	{ MP_SetBT, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_setbt" },
	{ MP_DISABLE_BT_COEXIST, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_disa_btcoex"},
#endif
#ifdef CONFIG_WOWLAN
	{ MP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "wow_mode" },
	{ MP_WOW_SET_PATTERN , IW_PRIV_TYPE_CHAR | 1024, 0, "wow_set_pattern" },
#endif
#ifdef CONFIG_AP_WOWLAN
	{ MP_AP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "ap_wow_mode" }, /* set  */
#endif
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
	{ MP_SD_IREAD, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "sd_iread" },
	{ MP_SD_IWRITE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "sd_iwrite" },
#endif
};


static const struct iw_priv_args rtw_mp_private_args[] = {
	/* --- sub-ioctls definitions --- */
#ifdef CONFIG_MP_INCLUDED
	{ MP_START , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_start" },
	{ MP_PHYPARA, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_phypara" },
	{ MP_STOP , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_stop" },
	{ MP_CHANNEL , IW_PRIV_TYPE_CHAR | 1024 , IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_channel" },
	{ MP_CHL_OFFSET , IW_PRIV_TYPE_CHAR | 1024 , IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ch_offset" },
	{ MP_BANDWIDTH , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_bandwidth"},
	{ MP_RATE , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rate" },
	{ MP_RESET_STATS , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_reset_stats"},
	{ MP_QUERY , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "mp_query"},
	{ READ_REG , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_reg" },
	{ MP_RATE , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rate" },
	{ READ_RF , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_rf" },
	{ MP_PSD , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_psd"},
	{ MP_DUMP, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_dump" },
	{ MP_TXPOWER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_txpower"},
	{ MP_ANT_TX , IW_PRIV_TYPE_CHAR | 1024,  IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ant_tx"},
	{ MP_ANT_RX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ant_rx"},
	{ WRITE_REG , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "write_reg" },
	{ WRITE_RF , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "write_rf" },
	{ MP_CTX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ctx"},
	{ MP_ARX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_arx"},
	{ MP_THER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ther"},
	{ EFUSE_SET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_set" },
	{ EFUSE_GET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get" },
	{ MP_PWRTRK , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrtrk"},
	{ MP_QueryDrvStats, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_drvquery" },
	{ MP_IOCTL, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ioctl"},
	{ MP_SetRFPathSwh, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_setrfpath" },
	{ MP_PwrCtlDM, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrctldm" },
	{ MP_GET_TXPOWER_INX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_get_txpower" },
	{ MP_GETVER, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_priv_ver" },
	{ MP_MON, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_mon" },
	{ EFUSE_BT_MASK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_bt_mask" },
	{ EFUSE_MASK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_mask" },
	{ EFUSE_FILE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_file" },
	{ MP_TX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_tx" },
	{ MP_RX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rx" },
	{ MP_HW_TX_MODE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_hxtx" },
	{ MP_PWRLMT, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrlmt" },
	{ MP_PWRBYRATE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrbyrate" },
	{ CTA_TEST, IW_PRIV_TYPE_CHAR | 1024, 0, "cta_test"},
	{ MP_IQK, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_iqk"},
	{ MP_LCK, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_lck"},
	{ BT_EFUSE_FILE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "bt_efuse_file" },
	{ MP_SWRFPath, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_swrfpath" },
	{ MP_LINK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_link" },
	{ MP_DPK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_dpk"},
	{ MP_DPK_TRK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_dpk_trk" },
#ifdef CONFIG_RTW_CUSTOMER_STR
	{ MP_CUSTOMER_STR, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "customer_str" },
#endif

#endif /* CONFIG_MP_INCLUDED */
};

static iw_handler rtw_private_handler[] = {
	rtw_wx_write32,					/* 0x00 */
	rtw_wx_read32,					/* 0x01 */
	NULL,					/* 0x02 */
#ifdef MP_IOCTL_HDL
	rtw_mp_ioctl_hdl,				/* 0x03 */
#else
	rtw_wx_priv_null,
#endif
	/* for MM DTV platform */
	rtw_get_ap_info,					/* 0x04 */

	rtw_set_pid,						/* 0x05 */
	rtw_wps_start,					/* 0x06 */

	/* for PLATFORM_MT53XX */
	rtw_wx_get_sensitivity,			/* 0x07 */
	rtw_wx_set_mtk_wps_probe_ie,	/* 0x08 */
	rtw_wx_set_mtk_wps_ie,			/* 0x09 */

	/* for RTK_DMP_PLATFORM
	 * Set Channel depend on the country code */
	rtw_wx_set_channel_plan,		/* 0x0A */

	rtw_dbg_port,					/* 0x0B */
	rtw_wx_write_rf,					/* 0x0C */
	rtw_wx_read_rf,					/* 0x0D */

	rtw_priv_set,					/*0x0E*/
	rtw_priv_get,					/*0x0F*/

	rtw_p2p_set,					/* 0x10 */
	rtw_p2p_get,					/* 0x11 */
	NULL,							/* 0x12 */
	rtw_p2p_get2,					/* 0x13 */

	rtw_tdls,						/* 0x14 */
	rtw_tdls_get,					/* 0x15 */

	rtw_pm_set,						/* 0x16 */
#ifdef CONFIG_RTW_80211K
	rtw_wx_priv_rrm,				/* 0x17 */
#else
	rtw_wx_priv_null,				/* 0x17 */
#endif
	rtw_rereg_nd_name,				/* 0x18 */
	rtw_wx_priv_null,				/* 0x19 */
#ifdef CONFIG_MP_INCLUDED
	rtw_wx_priv_null,				/* 0x1A */
	rtw_wx_priv_null,				/* 0x1B */
#else
	rtw_wx_priv_null,				/* 0x1A */
	rtw_mp_efuse_get,				/* 0x1B */
#endif
	NULL,							/* 0x1C is reserved for hostapd */
	rtw_test,						/* 0x1D */
};

#if WIRELESS_EXT >= 17
static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
{
	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
	struct iw_statistics *piwstats = &padapter->iwstats;
	int tmp_level = 0;
	int tmp_qual = 0;
	int tmp_noise = 0;

	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != _TRUE) {
		piwstats->qual.qual = 0;
		piwstats->qual.level = 0;
		piwstats->qual.noise = 0;
		/* RTW_INFO("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise); */
	} else {
#ifdef CONFIG_SIGNAL_DISPLAY_DBM
		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
#else
		tmp_level = padapter->recvpriv.signal_strength;
#endif

		tmp_qual = padapter->recvpriv.signal_qual;
		#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
		if (IS_NM_ENABLE(padapter)) {
			tmp_noise = rtw_noise_measure_curchan(padapter);
			#ifndef CONFIG_SIGNAL_DISPLAY_DBM
			tmp_noise = translate_dbm_to_percentage(tmp_noise);/*percentage*/
			#endif
		}
		#endif
		/* RTW_INFO("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi); */

		piwstats->qual.level = tmp_level;
		piwstats->qual.qual = tmp_qual;
		piwstats->qual.noise = tmp_noise;
	}
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14))
	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;/* |IW_QUAL_DBM; */
#else
#ifdef RTK_DMP_PLATFORM
	/* IW_QUAL_DBM= 0x8, if driver use this flag, wireless extension will show value of dbm. */
	/* remove this flag for show percentage 0~100 */
	piwstats->qual.updated = 0x07;
#else
	piwstats->qual.updated = 0x0f;
#endif
#endif

#ifdef CONFIG_SIGNAL_DISPLAY_DBM
	piwstats->qual.updated = piwstats->qual.updated | IW_QUAL_DBM;
#endif

	return &padapter->iwstats;
}
#endif

#ifdef CONFIG_WIRELESS_EXT
struct iw_handler_def rtw_handlers_def = {
	.standard = rtw_handlers,
	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)) || defined(CONFIG_WEXT_PRIV)
	.private = rtw_private_handler,
	.private_args = (struct iw_priv_args *)rtw_private_args,
	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
#endif
#if WIRELESS_EXT >= 17
	.get_wireless_stats = rtw_get_wireless_stats,
#endif
};
#endif

/* copy from net/wireless/wext.c start
 * ----------------------------------------------------------------
 *
 * Calculate size of private arguments
 */
static const char iw_priv_type_size[] = {
	0,                              /* IW_PRIV_TYPE_NONE */
	1,                              /* IW_PRIV_TYPE_BYTE */
	1,                              /* IW_PRIV_TYPE_CHAR */
	0,                              /* Not defined */
	sizeof(__u32),                  /* IW_PRIV_TYPE_INT */
	sizeof(struct iw_freq),         /* IW_PRIV_TYPE_FLOAT */
	sizeof(struct sockaddr),        /* IW_PRIV_TYPE_ADDR */
	0,                              /* Not defined */
};

static int get_priv_size(__u16 args)
{
	int num = args & IW_PRIV_SIZE_MASK;
	int type = (args & IW_PRIV_TYPE_MASK) >> 12;

	return num * iw_priv_type_size[type];
}
/* copy from net/wireless/wext.c end */


static int _rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_data)
{
	int err = 0;
	u8 *input = NULL;
	u32 input_len = 0;
	const char delim[] = " ";
	u8 *output = NULL;
	u32 output_len = 0;
	u32 count = 0;
	u8 *buffer = NULL;
	u32 buffer_len = 0;
	char *ptr = NULL;
	u8 cmdname[17] = {0}; /* IFNAMSIZ+1 */
	u32 cmdlen;
	s32 len;
	u8 *extra = NULL;
	u32 extra_size = 0;

	s32 k;
	const iw_handler *priv;		/* Private ioctl */
	const struct iw_priv_args *priv_args;	/* Private ioctl description */
	const struct iw_priv_args *mp_priv_args;	/*MP Private ioctl description */
	const struct iw_priv_args *sel_priv_args;	/*Selected Private ioctl description */
	u32 num_priv;				/* Number of ioctl */
	u32 num_priv_args;			/* Number of descriptions */
	u32 num_mp_priv_args;			/*Number of MP descriptions */
	u32 num_sel_priv_args;			/*Number of Selected descriptions */
	iw_handler handler;
	int temp;
	int subcmd = 0;				/* sub-ioctl index */
	int offset = 0;				/* Space for sub-ioctl index */

	union iwreq_data wdata;

	_rtw_memcpy(&wdata, wrq_data, sizeof(wdata));

	input_len = wdata.data.length;
	if (!input_len)
		return -EINVAL;
	input = rtw_zmalloc(input_len);

	if (input == NULL) {
		err = -EOPNOTSUPP;
		goto exit;
	}

	if (copy_from_user(input, wdata.data.pointer, input_len)) {
		err = -EFAULT;
		goto exit;
	}
	input[input_len - 1] = '\0';
	ptr = input;
	len = input_len;

	sscanf(ptr, "%16s", cmdname);
	cmdlen = strlen(cmdname);
	RTW_DBG("%s: cmd=%s\n", __func__, cmdname);

	/* skip command string */
	if (cmdlen > 0)
		cmdlen += 1; /* skip one space */
	ptr += cmdlen;
	len -= cmdlen;
	RTW_DBG("%s: parameters=%s\n", __func__, ptr);

	priv = rtw_private_handler;
	priv_args = rtw_private_args;
	mp_priv_args = rtw_mp_private_args;
	num_priv = sizeof(rtw_private_handler) / sizeof(iw_handler);
	num_priv_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args);
	num_mp_priv_args = sizeof(rtw_mp_private_args) / sizeof(struct iw_priv_args);

	if (num_priv_args == 0) {
		err = -EOPNOTSUPP;
		goto exit;
	}

	/* Search the correct ioctl */
	k = -1;
	sel_priv_args = priv_args;
	num_sel_priv_args = num_priv_args;
	while
	((++k < num_sel_priv_args) && strcmp(sel_priv_args[k].name, cmdname))
		;

	/* If not found... */
	if (k == num_sel_priv_args) {
		k = -1;
		sel_priv_args = mp_priv_args;
		num_sel_priv_args = num_mp_priv_args;
		while
		((++k < num_sel_priv_args) && strcmp(sel_priv_args[k].name, cmdname))
			;

		if (k == num_sel_priv_args) {
			err = -EOPNOTSUPP;
			goto exit;
		}
	}

	/* Watch out for sub-ioctls ! */
	if (sel_priv_args[k].cmd < SIOCDEVPRIVATE) {
		int j = -1;

		/* Find the matching *real* ioctl */
		while ((++j < num_priv_args) && ((priv_args[j].name[0] != '\0') ||
			 (priv_args[j].set_args != sel_priv_args[k].set_args) ||
			 (priv_args[j].get_args != sel_priv_args[k].get_args)))
			;

		/* If not found... */
		if (j == num_priv_args) {
			err = -EINVAL;
			goto exit;
		}

		/* Save sub-ioctl number */
		subcmd = sel_priv_args[k].cmd;
		/* Reserve one int (simplify alignment issues) */
		offset = sizeof(__u32);
		/* Use real ioctl definition from now on */
		k = j;
	}

	buffer = rtw_zmalloc(4096);
	if (NULL == buffer) {
		err = -ENOMEM;
		goto exit;
	}

	if (k >= num_priv_args) {
		err = -EINVAL;
		goto exit;
	}

	/* If we have to set some data */
	if ((priv_args[k].set_args & IW_PRIV_TYPE_MASK) &&
	    (priv_args[k].set_args & IW_PRIV_SIZE_MASK)) {
		u8 *str;

		switch (priv_args[k].set_args & IW_PRIV_TYPE_MASK) {
		case IW_PRIV_TYPE_BYTE:
			/* Fetch args */
			count = 0;
			do {
				str = strsep(&ptr, delim);
				if (NULL == str)
					break;
				sscanf(str, "%i", &temp);
				buffer[count++] = (u8)temp;
			} while (1);
			buffer_len = count;

			/* Number of args to fetch */
			wdata.data.length = count;
			if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
				wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;

			break;

		case IW_PRIV_TYPE_INT:
			/* Fetch args */
			count = 0;
			do {
				str = strsep(&ptr, delim);
				if (NULL == str)
					break;
				sscanf(str, "%i", &temp);
				((s32 *)buffer)[count++] = (s32)temp;
			} while (1);
			buffer_len = count * sizeof(s32);

			/* Number of args to fetch */
			wdata.data.length = count;
			if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
				wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;

			break;

		case IW_PRIV_TYPE_CHAR:
			if (len > 0) {
				/* Size of the string to fetch */
				wdata.data.length = len;
				if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
					wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;

				/* Fetch string */
				_rtw_memcpy(buffer, ptr, wdata.data.length);
			} else {
				wdata.data.length = 1;
				buffer[0] = '\0';
			}
			buffer_len = wdata.data.length;
			break;

		default:
			RTW_INFO("%s: Not yet implemented...\n", __func__);
			err = -1;
			goto exit;
		}

		if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
		    (wdata.data.length != (priv_args[k].set_args & IW_PRIV_SIZE_MASK))) {
			RTW_INFO("%s: The command %s needs exactly %d argument(s)...\n",
				__func__, cmdname, priv_args[k].set_args & IW_PRIV_SIZE_MASK);
			err = -EINVAL;
			goto exit;
		}
	}   /* if args to set */
	else
		wdata.data.length = 0L;

	/* Those two tests are important. They define how the driver
	* will have to handle the data */
	if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
	    ((get_priv_size(priv_args[k].set_args) + offset) <= IFNAMSIZ)) {
		/* First case : all SET args fit within wrq */
		if (offset)
			wdata.mode = subcmd;
		_rtw_memcpy(wdata.name + offset, buffer, IFNAMSIZ - offset);
	} else {
		if ((priv_args[k].set_args == 0) &&
		    (priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
		    (get_priv_size(priv_args[k].get_args) <= IFNAMSIZ)) {
			/* Second case : no SET args, GET args fit within wrq */
			if (offset)
				wdata.mode = subcmd;
		} else {
			/* Third case : args won't fit in wrq, or variable number of args */
			if (copy_to_user(wdata.data.pointer, buffer, buffer_len)) {
				err = -EFAULT;
				goto exit;
			}
			wdata.data.flags = subcmd;
		}
	}

	rtw_mfree(input, input_len);
	input = NULL;

	extra_size = 0;
	if (IW_IS_SET(priv_args[k].cmd)) {
		/* Size of set arguments */
		extra_size = get_priv_size(priv_args[k].set_args);

		/* Does it fits in iwr ? */
		if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
		    ((extra_size + offset) <= IFNAMSIZ))
			extra_size = 0;
	} else {
		/* Size of get arguments */
		extra_size = get_priv_size(priv_args[k].get_args);

		/* Does it fits in iwr ? */
		if ((priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
		    (extra_size <= IFNAMSIZ))
			extra_size = 0;
	}

	if (extra_size == 0) {
		extra = (u8 *)&wdata;
		rtw_mfree(buffer, 4096);
		buffer = NULL;
	} else
		extra = buffer;

	handler = priv[priv_args[k].cmd - SIOCIWFIRSTPRIV];
	err = handler(dev, NULL, &wdata, extra);

	/* If we have to get some data */
	if ((priv_args[k].get_args & IW_PRIV_TYPE_MASK) &&
	    (priv_args[k].get_args & IW_PRIV_SIZE_MASK)) {
		int j;
		int n = 0;	/* number of args */
		u8 str[20] = {0};

		/* Check where is the returned data */
		if ((priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
		    (get_priv_size(priv_args[k].get_args) <= IFNAMSIZ))
			n = priv_args[k].get_args & IW_PRIV_SIZE_MASK;
		else
			n = wdata.data.length;

		output = rtw_zmalloc(4096);
		if (NULL == output) {
			err =  -ENOMEM;
			goto exit;
		}

		switch (priv_args[k].get_args & IW_PRIV_TYPE_MASK) {
		case IW_PRIV_TYPE_BYTE:
			/* Display args */
			for (j = 0; j < n; j++) {
				sprintf(str, "%d  ", extra[j]);
				len = strlen(str);
				output_len = strlen(output);
				if ((output_len + len + 1) > 4096) {
					err = -E2BIG;
					goto exit;
				}
				_rtw_memcpy(output + output_len, str, len);
			}
			break;

		case IW_PRIV_TYPE_INT:
			/* Display args */
			for (j = 0; j < n; j++) {
				sprintf(str, "%d  ", ((__s32 *)extra)[j]);
				len = strlen(str);
				output_len = strlen(output);
				if ((output_len + len + 1) > 4096) {
					err = -E2BIG;
					goto exit;
				}
				_rtw_memcpy(output + output_len, str, len);
			}
			break;

		case IW_PRIV_TYPE_CHAR:
			/* Display args */
			_rtw_memcpy(output, extra, n);
			break;

		default:
			RTW_INFO("%s: Not yet implemented...\n", __func__);
			err = -1;
			goto exit;
		}

		output_len = strlen(output) + 1;
		wrq_data->data.length = output_len;
		if (copy_to_user(wrq_data->data.pointer, output, output_len)) {
			err = -EFAULT;
			goto exit;
		}
	}   /* if args to set */
	else
		wrq_data->data.length = 0;

exit:
	if (input)
		rtw_mfree(input, input_len);
	if (buffer)
		rtw_mfree(buffer, 4096);
	if (output)
		rtw_mfree(output, 4096);

	return err;
}

#ifdef CONFIG_COMPAT
static int rtw_ioctl_compat_wext_private(struct net_device *dev, struct ifreq *rq)
{
	struct compat_iw_point iwp_compat;
	union iwreq_data wrq_data;
	int err = 0;
	RTW_DBG("%s:...\n", __func__);
	if (copy_from_user(&iwp_compat, rq->ifr_ifru.ifru_data, sizeof(struct compat_iw_point)))
		return -EFAULT;

	wrq_data.data.pointer = compat_ptr(iwp_compat.pointer);
	wrq_data.data.length = iwp_compat.length;
	wrq_data.data.flags = iwp_compat.flags;

	err = _rtw_ioctl_wext_private(dev, &wrq_data);

	iwp_compat.pointer = ptr_to_compat(wrq_data.data.pointer);
	iwp_compat.length = wrq_data.data.length;
	iwp_compat.flags = wrq_data.data.flags;
	if (copy_to_user(rq->ifr_ifru.ifru_data, &iwp_compat, sizeof(struct compat_iw_point)))
		return -EFAULT;

	return err;
}
#endif /* CONFIG_COMPAT */

static int rtw_ioctl_standard_wext_private(struct net_device *dev, struct ifreq *rq)
{
	struct iw_point *iwp;
	union iwreq_data wrq_data;
	int err = 0;
	iwp = &wrq_data.data;
	RTW_DBG("%s:...\n", __func__);
	if (copy_from_user(iwp, rq->ifr_ifru.ifru_data, sizeof(struct iw_point)))
		return -EFAULT;

	err = _rtw_ioctl_wext_private(dev, &wrq_data);

	if (copy_to_user(rq->ifr_ifru.ifru_data, iwp, sizeof(struct iw_point)))
		return -EFAULT;

	return err;
}

static int rtw_ioctl_wext_private(struct net_device *dev, struct ifreq *rq)
{
#ifdef CONFIG_COMPAT
#if (KERNEL_VERSION(4, 6, 0) > LINUX_VERSION_CODE)
	if (is_compat_task())
#else
	if (in_compat_syscall())
#endif
		return rtw_ioctl_compat_wext_private(dev, rq);
	else
#endif /* CONFIG_COMPAT */
		return rtw_ioctl_standard_wext_private(dev, rq);
}

int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct iwreq *wrq = (struct iwreq *)rq;
	int ret = 0;

	switch (cmd) {
	case RTL_IOCTL_WPA_SUPPLICANT:
		ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
		break;
#ifdef CONFIG_AP_MODE
	case RTL_IOCTL_HOSTAPD:
		ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
		break;
#ifdef CONFIG_WIRELESS_EXT
	case SIOCSIWMODE:
		ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
		break;
#endif
#endif /* CONFIG_AP_MODE */
	case SIOCDEVPRIVATE:
		ret = rtw_ioctl_wext_private(dev, rq);
		break;
	case (SIOCDEVPRIVATE+1):
		ret = rtw_android_priv_cmd(dev, rq, cmd);
		break;
	default:
		ret = -EOPNOTSUPP;
		break;
	}

	return ret;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/os_dep/linux/custom_gpio_linux.c                                                      0000644 0001750 0001750 00000020342 14214766567 020325  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include "drv_types.h"

#ifdef CONFIG_PLATFORM_SPRD

/* gspi func & GPIO define */
#include <mach/gpio.h>/* 0915 */
#include <mach/board.h>

#if !(defined ANDROID_2X)

#ifdef CONFIG_RTL8188E
#include <mach/regulator.h>
#include <linux/regulator/consumer.h>
#endif /* CONFIG_RTL8188E */

#ifndef GPIO_WIFI_POWER
#define GPIO_WIFI_POWER -1
#endif /* !GPIO_WIFI_POWER */

#ifndef GPIO_WIFI_RESET
#define GPIO_WIFI_RESET -1
#endif /* !GPIO_WIFI_RESET */

#ifndef GPIO_WIFI_PWDN
#define GPIO_WIFI_PWDN -1
#endif /* !GPIO_WIFI_RESET */
#ifdef CONFIG_GSPI_HCI
extern unsigned int oob_irq;
#endif /* CONFIG_GSPI_HCI */

#ifdef CONFIG_SDIO_HCI
extern int rtw_mp_mode;
#else /* !CONFIG_SDIO_HCI */
#endif /* !CONFIG_SDIO_HCI */

int rtw_wifi_gpio_init(void)
{
#ifdef CONFIG_GSPI_HCI
	if (GPIO_WIFI_IRQ > 0) {
		gpio_request(GPIO_WIFI_IRQ, "oob_irq");
		gpio_direction_input(GPIO_WIFI_IRQ);

		oob_irq = gpio_to_irq(GPIO_WIFI_IRQ);

		RTW_INFO("%s oob_irq:%d\n", __func__, oob_irq);
	}
#endif
	if (GPIO_WIFI_RESET > 0)
		gpio_request(GPIO_WIFI_RESET , "wifi_rst");
	if (GPIO_WIFI_POWER > 0)
		gpio_request(GPIO_WIFI_POWER, "wifi_power");

#ifdef CONFIG_SDIO_HCI
#if (defined(CONFIG_RTL8723B)) && (MP_DRIVER == 1)
	if (rtw_mp_mode == 1) {
		RTW_INFO("%s GPIO_BT_RESET pin special for mp_test\n", __func__);
		if (GPIO_BT_RESET > 0)
			gpio_request(GPIO_BT_RESET , "bt_rst");
	}
#endif
#endif
	return 0;
}

int rtw_wifi_gpio_deinit(void)
{
#ifdef CONFIG_GSPI_HCI
	if (GPIO_WIFI_IRQ > 0)
		gpio_free(GPIO_WIFI_IRQ);
#endif
	if (GPIO_WIFI_RESET > 0)
		gpio_free(GPIO_WIFI_RESET);
	if (GPIO_WIFI_POWER > 0)
		gpio_free(GPIO_WIFI_POWER);

#ifdef CONFIG_SDIO_HCI
#if (defined(CONFIG_RTL8723B)) && (MP_DRIVER == 1)
	if (rtw_mp_mode == 1) {
		RTW_INFO("%s GPIO_BT_RESET pin special for mp_test\n", __func__);
		if (GPIO_BT_RESET > 0)
			gpio_free(GPIO_BT_RESET);
	}
#endif
#endif
	return 0;
}

/* Customer function to control hw specific wlan gpios */
void rtw_wifi_gpio_wlan_ctrl(int onoff)
{
	switch (onoff) {
	case WLAN_PWDN_OFF:
		RTW_INFO("%s: call customer specific GPIO(%d) to set wifi power down pin to 0\n",
			 __FUNCTION__, GPIO_WIFI_RESET);

#ifndef CONFIG_DONT_BUS_SCAN
		if (GPIO_WIFI_RESET > 0)
			gpio_direction_output(GPIO_WIFI_RESET , 0);
#endif
		break;

	case WLAN_PWDN_ON:
		RTW_INFO("%s: callc customer specific GPIO(%d) to set wifi power down pin to 1\n",
			 __FUNCTION__, GPIO_WIFI_RESET);

		if (GPIO_WIFI_RESET > 0)
			gpio_direction_output(GPIO_WIFI_RESET , 1);
		break;

	case WLAN_POWER_OFF:
		break;

	case WLAN_POWER_ON:
		break;
#ifdef CONFIG_SDIO_HCI
#if (defined(CONFIG_RTL8723B)) && (MP_DRIVER == 1)
	case WLAN_BT_PWDN_OFF:
		if (rtw_mp_mode == 1) {
			RTW_INFO("%s: call customer specific GPIO to set wifi power down pin to 0\n",
				 __FUNCTION__);
			if (GPIO_BT_RESET > 0)
				gpio_direction_output(GPIO_BT_RESET , 0);
		}
		break;

	case WLAN_BT_PWDN_ON:
		if (rtw_mp_mode == 1) {
			RTW_INFO("%s: callc customer specific GPIO to set wifi power down pin to 1 %x\n",
				 __FUNCTION__, GPIO_BT_RESET);

			if (GPIO_BT_RESET > 0)
				gpio_direction_output(GPIO_BT_RESET , 1);
		}
		break;
#endif
#endif
	}
}

#else /* ANDROID_2X */

#include <mach/ldo.h>

#ifdef CONFIG_RTL8188E
extern int sprd_3rdparty_gpio_wifi_power;
#endif
extern int sprd_3rdparty_gpio_wifi_pwd;
#if  defined(CONFIG_RTL8723B)
extern int sprd_3rdparty_gpio_bt_reset;
#endif

int rtw_wifi_gpio_init(void)
{
#if defined(CONFIG_RTL8723B)
	if (sprd_3rdparty_gpio_bt_reset > 0)
		gpio_direction_output(sprd_3rdparty_gpio_bt_reset, 1);
#endif

	return 0;
}

int rtw_wifi_gpio_deinit(void)
{
	return 0;
}

/* Customer function to control hw specific wlan gpios */
void rtw_wifi_gpio_wlan_ctrl(int onoff)
{
	switch (onoff) {
	case WLAN_PWDN_OFF:
		RTW_INFO("%s: call customer specific GPIO to set wifi power down pin to 0\n",
			 __FUNCTION__);
		if (sprd_3rdparty_gpio_wifi_pwd > 0)
			gpio_set_value(sprd_3rdparty_gpio_wifi_pwd, 0);

		if (sprd_3rdparty_gpio_wifi_pwd == 60) {
			RTW_INFO("%s: turn off VSIM2 2.8V\n", __func__);
			LDO_TurnOffLDO(LDO_LDO_SIM2);
		}
		break;

	case WLAN_PWDN_ON:
		RTW_INFO("%s: callc customer specific GPIO to set wifi power down pin to 1\n",
			 __FUNCTION__);
		if (sprd_3rdparty_gpio_wifi_pwd == 60) {
			RTW_INFO("%s: turn on VSIM2 2.8V\n", __func__);
			LDO_SetVoltLevel(LDO_LDO_SIM2, LDO_VOLT_LEVEL0);
			LDO_TurnOnLDO(LDO_LDO_SIM2);
		}
		if (sprd_3rdparty_gpio_wifi_pwd > 0)
			gpio_set_value(sprd_3rdparty_gpio_wifi_pwd, 1);
		break;

	case WLAN_POWER_OFF:
#ifdef CONFIG_RTL8188E
#ifdef CONFIG_WIF1_LDO
		RTW_INFO("%s: turn off VDD-WIFI0 1.2V\n", __FUNCTION__);
		LDO_TurnOffLDO(LDO_LDO_WIF1);
#endif /* CONFIG_WIF1_LDO */

		RTW_INFO("%s: turn off VDD-WIFI0 3.3V\n", __FUNCTION__);
		LDO_TurnOffLDO(LDO_LDO_WIF0);

		RTW_INFO("%s: call customer specific GPIO(%d) to turn off wifi power\n",
			 __FUNCTION__, sprd_3rdparty_gpio_wifi_power);
		if (sprd_3rdparty_gpio_wifi_power != 65535)
			gpio_set_value(sprd_3rdparty_gpio_wifi_power, 0);
#endif
		break;

	case WLAN_POWER_ON:
#ifdef CONFIG_RTL8188E
		RTW_INFO("%s: call customer specific GPIO(%d) to turn on wifi power\n",
			 __FUNCTION__, sprd_3rdparty_gpio_wifi_power);
		if (sprd_3rdparty_gpio_wifi_power != 65535)
			gpio_set_value(sprd_3rdparty_gpio_wifi_power, 1);

		RTW_INFO("%s: turn on VDD-WIFI0 3.3V\n", __FUNCTION__);
		LDO_TurnOnLDO(LDO_LDO_WIF0);
		LDO_SetVoltLevel(LDO_LDO_WIF0, LDO_VOLT_LEVEL1);

#ifdef CONFIG_WIF1_LDO
		RTW_INFO("%s: turn on VDD-WIFI1 1.2V\n", __func__);
		LDO_TurnOnLDO(LDO_LDO_WIF1);
		LDO_SetVoltLevel(LDO_LDO_WIF1, LDO_VOLT_LEVEL3);
#endif /* CONFIG_WIF1_LDO */
#endif
		break;

	case WLAN_BT_PWDN_OFF:
		RTW_INFO("%s: call customer specific GPIO to set bt power down pin to 0\n",
			 __FUNCTION__);
#if defined(CONFIG_RTL8723B)
		if (sprd_3rdparty_gpio_bt_reset > 0)
			gpio_set_value(sprd_3rdparty_gpio_bt_reset, 0);
#endif
		break;

	case WLAN_BT_PWDN_ON:
		RTW_INFO("%s: callc customer specific GPIO to set bt power down pin to 1\n",
			 __FUNCTION__);
#if defined(CONFIG_RTL8723B)
		if (sprd_3rdparty_gpio_bt_reset > 0)
			gpio_set_value(sprd_3rdparty_gpio_bt_reset, 1);
#endif
		break;
	}
}
#endif /* ANDROID_2X */

#elif defined(CONFIG_PLATFORM_ARM_RK3066)
#include <mach/iomux.h>

#define GPIO_WIFI_IRQ		RK30_PIN2_PC2
extern unsigned int oob_irq;
int rtw_wifi_gpio_init(void)
{
#ifdef CONFIG_GSPI_HCI
	if (GPIO_WIFI_IRQ > 0) {
		rk30_mux_api_set(GPIO2C2_LCDC1DATA18_SMCBLSN1_HSADCDATA5_NAME, GPIO2C_GPIO2C2);/* jacky_test */
		gpio_request(GPIO_WIFI_IRQ, "oob_irq");
		gpio_direction_input(GPIO_WIFI_IRQ);

		oob_irq = gpio_to_irq(GPIO_WIFI_IRQ);

		RTW_INFO("%s oob_irq:%d\n", __func__, oob_irq);
	}
#endif
	return 0;
}


int rtw_wifi_gpio_deinit(void)
{
#ifdef CONFIG_GSPI_HCI
	if (GPIO_WIFI_IRQ > 0)
		gpio_free(GPIO_WIFI_IRQ);
#endif
	return 0;
}

void rtw_wifi_gpio_wlan_ctrl(int onoff)
{
}

#ifdef CONFIG_GPIO_API
/* this is a demo for extending GPIO pin[7] as interrupt mode */
struct net_device *rtl_net;
extern int rtw_register_gpio_interrupt(struct net_device *netdev, int gpio_num, void(*callback)(u8 level));
extern int rtw_disable_gpio_interrupt(struct net_device *netdev, int gpio_num);
void gpio_int(u8 is_high)
{
	RTW_INFO("%s level=%d\n", __func__, is_high);
}
int register_net_gpio_init(void)
{
	rtl_net = dev_get_by_name(&init_net, "wlan0");
	if (!rtl_net) {
		RTW_PRINT("rtl_net init fail!\n");
		return -1;
	}
	return rtw_register_gpio_interrupt(rtl_net, 7, gpio_int);
}
int unregister_net_gpio_init(void)
{
	rtl_net = dev_get_by_name(&init_net, "wlan0");
	if (!rtl_net) {
		RTW_PRINT("rtl_net init fail!\n");
		return -1;
	}
	return rtw_disable_gpio_interrupt(rtl_net, 7);
}
#endif

#else

int rtw_wifi_gpio_init(void)
{
	return 0;
}

void rtw_wifi_gpio_wlan_ctrl(int onoff)
{
}
#endif /* CONFIG_PLATFORM_SPRD */
                                                                                                                                                                                                                                                                                              rtl8822bu/src/os_dep/linux/rtw_cfgvendor.c                                                          0000644 0001750 0001750 00000163224 14214766567 017436  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#include <drv_types.h>

#ifdef CONFIG_IOCTL_CFG80211

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)

/*
#include <linux/kernel.h>
#include <linux/if_arp.h>
#include <asm/uaccess.h>

#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/netdevice.h>
#include <linux/sched.h>
#include <linux/etherdevice.h>
#include <linux/wireless.h>
#include <linux/ieee80211.h>
#include <linux/wait.h>
#include <net/cfg80211.h>
*/

#include <net/rtnetlink.h>

#ifdef DBG_MEM_ALLOC
extern bool match_mstat_sniff_rules(const enum mstat_f flags, const size_t size);
struct sk_buff *dbg_rtw_cfg80211_vendor_event_alloc(struct wiphy *wiphy, struct wireless_dev *wdev, int len, int event_id, gfp_t gfp
		, const enum mstat_f flags, const char *func, const int line)
{
	struct sk_buff *skb;
	unsigned int truesize = 0;

#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
	skb = cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp);
#else
	skb = cfg80211_vendor_event_alloc(wiphy, wdev, len, event_id, gfp);
#endif

	if (skb)
		truesize = skb->truesize;

	if (!skb || truesize < len || match_mstat_sniff_rules(flags, truesize))
		RTW_INFO("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, len, skb, truesize);

	rtw_mstat_update(
		flags
		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
		, truesize
	);

	return skb;
}

void dbg_rtw_cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp
		   , const enum mstat_f flags, const char *func, const int line)
{
	unsigned int truesize = skb->truesize;

	if (match_mstat_sniff_rules(flags, truesize))
		RTW_INFO("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);

	cfg80211_vendor_event(skb, gfp);

	rtw_mstat_update(
		flags
		, MSTAT_FREE
		, truesize
	);
}

struct sk_buff *dbg_rtw_cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int len
		, const enum mstat_f flags, const char *func, const int line)
{
	struct sk_buff *skb;
	unsigned int truesize = 0;

	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len);

	if (skb)
		truesize = skb->truesize;

	if (!skb || truesize < len || match_mstat_sniff_rules(flags, truesize))
		RTW_INFO("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, len, skb, truesize);

	rtw_mstat_update(
		flags
		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
		, truesize
	);

	return skb;
}

int dbg_rtw_cfg80211_vendor_cmd_reply(struct sk_buff *skb
	      , const enum mstat_f flags, const char *func, const int line)
{
	unsigned int truesize = skb->truesize;
	int ret;

	if (match_mstat_sniff_rules(flags, truesize))
		RTW_INFO("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);

	ret = cfg80211_vendor_cmd_reply(skb);

	rtw_mstat_update(
		flags
		, MSTAT_FREE
		, truesize
	);

	return ret;
}

#define rtw_cfg80211_vendor_event_alloc(wiphy, wdev, len, event_id, gfp) \
	dbg_rtw_cfg80211_vendor_event_alloc(wiphy, wdev, len, event_id, gfp, MSTAT_FUNC_CFG_VENDOR | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)

#define rtw_cfg80211_vendor_event(skb, gfp) \
	dbg_rtw_cfg80211_vendor_event(skb, gfp, MSTAT_FUNC_CFG_VENDOR | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)

#define rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len) \
	dbg_rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len, MSTAT_FUNC_CFG_VENDOR | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)

#define rtw_cfg80211_vendor_cmd_reply(skb) \
	dbg_rtw_cfg80211_vendor_cmd_reply(skb, MSTAT_FUNC_CFG_VENDOR | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#else

struct sk_buff *rtw_cfg80211_vendor_event_alloc(
	struct wiphy *wiphy, struct wireless_dev *wdev, int len, int event_id, gfp_t gfp)
{
	struct sk_buff *skb;

#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
	skb = cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp);
#else
	skb = cfg80211_vendor_event_alloc(wiphy, wdev, len, event_id, gfp);
#endif
	return skb;
}

#define rtw_cfg80211_vendor_event(skb, gfp) \
	cfg80211_vendor_event(skb, gfp)

#define rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len) \
	cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len)

#define rtw_cfg80211_vendor_cmd_reply(skb) \
	cfg80211_vendor_cmd_reply(skb)
#endif /* DBG_MEM_ALLOC */

/*
 * This API is to be used for asynchronous vendor events. This
 * shouldn't be used in response to a vendor command from its
 * do_it handler context (instead rtw_cfgvendor_send_cmd_reply should
 * be used).
 */
int rtw_cfgvendor_send_async_event(struct wiphy *wiphy,
	   struct net_device *dev, int event_id, const void  *data, int len)
{
	u16 kflags;
	struct sk_buff *skb;

	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;

	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_event_alloc(wiphy, ndev_to_wdev(dev), len, event_id, kflags);
	if (!skb) {
		RTW_ERR(FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(dev));
		return -ENOMEM;
	}

	/* Push the data to the skb */
	nla_put_nohdr(skb, len, data);

	rtw_cfg80211_vendor_event(skb, kflags);

	return 0;
}

static int rtw_cfgvendor_send_cmd_reply(struct wiphy *wiphy,
			struct net_device *dev, const void  *data, int len)
{
	struct sk_buff *skb;

	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len);
	if (unlikely(!skb)) {
		RTW_ERR(FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(dev));
		return -ENOMEM;
	}

	/* Push the data to the skb */
	nla_put_nohdr(skb, len, data);

	return rtw_cfg80211_vendor_cmd_reply(skb);
}

/* Feature enums */
#define WIFI_FEATURE_INFRA              0x0001      // Basic infrastructure mode
#define WIFI_FEATURE_INFRA_5G           0x0002      // Support for 5 GHz Band
#define WIFI_FEATURE_HOTSPOT            0x0004      // Support for GAS/ANQP
#define WIFI_FEATURE_P2P                0x0008      // Wifi-Direct
#define WIFI_FEATURE_SOFT_AP            0x0010      // Soft AP
#define WIFI_FEATURE_GSCAN              0x0020      // Google-Scan APIs
#define WIFI_FEATURE_NAN                0x0040      // Neighbor Awareness Networking
#define WIFI_FEATURE_D2D_RTT            0x0080      // Device-to-device RTT
#define WIFI_FEATURE_D2AP_RTT           0x0100      // Device-to-AP RTT
#define WIFI_FEATURE_BATCH_SCAN         0x0200      // Batched Scan (legacy)
#define WIFI_FEATURE_PNO                0x0400      // Preferred network offload
#define WIFI_FEATURE_ADDITIONAL_STA     0x0800      // Support for two STAs
#define WIFI_FEATURE_TDLS               0x1000      // Tunnel directed link setup
#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000      // Support for TDLS off channel
#define WIFI_FEATURE_EPR                0x4000      // Enhanced power reporting
#define WIFI_FEATURE_AP_STA             0x8000      // Support for AP STA Concurrency
#define WIFI_FEATURE_LINK_LAYER_STATS   0x10000     // Link layer stats collection
#define WIFI_FEATURE_LOGGER             0x20000     // WiFi Logger
#define WIFI_FEATURE_HAL_EPNO           0x40000     // WiFi PNO enhanced
#define WIFI_FEATURE_RSSI_MONITOR       0x80000     // RSSI Monitor
#define WIFI_FEATURE_MKEEP_ALIVE        0x100000    // WiFi mkeep_alive
#define WIFI_FEATURE_CONFIG_NDO         0x200000    // ND offload configure
#define WIFI_FEATURE_TX_TRANSMIT_POWER  0x400000    // Capture Tx transmit power levels
#define WIFI_FEATURE_CONTROL_ROAMING    0x800000    // Enable/Disable firmware roaming
#define WIFI_FEATURE_IE_WHITELIST       0x1000000   // Support Probe IE white listing
#define WIFI_FEATURE_SCAN_RAND          0x2000000   // Support MAC & Probe Sequence Number randomization
// Add more features here

#define MAX_FEATURE_SET_CONCURRRENT_GROUPS  3

#include <hal_data.h>
int rtw_dev_get_feature_set(struct net_device *dev)
{
	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
	HAL_DATA_TYPE *HalData = GET_HAL_DATA(adapter);
	int feature_set = 0;

	feature_set |= WIFI_FEATURE_INFRA;

#if CONFIG_IEEE80211_BAND_5GHZ
	if (is_supported_5g(adapter_to_regsty(adapter)->wireless_mode))
		feature_set |= WIFI_FEATURE_INFRA_5G;
#endif

	feature_set |= WIFI_FEATURE_P2P;
	feature_set |= WIFI_FEATURE_SOFT_AP;

	feature_set |= WIFI_FEATURE_ADDITIONAL_STA;
#ifdef CONFIG_RTW_CFGVEDNOR_LLSTATS
	feature_set |= WIFI_FEATURE_LINK_LAYER_STATS;
#endif /* CONFIG_RTW_CFGVEDNOR_LLSTATS */

#ifdef CONFIG_RTW_CFGVEDNOR_RSSIMONITOR
        feature_set |= WIFI_FEATURE_RSSI_MONITOR;
#endif

#ifdef CONFIG_RTW_CFGVENDOR_WIFI_LOGGER
	feature_set |= WIFI_FEATURE_LOGGER;
#endif

#ifdef CONFIG_RTW_WIFI_HAL
	feature_set |= WIFI_FEATURE_CONFIG_NDO;
	feature_set |= WIFI_FEATURE_SCAN_RAND;
#endif

	return feature_set;
}

int *rtw_dev_get_feature_set_matrix(struct net_device *dev, int *num)
{
	int feature_set_full, mem_needed;
	int *ret;

	*num = 0;
	mem_needed = sizeof(int) * MAX_FEATURE_SET_CONCURRRENT_GROUPS;
	ret = (int *)rtw_malloc(mem_needed);

	if (!ret) {
		RTW_ERR(FUNC_NDEV_FMT" failed to allocate %d bytes\n"
			, FUNC_NDEV_ARG(dev), mem_needed);
		return ret;
	}

	feature_set_full = rtw_dev_get_feature_set(dev);

	ret[0] = (feature_set_full & WIFI_FEATURE_INFRA) |
		 (feature_set_full & WIFI_FEATURE_INFRA_5G) |
		 (feature_set_full & WIFI_FEATURE_NAN) |
		 (feature_set_full & WIFI_FEATURE_D2D_RTT) |
		 (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
		 (feature_set_full & WIFI_FEATURE_PNO) |
		 (feature_set_full & WIFI_FEATURE_BATCH_SCAN) |
		 (feature_set_full & WIFI_FEATURE_GSCAN) |
		 (feature_set_full & WIFI_FEATURE_HOTSPOT) |
		 (feature_set_full & WIFI_FEATURE_ADDITIONAL_STA) |
		 (feature_set_full & WIFI_FEATURE_EPR);

	ret[1] = (feature_set_full & WIFI_FEATURE_INFRA) |
		 (feature_set_full & WIFI_FEATURE_INFRA_5G) |
		 /* Not yet verified NAN with P2P */
		 /* (feature_set_full & WIFI_FEATURE_NAN) | */
		 (feature_set_full & WIFI_FEATURE_P2P) |
		 (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
		 (feature_set_full & WIFI_FEATURE_D2D_RTT) |
		 (feature_set_full & WIFI_FEATURE_EPR);

	ret[2] = (feature_set_full & WIFI_FEATURE_INFRA) |
		 (feature_set_full & WIFI_FEATURE_INFRA_5G) |
		 (feature_set_full & WIFI_FEATURE_NAN) |
		 (feature_set_full & WIFI_FEATURE_D2D_RTT) |
		 (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
		 (feature_set_full & WIFI_FEATURE_TDLS) |
		 (feature_set_full & WIFI_FEATURE_TDLS_OFFCHANNEL) |
		 (feature_set_full & WIFI_FEATURE_EPR);
	*num = MAX_FEATURE_SET_CONCURRRENT_GROUPS;

	return ret;
}

static int rtw_cfgvendor_get_feature_set(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	int reply;

	reply = rtw_dev_get_feature_set(wdev_to_ndev(wdev));

	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), &reply, sizeof(int));

	if (unlikely(err))
		RTW_ERR(FUNC_NDEV_FMT" Vendor Command reply failed ret:%d\n"
			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);

	return err;
}

static int rtw_cfgvendor_get_feature_set_matrix(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct sk_buff *skb;
	int *reply;
	int num, mem_needed, i;

	reply = rtw_dev_get_feature_set_matrix(wdev_to_ndev(wdev), &num);

	if (!reply) {
		RTW_ERR(FUNC_NDEV_FMT" Could not get feature list matrix\n"
			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)));
		err = -EINVAL;
		return err;
	}

	mem_needed = VENDOR_REPLY_OVERHEAD + (ATTRIBUTE_U32_LEN * num) +
		     ATTRIBUTE_U32_LEN;

	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
	if (unlikely(!skb)) {
		RTW_ERR(FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(wdev_to_ndev(wdev)));
		err = -ENOMEM;
		goto exit;
	}

	nla_put_u32(skb, ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET, num);
	for (i = 0; i < num; i++)
		nla_put_u32(skb, ANDR_WIFI_ATTRIBUTE_FEATURE_SET, reply[i]);

	err =  rtw_cfg80211_vendor_cmd_reply(skb);

	if (unlikely(err))
		RTW_ERR(FUNC_NDEV_FMT" Vendor Command reply failed ret:%d\n"
			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
exit:
	rtw_mfree((u8 *)reply, sizeof(int) * num);
	return err;
}

#if defined(GSCAN_SUPPORT) && 0
int rtw_cfgvendor_send_hotlist_event(struct wiphy *wiphy,
	struct net_device *dev, void  *data, int len, rtw_vendor_event_t event)
{
	u16 kflags;
	const void *ptr;
	struct sk_buff *skb;
	int malloc_len, total, iter_cnt_to_send, cnt;
	gscan_results_cache_t *cache = (gscan_results_cache_t *)data;

	total = len / sizeof(wifi_gscan_result_t);
	while (total > 0) {
		malloc_len = (total * sizeof(wifi_gscan_result_t)) + VENDOR_DATA_OVERHEAD;
		if (malloc_len > NLMSG_DEFAULT_SIZE)
			malloc_len = NLMSG_DEFAULT_SIZE;
		iter_cnt_to_send =
			(malloc_len - VENDOR_DATA_OVERHEAD) / sizeof(wifi_gscan_result_t);
		total = total - iter_cnt_to_send;

		kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;

		/* Alloc the SKB for vendor_event */
		skb = rtw_cfg80211_vendor_event_alloc(wiphy, ndev_to_wdev(dev), malloc_len, event, kflags);
		if (!skb) {
			WL_ERR(("skb alloc failed"));
			return -ENOMEM;
		}

		while (cache && iter_cnt_to_send) {
			ptr = (const void *) &cache->results[cache->tot_consumed];

			if (iter_cnt_to_send < (cache->tot_count - cache->tot_consumed))
				cnt = iter_cnt_to_send;
			else
				cnt = (cache->tot_count - cache->tot_consumed);

			iter_cnt_to_send -= cnt;
			cache->tot_consumed += cnt;
			/* Push the data to the skb */
			nla_append(skb, cnt * sizeof(wifi_gscan_result_t), ptr);
			if (cache->tot_consumed == cache->tot_count)
				cache = cache->next;

		}

		rtw_cfg80211_vendor_event(skb, kflags);
	}

	return 0;
}


static int rtw_cfgvendor_gscan_get_capabilities(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	dhd_pno_gscan_capabilities_t *reply = NULL;
	uint32 reply_len = 0;


	reply = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
			      DHD_PNO_GET_CAPABILITIES, NULL, &reply_len);
	if (!reply) {
		WL_ERR(("Could not get capabilities\n"));
		err = -EINVAL;
		return err;
	}

	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
					    reply, reply_len);

	if (unlikely(err))
		WL_ERR(("Vendor Command reply failed ret:%d\n", err));

	kfree(reply);
	return err;
}

static int rtw_cfgvendor_gscan_get_channel_list(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0, type, band;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	uint16 *reply = NULL;
	uint32 reply_len = 0, num_channels, mem_needed;
	struct sk_buff *skb;

	type = nla_type(data);

	if (type == GSCAN_ATTRIBUTE_BAND)
		band = nla_get_u32(data);
	else
		return -1;

	reply = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
			      DHD_PNO_GET_CHANNEL_LIST, &band, &reply_len);

	if (!reply) {
		WL_ERR(("Could not get channel list\n"));
		err = -EINVAL;
		return err;
	}
	num_channels =  reply_len / sizeof(uint32);
	mem_needed = reply_len + VENDOR_REPLY_OVERHEAD + (ATTRIBUTE_U32_LEN * 2);

	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
	if (unlikely(!skb)) {
		WL_ERR(("skb alloc failed"));
		err = -ENOMEM;
		goto exit;
	}

	nla_put_u32(skb, GSCAN_ATTRIBUTE_NUM_CHANNELS, num_channels);
	nla_put(skb, GSCAN_ATTRIBUTE_CHANNEL_LIST, reply_len, reply);

	err =  rtw_cfg80211_vendor_cmd_reply(skb);

	if (unlikely(err))
		WL_ERR(("Vendor Command reply failed ret:%d\n", err));
exit:
	kfree(reply);
	return err;
}

static int rtw_cfgvendor_gscan_get_batch_results(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	gscan_results_cache_t *results, *iter;
	uint32 reply_len, complete = 0, num_results_iter;
	int32 mem_needed;
	wifi_gscan_result_t *ptr;
	uint16 num_scan_ids, num_results;
	struct sk_buff *skb;
	struct nlattr *scan_hdr;

	dhd_dev_wait_batch_results_complete(bcmcfg_to_prmry_ndev(cfg));
	dhd_dev_pno_lock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
	results = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
				DHD_PNO_GET_BATCH_RESULTS, NULL, &reply_len);

	if (!results) {
		WL_ERR(("No results to send %d\n", err));
		err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
						    results, 0);

		if (unlikely(err))
			WL_ERR(("Vendor Command reply failed ret:%d\n", err));
		dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
		return err;
	}
	num_scan_ids = reply_len & 0xFFFF;
	num_results = (reply_len & 0xFFFF0000) >> 16;
	mem_needed = (num_results * sizeof(wifi_gscan_result_t)) +
		     (num_scan_ids * GSCAN_BATCH_RESULT_HDR_LEN) +
		     VENDOR_REPLY_OVERHEAD + SCAN_RESULTS_COMPLETE_FLAG_LEN;

	if (mem_needed > (int32)NLMSG_DEFAULT_SIZE) {
		mem_needed = (int32)NLMSG_DEFAULT_SIZE;
		complete = 0;
	} else
		complete = 1;

	WL_TRACE(("complete %d mem_needed %d max_mem %d\n", complete, mem_needed,
		  (int)NLMSG_DEFAULT_SIZE));
	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
	if (unlikely(!skb)) {
		WL_ERR(("skb alloc failed"));
		dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
		return -ENOMEM;
	}
	iter = results;

	nla_put_u32(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE, complete);

	mem_needed = mem_needed - (SCAN_RESULTS_COMPLETE_FLAG_LEN + VENDOR_REPLY_OVERHEAD);

	while (iter && ((mem_needed - GSCAN_BATCH_RESULT_HDR_LEN)  > 0)) {
		scan_hdr = nla_nest_start(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS);
		nla_put_u32(skb, GSCAN_ATTRIBUTE_SCAN_ID, iter->scan_id);
		nla_put_u8(skb, GSCAN_ATTRIBUTE_SCAN_FLAGS, iter->flag);
		num_results_iter =
			(mem_needed - GSCAN_BATCH_RESULT_HDR_LEN) / sizeof(wifi_gscan_result_t);

		if ((iter->tot_count - iter->tot_consumed) < num_results_iter)
			num_results_iter = iter->tot_count - iter->tot_consumed;

		nla_put_u32(skb, GSCAN_ATTRIBUTE_NUM_OF_RESULTS, num_results_iter);
		if (num_results_iter) {
			ptr = &iter->results[iter->tot_consumed];
			iter->tot_consumed += num_results_iter;
			nla_put(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS,
				num_results_iter * sizeof(wifi_gscan_result_t), ptr);
		}
		nla_nest_end(skb, scan_hdr);
		mem_needed -= GSCAN_BATCH_RESULT_HDR_LEN +
			      (num_results_iter * sizeof(wifi_gscan_result_t));
		iter = iter->next;
	}

	dhd_dev_gscan_batch_cache_cleanup(bcmcfg_to_prmry_ndev(cfg));
	dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));

	return rtw_cfg80211_vendor_cmd_reply(skb);
}

static int rtw_cfgvendor_initiate_gscan(struct wiphy *wiphy,
		       struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	int type, tmp = len;
	int run = 0xFF;
	int flush = 0;
	const struct nlattr *iter;

	nla_for_each_attr(iter, data, len, tmp) {
		type = nla_type(iter);
		if (type == GSCAN_ATTRIBUTE_ENABLE_FEATURE)
			run = nla_get_u32(iter);
		else if (type == GSCAN_ATTRIBUTE_FLUSH_FEATURE)
			flush = nla_get_u32(iter);
	}

	if (run != 0xFF) {
		err = dhd_dev_pno_run_gscan(bcmcfg_to_prmry_ndev(cfg), run, flush);

		if (unlikely(err))
			WL_ERR(("Could not run gscan:%d\n", err));
		return err;
	} else
		return -1;


}

static int rtw_cfgvendor_enable_full_scan_result(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	int type;
	bool real_time = FALSE;

	type = nla_type(data);

	if (type == GSCAN_ATTRIBUTE_ENABLE_FULL_SCAN_RESULTS) {
		real_time = nla_get_u32(data);

		err = dhd_dev_pno_enable_full_scan_result(bcmcfg_to_prmry_ndev(cfg), real_time);

		if (unlikely(err))
			WL_ERR(("Could not run gscan:%d\n", err));

	} else
		err = -1;

	return err;
}

static int rtw_cfgvendor_set_scan_cfg(struct wiphy *wiphy,
		     struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	gscan_scan_params_t *scan_param;
	int j = 0;
	int type, tmp, tmp1, tmp2, k = 0;
	const struct nlattr *iter, *iter1, *iter2;
	struct dhd_pno_gscan_channel_bucket  *ch_bucket;

	scan_param = kzalloc(sizeof(gscan_scan_params_t), GFP_KERNEL);
	if (!scan_param) {
		WL_ERR(("Could not set GSCAN scan cfg, mem alloc failure\n"));
		err = -EINVAL;
		return err;

	}

	scan_param->scan_fr = PNO_SCAN_MIN_FW_SEC;
	nla_for_each_attr(iter, data, len, tmp) {
		type = nla_type(iter);

		if (j >= GSCAN_MAX_CH_BUCKETS)
			break;

		switch (type) {
		case GSCAN_ATTRIBUTE_BASE_PERIOD:
			scan_param->scan_fr = nla_get_u32(iter) / 1000;
			break;
		case GSCAN_ATTRIBUTE_NUM_BUCKETS:
			scan_param->nchannel_buckets = nla_get_u32(iter);
			break;
		case GSCAN_ATTRIBUTE_CH_BUCKET_1:
		case GSCAN_ATTRIBUTE_CH_BUCKET_2:
		case GSCAN_ATTRIBUTE_CH_BUCKET_3:
		case GSCAN_ATTRIBUTE_CH_BUCKET_4:
		case GSCAN_ATTRIBUTE_CH_BUCKET_5:
		case GSCAN_ATTRIBUTE_CH_BUCKET_6:
		case GSCAN_ATTRIBUTE_CH_BUCKET_7:
			nla_for_each_nested(iter1, iter, tmp1) {
				type = nla_type(iter1);
				ch_bucket =
					scan_param->channel_bucket;

				switch (type) {
				case GSCAN_ATTRIBUTE_BUCKET_ID:
					break;
				case GSCAN_ATTRIBUTE_BUCKET_PERIOD:
					ch_bucket[j].bucket_freq_multiple =
						nla_get_u32(iter1) / 1000;
					break;
				case GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS:
					ch_bucket[j].num_channels =
						nla_get_u32(iter1);
					break;
				case GSCAN_ATTRIBUTE_BUCKET_CHANNELS:
					nla_for_each_nested(iter2, iter1, tmp2) {
						if (k >= PFN_SWC_RSSI_WINDOW_MAX)
							break;
						ch_bucket[j].chan_list[k] =
							nla_get_u32(iter2);
						k++;
					}
					k = 0;
					break;
				case GSCAN_ATTRIBUTE_BUCKETS_BAND:
					ch_bucket[j].band = (uint16)
							    nla_get_u32(iter1);
					break;
				case GSCAN_ATTRIBUTE_REPORT_EVENTS:
					ch_bucket[j].report_flag = (uint8)
							   nla_get_u32(iter1);
					break;
				}
			}
			j++;
			break;
		}
	}

	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
				      DHD_PNO_SCAN_CFG_ID, scan_param, 0) < 0) {
		WL_ERR(("Could not set GSCAN scan cfg\n"));
		err = -EINVAL;
	}

	kfree(scan_param);
	return err;

}

static int rtw_cfgvendor_hotlist_cfg(struct wiphy *wiphy,
		    struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	gscan_hotlist_scan_params_t *hotlist_params;
	int tmp, tmp1, tmp2, type, j = 0, dummy;
	const struct nlattr *outer, *inner, *iter;
	uint8 flush = 0;
	struct bssid_t *pbssid;

	hotlist_params = (gscan_hotlist_scan_params_t *)kzalloc(len, GFP_KERNEL);
	if (!hotlist_params) {
		WL_ERR(("Cannot Malloc mem to parse config commands size - %d bytes\n", len));
		return -1;
	}

	hotlist_params->lost_ap_window = GSCAN_LOST_AP_WINDOW_DEFAULT;

	nla_for_each_attr(iter, data, len, tmp2) {
		type = nla_type(iter);
		switch (type) {
		case GSCAN_ATTRIBUTE_HOTLIST_BSSIDS:
			pbssid = hotlist_params->bssid;
			nla_for_each_nested(outer, iter, tmp) {
				nla_for_each_nested(inner, outer, tmp1) {
					type = nla_type(inner);

					switch (type) {
					case GSCAN_ATTRIBUTE_BSSID:
						memcpy(&(pbssid[j].macaddr),
						       nla_data(inner), ETHER_ADDR_LEN);
						break;
					case GSCAN_ATTRIBUTE_RSSI_LOW:
						pbssid[j].rssi_reporting_threshold =
							(int8) nla_get_u8(inner);
						break;
					case GSCAN_ATTRIBUTE_RSSI_HIGH:
						dummy = (int8) nla_get_u8(inner);
						break;
					}
				}
				j++;
			}
			hotlist_params->nbssid = j;
			break;
		case GSCAN_ATTRIBUTE_HOTLIST_FLUSH:
			flush = nla_get_u8(iter);
			break;
		case GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE:
			hotlist_params->lost_ap_window = nla_get_u32(iter);
			break;
		}

	}

	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
		DHD_PNO_GEOFENCE_SCAN_CFG_ID, hotlist_params, flush) < 0) {
		WL_ERR(("Could not set GSCAN HOTLIST cfg\n"));
		err = -EINVAL;
		goto exit;
	}
exit:
	kfree(hotlist_params);
	return err;
}
static int rtw_cfgvendor_set_batch_scan_cfg(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0, tmp, type;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	gscan_batch_params_t batch_param;
	const struct nlattr *iter;

	batch_param.mscan = batch_param.bestn = 0;
	batch_param.buffer_threshold = GSCAN_BATCH_NO_THR_SET;

	nla_for_each_attr(iter, data, len, tmp) {
		type = nla_type(iter);

		switch (type) {
		case GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN:
			batch_param.bestn = nla_get_u32(iter);
			break;
		case GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE:
			batch_param.mscan = nla_get_u32(iter);
			break;
		case GSCAN_ATTRIBUTE_REPORT_THRESHOLD:
			batch_param.buffer_threshold = nla_get_u32(iter);
			break;
		}
	}

	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
			      DHD_PNO_BATCH_SCAN_CFG_ID, &batch_param, 0) < 0) {
		WL_ERR(("Could not set batch cfg\n"));
		err = -EINVAL;
		return err;
	}

	return err;
}

static int rtw_cfgvendor_significant_change_cfg(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	gscan_swc_params_t *significant_params;
	int tmp, tmp1, tmp2, type, j = 0;
	const struct nlattr *outer, *inner, *iter;
	uint8 flush = 0;
	wl_pfn_significant_bssid_t *pbssid;

	significant_params = (gscan_swc_params_t *) kzalloc(len, GFP_KERNEL);
	if (!significant_params) {
		WL_ERR(("Cannot Malloc mem to parse config commands size - %d bytes\n", len));
		return -1;
	}


	nla_for_each_attr(iter, data, len, tmp2) {
		type = nla_type(iter);

		switch (type) {
		case GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH:
			flush = nla_get_u8(iter);
			break;
		case GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE:
			significant_params->rssi_window = nla_get_u16(iter);
			break;
		case GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE:
			significant_params->lost_ap_window = nla_get_u16(iter);
			break;
		case GSCAN_ATTRIBUTE_MIN_BREACHING:
			significant_params->swc_threshold = nla_get_u16(iter);
			break;
		case GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS:
			pbssid = significant_params->bssid_elem_list;
			nla_for_each_nested(outer, iter, tmp) {
				nla_for_each_nested(inner, outer, tmp1) {
					switch (nla_type(inner)) {
					case GSCAN_ATTRIBUTE_BSSID:
						memcpy(&(pbssid[j].macaddr),
						       nla_data(inner),
						       ETHER_ADDR_LEN);
						break;
					case GSCAN_ATTRIBUTE_RSSI_HIGH:
						pbssid[j].rssi_high_threshold =
							(int8) nla_get_u8(inner);
						break;
					case GSCAN_ATTRIBUTE_RSSI_LOW:
						pbssid[j].rssi_low_threshold =
							(int8) nla_get_u8(inner);
						break;
					}
				}
				j++;
			}
			break;
		}
	}
	significant_params->nbssid = j;

	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
		DHD_PNO_SIGNIFICANT_SCAN_CFG_ID, significant_params, flush) < 0) {
		WL_ERR(("Could not set GSCAN significant cfg\n"));
		err = -EINVAL;
		goto exit;
	}
exit:
	kfree(significant_params);
	return err;
}
#endif /* GSCAN_SUPPORT */

#if defined(RTT_SUPPORT) && 0
void rtw_cfgvendor_rtt_evt(void *ctx, void *rtt_data)
{
	struct wireless_dev *wdev = (struct wireless_dev *)ctx;
	struct wiphy *wiphy;
	struct sk_buff *skb;
	uint32 tot_len = NLMSG_DEFAULT_SIZE, entry_len = 0;
	gfp_t kflags;
	rtt_report_t *rtt_report = NULL;
	rtt_result_t *rtt_result = NULL;
	struct list_head *rtt_list;
	wiphy = wdev->wiphy;

	WL_DBG(("In\n"));
	/* Push the data to the skb */
	if (!rtt_data) {
		WL_ERR(("rtt_data is NULL\n"));
		goto exit;
	}
	rtt_list = (struct list_head *)rtt_data;
	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_event_alloc(wiphy, wdev, tot_len, GOOGLE_RTT_COMPLETE_EVENT, kflags);
	if (!skb) {
		WL_ERR(("skb alloc failed"));
		goto exit;
	}
	/* fill in the rtt results on each entry */
	list_for_each_entry(rtt_result, rtt_list, list) {
		entry_len = 0;
		if (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) {
			entry_len = sizeof(rtt_report_t);
			rtt_report = kzalloc(entry_len, kflags);
			if (!rtt_report) {
				WL_ERR(("rtt_report alloc failed"));
				goto exit;
			}
			rtt_report->addr = rtt_result->peer_mac;
			rtt_report->num_measurement = 1; /* ONE SHOT */
			rtt_report->status = rtt_result->err_code;
			rtt_report->type = (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) ? RTT_ONE_WAY : RTT_TWO_WAY;
			rtt_report->peer = rtt_result->target_info->peer;
			rtt_report->channel = rtt_result->target_info->channel;
			rtt_report->rssi = rtt_result->avg_rssi;
			/* tx_rate */
			rtt_report->tx_rate = rtt_result->tx_rate;
			/* RTT */
			rtt_report->rtt = rtt_result->meanrtt;
			rtt_report->rtt_sd = rtt_result->sdrtt;
			/* convert to centi meter */
			if (rtt_result->distance != 0xffffffff)
				rtt_report->distance = (rtt_result->distance >> 2) * 25;
			else /* invalid distance */
				rtt_report->distance = -1;

			rtt_report->ts = rtt_result->ts;
			nla_append(skb, entry_len, rtt_report);
			kfree(rtt_report);
		}
	}
	rtw_cfg80211_vendor_event(skb, kflags);
exit:
	return;
}

static int rtw_cfgvendor_rtt_set_config(struct wiphy *wiphy, struct wireless_dev *wdev,
				       const void *data, int len)
{
	int err = 0, rem, rem1, rem2, type;
	rtt_config_params_t rtt_param;
	rtt_target_info_t *rtt_target = NULL;
	const struct nlattr *iter, *iter1, *iter2;
	int8 eabuf[ETHER_ADDR_STR_LEN];
	int8 chanbuf[CHANSPEC_STR_LEN];
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);

	WL_DBG(("In\n"));
	err = dhd_dev_rtt_register_noti_callback(wdev->netdev, wdev, wl_cfgvendor_rtt_evt);
	if (err < 0) {
		WL_ERR(("failed to register rtt_noti_callback\n"));
		goto exit;
	}
	memset(&rtt_param, 0, sizeof(rtt_param));
	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);
		switch (type) {
		case RTT_ATTRIBUTE_TARGET_CNT:
			rtt_param.rtt_target_cnt = nla_get_u8(iter);
			if (rtt_param.rtt_target_cnt > RTT_MAX_TARGET_CNT) {
				WL_ERR(("exceed max target count : %d\n",
					rtt_param.rtt_target_cnt));
				err = BCME_RANGE;
			}
			break;
		case RTT_ATTRIBUTE_TARGET_INFO:
			rtt_target = rtt_param.target_info;
			nla_for_each_nested(iter1, iter, rem1) {
				nla_for_each_nested(iter2, iter1, rem2) {
					type = nla_type(iter2);
					switch (type) {
					case RTT_ATTRIBUTE_TARGET_MAC:
						memcpy(&rtt_target->addr, nla_data(iter2), ETHER_ADDR_LEN);
						break;
					case RTT_ATTRIBUTE_TARGET_TYPE:
						rtt_target->type = nla_get_u8(iter2);
						break;
					case RTT_ATTRIBUTE_TARGET_PEER:
						rtt_target->peer = nla_get_u8(iter2);
						break;
					case RTT_ATTRIBUTE_TARGET_CHAN:
						memcpy(&rtt_target->channel, nla_data(iter2),
						       sizeof(rtt_target->channel));
						break;
					case RTT_ATTRIBUTE_TARGET_MODE:
						rtt_target->continuous = nla_get_u8(iter2);
						break;
					case RTT_ATTRIBUTE_TARGET_INTERVAL:
						rtt_target->interval = nla_get_u32(iter2);
						break;
					case RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT:
						rtt_target->measure_cnt = nla_get_u32(iter2);
						break;
					case RTT_ATTRIBUTE_TARGET_NUM_PKT:
						rtt_target->ftm_cnt = nla_get_u32(iter2);
						break;
					case RTT_ATTRIBUTE_TARGET_NUM_RETRY:
						rtt_target->retry_cnt = nla_get_u32(iter2);
					}
				}
				/* convert to chanspec value */
				rtt_target->chanspec = dhd_rtt_convert_to_chspec(rtt_target->channel);
				if (rtt_target->chanspec == 0) {
					WL_ERR(("Channel is not valid\n"));
					goto exit;
				}
				WL_INFORM(("Target addr %s, Channel : %s for RTT\n",
					bcm_ether_ntoa((const struct ether_addr *)&rtt_target->addr, eabuf),
					wf_chspec_ntoa(rtt_target->chanspec, chanbuf)));
				rtt_target++;
			}
			break;
		}
	}
	WL_DBG(("leave :target_cnt : %d\n", rtt_param.rtt_target_cnt));
	if (dhd_dev_rtt_set_cfg(bcmcfg_to_prmry_ndev(cfg), &rtt_param) < 0) {
		WL_ERR(("Could not set RTT configuration\n"));
		err = -EINVAL;
	}
exit:
	return err;
}

static int rtw_cfgvendor_rtt_cancel_config(struct wiphy *wiphy, struct wireless_dev *wdev,
		const void *data, int len)
{
	int err = 0, rem, type, target_cnt = 0;
	const struct nlattr *iter;
	struct ether_addr *mac_list = NULL, *mac_addr = NULL;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);

	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);
		switch (type) {
		case RTT_ATTRIBUTE_TARGET_CNT:
			target_cnt = nla_get_u8(iter);
			mac_list = (struct ether_addr *)kzalloc(target_cnt * ETHER_ADDR_LEN , GFP_KERNEL);
			if (mac_list == NULL) {
				WL_ERR(("failed to allocate mem for mac list\n"));
				goto exit;
			}
			mac_addr = &mac_list[0];
			break;
		case RTT_ATTRIBUTE_TARGET_MAC:
			if (mac_addr)
				memcpy(mac_addr++, nla_data(iter), ETHER_ADDR_LEN);
			else {
				WL_ERR(("mac_list is NULL\n"));
				goto exit;
			}
			break;
		}
		if (dhd_dev_rtt_cancel_cfg(bcmcfg_to_prmry_ndev(cfg), mac_list, target_cnt) < 0) {
			WL_ERR(("Could not cancel RTT configuration\n"));
			err = -EINVAL;
			goto exit;
		}
	}
exit:
	if (mac_list)
		kfree(mac_list);
	return err;
}
static int rtw_cfgvendor_rtt_get_capability(struct wiphy *wiphy, struct wireless_dev *wdev,
		const void *data, int len)
{
	int err = 0;
	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
	rtt_capabilities_t capability;

	err = dhd_dev_rtt_capability(bcmcfg_to_prmry_ndev(cfg), &capability);
	if (unlikely(err)) {
		WL_ERR(("Vendor Command reply failed ret:%d\n", err));
		goto exit;
	}
	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
					    &capability, sizeof(capability));

	if (unlikely(err))
		WL_ERR(("Vendor Command reply failed ret:%d\n", err));
exit:
	return err;
}

#endif /* RTT_SUPPORT */

#ifdef CONFIG_RTW_CFGVEDNOR_LLSTATS
enum {
    LSTATS_SUBCMD_GET_INFO = ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START,
	LSTATS_SUBCMD_SET_INFO,
	LSTATS_SUBCMD_CLEAR_INFO,
};
static void LinkLayerStats(_adapter *padapter)
{
	struct xmit_priv		*pxmitpriv = &(padapter->xmitpriv);
	struct recv_priv		*precvpriv = &(padapter->recvpriv);
	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
	u32 ps_time, trx_total_time;
	u64 tx_bytes, rx_bytes, trx_total_bytes = 0;
	u64 tmp = 0;
	
	RTW_DBG("%s adapter type : %u\n", __func__, padapter->adapter_type);

	tx_bytes = 0;
	rx_bytes = 0;
	ps_time = 0;
	trx_total_time = 0;

	if ( padapter->netif_up == _TRUE ) {

		pwrpriv->on_time = rtw_get_passing_time_ms(pwrpriv->radio_on_start_time);

		if (rtw_mi_check_fwstate(padapter, _FW_LINKED)) {
			if ( pwrpriv->bpower_saving == _TRUE ) {
				pwrpriv->pwr_saving_time += rtw_get_passing_time_ms(pwrpriv->pwr_saving_start_time);
				pwrpriv->pwr_saving_start_time = rtw_get_current_time();
			}
		} else {		
#ifdef CONFIG_IPS
			if ( pwrpriv->bpower_saving == _TRUE ) {
				pwrpriv->pwr_saving_time += rtw_get_passing_time_ms(pwrpriv->pwr_saving_start_time);
				pwrpriv->pwr_saving_start_time = rtw_get_current_time();
			}
#else
			pwrpriv->pwr_saving_time = pwrpriv->on_time;
#endif
		}

		ps_time = pwrpriv->pwr_saving_time;

		/* Deviation caused by caculation start time */
		if ( ps_time > pwrpriv->on_time )
			ps_time = pwrpriv->on_time;

		tx_bytes = pdvobjpriv->traffic_stat.last_tx_bytes;
		rx_bytes = pdvobjpriv->traffic_stat.last_rx_bytes;		
		trx_total_bytes = tx_bytes + rx_bytes;

		trx_total_time = pwrpriv->on_time - ps_time;

		if ( trx_total_bytes == 0) {
			pwrpriv->tx_time = 0;
			pwrpriv->rx_time = 0;
		} else {

			/* tx_time = (trx_total_time * tx_total_bytes) / trx_total_bytes; */
			/* rx_time = (trx_total_time * rx_total_bytes) / trx_total_bytes; */

			tmp = (tx_bytes * trx_total_time);
			tmp = rtw_division64(tmp, trx_total_bytes);
			pwrpriv->tx_time = tmp;

			tmp = (rx_bytes * trx_total_time);
			tmp = rtw_division64(tmp, trx_total_bytes);
			pwrpriv->rx_time = tmp;		

		}
	
	}
	else {
			pwrpriv->on_time = 0;
			pwrpriv->tx_time = 0;
			pwrpriv->rx_time = 0;	
	}

#ifdef CONFIG_RTW_WIFI_HAL_DEBUG
	RTW_INFO("- tx_bytes : %llu rx_bytes : %llu total bytes : %llu\n", tx_bytes, rx_bytes, trx_total_bytes);
	RTW_INFO("- netif_up = %s, on_time : %u ms\n", padapter->netif_up ? "1":"0", pwrpriv->on_time);
	RTW_INFO("- pwr_saving_time : %u (%u) ms\n", pwrpriv->pwr_saving_time, ps_time);
	RTW_INFO("- trx_total_time : %u ms\n", trx_total_time);		
	RTW_INFO("- tx_time : %u ms\n", pwrpriv->tx_time);
	RTW_INFO("- rx_time : %u ms\n", pwrpriv->rx_time);	
#endif /* CONFIG_RTW_WIFI_HAL_DEBUG */

}

#define DUMMY_TIME_STATICS 99
static int rtw_cfgvendor_lstats_get_info(struct wiphy *wiphy,	
	struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	_adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));
	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
	wifi_radio_stat_internal *radio;
	wifi_iface_stat *iface;
	char *output;

	output = rtw_malloc(sizeof(wifi_radio_stat_internal) + sizeof(wifi_iface_stat));
	if (output == NULL) {
		RTW_DBG("Allocate lstats info buffer fail!\n");
	}

	radio = (wifi_radio_stat_internal *)output;

	radio->num_channels = 0;
	radio->radio = 1;

	/* to get on_time, tx_time, rx_time */
	LinkLayerStats(padapter); 
	
	radio->on_time = pwrpriv->on_time;
	radio->tx_time = pwrpriv->tx_time;
	radio->rx_time = pwrpriv->rx_time;
	radio->on_time_scan = 0;
	radio->on_time_nbd = 0;
	radio->on_time_gscan = 0;
	radio->on_time_pno_scan = 0;
	radio->on_time_hs20 = 0;
	#ifdef CONFIG_RTW_WIFI_HAL_DEBUG
	RTW_INFO("==== %s ====\n", __func__);
	RTW_INFO("radio->radio : %d\n", (radio->radio));
	RTW_INFO("pwrpriv->on_time : %u ms\n", (pwrpriv->on_time));
	RTW_INFO("pwrpriv->tx_time :  %u ms\n", (pwrpriv->tx_time));
	RTW_INFO("pwrpriv->rx_time :  %u ms\n", (pwrpriv->rx_time));
	RTW_INFO("radio->on_time :  %u ms\n", (radio->on_time));
	RTW_INFO("radio->tx_time :  %u ms\n", (radio->tx_time));
	RTW_INFO("radio->rx_time :  %u ms\n", (radio->rx_time));
	#endif /* CONFIG_RTW_WIFI_HAL_DEBUG */
	
	RTW_DBG(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);
	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), 
		output, sizeof(wifi_iface_stat) + sizeof(wifi_radio_stat_internal));
	if (unlikely(err))
		RTW_ERR(FUNC_NDEV_FMT"Vendor Command reply failed ret:%d \n"
			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
	rtw_mfree(output, sizeof(wifi_iface_stat) + sizeof(wifi_radio_stat_internal));
	return err;
}
static int rtw_cfgvendor_lstats_set_info(struct wiphy *wiphy,	
	struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	RTW_INFO("%s\n", __func__);
	return err;
}
static int rtw_cfgvendor_lstats_clear_info(struct wiphy *wiphy,	
	struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	RTW_INFO("%s\n", __func__);
	return err;
}
#endif /* CONFIG_RTW_CFGVEDNOR_LLSTATS */
#ifdef CONFIG_RTW_CFGVEDNOR_RSSIMONITOR
static int rtw_cfgvendor_set_rssi_monitor(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
        _adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));
        struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);

        struct recv_priv *precvpriv = &padapter->recvpriv;
	int err = 0, rem, type;
        const struct nlattr *iter;

        RTW_DBG(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);

	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);

		switch (type) {
        		case RSSI_MONITOR_ATTRIBUTE_MAX_RSSI:
                                pwdev_priv->rssi_monitor_max = (s8)nla_get_u32(iter);;
	        		break;
		        case RSSI_MONITOR_ATTRIBUTE_MIN_RSSI:
                                pwdev_priv->rssi_monitor_min = (s8)nla_get_u32(iter);
			        break;
        		case RSSI_MONITOR_ATTRIBUTE_START:
                                pwdev_priv->rssi_monitor_enable = (u8)nla_get_u32(iter);
	        		break;
		}
	}

	return err;
}

void rtw_cfgvendor_rssi_monitor_evt(_adapter *padapter) {
	struct wireless_dev *wdev =  padapter->rtw_wdev;
	struct wiphy *wiphy= wdev->wiphy;
        struct recv_priv *precvpriv = &padapter->recvpriv;
	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
        struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
	struct sk_buff *skb;
	u32 tot_len = NLMSG_DEFAULT_SIZE;
	gfp_t kflags;
        rssi_monitor_evt data ;
        s8 rssi = precvpriv->rssi;

        if (pwdev_priv->rssi_monitor_enable == 0 || check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
                return;

        if (rssi < pwdev_priv->rssi_monitor_max || rssi > pwdev_priv->rssi_monitor_min)
                return;

	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;

	/* Alloc the SKB for vendor_event */
	skb = rtw_cfg80211_vendor_event_alloc(wiphy, wdev, tot_len, GOOGLE_RSSI_MONITOR_EVENT, kflags);
	if (!skb) {
		goto exit;
	}

        _rtw_memset(&data, 0, sizeof(data));

        data.version = RSSI_MONITOR_EVT_VERSION;
        data.cur_rssi = rssi;
        _rtw_memcpy(data.BSSID, pcur_network->network.MacAddress, sizeof(mac_addr));

        nla_append(skb, sizeof(data), &data);

	rtw_cfg80211_vendor_event(skb, kflags);
exit:
	return;
}
#endif /* CONFIG_RTW_CFGVEDNOR_RSSIMONITR */

#ifdef CONFIG_RTW_CFGVENDOR_WIFI_LOGGER
static int rtw_cfgvendor_logger_start_logging(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = 0, rem, type;
	char ring_name[32] = {0};
	int log_level = 0, flags = 0, time_intval = 0, threshold = 0;
	const struct nlattr *iter;

	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);
		switch (type) {
			case LOGGER_ATTRIBUTE_RING_NAME:
				strncpy(ring_name, nla_data(iter),
					MIN(sizeof(ring_name) -1, nla_len(iter)));
				break;
			case LOGGER_ATTRIBUTE_LOG_LEVEL:
				log_level = nla_get_u32(iter);
				break;
			case LOGGER_ATTRIBUTE_RING_FLAGS:
				flags = nla_get_u32(iter);
				break;
			case LOGGER_ATTRIBUTE_LOG_TIME_INTVAL:
				time_intval = nla_get_u32(iter);
				break;
			case LOGGER_ATTRIBUTE_LOG_MIN_DATA_SIZE:
				threshold = nla_get_u32(iter);
				break;
			default:
				RTW_ERR("Unknown type: %d\n", type);
				ret = WIFI_ERROR_INVALID_ARGS;
				goto exit;
		}
	}

exit:
	return ret;
}
static int rtw_cfgvendor_logger_get_feature(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void *data, int len)
{
	int err = 0;
	u32 supported_features = 0;

	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), &supported_features, sizeof(supported_features));

	if (unlikely(err))
		RTW_ERR(FUNC_NDEV_FMT" Vendor Command reply failed ret:%d\n"
			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);

	return err;
}
static int rtw_cfgvendor_logger_get_version(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void *data, int len)
{
	_adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));
	HAL_DATA_TYPE *hal = GET_HAL_DATA(padapter);
	int ret = 0, rem, type;
	int buf_len = 1024;
	char *buf_ptr;
	const struct nlattr *iter;
	gfp_t kflags;

	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
	buf_ptr = kzalloc(buf_len, kflags);
	if (!buf_ptr) {
		RTW_ERR("failed to allocate the buffer for version n");
		ret = -ENOMEM;
		goto exit;
	}
	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);
		switch (type) {
			case LOGGER_ATTRIBUTE_GET_DRIVER:
				memcpy(buf_ptr, DRIVERVERSION, strlen(DRIVERVERSION)+1);
				break;
			case LOGGER_ATTRIBUTE_GET_FW:
				sprintf(buf_ptr, "v%d.%d", hal->firmware_version, hal->firmware_sub_version);
				break;
			default:
				RTW_ERR("Unknown type: %d\n", type);
				ret = -EINVAL;
				goto exit;
		}
	}
	if (ret < 0) {
		RTW_ERR("failed to get the version %d\n", ret);
		goto exit;
	}


	ret =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), buf_ptr, strlen(buf_ptr));
exit:
	kfree(buf_ptr);
	return ret;
}

static int rtw_cfgvendor_logger_get_ring_status(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = 0;
	int ring_id;
	char ring_buf_name[] = "RTW_RING_BUFFER";

	struct sk_buff *skb;
	wifi_ring_buffer_status ring_status;


	_rtw_memcpy(ring_status.name, ring_buf_name, strlen(ring_buf_name)+1);
	ring_status.ring_id = 1;
	/* Alloc the SKB for vendor_event */
	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
		sizeof(wifi_ring_buffer_status));
	if (!skb) {
		RTW_ERR("skb allocation is failed\n");
		ret = FAIL;
		goto exit;
	}

	nla_put_u32(skb, LOGGER_ATTRIBUTE_RING_NUM, 1);
	nla_put(skb, LOGGER_ATTRIBUTE_RING_STATUS, sizeof(wifi_ring_buffer_status),
				&ring_status);
	ret = cfg80211_vendor_cmd_reply(skb);

	if (ret) {
		RTW_ERR("Vendor Command reply failed ret:%d \n", ret);
	}
exit:
	return ret;
}

static int rtw_cfgvendor_logger_get_ring_data(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = 0, rem, type;
	char ring_name[32] = {0};
	const struct nlattr *iter;

	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);
		switch (type) {
			case LOGGER_ATTRIBUTE_RING_NAME:
				strncpy(ring_name, nla_data(iter),
					MIN(sizeof(ring_name) -1, nla_len(iter)));
				RTW_INFO(" %s LOGGER_ATTRIBUTE_RING_NAME : %s\n", __func__, ring_name);
				break;
			default:
				RTW_ERR("Unknown type: %d\n", type);
				return ret;
		}
	}


	return ret;
}

static int rtw_cfgvendor_logger_get_firmware_memory_dump(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = WIFI_ERROR_NOT_SUPPORTED;

	return ret;
}

static int rtw_cfgvendor_logger_start_pkt_fate_monitoring(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = WIFI_SUCCESS;

	return ret;
}

static int rtw_cfgvendor_logger_get_tx_pkt_fates(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = WIFI_SUCCESS;

	return ret;
}

static int rtw_cfgvendor_logger_get_rx_pkt_fates(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
	int ret = WIFI_SUCCESS;

	return ret;
}

#endif /* CONFIG_RTW_CFGVENDOR_WIFI_LOGGER */
#ifdef CONFIG_RTW_WIFI_HAL
#ifdef CONFIG_RTW_CFGVENDOR_RANDOM_MAC_OUI

#ifndef ETHER_ISMULTI
#define ETHER_ISMULTI(ea) (((const u8 *)(ea))[0] & 1)
#endif


static u8 null_addr[ETH_ALEN] = {0};
static void rtw_hal_random_gen_mac_addr(u8 *mac_addr)
{
	do {
		get_random_bytes(&mac_addr[3], ETH_ALEN-3);
		if (memcmp(mac_addr, null_addr, ETH_ALEN) != 0)
			break;
	} while(1);
}

void rtw_hal_pno_random_gen_mac_addr(PADAPTER adapter)
{
	u8 mac_addr[ETH_ALEN];
	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);

	memcpy(mac_addr, pwdev_priv->pno_mac_addr, ETH_ALEN);
	if (mac_addr[0] == 0xFF) return;
	rtw_hal_random_gen_mac_addr(mac_addr);
	memcpy(pwdev_priv->pno_mac_addr, mac_addr, ETH_ALEN);
#ifdef CONFIG_RTW_DEBUG
	print_hex_dump(KERN_DEBUG, "pno_mac_addr: ",
		       DUMP_PREFIX_OFFSET, 16, 1, pwdev_priv->pno_mac_addr,
		       ETH_ALEN, 1);
#endif
}

void rtw_hal_set_hw_mac_addr(PADAPTER adapter, u8 *mac_addr)
{
	rtw_ps_deny(adapter, PS_DENY_IOCTL);
	LeaveAllPowerSaveModeDirect(adapter);

#ifdef CONFIG_MI_WITH_MBSSID_CAM
	rtw_hal_change_macaddr_mbid(adapter, mac_addr);
#else
	rtw_hal_set_hwreg(adapter, HW_VAR_MAC_ADDR, mac_addr);
#endif
#ifdef CONFIG_RTW_DEBUG
	rtw_hal_dump_macaddr(RTW_DBGDUMP, adapter);
#endif
	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
}

static int rtw_cfgvendor_set_rand_mac_oui(struct wiphy *wiphy,
		struct wireless_dev *wdev, const void  *data, int len)
{
	int err = 0;
	PADAPTER adapter;
	void *devaddr;
	struct net_device *netdev;
	int type, mac_len;
	u8 pno_random_mac_oui[3];
	u8 mac_addr[ETH_ALEN] = {0};
	struct pwrctrl_priv *pwrctl;
	struct rtw_wdev_priv *pwdev_priv;

	type = nla_type(data);
	mac_len = nla_len(data);
	if (mac_len != 3) {
		RTW_ERR("%s oui len error %d != 3\n", __func__, mac_len);
		return -1;
	}

	if (type == ANDR_WIFI_ATTRIBUTE_RANDOM_MAC_OUI) {
		memcpy(pno_random_mac_oui, nla_data(data), 3);
		print_hex_dump(KERN_DEBUG, "pno_random_mac_oui: ",
			       DUMP_PREFIX_OFFSET, 16, 1, pno_random_mac_oui,
			       3, 1);

		if (ETHER_ISMULTI(pno_random_mac_oui)) {
			pr_err("%s: oui is multicast address\n", __func__);
			return -1;
		}

		adapter = wiphy_to_adapter(wiphy);
		if (adapter == NULL) {
			pr_err("%s: wiphy_to_adapter == NULL\n", __func__);
			return -1;
		}

		pwdev_priv = adapter_wdev_data(adapter);

		memcpy(mac_addr, pno_random_mac_oui, 3);
		rtw_hal_random_gen_mac_addr(mac_addr);
		memcpy(pwdev_priv->pno_mac_addr, mac_addr, ETH_ALEN);
#ifdef CONFIG_RTW_DEBUG
		print_hex_dump(KERN_DEBUG, "pno_mac_addr: ",
			       DUMP_PREFIX_OFFSET, 16, 1, pwdev_priv->pno_mac_addr,
			       ETH_ALEN, 1);
#endif
	} else {
		RTW_ERR("%s oui type error %x != 0x2\n", __func__, type);
		err = -1;
	}


	return err;
}

#endif


static int rtw_cfgvendor_set_nodfs_flag(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void *data, int len)
{
	int err = 0;	
	int type;
	u32 nodfs = 0;
	_adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));

	RTW_DBG(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);

	type = nla_type(data);
	if (type == ANDR_WIFI_ATTRIBUTE_NODFS_SET) {
		nodfs = nla_get_u32(data);
		adapter_to_dvobj(padapter)->nodfs = nodfs;
	} else {
		err = -EINVAL;
	}

	RTW_INFO("%s nodfs=%d, err=%d\n", __func__, nodfs, err);
	
	return err;
}

static int rtw_cfgvendor_set_country(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void  *data, int len)
{
#define CNTRY_BUF_SZ	4	/* Country string is 3 bytes + NUL */
	int err = 0, rem, type;
	char country_code[CNTRY_BUF_SZ] = {0};
	const struct nlattr *iter;
	_adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));

	RTW_DBG(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);

	nla_for_each_attr(iter, data, len, rem) {
		type = nla_type(iter);
		switch (type) {
			case ANDR_WIFI_ATTRIBUTE_COUNTRY:
				_rtw_memcpy(country_code, nla_data(iter),
					MIN(nla_len(iter), CNTRY_BUF_SZ));
				break;
			default:
				RTW_ERR("Unknown type: %d\n", type);
				return -EINVAL;
		}
	}

	RTW_INFO("%s country_code:\"%c%c\" \n", __func__, country_code[0], country_code[1]);

	rtw_set_country(padapter, country_code);

	return err;
}

static int rtw_cfgvendor_set_nd_offload(struct wiphy *wiphy,
	struct wireless_dev *wdev, const void *data, int len)
{
	int err = 0;	
	int type;
	u8 nd_en = 0;
	_adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));

	RTW_DBG(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);

	type = nla_type(data);
	if (type == ANDR_WIFI_ATTRIBUTE_ND_OFFLOAD_VALUE) {
		nd_en = nla_get_u8(data);
		/* ND has been enabled when wow is enabled */
	} else {
		err = -EINVAL;
	}

	RTW_INFO("%s nd_en=%d, err=%d\n", __func__, nd_en, err);
	
	return err;
}
#endif /* CONFIG_RTW_WIFI_HAL */

static const struct wiphy_vendor_command rtw_vendor_cmds[] = {
#if defined(GSCAN_SUPPORT) && 0
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_GET_CAPABILITIES
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_gscan_get_capabilities
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_SET_CONFIG
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_set_scan_cfg
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_SET_SCAN_CONFIG
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_set_batch_scan_cfg
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_ENABLE_GSCAN
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_initiate_gscan
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_enable_full_scan_result
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_SET_HOTLIST
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_hotlist_cfg
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_significant_change_cfg
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_GET_SCAN_RESULTS
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_gscan_get_batch_results
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = GSCAN_SUBCMD_GET_CHANNEL_LIST
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_gscan_get_channel_list
	},
#endif /* GSCAN_SUPPORT */
#if defined(RTT_SUPPORT) && 0
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = RTT_SUBCMD_SET_CONFIG
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_rtt_set_config
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = RTT_SUBCMD_CANCEL_CONFIG
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_rtt_cancel_config
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = RTT_SUBCMD_GETCAPABILITY
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_rtt_get_capability
	},
#endif /* RTT_SUPPORT */
#ifdef CONFIG_RTW_CFGVEDNOR_LLSTATS
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LSTATS_SUBCMD_GET_INFO
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_lstats_get_info
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LSTATS_SUBCMD_SET_INFO
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_lstats_set_info
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LSTATS_SUBCMD_CLEAR_INFO
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_lstats_clear_info
	},
#endif /* CONFIG_RTW_CFGVEDNOR_LLSTATS */
#ifdef CONFIG_RTW_CFGVEDNOR_RSSIMONITOR
        {
                {
                        .vendor_id = OUI_GOOGLE,
                        .subcmd = WIFI_SUBCMD_SET_RSSI_MONITOR
                },
                .flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
                .doit = rtw_cfgvendor_set_rssi_monitor
        },
#endif /* CONFIG_RTW_CFGVEDNOR_RSSIMONITOR */
#ifdef CONFIG_RTW_CFGVENDOR_WIFI_LOGGER
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_START_LOGGING
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_start_logging
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_GET_FEATURE
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_feature
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_GET_VER
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_version
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_GET_RING_STATUS
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_ring_status
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_GET_RING_DATA
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_ring_data
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_TRIGGER_MEM_DUMP
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_firmware_memory_dump
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_START_PKT_FATE_MONITORING
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_start_pkt_fate_monitoring
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_GET_TX_PKT_FATES
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_tx_pkt_fates
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = LOGGER_GET_RX_PKT_FATES
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_logger_get_rx_pkt_fates
	},	
#endif /* CONFIG_RTW_CFGVENDOR_WIFI_LOGGER */
#ifdef CONFIG_RTW_WIFI_HAL
#ifdef CONFIG_RTW_CFGVENDOR_RANDOM_MAC_OUI
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_set_rand_mac_oui
	},
#endif
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = WIFI_SUBCMD_NODFS_SET
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_set_nodfs_flag

	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = WIFI_SUBCMD_SET_COUNTRY_CODE
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_set_country
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = WIFI_SUBCMD_CONFIG_ND_OFFLOAD
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_set_nd_offload
	},
#endif /* CONFIG_RTW_WIFI_HAL */
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = WIFI_SUBCMD_GET_FEATURE_SET
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_get_feature_set
	},
	{
		{
			.vendor_id = OUI_GOOGLE,
			.subcmd = WIFI_SUBCMD_GET_FEATURE_SET_MATRIX
		},
		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
		.doit = rtw_cfgvendor_get_feature_set_matrix
	}
};

static const struct  nl80211_vendor_cmd_info rtw_vendor_events[] = {
#if defined(GSCAN_SUPPORT) && 0
	{ OUI_GOOGLE, GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS },
	{ OUI_GOOGLE, GSCAN_EVENT_HOTLIST_RESULTS_FOUND },
	{ OUI_GOOGLE, GSCAN_EVENT_SCAN_RESULTS_AVAILABLE },
	{ OUI_GOOGLE, GSCAN_EVENT_FULL_SCAN_RESULTS },
#endif /* GSCAN_SUPPORT */
#if defined(RTT_SUPPORT) && 0
	{ OUI_GOOGLE, RTT_EVENT_COMPLETE },
#endif /* RTT_SUPPORT */

#ifdef CONFIG_RTW_CFGVEDNOR_RSSIMONITOR
	{ OUI_GOOGLE, GOOGLE_RSSI_MONITOR_EVENT },
#endif /* RTW_CFGVEDNOR_RSSIMONITR */

#if defined(GSCAN_SUPPORT) && 0
	{ OUI_GOOGLE, GSCAN_EVENT_COMPLETE_SCAN },
	{ OUI_GOOGLE, GSCAN_EVENT_HOTLIST_RESULTS_LOST }
#endif /* GSCAN_SUPPORT */
};

int rtw_cfgvendor_attach(struct wiphy *wiphy)
{

	RTW_INFO("Register RTW cfg80211 vendor cmd(0x%x) interface\n", NL80211_CMD_VENDOR);

	wiphy->vendor_commands	= rtw_vendor_cmds;
	wiphy->n_vendor_commands = ARRAY_SIZE(rtw_vendor_cmds);
	wiphy->vendor_events	= rtw_vendor_events;
	wiphy->n_vendor_events	= ARRAY_SIZE(rtw_vendor_events);

	return 0;
}

int rtw_cfgvendor_detach(struct wiphy *wiphy)
{
	RTW_INFO("Vendor: Unregister RTW cfg80211 vendor interface\n");

	wiphy->vendor_commands  = NULL;
	wiphy->vendor_events    = NULL;
	wiphy->n_vendor_commands = 0;
	wiphy->n_vendor_events  = 0;

	return 0;
}
#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT) */

#endif /* CONFIG_IOCTL_CFG80211 */
                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/ifcfg-wlan0                                                                           0000644 0001750 0001750 00000000066 14214766567 014023  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 #DHCP client
DEVICE=wlan0
BOOTPROTO=dhcp
ONBOOT=yes                                                                                                                                                                                                                                                                                                                                                                                                                                                                          rtl8822bu/src/Makefile                                                                              0000755 0001750 0001750 00000215356 14214771213 013440  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
EXTRA_CFLAGS += -O1
#EXTRA_CFLAGS += -O3
#EXTRA_CFLAGS += -Wall
#EXTRA_CFLAGS += -Wextra
#EXTRA_CFLAGS += -Werror
#EXTRA_CFLAGS += -pedantic
#EXTRA_CFLAGS += -Wshadow -Wpointer-arith -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes

EXTRA_CFLAGS += -Wno-unused-variable
#EXTRA_CFLAGS += -Wno-unused-value
#EXTRA_CFLAGS += -Wno-unused-label
#EXTRA_CFLAGS += -Wno-unused-parameter
#EXTRA_CFLAGS += -Wno-unused-function
#EXTRA_CFLAGS += -Wno-unused
#EXTRA_CFLAGS += -Wno-uninitialized

GCC_VER_49 := $(shell echo `$(CC) -dumpversion | cut -f1-2 -d.` \>= 4.9 | bc )
ifeq ($(GCC_VER_49),1)
EXTRA_CFLAGS += -Wno-date-time	# Fix compile error && warning on gcc 4.9 and later
endif

EXTRA_CFLAGS += -I$(src)/include

EXTRA_LDFLAGS += --strip-debug

CONFIG_AUTOCFG_CP = n

########################## WIFI IC ############################
CONFIG_MULTIDRV = n
CONFIG_RTL8188E = n
CONFIG_RTL8812A = n
CONFIG_RTL8821A = n
CONFIG_RTL8192E = n
CONFIG_RTL8723B = n
CONFIG_RTL8814A = n
CONFIG_RTL8723C = n
CONFIG_RTL8188F = n
CONFIG_RTL8188GTV = n
CONFIG_RTL8822B = y
CONFIG_RTL8723D = n
CONFIG_RTL8821C = n
CONFIG_RTL8710B = n
CONFIG_RTL8192F = n
CONFIG_RTL8822C = n
CONFIG_RTL8814B = n
######################### Interface ###########################
CONFIG_USB_HCI = y
CONFIG_PCI_HCI = n
CONFIG_SDIO_HCI = n
CONFIG_GSPI_HCI = n
########################## Features ###########################
CONFIG_MP_INCLUDED = y
CONFIG_POWER_SAVING = y
CONFIG_IPS_MODE = default
CONFIG_LPS_MODE = default
CONFIG_USB_AUTOSUSPEND = n
CONFIG_HW_PWRP_DETECTION = n
CONFIG_BT_COEXIST = y
CONFIG_WAPI_SUPPORT = n
CONFIG_EFUSE_CONFIG_FILE = y
CONFIG_EXT_CLK = n
CONFIG_TRAFFIC_PROTECT = n
CONFIG_LOAD_PHY_PARA_FROM_FILE = y
CONFIG_TXPWR_BY_RATE = y
CONFIG_TXPWR_BY_RATE_EN = y
CONFIG_TXPWR_LIMIT = y
CONFIG_TXPWR_LIMIT_EN = n
CONFIG_RTW_CHPLAN = 0xFF
CONFIG_RTW_ADAPTIVITY_EN = disable
CONFIG_RTW_ADAPTIVITY_MODE = normal
CONFIG_SIGNAL_SCALE_MAPPING = n
CONFIG_80211W = y
CONFIG_REDUCE_TX_CPU_LOADING = n
CONFIG_BR_EXT = y
CONFIG_TDLS = n
CONFIG_WIFI_MONITOR = n
CONFIG_MCC_MODE = n
CONFIG_APPEND_VENDOR_IE_ENABLE = n
CONFIG_RTW_NAPI = y
CONFIG_RTW_GRO = y
CONFIG_RTW_NETIF_SG = y
CONFIG_RTW_IPCAM_APPLICATION = n
CONFIG_RTW_REPEATER_SON = n
CONFIG_RTW_WIFI_HAL = n
CONFIG_ICMP_VOQ = n
CONFIG_IP_R_MONITOR = n #arp VOQ and high rate
# user priority mapping rule : tos, dscp
CONFIG_RTW_UP_MAPPING_RULE = tos
# Enable VHT rate on 2.4G channel or not
CONFIG_RTW_VHT_2G4 = y

########################## Debug ###########################
CONFIG_RTW_DEBUG = y
# default log level is _DRV_INFO_ = 4,
# please refer to "How_to_set_driver_debug_log_level.doc" to set the available level.
CONFIG_RTW_LOG_LEVEL = 4

# enable /proc/net/rtlxxxx/ debug interfaces
CONFIG_PROC_DEBUG = y

######################## Wake On Lan ##########################
CONFIG_WOWLAN = n
#bit2: deauth, bit1: unicast, bit0: magic pkt.
CONFIG_WAKEUP_TYPE = 0x7
CONFIG_WOW_LPS_MODE = default
#bit0: disBBRF off, #bit1: Wireless remote controller (WRC)
CONFIG_SUSPEND_TYPE = 0
CONFIG_WOW_STA_MIX = n
CONFIG_GPIO_WAKEUP = n
CONFIG_WAKEUP_GPIO_IDX = default
CONFIG_HIGH_ACTIVE_DEV2HST = n
######### only for USB #########
CONFIG_ONE_PIN_GPIO = n
CONFIG_HIGH_ACTIVE_HST2DEV = n
CONFIG_PNO_SUPPORT = n
CONFIG_PNO_SET_DEBUG = n
CONFIG_AP_WOWLAN = n
######### Notify SDIO Host Keep Power During Syspend ##########
CONFIG_RTW_SDIO_PM_KEEP_POWER = y
###################### MP HW TX MODE FOR VHT #######################
CONFIG_MP_VHT_HW_TX_MODE = n
###################### Platform Related #######################
CONFIG_PLATFORM_I386_PC = y
CONFIG_PLATFORM_ANDROID_X86 = n
CONFIG_PLATFORM_ANDROID_INTEL_X86 = n
CONFIG_PLATFORM_JB_X86 = n
CONFIG_PLATFORM_ARM_S3C2K4 = n
CONFIG_PLATFORM_ARM_PXA2XX = n
CONFIG_PLATFORM_ARM_S3C6K4 = n
CONFIG_PLATFORM_MIPS_RMI = n
CONFIG_PLATFORM_RTD2880B = n
CONFIG_PLATFORM_MIPS_AR9132 = n
CONFIG_PLATFORM_RTK_DMP = n
CONFIG_PLATFORM_MIPS_PLM = n
CONFIG_PLATFORM_MSTAR389 = n
CONFIG_PLATFORM_MT53XX = n
CONFIG_PLATFORM_ARM_MX51_241H = n
CONFIG_PLATFORM_FS_MX61 = n
CONFIG_PLATFORM_ACTIONS_ATJ227X = n
CONFIG_PLATFORM_TEGRA3_CARDHU = n
CONFIG_PLATFORM_TEGRA4_DALMORE = n
CONFIG_PLATFORM_ARM_TCC8900 = n
CONFIG_PLATFORM_ARM_TCC8920 = n
CONFIG_PLATFORM_ARM_TCC8920_JB42 = n
CONFIG_PLATFORM_ARM_TCC8930_JB42 = n
CONFIG_PLATFORM_ARM_RK2818 = n
CONFIG_PLATFORM_ARM_RK3066 = n
CONFIG_PLATFORM_ARM_RK3188 = n
CONFIG_PLATFORM_ARM_RK3399 = n
CONFIG_PLATFORM_ARM_URBETTER = n
CONFIG_PLATFORM_ARM_TI_PANDA = n
CONFIG_PLATFORM_MIPS_JZ4760 = n
CONFIG_PLATFORM_DMP_PHILIPS = n
CONFIG_PLATFORM_MSTAR_TITANIA12 = n
CONFIG_PLATFORM_MSTAR = n
CONFIG_PLATFORM_SZEBOOK = n
CONFIG_PLATFORM_ARM_SUNxI = n
CONFIG_PLATFORM_ARM_SUN6I = n
CONFIG_PLATFORM_ARM_SUN7I = n
CONFIG_PLATFORM_ARM_SUN8I_W3P1 = n
CONFIG_PLATFORM_ARM_SUN8I_W5P1 = n
CONFIG_PLATFORM_ACTIONS_ATM702X = n
CONFIG_PLATFORM_ACTIONS_ATV5201 = n
CONFIG_PLATFORM_ACTIONS_ATM705X = n
CONFIG_PLATFORM_ARM_SUN50IW1P1 = n
CONFIG_PLATFORM_ARM_RTD299X = n
CONFIG_PLATFORM_ARM_LGE = n
CONFIG_PLATFORM_ARM_SPREADTRUM_6820 = n
CONFIG_PLATFORM_ARM_SPREADTRUM_8810 = n
CONFIG_PLATFORM_ARM_WMT = n
CONFIG_PLATFORM_TI_DM365 = n
CONFIG_PLATFORM_MOZART = n
CONFIG_PLATFORM_RTK119X = n
CONFIG_PLATFORM_RTK119X_AM = n
CONFIG_PLATFORM_RTK129X = n
CONFIG_PLATFORM_RTK390X = n
CONFIG_PLATFORM_NOVATEK_NT72668 = n
CONFIG_PLATFORM_HISILICON = n
CONFIG_PLATFORM_HISILICON_HI3798 = n
CONFIG_PLATFORM_NV_TK1 = n
CONFIG_PLATFORM_NV_TK1_UBUNTU = n
CONFIG_PLATFORM_RTL8197D = n
CONFIG_PLATFORM_AML_S905 = n
CONFIG_PLATFORM_ZTE_ZX296716 = n
########### CUSTOMER ################################
CONFIG_CUSTOMER_HUAWEI_GENERAL = n

CONFIG_DRVEXT_MODULE = n

export TopDIR ?= $(shell pwd)

########### COMMON  #################################
ifeq ($(CONFIG_GSPI_HCI), y)
HCI_NAME = gspi
endif

ifeq ($(CONFIG_SDIO_HCI), y)
HCI_NAME = sdio
endif

ifeq ($(CONFIG_USB_HCI), y)
HCI_NAME = usb
endif

ifeq ($(CONFIG_PCI_HCI), y)
HCI_NAME = pci
endif


_OS_INTFS_FILES :=	os_dep/osdep_service.o \
			os_dep/linux/os_intfs.o \
			os_dep/linux/$(HCI_NAME)_intf.o \
			os_dep/linux/$(HCI_NAME)_ops_linux.o \
			os_dep/linux/ioctl_linux.o \
			os_dep/linux/xmit_linux.o \
			os_dep/linux/mlme_linux.o \
			os_dep/linux/recv_linux.o \
			os_dep/linux/ioctl_cfg80211.o \
			os_dep/linux/rtw_cfgvendor.o \
			os_dep/linux/wifi_regd.o \
			os_dep/linux/rtw_android.o \
			os_dep/linux/rtw_proc.o \
			os_dep/linux/rtw_rhashtable.o

ifeq ($(CONFIG_MP_INCLUDED), y)
_OS_INTFS_FILES += os_dep/linux/ioctl_mp.o
endif

ifeq ($(CONFIG_SDIO_HCI), y)
_OS_INTFS_FILES += os_dep/linux/custom_gpio_linux.o
_OS_INTFS_FILES += os_dep/linux/$(HCI_NAME)_ops_linux.o
endif

ifeq ($(CONFIG_GSPI_HCI), y)
_OS_INTFS_FILES += os_dep/linux/custom_gpio_linux.o
_OS_INTFS_FILES += os_dep/linux/$(HCI_NAME)_ops_linux.o
endif


_HAL_INTFS_FILES :=	hal/hal_intf.o \
			hal/hal_com.o \
			hal/hal_com_phycfg.o \
			hal/hal_phy.o \
			hal/hal_dm.o \
			hal/hal_dm_acs.o \
			hal/hal_btcoex_wifionly.o \
			hal/hal_btcoex.o \
			hal/hal_mp.o \
			hal/hal_mcc.o \
			hal/hal_hci/hal_$(HCI_NAME).o \
			hal/led/hal_led.o \
			hal/led/hal_$(HCI_NAME)_led.o


EXTRA_CFLAGS += -I$(src)/platform
_PLATFORM_FILES := platform/platform_ops.o

EXTRA_CFLAGS += -I$(src)/hal/btc

########### HAL_RTL8188E #################################
ifeq ($(CONFIG_RTL8188E), y)

RTL871X = rtl8188e
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8189es
endif

ifeq ($(CONFIG_GSPI_HCI), y)
MODULE_NAME = 8189es
endif

ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8188eu
endif

ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8188ee
endif
EXTRA_CFLAGS += -DCONFIG_RTL8188E

_HAL_INTFS_FILES +=	hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8188EPwrSeq.o\
 					hal/$(RTL871X)/$(RTL871X)_xmit.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8188e_s_fw.o \
			hal/$(RTL871X)/hal8188e_t_fw.o \
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
ifeq ($(CONFIG_GSPI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
endif
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188E_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188E_PCIE.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188E_SDIO.o
endif

endif

########### HAL_RTL8192E #################################
ifeq ($(CONFIG_RTL8192E), y)

RTL871X = rtl8192e
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8192es
endif

ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8192eu
endif

ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8192ee
endif
EXTRA_CFLAGS += -DCONFIG_RTL8192E
_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8192EPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_xmit.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8192e_fw.o \
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
ifeq ($(CONFIG_GSPI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
endif
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8192E_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8192E_PCIE.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8192E_SDIO.o
endif

ifeq ($(CONFIG_BT_COEXIST), y)
_BTC_FILES += hal/btc/halbtc8192e1ant.o \
				hal/btc/halbtc8192e2ant.o
endif

endif

########### HAL_RTL8812A_RTL8821A #################################

ifneq ($(CONFIG_RTL8812A)_$(CONFIG_RTL8821A), n_n)

RTL871X = rtl8812a
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8812au
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8812ae
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8812as
endif

_HAL_INTFS_FILES +=  hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8812PwrSeq.o \
					hal/$(RTL871X)/Hal8821APwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_xmit.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
ifeq ($(CONFIG_GSPI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
endif
endif

ifeq ($(CONFIG_RTL8812A), y)
ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8812A_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8812A_PCIE.o
endif
endif
ifeq ($(CONFIG_RTL8821A), y)
ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8821A_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8821A_PCIE.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8821A_SDIO.o
endif
endif

ifeq ($(CONFIG_RTL8812A), y)
EXTRA_CFLAGS += -DCONFIG_RTL8812A
_HAL_INTFS_FILES +=	hal/rtl8812a/hal8812a_fw.o
endif

ifeq ($(CONFIG_RTL8821A), y)

ifeq ($(CONFIG_RTL8812A), n)

RTL871X = rtl8821a
ifeq ($(CONFIG_USB_HCI), y)
ifeq ($(CONFIG_BT_COEXIST), y)
MODULE_NAME := 8821au
else
MODULE_NAME := 8811au
endif
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME := 8821ae
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME := 8821as
endif

endif

EXTRA_CFLAGS += -DCONFIG_RTL8821A

_HAL_INTFS_FILES +=	hal/rtl8812a/hal8821a_fw.o
		
endif

ifeq ($(CONFIG_BT_COEXIST), y)
ifeq ($(CONFIG_RTL8812A), y)
_BTC_FILES += hal/btc/halbtc8812a1ant.o \
				hal/btc/halbtc8812a2ant.o
endif
ifeq ($(CONFIG_RTL8821A), y)
_BTC_FILES += hal/btc/halbtc8821a1ant.o \
				hal/btc/halbtc8821a2ant.o
endif
endif

endif

########### HAL_RTL8723B #################################
ifeq ($(CONFIG_RTL8723B), y)

RTL871X = rtl8723b
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8723bu
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8723be
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8723bs
endif

EXTRA_CFLAGS += -DCONFIG_RTL8723B

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8723BPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8723b_fw.o

_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8723B_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8723B_PCIE.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8723B_SDIO.o
endif

_BTC_FILES += hal/btc/halbtc8723bwifionly.o
ifeq ($(CONFIG_BT_COEXIST), y)
_BTC_FILES += hal/btc/halbtc8723b1ant.o \
				hal/btc/halbtc8723b2ant.o
endif

endif

########### HAL_RTL8814A #################################
ifeq ($(CONFIG_RTL8814A), y)
## ADD NEW VHT MP HW TX MODE ##
#EXTRA_CFLAGS += -DCONFIG_MP_VHT_HW_TX_MODE
#CONFIG_MP_VHT_HW_TX_MODE = y
##########################################
RTL871X = rtl8814a
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8814au
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8814ae
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8814as
endif

EXTRA_CFLAGS += -DCONFIG_RTL8814A

_HAL_INTFS_FILES +=  hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8814PwrSeq.o \
					hal/$(RTL871X)/$(RTL871X)_xmit.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8814a_fw.o


_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
ifeq ($(CONFIG_GSPI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
endif
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8814A_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8814A_PCIE.o
endif

ifeq ($(CONFIG_BT_COEXIST), y)
_BTC_FILES += hal/btc/halbtc8814a2ant.o
endif
endif

########### HAL_RTL8723C #################################
ifeq ($(CONFIG_RTL8723C), y)

RTL871X = rtl8703b
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8723cu
MODULE_SUB_NAME = 8703bu
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8723ce
MODULE_SUB_NAME = 8703be
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8723cs
MODULE_SUB_NAME = 8703bs
endif

EXTRA_CFLAGS += -DCONFIG_RTL8703B

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8703BPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8703b_fw.o

_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_recv.o

ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8703B_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8703B_PCIE.o
endif

ifeq ($(CONFIG_BT_COEXIST), y)
_BTC_FILES += hal/btc/halbtc8703b1ant.o
endif

endif

########### HAL_RTL8723D #################################
ifeq ($(CONFIG_RTL8723D), y)

RTL871X = rtl8723d
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8723du
MODULE_SUB_NAME = 8723du
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8723de
MODULE_SUB_NAME = 8723de
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8723ds
MODULE_SUB_NAME = 8723ds
endif

EXTRA_CFLAGS += -DCONFIG_RTL8723D

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8723DPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8723d_fw.o \
			hal/$(RTL871X)/$(RTL871X)_lps_poff.o


_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_recv.o

ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8723D_USB.o
endif
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8723D_PCIE.o
endif

ifeq ($(CONFIG_BT_COEXIST), y)
_BTC_FILES += hal/btc/halbtc8723d1ant.o \
				hal/btc/halbtc8723d2ant.o
endif

endif

########### HAL_RTL8188F #################################
ifeq ($(CONFIG_RTL8188F), y)

RTL871X = rtl8188f
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8188fu
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8188fe
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8189fs
endif

EXTRA_CFLAGS += -DCONFIG_RTL8188F

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8188FPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8188f_fw.o

_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188F_USB.o
endif

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188F_SDIO.o
endif

endif

########### HAL_RTL8188GTV #################################
ifeq ($(CONFIG_RTL8188GTV), y)

RTL871X = rtl8188gtv
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8188gtvu
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8189gtvs
endif

EXTRA_CFLAGS += -DCONFIG_RTL8188GTV

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8188GTVPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8188gtv_fw.o

_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o

ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188GTV_USB.o
endif

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8188GTV_SDIO.o
endif

endif

########### HAL_RTL8822B #################################
ifeq ($(CONFIG_RTL8822B), y)
RTL871X := rtl8822b
ifeq ($(CONFIG_USB_HCI), y)
ifeq ($(CONFIG_BT_COEXIST), n)
MODULE_NAME = 8812bu
else
MODULE_NAME = 88x2bu
endif
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 88x2be
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 88x2bs
endif

endif
########### HAL_RTL8821C #################################
ifeq ($(CONFIG_RTL8821C), y)
RTL871X := rtl8821c
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8821cu
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8821ce
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8821cs
endif

endif

########### HAL_RTL8710B #################################
ifeq ($(CONFIG_RTL8710B), y)

RTL871X = rtl8710b
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8710bu
MODULE_SUB_NAME = 8710bu
endif

EXTRA_CFLAGS += -DCONFIG_RTL8710B

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8710BPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8710b_fw.o \
			hal/$(RTL871X)/$(RTL871X)_lps_poff.o


_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_recv.o

_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES +=hal/efuse/$(RTL871X)/HalEfuseMask8710B_USB.o
endif

endif

########### HAL_RTL8192F #################################
ifeq ($(CONFIG_RTL8192F), y)

RTL871X = rtl8192f
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8192fu
MODULE_SUB_NAME = 8192fu
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8192fe
MODULE_SUB_NAME = 8192fe
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 8192fs
MODULE_SUB_NAME = 8192fs
endif

EXTRA_CFLAGS += -DCONFIG_RTL8192F

_HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
					hal/$(RTL871X)/Hal8192FPwrSeq.o\
					hal/$(RTL871X)/$(RTL871X)_sreset.o

_HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
			hal/$(RTL871X)/$(RTL871X)_dm.o \
			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
			hal/$(RTL871X)/$(RTL871X)_cmd.o \
			hal/$(RTL871X)/hal8192f_fw.o \
			hal/$(RTL871X)/$(RTL871X)_lps_poff.o


_HAL_INTFS_FILES +=	\
			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_led.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_xmit.o \
			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_recv.o
			
ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
else
_HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
endif

ifeq ($(CONFIG_SDIO_HCI), y)
_HAL_INTFS_FILES += hal/efuse/$(RTL871X)/HalEfuseMask8192F_SDIO.o
endif

ifeq ($(CONFIG_USB_HCI), y)
_HAL_INTFS_FILES += hal/efuse/$(RTL871X)/HalEfuseMask8192F_USB.o
endif

ifeq ($(CONFIG_PCI_HCI), y)
_HAL_INTFS_FILES += hal/efuse/$(RTL871X)/HalEfuseMask8192F_PCIE.o
endif

ifeq ($(CONFIG_BT_COEXIST), y)
_BTC_FILES += hal/btc/halbtccommon.o \
				hal/btc/halbtc8192f.o
endif

endif

########### HAL_RTL8822C #################################
ifeq ($(CONFIG_RTL8822C), y)
RTL871X := rtl8822c
ifeq ($(CONFIG_USB_HCI), y)
ifeq ($(CONFIG_BT_COEXIST), n)
MODULE_NAME = 8812cu
else
MODULE_NAME = 88x2cu
endif
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 88x2ce
endif
ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME = 88x2cs
endif

endif

########### HAL_RTL8814B #################################
ifeq ($(CONFIG_RTL8814B), y)
RTL871X := rtl8814b
ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME = 8814bu
endif
ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME = 8814be
endif

endif

########### AUTO_CFG  #################################

ifeq ($(CONFIG_AUTOCFG_CP), y)

ifeq ($(CONFIG_MULTIDRV), y)
$(shell cp $(TopDIR)/autoconf_multidrv_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
else
ifeq ($(CONFIG_RTL8188E)$(CONFIG_SDIO_HCI),yy)
$(shell cp $(TopDIR)/autoconf_rtl8189e_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
else ifeq ($(CONFIG_RTL8188F)$(CONFIG_SDIO_HCI),yy)
$(shell cp $(TopDIR)/autoconf_rtl8189f_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
else ifeq ($(CONFIG_RTL8723C),y)
$(shell cp $(TopDIR)/autoconf_rtl8723c_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
else
$(shell cp $(TopDIR)/autoconf_$(RTL871X)_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
endif
endif

endif

########### END OF PATH  #################################

ifeq ($(CONFIG_USB_HCI), y)
ifeq ($(CONFIG_USB_AUTOSUSPEND), y)
EXTRA_CFLAGS += -DCONFIG_USB_AUTOSUSPEND
endif
endif

ifeq ($(CONFIG_MP_INCLUDED), y)
#MODULE_NAME := $(MODULE_NAME)_mp
EXTRA_CFLAGS += -DCONFIG_MP_INCLUDED
endif

ifeq ($(CONFIG_POWER_SAVING), y)
ifneq ($(CONFIG_IPS_MODE), default)
EXTRA_CFLAGS += -DRTW_IPS_MODE=$(CONFIG_IPS_MODE)
endif
ifneq ($(CONFIG_LPS_MODE), default)
EXTRA_CFLAGS += -DRTW_LPS_MODE=$(CONFIG_LPS_MODE)
endif
ifneq ($(CONFIG_WOW_LPS_MODE), default)
EXTRA_CFLAGS += -DRTW_WOW_LPS_MODE=$(CONFIG_WOW_LPS_MODE)
endif
EXTRA_CFLAGS += -DCONFIG_POWER_SAVING
endif

ifeq ($(CONFIG_HW_PWRP_DETECTION), y)
EXTRA_CFLAGS += -DCONFIG_HW_PWRP_DETECTION
endif

ifeq ($(CONFIG_BT_COEXIST), y)
EXTRA_CFLAGS += -DCONFIG_BT_COEXIST
endif

ifeq ($(CONFIG_WAPI_SUPPORT), y)
EXTRA_CFLAGS += -DCONFIG_WAPI_SUPPORT
endif


ifeq ($(CONFIG_EFUSE_CONFIG_FILE), y)
EXTRA_CFLAGS += -DCONFIG_EFUSE_CONFIG_FILE

#EFUSE_MAP_PATH
USER_EFUSE_MAP_PATH ?=
ifneq ($(USER_EFUSE_MAP_PATH),)
EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"$(USER_EFUSE_MAP_PATH)\"
else ifeq ($(MODULE_NAME), 8189es)
EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_8189e.map\"
else ifeq ($(MODULE_NAME), 8723bs)
EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_8723bs.map\"
else
EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_$(MODULE_NAME).map\"
endif

#WIFIMAC_PATH
USER_WIFIMAC_PATH ?=
ifneq ($(USER_WIFIMAC_PATH),)
EXTRA_CFLAGS += -DWIFIMAC_PATH=\"$(USER_WIFIMAC_PATH)\"
else
EXTRA_CFLAGS += -DWIFIMAC_PATH=\"/data/wifimac.txt\"
endif

endif

ifeq ($(CONFIG_EXT_CLK), y)
EXTRA_CFLAGS += -DCONFIG_EXT_CLK
endif

ifeq ($(CONFIG_TRAFFIC_PROTECT), y)
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
endif

ifeq ($(CONFIG_LOAD_PHY_PARA_FROM_FILE), y)
EXTRA_CFLAGS += -DCONFIG_LOAD_PHY_PARA_FROM_FILE
#EXTRA_CFLAGS += -DREALTEK_CONFIG_PATH_WITH_IC_NAME_FOLDER
EXTRA_CFLAGS += -DREALTEK_CONFIG_PATH=\"/lib/firmware/\"
endif

ifeq ($(CONFIG_TXPWR_BY_RATE), n)
EXTRA_CFLAGS += -DCONFIG_TXPWR_BY_RATE=0
else ifeq ($(CONFIG_TXPWR_BY_RATE), y)
EXTRA_CFLAGS += -DCONFIG_TXPWR_BY_RATE=1
endif
ifeq ($(CONFIG_TXPWR_BY_RATE_EN), n)
EXTRA_CFLAGS += -DCONFIG_TXPWR_BY_RATE_EN=0
else ifeq ($(CONFIG_TXPWR_BY_RATE_EN), y)
EXTRA_CFLAGS += -DCONFIG_TXPWR_BY_RATE_EN=1
else ifeq ($(CONFIG_TXPWR_BY_RATE_EN), auto)
EXTRA_CFLAGS += -DCONFIG_TXPWR_BY_RATE_EN=2
endif

ifeq ($(CONFIG_TXPWR_LIMIT), n)
EXTRA_CFLAGS += -DCONFIG_TXPWR_LIMIT=0
else ifeq ($(CONFIG_TXPWR_LIMIT), y)
EXTRA_CFLAGS += -DCONFIG_TXPWR_LIMIT=1
endif
ifeq ($(CONFIG_TXPWR_LIMIT_EN), n)
EXTRA_CFLAGS += -DCONFIG_TXPWR_LIMIT_EN=0
else ifeq ($(CONFIG_TXPWR_LIMIT_EN), y)
EXTRA_CFLAGS += -DCONFIG_TXPWR_LIMIT_EN=1
else ifeq ($(CONFIG_TXPWR_LIMIT_EN), auto)
EXTRA_CFLAGS += -DCONFIG_TXPWR_LIMIT_EN=2
endif

ifneq ($(CONFIG_RTW_CHPLAN), 0xFF)
EXTRA_CFLAGS += -DCONFIG_RTW_CHPLAN=$(CONFIG_RTW_CHPLAN)
endif

ifeq ($(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY), y)
EXTRA_CFLAGS += -DCONFIG_CALIBRATE_TX_POWER_BY_REGULATORY
endif

ifeq ($(CONFIG_CALIBRATE_TX_POWER_TO_MAX), y)
EXTRA_CFLAGS += -DCONFIG_CALIBRATE_TX_POWER_TO_MAX
endif

ifeq ($(CONFIG_RTW_ADAPTIVITY_EN), disable)
EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_EN=0
else ifeq ($(CONFIG_RTW_ADAPTIVITY_EN), enable)
EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_EN=1
endif

ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), normal)
EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=0
else ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), carrier_sense)
EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=1
endif

ifeq ($(CONFIG_SIGNAL_SCALE_MAPPING), y)
EXTRA_CFLAGS += -DCONFIG_SIGNAL_SCALE_MAPPING
endif

ifeq ($(CONFIG_80211W), y)
EXTRA_CFLAGS += -DCONFIG_IEEE80211W
endif

ifeq ($(CONFIG_WOWLAN), y)
EXTRA_CFLAGS += -DCONFIG_WOWLAN -DRTW_WAKEUP_EVENT=$(CONFIG_WAKEUP_TYPE)
EXTRA_CFLAGS += -DRTW_SUSPEND_TYPE=$(CONFIG_SUSPEND_TYPE)
ifeq ($(CONFIG_WOW_STA_MIX), y)
EXTRA_CFLAGS += -DRTW_WOW_STA_MIX
endif
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_RTW_SDIO_PM_KEEP_POWER
endif
endif

ifeq ($(CONFIG_AP_WOWLAN), y)
EXTRA_CFLAGS += -DCONFIG_AP_WOWLAN
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_RTW_SDIO_PM_KEEP_POWER
endif
endif

ifeq ($(CONFIG_PNO_SUPPORT), y)
EXTRA_CFLAGS += -DCONFIG_PNO_SUPPORT
ifeq ($(CONFIG_PNO_SET_DEBUG), y)
EXTRA_CFLAGS += -DCONFIG_PNO_SET_DEBUG
endif
endif

ifeq ($(CONFIG_GPIO_WAKEUP), y)
EXTRA_CFLAGS += -DCONFIG_GPIO_WAKEUP
ifeq ($(CONFIG_ONE_PIN_GPIO), y)
EXTRA_CFLAGS += -DCONFIG_RTW_ONE_PIN_GPIO
endif
ifeq ($(CONFIG_HIGH_ACTIVE_DEV2HST), y)
EXTRA_CFLAGS += -DHIGH_ACTIVE_DEV2HST=1
else
EXTRA_CFLAGS += -DHIGH_ACTIVE_DEV2HST=0
endif
endif

ifeq ($(CONFIG_HIGH_ACTIVE_HST2DEV), y)
EXTRA_CFLAGS += -DHIGH_ACTIVE_HST2DEV=1
else
EXTRA_CFLAGS += -DHIGH_ACTIVE_HST2DEV=0
endif

ifneq ($(CONFIG_WAKEUP_GPIO_IDX), default)
EXTRA_CFLAGS += -DWAKEUP_GPIO_IDX=$(CONFIG_WAKEUP_GPIO_IDX)
endif

ifeq ($(CONFIG_RTW_SDIO_PM_KEEP_POWER), y)
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_RTW_SDIO_PM_KEEP_POWER
endif
endif

ifeq ($(CONFIG_REDUCE_TX_CPU_LOADING), y)
EXTRA_CFLAGS += -DCONFIG_REDUCE_TX_CPU_LOADING
endif

ifeq ($(CONFIG_BR_EXT), y)
BR_NAME = br0
EXTRA_CFLAGS += -DCONFIG_BR_EXT
EXTRA_CFLAGS += '-DCONFIG_BR_EXT_BRNAME="'$(BR_NAME)'"'
endif


ifeq ($(CONFIG_TDLS), y)
EXTRA_CFLAGS += -DCONFIG_TDLS
endif

ifeq ($(CONFIG_WIFI_MONITOR), y)
EXTRA_CFLAGS += -DCONFIG_WIFI_MONITOR
endif

ifeq ($(CONFIG_MCC_MODE), y)
EXTRA_CFLAGS += -DCONFIG_MCC_MODE
endif

ifeq ($(CONFIG_RTW_NAPI), y)
EXTRA_CFLAGS += -DCONFIG_RTW_NAPI
endif

ifeq ($(CONFIG_RTW_GRO), y)
EXTRA_CFLAGS += -DCONFIG_RTW_GRO
endif

ifeq ($(CONFIG_RTW_REPEATER_SON), y)
EXTRA_CFLAGS += -DCONFIG_RTW_REPEATER_SON
endif

ifeq ($(CONFIG_RTW_IPCAM_APPLICATION), y)
EXTRA_CFLAGS += -DCONFIG_RTW_IPCAM_APPLICATION
ifeq ($(CONFIG_WIFI_MONITOR), n)
EXTRA_CFLAGS += -DCONFIG_WIFI_MONITOR
endif
endif

ifeq ($(CONFIG_RTW_NETIF_SG), y)
EXTRA_CFLAGS += -DCONFIG_RTW_NETIF_SG
endif

ifeq ($(CONFIG_ICMP_VOQ), y)
EXTRA_CFLAGS += -DCONFIG_ICMP_VOQ
endif

ifeq ($(CONFIG_IP_R_MONITOR), y)
EXTRA_CFLAGS += -DCONFIG_IP_R_MONITOR
endif

ifeq ($(CONFIG_RTW_WIFI_HAL), y)
#EXTRA_CFLAGS += -DCONFIG_RTW_WIFI_HAL_DEBUG
EXTRA_CFLAGS += -DCONFIG_RTW_WIFI_HAL
EXTRA_CFLAGS += -DCONFIG_RTW_CFGVEDNOR_LLSTATS
EXTRA_CFLAGS += -DCONFIG_RTW_CFGVENDOR_RANDOM_MAC_OUI
EXTRA_CFLAGS += -DCONFIG_RTW_CFGVEDNOR_RSSIMONITOR
EXTRA_CFLAGS += -DCONFIG_RTW_CFGVENDOR_WIFI_LOGGER
endif

ifeq ($(CONFIG_MP_VHT_HW_TX_MODE), y)
EXTRA_CFLAGS += -DCONFIG_MP_VHT_HW_TX_MODE
ifeq ($(CONFIG_PLATFORM_I386_PC), y)
## For I386 X86 ToolChain use Hardware FLOATING
EXTRA_CFLAGS += -mhard-float
else
## For ARM ToolChain use Hardware FLOATING
EXTRA_CFLAGS += -mfloat-abi=hard
endif
endif

ifeq ($(CONFIG_APPEND_VENDOR_IE_ENABLE), y)
EXTRA_CFLAGS += -DCONFIG_APPEND_VENDOR_IE_ENABLE
endif

ifeq ($(CONFIG_RTW_DEBUG), y)
EXTRA_CFLAGS += -DCONFIG_RTW_DEBUG
EXTRA_CFLAGS += -DRTW_LOG_LEVEL=$(CONFIG_RTW_LOG_LEVEL)
endif

ifeq ($(CONFIG_PROC_DEBUG), y)
EXTRA_CFLAGS += -DCONFIG_PROC_DEBUG
endif

ifeq ($(CONFIG_RTW_UP_MAPPING_RULE), dscp)
EXTRA_CFLAGS += -DCONFIG_RTW_UP_MAPPING_RULE=1
else
EXTRA_CFLAGS += -DCONFIG_RTW_UP_MAPPING_RULE=0
endif

EXTRA_CFLAGS += -DDM_ODM_SUPPORT_TYPE=0x04

ifeq ($(CONFIG_RTW_VHT_2G4), y)
EXTRA_CFLAGS += -DRTW_VHT_2G4=1
else
EXTRA_CFLAGS += -DRTW_VHT_2G4=0
endif

ifeq ($(CONFIG_PLATFORM_I386_PC), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
ARCH ?= $(SUBARCH)
CROSS_COMPILE ?=
KVER  := $(shell uname -r)
KSRC := /lib/modules/$(KVER)/build
MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
INSTALL_PREFIX :=
STAGINGMODDIR := /lib/modules/$(KVER)/kernel/drivers/staging
endif

ifeq ($(CONFIG_PLATFORM_NV_TK1), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_NV_TK1
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_P2P_IPS -DCONFIG_PLATFORM_ANDROID
# Enable this for Android 5.0
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK
EXTRA_CFLAGS += -DRTW_VENDOR_EXT_SUPPORT
EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
ARCH ?= arm

CROSS_COMPILE := /mnt/newdisk/android_sdk/nvidia_tk1/android_L/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin/arm-eabi-
KSRC :=/mnt/newdisk/android_sdk/nvidia_tk1/android_L/out/target/product/shieldtablet/obj/KERNEL/
MODULE_NAME = wlan
endif

ifeq ($(CONFIG_PLATFORM_NV_TK1_UBUNTU), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_NV_TK1
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT

ARCH ?= arm

CROSS_COMPILE ?=
KVER := $(shell uname -r)
KSRC := /lib/modules/$(KVER)/build
MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
INSTALL_PREFIX :=
endif

ifeq ($(CONFIG_PLATFORM_ACTIONS_ATM702X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ACTIONS_ATM702X
#ARCH := arm
ARCH := $(R_ARCH)
#CROSS_COMPILE := arm-none-linux-gnueabi-
CROSS_COMPILE := $(R_CROSS_COMPILE)
KVER:= 3.4.0
#KSRC := ../../../../build/out/kernel
KSRC := $(KERNEL_BUILD_PATH)
MODULE_NAME :=wlan
endif


ifeq ($(CONFIG_PLATFORM_ACTIONS_ATM705X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
#EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
# default setting for Android 4.1, 4.2, 4.3, 4.4
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ACTIONS_ATM705X
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT

# Enable this for Android 5.0
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
_PLATFORM_FILES += platform/platform_arm_act_sdio.o
endif

ARCH := arm
CROSS_COMPILE := /opt/arm-2011.09/bin/arm-none-linux-gnueabi-
KSRC := /home/android_sdk/Action-semi/705a_android_L/android/kernel
endif

ifeq ($(CONFIG_PLATFORM_ARM_SUN50IW1P1), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN50IW1P1
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_RESUME_IN_WORKQUEUE
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS

# Enable this for Android 5.0
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_PLATFORM_FILES += platform/platform_ARM_SUN50IW1P1_sdio.o
endif

ARCH := arm64
# ===Cross compile setting for Android 5.1(64) SDK ===
CROSS_COMPILE := /home/android_sdk/Allwinner/a64/android-51/lichee/out/sun50iw1p1/android/common/buildroot/external-toolchain/bin/aarch64-linux-gnu-
KSRC :=/home/android_sdk/Allwinner/a64/android-51/lichee/linux-3.10/
endif

ifeq ($(CONFIG_PLATFORM_TI_AM3517), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_SHUTTLE
CROSS_COMPILE := arm-eabi-
KSRC := $(shell pwd)/../../../Android/kernel
ARCH := arm
endif

ifeq ($(CONFIG_PLATFORM_MSTAR_TITANIA12), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR -DCONFIG_PLATFORM_MSTAR_TITANIA12
ARCH:=mips
CROSS_COMPILE:= /usr/src/Mstar_kernel/mips-4.3/bin/mips-linux-gnu-
KVER:= 2.6.28.9
KSRC:= /usr/src/Mstar_kernel/2.6.28.9/
endif

ifeq ($(CONFIG_PLATFORM_MSTAR), y)
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_MSTAR
EXTRA_CFLAGS += -DCONFIG_PLATFORM_MSTAR_HIGH
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX -DCONFIG_FIX_NR_BULKIN_BUFFER
endif
ARCH:=arm
CROSS_COMPILE:= /usr/src/bin/arm-none-linux-gnueabi-
KVER:= 3.1.10
KSRC:= /usr/src/Mstar_kernel/3.1.10/
endif

ifeq ($(CONFIG_PLATFORM_ANDROID_X86), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
ARCH := $(SUBARCH)
CROSS_COMPILE := /media/DATA-2/android-x86/ics-x86_20120130/prebuilt/linux-x86/toolchain/i686-unknown-linux-gnu-4.2.1/bin/i686-unknown-linux-gnu-
KSRC := /media/DATA-2/android-x86/ics-x86_20120130/out/target/product/generic_x86/obj/kernel
MODULE_NAME :=wlan
endif

ifeq ($(CONFIG_PLATFORM_ANDROID_INTEL_X86), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ANDROID_INTEL_X86
EXTRA_CFLAGS += -DCONFIG_PLATFORM_INTEL_BYT
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_SKIP_SIGNAL_SCALE_MAPPING
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_RESUME_IN_WORKQUEUE
endif
endif

ifeq ($(CONFIG_PLATFORM_JB_X86), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
ARCH := $(SUBARCH)
CROSS_COMPILE := /home/android_sdk/android-x86_JB/prebuilts/gcc/linux-x86/x86/i686-linux-android-4.7/bin/i686-linux-android-
KSRC := /home/android_sdk/android-x86_JB/out/target/product/x86/obj/kernel/
MODULE_NAME :=wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_PXA2XX), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE := arm-none-linux-gnueabi-
KVER  := 2.6.34.1
KSRC ?= /usr/src/linux-2.6.34.1
endif

ifeq ($(CONFIG_PLATFORM_ARM_S3C2K4), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE := arm-linux-
KVER  := 2.6.24.7_$(ARCH)
KSRC := /usr/src/kernels/linux-$(KVER)
endif

ifeq ($(CONFIG_PLATFORM_ARM_S3C6K4), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE := arm-none-linux-gnueabi-
KVER  := 2.6.34.1
KSRC ?= /usr/src/linux-2.6.34.1
endif

ifeq ($(CONFIG_PLATFORM_RTD2880B), y)
EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTD2880B
ARCH:=
CROSS_COMPILE:=
KVER:=
KSRC:=
endif

ifeq ($(CONFIG_PLATFORM_MIPS_RMI), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH:=mips
CROSS_COMPILE:=mipsisa32r2-uclibc-
KVER:=
KSRC:= /root/work/kernel_realtek
endif

ifeq ($(CONFIG_PLATFORM_MIPS_PLM), y)
EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
ARCH:=mips
CROSS_COMPILE:=mipsisa32r2-uclibc-
KVER:=
KSRC:= /root/work/kernel_realtek
endif

ifeq ($(CONFIG_PLATFORM_MSTAR389), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR389
ARCH:=mips
CROSS_COMPILE:= mips-linux-gnu-
KVER:= 2.6.28.10
KSRC:= /home/mstar/mstar_linux/2.6.28.9/
endif

ifeq ($(CONFIG_PLATFORM_MIPS_AR9132), y)
EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
ARCH := mips
CROSS_COMPILE := mips-openwrt-linux-
KSRC := /home/alex/test_openwrt/tmp/linux-2.6.30.9
endif

ifeq ($(CONFIG_PLATFORM_DMP_PHILIPS), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DRTK_DMP_PLATFORM
ARCH := mips
#CROSS_COMPILE:=/usr/local/msdk-4.3.6-mips-EL-2.6.12.6-0.9.30.3/bin/mipsel-linux-
CROSS_COMPILE:=/usr/local/toolchain_mipsel/bin/mipsel-linux-
KSRC ?=/usr/local/Jupiter/linux-2.6.12
endif

ifeq ($(CONFIG_PLATFORM_RTK_DMP), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DRTK_DMP_PLATFORM  -DCONFIG_WIRELESS_EXT
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
_PLATFORM_FILES += platform/platform_RTK_DMP_usb.o
endif
ARCH:=mips
CROSS_COMPILE:=mipsel-linux-
KVER:=
KSRC ?= /usr/src/DMP_Kernel/jupiter/linux-2.6.12
endif

ifeq ($(CONFIG_PLATFORM_MT53XX), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MT53XX
ARCH:= arm
CROSS_COMPILE:= arm11_mtk_le-
KVER:= 2.6.27
KSRC?= /proj/mtk00802/BD_Compare/BDP/Dev/BDP_V301/BDP_Linux/linux-2.6.27
endif

ifeq ($(CONFIG_PLATFORM_ARM_MX51_241H), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_WISTRON_PLATFORM
ARCH := arm
CROSS_COMPILE := /opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-
KVER  := 2.6.31
KSRC ?= /lib/modules/2.6.31-770-g0e46b52/source
endif

ifeq ($(CONFIG_PLATFORM_FS_MX61), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE := /home/share/CusEnv/FreeScale/arm-eabi-4.4.3/bin/arm-eabi-
KSRC ?= /home/share/CusEnv/FreeScale/FS_kernel_env
endif



ifeq ($(CONFIG_PLATFORM_ACTIONS_ATJ227X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ACTIONS_ATJ227X
ARCH := mips
CROSS_COMPILE := /home/cnsd4/project/actions/tools-2.6.27/bin/mipsel-linux-gnu-
KVER  := 2.6.27
KSRC := /home/cnsd4/project/actions/linux-2.6.27.28
endif

ifeq ($(CONFIG_PLATFORM_TI_DM365), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_TI_DM365
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_RX
EXTRA_CFLAGS += -DCONFIG_SINGLE_XMIT_BUF -DCONFIG_SINGLE_RECV_BUF
ARCH := arm
#CROSS_COMPILE := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/arm/v5t_le/bin/arm_v5t_le-
#KSRC := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/lsp/ti-davinci/linux-dm365
CROSS_COMPILE := /opt/montavista/pro5.0/devkit/arm/v5t_le/bin/arm-linux-
KSRC:= /home/vivotek/lsp/DM365/kernel_platform/kernel/linux-2.6.18
KERNELOUTPUT := ${PRODUCTDIR}/tmp
KVER  := 2.6.18
endif

ifeq ($(CONFIG_PLATFORM_MOZART), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MOZART
ARCH := arm
CROSS_COMPILE := /home/vivotek/lsp/mozart3v2/Mozart3e_Toolchain/build_arm_nofpu/usr/bin/arm-linux-
KVER  := $(shell uname -r)
KSRC:= /opt/Vivotek/lsp/mozart3v2/kernel_platform/kernel/mozart_kernel-1.17
KERNELOUTPUT := /home/pink/sample/ODM/IP8136W-VINT/tmp/kernel
endif

ifeq ($(CONFIG_PLATFORM_TEGRA3_CARDHU), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
ARCH := arm
CROSS_COMPILE := /home/android_sdk/nvidia/tegra-16r3-partner-android-4.1_20120723/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
KSRC := /home/android_sdk/nvidia/tegra-16r3-partner-android-4.1_20120723/out/target/product/cardhu/obj/KERNEL
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_TEGRA4_DALMORE), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
ARCH := arm
CROSS_COMPILE := /home/android_sdk/nvidia/tegra-17r9-partner-android-4.2-dalmore_20130131/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
KSRC := /home/android_sdk/nvidia/tegra-17r9-partner-android-4.2-dalmore_20130131/out/target/product/dalmore/obj/KERNEL
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_TCC8900), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE := /home/android_sdk/Telechips/SDK_2304_20110613/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
KSRC := /home/android_sdk/Telechips/SDK_2304_20110613/kernel
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_TCC8920), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE := /home/android_sdk/Telechips/v12.06_r1-tcc-android-4.0.4/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
KSRC := /home/android_sdk/Telechips/v12.06_r1-tcc-android-4.0.4/kernel
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_TCC8920_JB42), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
ARCH := arm
CROSS_COMPILE := /home/android_sdk/Telechips/v13.03_r1-tcc-android-4.2.2_ds_patched/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
KSRC := /home/android_sdk/Telechips/v13.03_r1-tcc-android-4.2.2_ds_patched/kernel
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_RK2818), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS
ARCH := arm
CROSS_COMPILE := /usr/src/release_fae_version/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
KSRC := /usr/src/release_fae_version/kernel25_A7_281x
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_RK3188), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS
# default setting for Android 4.1, 4.2, 4.3, 4.4
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
# default setting for Power control
EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN
# default setting for Special function
ARCH := arm
CROSS_COMPILE := /home/android_sdk/Rockchip/Rk3188/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
KSRC := /home/android_sdk/Rockchip/Rk3188/kernel
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_RK3066), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_RK3066
EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN
endif
EXTRA_CFLAGS += -fno-pic
ARCH := arm
CROSS_COMPILE := /home/android_sdk/Rockchip/rk3066_20130607/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6/bin/arm-linux-androideabi-
#CROSS_COMPILE := /home/android_sdk/Rockchip/Rk3066sdk/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6/bin/arm-linux-androideabi-
KSRC := /home/android_sdk/Rockchip/Rk3066sdk/kernel
MODULE_NAME :=wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_RK3399), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ROCKCHIPS
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ROCKCHIPS_RK3399
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -Wno-error=date-time

# default setting for Android
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ANDROID
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
# default setting for Android 5.0 and later
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

# default setting for Special function
EXTRA_CFLAGS += -DCONFIG_P2P_IPS
EXTRA_CFLAGS += -DCONFIG_RESUME_IN_WORKQUEUE

ARCH ?= arm64
CROSS_COMPILE ?= /rk3328_box_android_8.0_pro/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-
KSRC ?= /rk3328_box_android_8.0_pro/kernel

ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
_PLATFORM_FILES += platform/platform_rockchips_sdio.o
ifeq ($(CONFIG_RTL8822B), y)
USER_MODULE_NAME := 8822bs
endif
endif

endif

ifeq ($(CONFIG_PLATFORM_ARM_URBETTER), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN #-DCONFIG_MINIMAL_MEMORY_USAGE
ARCH := arm
CROSS_COMPILE := /media/DATA-1/urbetter/arm-2009q3/bin/arm-none-linux-gnueabi-
KSRC := /media/DATA-1/urbetter/ics-urbetter/kernel
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_ARM_TI_PANDA), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN #-DCONFIG_MINIMAL_MEMORY_USAGE
ARCH := arm
#CROSS_COMPILE := /media/DATA-1/aosp/ics-aosp_20111227/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
#KSRC := /media/DATA-1/aosp/android-omap-panda-3.0_20120104
CROSS_COMPILE := /media/DATA-1/android-4.0/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
KSRC := /media/DATA-1/android-4.0/panda_kernel/omap
MODULE_NAME := wlan
endif

ifeq ($(CONFIG_PLATFORM_MIPS_JZ4760), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_MINIMAL_MEMORY_USAGE
ARCH ?= mips
CROSS_COMPILE ?= /mnt/sdb5/Ingenic/Umido/mips-4.3/bin/mips-linux-gnu-
KSRC ?= /mnt/sdb5/Ingenic/Umido/kernel
endif

ifeq ($(CONFIG_PLATFORM_SZEBOOK), y)
EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
ARCH:=arm
CROSS_COMPILE:=/opt/crosstool2/bin/armeb-unknown-linux-gnueabi-
KVER:= 2.6.31.6
KSRC:= ../code/linux-2.6.31.6-2020/
endif

ifeq ($(CONFIG_PLATFORM_ARM_SUNxI), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUNxI
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT

EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
# default setting for A10-EVB mmc0
#EXTRA_CFLAGS += -DCONFIG_WITS_EVB_V13
_PLATFORM_FILES += platform/platform_ARM_SUNxI_sdio.o
endif

ARCH := arm
#CROSS_COMPILE := arm-none-linux-gnueabi-
CROSS_COMPILE=/home/android_sdk/Allwinner/a10/android-jb42/lichee-jb42/buildroot/output/external-toolchain/bin/arm-none-linux-gnueabi-
KVER  := 3.0.8
#KSRC:= ../lichee/linux-3.0/
KSRC=/home/android_sdk/Allwinner/a10/android-jb42/lichee-jb42/linux-3.0
endif

ifeq ($(CONFIG_PLATFORM_ARM_SUN6I), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN6I
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2, 4.3, 4.4
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS +=  -DCONFIG_QOS_OPTIMIZATION

EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
# default setting for A31-EVB mmc0
EXTRA_CFLAGS += -DCONFIG_A31_EVB
_PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
endif

ARCH := arm
#Android-JB42
#CROSS_COMPILE := /home/android_sdk/Allwinner/a31/android-jb42/lichee/buildroot/output/external-toolchain/bin/arm-linux-gnueabi-
#KSRC :=/home/android_sdk/Allwinner/a31/android-jb42/lichee/linux-3.3
#ifeq ($(CONFIG_USB_HCI), y)
#MODULE_NAME := 8188eu_sw
#endif
# ==== Cross compile setting for kitkat-a3x_v4.5 =====
CROSS_COMPILE := /home/android_sdk/Allwinner/a31/kitkat-a3x_v4.5/lichee/buildroot/output/external-toolchain/bin/arm-linux-gnueabi-
KSRC :=/home/android_sdk/Allwinner/a31/kitkat-a3x_v4.5/lichee/linux-3.3
endif

ifeq ($(CONFIG_PLATFORM_ARM_SUN7I), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN7I
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2, 4.3, 4.4
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS +=  -DCONFIG_QOS_OPTIMIZATION

EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
endif

ARCH := arm
# ===Cross compile setting for Android 4.2 SDK ===
#CROSS_COMPILE := /home/android_sdk/Allwinner/a20_evb/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
#KSRC := /home/android_sdk/Allwinner/a20_evb/lichee/linux-3.3
# ==== Cross compile setting for Android 4.3 SDK =====
#CROSS_COMPILE := /home/android_sdk/Allwinner/a20/android-jb43/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
#KSRC := /home/android_sdk/Allwinner/a20/android-jb43/lichee/linux-3.4
# ==== Cross compile setting for kitkat-a20_v4.4 =====
CROSS_COMPILE := /home/android_sdk/Allwinner/a20/kitkat-a20_v4.4/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
KSRC := /home/android_sdk/Allwinner/a20/kitkat-a20_v4.4/lichee/linux-3.4
endif

ifeq ($(CONFIG_PLATFORM_ARM_SUN8I_W3P1), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN8I
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN8I_W3P1
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT

EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
endif

ARCH := arm
# ===Cross compile setting for Android 4.2 SDK ===
#CROSS_COMPILE := /home/android_sdk/Allwinner/a23/android-jb42/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
#KSRC :=/home/android_sdk/Allwinner/a23/android-jb42/lichee/linux-3.4
# ===Cross compile setting for Android 4.4 SDK ===
CROSS_COMPILE := /home/android_sdk/Allwinner/a23/android-kk44/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
KSRC :=/home/android_sdk/Allwinner/a23/android-kk44/lichee/linux-3.4
endif

ifeq ($(CONFIG_PLATFORM_ARM_SUN8I_W5P1), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN8I
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN8I_W5P1
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT

# Enable this for Android 5.0
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
endif

ARCH := arm
# ===Cross compile setting for Android L SDK ===
CROSS_COMPILE := /home/android_sdk/Allwinner/a33/android-L/lichee/out/sun8iw5p1/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
KSRC :=/home/android_sdk/Allwinner/a33/android-L/lichee/linux-3.4
endif

ifeq ($(CONFIG_PLATFORM_ACTIONS_ATV5201), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ACTIONS_ATV5201
EXTRA_CFLAGS += -DCONFIG_SDIO_DISABLE_RXFIFO_POLLING_LOOP
ARCH := mips
CROSS_COMPILE := mipsel-linux-gnu-
KVER  := $(KERNEL_VER)
KSRC:= $(CFGDIR)/../../kernel/linux-$(KERNEL_VER)
endif

ifeq ($(CONFIG_PLATFORM_ARM_RTD299X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
ifeq ($(CONFIG_ANDROID), y)
# Enable this for Android 5.0
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK
endif
#ARCH, CROSS_COMPILE, KSRC,and  MODDESTDIR are provided by external makefile
INSTALL_PREFIX :=
endif

ifeq ($(CONFIG_PLATFORM_ARM_RTD299X_LG), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DRTW_P2P_GROUP_INTERFACE=1
EXTRA_CFLAGS += -DCONFIG_IFACE_NUMBER=3
#EXTRA_CFLAGS += -DCONFIG_FIX_HWPORT
EXTRA_CFLAGS += -DLGE_PRIVATE
EXTRA_CFLAGS += -DPURE_SUPPLICANT
EXTRA_CFLAGS += -DCONFIG_CUSTOMIZED_COUNTRY_CHPLAN_MAP -DCONFIG_RTW_IOCTL_SET_COUNTRY
EXTRA_CFLAGS += -DDBG_RX_DFRAME_RAW_DATA
EXTRA_CFLAGS += -DRTW_REDUCE_SCAN_SWITCH_CH_TIME
ARCH ?= arm
KVER ?=

ifneq ($(PLATFORM), WEBOS)
$(info PLATFORM is empty)
CROSS_COMPILE ?= /mnt/newdisk/LGE/arm-lg115x-linux-gnueabi-4.8-2016.03-x86_64/bin/arm-lg115x-linux-gnueabi-
KSRC ?= /mnt/newdisk/LGE/linux-rockhopper_k3lp_drd4tv_423
endif

CROSS_COMPILE ?=
KSRC ?= $(LINUX_SRC)
INSTALL_PREFIX ?=
endif

ifeq ($(CONFIG_PLATFORM_HISILICON), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_HISILICON
ifeq ($(SUPPORT_CONCURRENT),y)
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
endif
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
ARCH := arm
ifeq ($(CROSS_COMPILE),)
       CROSS_COMPILE = arm-hisiv200-linux-
endif
MODULE_NAME := rtl8192eu
ifeq ($(KSRC),)
       KSRC := ../../../../../../kernel/linux-3.4.y
endif
endif

ifeq ($(CONFIG_PLATFORM_HISILICON_HI3798), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_HISILICON
EXTRA_CFLAGS += -DCONFIG_PLATFORM_HISILICON_HI3798
#EXTRA_CFLAGS += -DCONFIG_PLATFORM_HISILICON_HI3798_MV200_HDMI_DONGLE
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211
EXTRA_CFLAGS += -DRTW_USE_CFG80211_STA_EVENT
# default setting for Android 5.x and later
#EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

# Change active scan time in each channel, unit is ms
#EXTRA_CFLAGS += -DSURVEY_TO_ACTIVE=50

# If system could power on and recognize Wi-Fi SDIO automatically,
# platfrom operations are not necessary.
#ifeq ($(CONFIG_SDIO_HCI), y)
#EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
#_PLATFORM_FILES += platform/platform_hisilicon_hi3798_sdio.o
#EXTRA_CFLAGS += -DCONFIG_HISI_SDIO_ID=1
#endif

ARCH ?= arm
CROSS_COMPILE ?= /HiSTBAndroidV600R003C00SPC021_git_0512/device/hisilicon/bigfish/sdk/tools/linux/toolchains/arm-histbv310-linux/bin/arm-histbv310-linux-
ifndef KSRC
KSRC := /HiSTBAndroidV600R003C00SPC021_git_0512/device/hisilicon/bigfish/sdk/source/kernel/linux-3.18.y
KSRC += O=/HiSTBAndroidV600R003C00SPC021_git_0512/out/target/product/Hi3798MV200/obj/KERNEL_OBJ
endif

ifeq ($(CONFIG_RTL8822B), y)
ifeq ($(CONFIG_SDIO_HCI), y)
CONFIG_RTL8822BS ?= m
USER_MODULE_NAME := rtl8822bs
endif
endif

endif

# Platform setting
ifeq ($(CONFIG_PLATFORM_ARM_SPREADTRUM_6820), y)
ifeq ($(CONFIG_ANDROID_2X), y)
EXTRA_CFLAGS += -DANDROID_2X
endif
EXTRA_CFLAGS += -DCONFIG_PLATFORM_SPRD
EXTRA_CFLAGS += -DPLATFORM_SPREADTRUM_6820
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ifeq ($(RTL871X), rtl8188e)
EXTRA_CFLAGS += -DSOFTAP_PS_DURATION=50
endif
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
_PLATFORM_FILES += platform/platform_sprd_sdio.o
endif
endif

ifeq ($(CONFIG_PLATFORM_ARM_SPREADTRUM_8810), y)
ifeq ($(CONFIG_ANDROID_2X), y)
EXTRA_CFLAGS += -DANDROID_2X
endif
EXTRA_CFLAGS += -DCONFIG_PLATFORM_SPRD
EXTRA_CFLAGS += -DPLATFORM_SPREADTRUM_8810
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ifeq ($(RTL871X), rtl8188e)
EXTRA_CFLAGS += -DSOFTAP_PS_DURATION=50
endif
ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
_PLATFORM_FILES += platform/platform_sprd_sdio.o
endif
endif

ifeq ($(CONFIG_PLATFORM_ARM_WMT), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
ifeq ($(CONFIG_SDIO_HCI), y)
_PLATFORM_FILES += platform/platform_ARM_WMT_sdio.o
endif
ARCH := arm
CROSS_COMPILE := /home/android_sdk/WonderMedia/wm8880-android4.4/toolchain/arm_201103_gcc4.5.2/mybin/arm_1103_le-
KSRC := /home/android_sdk/WonderMedia/wm8880-android4.4/kernel4.4/
MODULE_NAME :=8189es_kk
endif

ifeq ($(CONFIG_PLATFORM_RTK119X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
#EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN7I
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
#EXTRA_CFLAGS +=  -DCONFIG_QOS_OPTIMIZATION
EXTRA_CFLAGS += -DCONFIG_QOS_OPTIMIZATION

#EXTRA_CFLAGS += -DCONFIG_#PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
#_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
endif
ifeq ($(CONFIG_SDIO_HCI), y)
_PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
endif

ARCH := arm

# ==== Cross compile setting for Android 4.4 SDK =====
#CROSS_COMPILE := arm-linux-gnueabihf-
KVER  := 3.10.24
#KSRC :=/home/android_sdk/Allwinner/a20/android-kitkat44/lichee/linux-3.4
CROSS_COMPILE := /home/realtek/software_phoenix/phoenix/toolchain/usr/local/arm-2013.11/bin/arm-linux-gnueabihf-
KSRC := /home/realtek/software_phoenix/linux-kernel
MODULE_NAME := 8192eu

endif

ifeq ($(CONFIG_PLATFORM_RTK119X_AM), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_RTK119X_AM
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE -DCONFIG_FULL_CH_IN_P2P_HANDSHAKE
EXTRA_CFLAGS += -DCONFIG_IFACE_NUMBER=3
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT

ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
endif

ARCH := arm

#CROSS_COMPILE := arm-linux-gnueabihf-
KVER  := 3.10.24
#KSRC :=
CROSS_COMPILE :=
endif

ifeq ($(CONFIG_PLATFORM_RTK129X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DRTK_129X_PLATFORM
EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
#EXTRA_CFLAGS += -DCONFIG_P2P_IPS -DCONFIG_QOS_OPTIMIZATION
EXTRA_CFLAGS += -DCONFIG_QOS_OPTIMIZATION
# Enable this for Android 5.0
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK
ifeq ($(CONFIG_RTL8821C)$(CONFIG_SDIO_HCI),yy)
EXTRA_CFLAGS += -DCONFIG_WAKEUP_GPIO_INPUT_MODE
EXTRA_CFLAGS += -DCONFIG_BT_WAKE_HST_OPEN_DRAIN
endif
EXTRA_CFLAGS += -Wno-error=date-time
# default setting for Android 7.0
ifeq ($(RTK_ANDROID_VERSION), nougat)
EXTRA_CFLAGS += -DRTW_P2P_GROUP_INTERFACE=1
endif
#EXTRA_CFLAGS += -DCONFIG_#PLATFORM_OPS
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
endif

ARCH := arm64

# ==== Cross compile setting for Android 4.4 SDK =====
#CROSS_COMPILE := arm-linux-gnueabihf-
#KVER  := 4.1.10
#CROSS_COMPILE := $(CROSS)
#KSRC := $(LINUX_KERNEL_PATH)
CROSS_COMPILE := /home/android_sdk/DHC/trunk-6.0.0_r1-QA160627/phoenix/toolchain/asdk64-4.9.4-a53-EL-3.10-g2.19-a64nt-160307/bin/asdk64-linux-
KSRC := /home/android_sdk/DHC/trunk-6.0.0_r1-QA160627/linux-kernel
endif

ifeq ($(CONFIG_PLATFORM_RTK390X), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_PLATFORM_RTK390X
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_RTW_NETIF_SG
ifeq ($(CONFIG_USB_HCI), y)
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
endif

ARCH:=rlx

CROSS_COMPILE:=mips-linux-
KSRC:= /home/realtek/share/Develop/IPCAM_SDK/RealSil/rts3901_sdk_v1.2_vanilla/linux-3.10

endif

ifeq ($(CONFIG_PLATFORM_NOVATEK_NT72668), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_NOVATEK_NT72668
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_RX
EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
ARCH ?= arm
CROSS_COMPILE := arm-linux-gnueabihf-
KVER := 3.8.0
KSRC := /Custom/Novatek/TCL/linux-3.8_header
#KSRC := $(KERNELDIR)
endif

ifeq ($(CONFIG_PLATFORM_ARM_TCC8930_JB42), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android 4.1, 4.2
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
ARCH := arm
CROSS_COMPILE := /home/android_sdk/Telechips/v13.05_r1-tcc-android-4.2.2_tcc893x-evm_build/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
KSRC := /home/android_sdk/Telechips/v13.05_r1-tcc-android-4.2.2_tcc893x-evm_build/kernel
MODULE_NAME := wlan
endif 

ifeq ($(CONFIG_PLATFORM_RTL8197D), y)
EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTL8197D
export DIR_LINUX=$(shell pwd)/../SDK/rlxlinux-sdk321-v50/linux-2.6.30
ARCH ?= rlx
CROSS_COMPILE:= $(DIR_LINUX)/../toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/rsdk-linux-
KSRC := $(DIR_LINUX)
endif

ifeq ($(CONFIG_PLATFORM_AML_S905), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_AML_S905
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -fno-pic
# default setting for Android
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211
EXTRA_CFLAGS += -DRTW_USE_CFG80211_STA_EVENT
# default setting for Android 5.x and later
EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

# Change active scan time in each channel, unit is ms
#EXTRA_CFLAGS += -DSURVEY_TO_ACTIVE=50

ifeq ($(CONFIG_SDIO_HCI), y)
EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
_PLATFORM_FILES += platform/platform_aml_s905_sdio.o
endif

ARCH ?= arm64
CROSS_COMPILE ?= /4.4_S905L_8822bs_compile/gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux/bin/aarch64-linux-gnu-
ifndef KSRC
KSRC := /4.4_S905L_8822bs_compile/common
# To locate output files in a separate directory.
KSRC += O=/4.4_S905L_8822bs_compile/KERNEL_OBJ
endif

ifeq ($(CONFIG_RTL8822B), y)
ifeq ($(CONFIG_SDIO_HCI), y)
CONFIG_RTL8822BS ?= m
USER_MODULE_NAME := 8822bs
endif
endif

endif

ifeq ($(CONFIG_PLATFORM_ZTE_ZX296716), y)
EXTRA_CFLAGS += -Wno-error=date-time
EXTRA_CFLAGS += -DCONFIG_PLATFORM_ZTE_ZX296716
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
# default setting for Android
EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211
EXTRA_CFLAGS += -DRTW_USE_CFG80211_STA_EVENT
# default setting for Android 5.x and later
#EXTRA_CFLAGS += -DCONFIG_RADIO_WORK

ifeq ($(CONFIG_SDIO_HCI), y)
# mark this temporarily
#EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
#_PLATFORM_FILES += platform/platform_zte_zx296716_sdio.o
endif

ARCH ?= arm64
CROSS_COMPILE ?=
KSRC ?=

ifeq ($(CONFIG_RTL8822B), y)
ifeq ($(CONFIG_SDIO_HCI), y)
CONFIG_RTL8822BS ?= m
USER_MODULE_NAME := 8822bs
endif
endif

endif

########### CUSTOMER ################################
ifeq ($(CONFIG_CUSTOMER_HUAWEI_GENERAL), y)
CONFIG_CUSTOMER_HUAWEI = y
endif

ifeq ($(CONFIG_CUSTOMER_HUAWEI), y)
EXTRA_CFLAGS += -DCONFIG_HUAWEI_PROC
endif

ifeq ($(CONFIG_MULTIDRV), y)

ifeq ($(CONFIG_SDIO_HCI), y)
MODULE_NAME := rtw_sdio
endif

ifeq ($(CONFIG_USB_HCI), y)
MODULE_NAME := rtw_usb
endif

ifeq ($(CONFIG_PCI_HCI), y)
MODULE_NAME := rtw_pci
endif


endif

USER_MODULE_NAME ?=
ifneq ($(USER_MODULE_NAME),)
MODULE_NAME := $(USER_MODULE_NAME)
endif

ifneq ($(KERNELRELEASE),)

########### this part for *.mk ############################
include $(src)/hal/phydm/phydm.mk

########### HAL_RTL8822B #################################
ifeq ($(CONFIG_RTL8822B), y)
include $(src)/rtl8822b.mk
endif

########### HAL_RTL8821C #################################
ifeq ($(CONFIG_RTL8821C), y)
include $(src)/rtl8821c.mk
endif

########### HAL_RTL8822C #################################
ifeq ($(CONFIG_RTL8822C), y)
include $(src)/rtl8822c.mk
endif

########### HAL_RTL8814B #################################
ifeq ($(CONFIG_RTL8814B), y)
include $(src)/rtl8814b.mk
endif

rtk_core :=	core/rtw_cmd.o \
		core/rtw_security.o \
		core/rtw_debug.o \
		core/rtw_io.o \
		core/rtw_ioctl_query.o \
		core/rtw_ioctl_set.o \
		core/rtw_ieee80211.o \
		core/rtw_mlme.o \
		core/rtw_mlme_ext.o \
		core/rtw_mi.o \
		core/rtw_wlan_util.o \
		core/rtw_vht.o \
		core/rtw_pwrctrl.o \
		core/rtw_rf.o \
		core/rtw_chplan.o \
		core/rtw_recv.o \
		core/rtw_sta_mgt.o \
		core/rtw_ap.o \
		core/mesh/rtw_mesh.o \
		core/mesh/rtw_mesh_pathtbl.o \
		core/mesh/rtw_mesh_hwmp.o \
		core/rtw_xmit.o	\
		core/rtw_p2p.o \
		core/rtw_rson.o \
		core/rtw_tdls.o \
		core/rtw_br_ext.o \
		core/rtw_iol.o \
		core/rtw_sreset.o \
		core/rtw_btcoex_wifionly.o \
		core/rtw_btcoex.o \
		core/rtw_beamforming.o \
		core/rtw_odm.o \
		core/rtw_rm.o \
		core/rtw_rm_fsm.o \
		core/rtw_rm_util.o \
		core/efuse/rtw_efuse.o 

ifeq ($(CONFIG_SDIO_HCI), y)
rtk_core += core/rtw_sdio.o
endif

$(MODULE_NAME)-y += $(rtk_core)

$(MODULE_NAME)-$(CONFIG_WAPI_SUPPORT) += core/rtw_wapi.o	\
					core/rtw_wapi_sms4.o

$(MODULE_NAME)-y += $(_OS_INTFS_FILES)
$(MODULE_NAME)-y += $(_HAL_INTFS_FILES)
$(MODULE_NAME)-y += $(_PHYDM_FILES)
$(MODULE_NAME)-y += $(_BTC_FILES)
$(MODULE_NAME)-y += $(_PLATFORM_FILES)

$(MODULE_NAME)-$(CONFIG_MP_INCLUDED) += core/rtw_mp.o

ifeq ($(CONFIG_RTL8723B), y)
$(MODULE_NAME)-$(CONFIG_MP_INCLUDED)+= core/rtw_bt_mp.o
endif

#obj-$(CONFIG_RTL8822BU) := $(MODULE_NAME).o
#gcat
obj-m := $(MODULE_NAME).o

else

export CONFIG_RTL8822BU = m

all: modules

modules:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(shell pwd)  modules

strip:
	$(CROSS_COMPILE)strip $(MODULE_NAME).ko --strip-unneeded

install:
	install -p -m 644 $(MODULE_NAME).ko  $(MODDESTDIR)
	/sbin/depmod -a ${KVER}

uninstall:
	rm -f $(MODDESTDIR)/$(MODULE_NAME).ko
	/sbin/depmod -a ${KVER}

backup_rtlwifi:
	@echo "Making backup rtlwifi drivers"
ifneq (,$(wildcard $(STAGINGMODDIR)/rtl*))
	@tar cPf $(wildcard $(STAGINGMODDIR))/backup_rtlwifi_driver.tar $(wildcard $(STAGINGMODDIR)/rtl*)
	@rm -rf $(wildcard $(STAGINGMODDIR)/rtl*)
endif
ifneq (,$(wildcard $(MODDESTDIR)realtek))
	@tar cPf $(MODDESTDIR)backup_rtlwifi_driver.tar $(MODDESTDIR)realtek
	@rm -fr $(MODDESTDIR)realtek
endif
ifneq (,$(wildcard $(MODDESTDIR)rtl*))
	@tar cPf $(MODDESTDIR)../backup_rtlwifi_driver.tar $(wildcard $(MODDESTDIR)rtl*)
	@rm -fr $(wildcard $(MODDESTDIR)rtl*)
endif
	@/sbin/depmod -a ${KVER}
	@echo "Please reboot your system"

restore_rtlwifi:
	@echo "Restoring backups"
ifneq (,$(wildcard $(STAGINGMODDIR)/backup_rtlwifi_driver.tar))
	@tar xPf $(STAGINGMODDIR)/backup_rtlwifi_driver.tar
	@rm $(STAGINGMODDIR)/backup_rtlwifi_driver.tar
endif
ifneq (,$(wildcard $(MODDESTDIR)backup_rtlwifi_driver.tar))
	@tar xPf $(MODDESTDIR)backup_rtlwifi_driver.tar
	@rm $(MODDESTDIR)backup_rtlwifi_driver.tar
endif
ifneq (,$(wildcard $(MODDESTDIR)../backup_rtlwifi_driver.tar))
	@tar xPf $(MODDESTDIR)../backup_rtlwifi_driver.tar
	@rm $(MODDESTDIR)../backup_rtlwifi_driver.tar
endif
	@/sbin/depmod -a ${KVER}
	@echo "Please reboot your system"

config_r:
	@echo "make config"
	/bin/bash script/Configure script/config.in


.PHONY: modules clean

clean:
	#$(MAKE) -C $(KSRC) M=$(shell pwd) clean
	cd hal ; rm -fr */*/*/*.mod.c */*/*/*.mod */*/*/*.o */*/*/.*.cmd */*/*/*.ko */*/*/*.ur-safe
	cd hal ; rm -fr */*/*.mod.c */*/*.mod */*/*.o */*/.*.cmd */*/*.ko */*/*.ur-safe
	cd hal ; rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*.ko */*.ur-safe
	cd hal ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko *.ur-safe
	cd core ; rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*.ko */*.ur-safe
	cd core ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko *.ur-safe
	cd os_dep/linux ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko *.ur-safe
	cd os_dep ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko *.ur-safe
	cd platform ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko *.ur-safe
	rm -fr Module.symvers ; rm -fr Module.markers ; rm -fr modules.order
	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
	rm -fr .tmp_versions *.ur-safe
endif

                                                                                                                                                                                                                                                                                  rtl8822bu/src/runwpa                                                                                0000644 0001750 0001750 00000000647 14214766567 013247  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 #!/bin/bash

if [ "`which iwconfig`" = "" ] ; then 
	echo "WARNING:Wireless tool not exist!"
	echo "        Please install it!"
	exit
else
	if [ `uname -r | cut -d. -f2` -eq 4 ]; then
		wpa_supplicant -D ipw -c wpa1.conf -i wlan0	
	else
	if [ `iwconfig -v |awk '{print $4}' | head -n 1` -lt  18 ] ; then
		wpa_supplicant -D ipw -c wpa1.conf -i wlan0  
	else	  
		wpa_supplicant -D wext -c wpa1.conf -i wlan0 
	fi

	fi
fi


                                                                                         rtl8822bu/src/platform/                                                                             0000755 0001750 0001750 00000000000 14214766567 013625  5                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 rtl8822bu/src/platform/platform_zte_zx296716_sdio.c                                                 0000644 0001750 0001750 00000002666 14214766567 020747  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2018 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <linux/printk.h>		/* pr_info(() */
#include <linux/delay.h>		/* msleep() */
#include "platform_zte_zx296716_sdio.h"	/* sdio_reinit() and etc */


/*
 * Return:
 *	0:	power on successfully
 *	others:	power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;

	pr_info("######%s: disable--1--\n", __func__);
	extern_wifi_set_enable(0);
	/*msleep(500);*/ /* add in function:extern_wifi_set_enable */
	pr_info("######%s: enable--2---\n", __func__);
	extern_wifi_set_enable(1);
	/*msleep(500);*/
	sdio_reinit();

	return ret;
}

void platform_wifi_power_off(void)
{
	int card_val;

	pr_info("######%s:\n", __func__);
#ifdef CONFIG_A16T03_BOARD
	card_val = sdio_host_is_null();
	if (card_val)
		remove_card();
#endif /* CONFIG_A16T03_BOARD */
	extern_wifi_set_enable(0);

	/*msleep(500);*/
}
                                                                          rtl8822bu/src/platform/platform_aml_s905_sdio.h                                                     0000644 0001750 0001750 00000002032 14214766567 020246  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2018 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PLATFORM_AML_S905_SDIO_H__
#define __PLATFORM_AML_S905_SDIO_H__

#include <linux/version.h>	/* Linux vresion */

extern void sdio_reinit(void);
extern void extern_wifi_set_enable(int is_on);

#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
extern void wifi_teardown_dt(void);
extern int wifi_setup_dt(void);
#endif /* kernel < 3.14.0 */

#endif /* __PLATFORM_AML_S905_SDIO_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/platform/platform_ARM_SUN50IW1P1_sdio.c                                               0000644 0001750 0001750 00000004245 14214766567 020753  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*
 * Description:
 *	This file can be applied to following platforms:
 *	CONFIG_PLATFORM_ARM_SUN50IW1P1
 */
#include <drv_types.h>
#ifdef CONFIG_GPIO_WAKEUP
#include <linux/gpio.h>
#endif

#ifdef CONFIG_MMC
#if defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
extern void sunxi_mmc_rescan_card(unsigned ids);
extern void sunxi_wlan_set_power(int on);
extern int sunxi_wlan_get_bus_index(void);
extern int sunxi_wlan_get_oob_irq(void);
extern int sunxi_wlan_get_oob_irq_flags(void);
#endif
#ifdef CONFIG_GPIO_WAKEUP
extern unsigned int oob_irq;
#endif
#endif /* CONFIG_MMC */

/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;

#ifdef CONFIG_MMC
	{

#if defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
		int wlan_bus_index = sunxi_wlan_get_bus_index();
		if (wlan_bus_index < 0)
			return wlan_bus_index;

		sunxi_wlan_set_power(1);
		mdelay(100);
		sunxi_mmc_rescan_card(wlan_bus_index);
#endif
		RTW_INFO("%s: power up, rescan card.\n", __FUNCTION__);

#ifdef CONFIG_GPIO_WAKEUP
#if defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
		oob_irq = sunxi_wlan_get_oob_irq();
#endif
#endif /* CONFIG_GPIO_WAKEUP */
	}
#endif /* CONFIG_MMC */

	return ret;
}

void platform_wifi_power_off(void)
{
#ifdef CONFIG_MMC
#if defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
	int wlan_bus_index = sunxi_wlan_get_bus_index();
	if (wlan_bus_index < 0)
		return;

	sunxi_mmc_rescan_card(wlan_bus_index);
	mdelay(100);
	sunxi_wlan_set_power(0);
#endif
	RTW_INFO("%s: remove card, power off.\n", __FUNCTION__);
#endif /* CONFIG_MMC */
}
                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/platform/platform_ARM_SUNxI_usb.c                                                     0000644 0001750 0001750 00000007467 14214766567 020231  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*
 * Description:
 *	This file can be applied to following platforms:
 *	CONFIG_PLATFORM_ARM_SUNXI Series platform
 *
 */

#include <drv_types.h>
#include <mach/sys_config.h>

#ifdef CONFIG_PLATFORM_ARM_SUNxI
extern int sw_usb_disable_hcd(__u32 usbc_no);
extern int sw_usb_enable_hcd(__u32 usbc_no);
static int usb_wifi_host = 2;
#endif

#if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
extern int sw_usb_disable_hcd(__u32 usbc_no);
extern int sw_usb_enable_hcd(__u32 usbc_no);
extern void wifi_pm_power(int on);
static script_item_u item;
#endif

#ifdef CONFIG_PLATFORM_ARM_SUN8I
extern int sunxi_usb_disable_hcd(__u32 usbc_no);
extern int sunxi_usb_enable_hcd(__u32 usbc_no);
extern void wifi_pm_power(int on);
static script_item_u item;
#endif


int platform_wifi_power_on(void)
{
	int ret = 0;

#ifdef CONFIG_PLATFORM_ARM_SUNxI
#ifndef CONFIG_RTL8723A
	{
		/* ----------get usb_wifi_usbc_num------------- */
		ret = script_parser_fetch("usb_wifi_para", "usb_wifi_usbc_num", (int *)&usb_wifi_host, 64);
		if (ret != 0) {
			RTW_INFO("ERR: script_parser_fetch usb_wifi_usbc_num failed\n");
			ret = -ENOMEM;
			goto exit;
		}
		RTW_INFO("sw_usb_enable_hcd: usbc_num = %d\n", usb_wifi_host);
		sw_usb_enable_hcd(usb_wifi_host);
	}
#endif /* CONFIG_RTL8723A */
#endif /* CONFIG_PLATFORM_ARM_SUNxI */

#if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
	{
		script_item_value_type_e type;

		type = script_get_item("wifi_para", "wifi_usbc_id", &item);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			printk("ERR: script_get_item wifi_usbc_id failed\n");
			ret = -ENOMEM;
			goto exit;
		}

		printk("sw_usb_enable_hcd: usbc_num = %d\n", item.val);
		wifi_pm_power(1);
		mdelay(10);

#if !(defined(CONFIG_RTL8723A)) && !(defined(CONFIG_RTL8723B))
		sw_usb_enable_hcd(item.val);
#endif
	}
#endif /* defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I) */

#if defined(CONFIG_PLATFORM_ARM_SUN8I)
	{
		script_item_value_type_e type;

		type = script_get_item("wifi_para", "wifi_usbc_id", &item);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			printk("ERR: script_get_item wifi_usbc_id failed\n");
			ret = -ENOMEM;
			goto exit;
		}

		printk("sw_usb_enable_hcd: usbc_num = %d\n", item.val);
		wifi_pm_power(1);
		mdelay(10);

#if !(defined(CONFIG_RTL8723A)) && !(defined(CONFIG_RTL8723B))
		sunxi_usb_enable_hcd(item.val);
#endif
	}
#endif /* CONFIG_PLATFORM_ARM_SUN8I */

exit:
	return ret;
}

void platform_wifi_power_off(void)
{

#ifdef CONFIG_PLATFORM_ARM_SUNxI
#ifndef CONFIG_RTL8723A
	RTW_INFO("sw_usb_disable_hcd: usbc_num = %d\n", usb_wifi_host);
	sw_usb_disable_hcd(usb_wifi_host);
#endif /* ifndef CONFIG_RTL8723A */
#endif /* CONFIG_PLATFORM_ARM_SUNxI */

#if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
	#if !(defined(CONFIG_RTL8723A)) && !(defined(CONFIG_RTL8723B))
	sw_usb_disable_hcd(item.val);
	#endif
	wifi_pm_power(0);
#endif /* defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I) */

#if defined(CONFIG_PLATFORM_ARM_SUN8I)
	#if !(defined(CONFIG_RTL8723A)) && !(defined(CONFIG_RTL8723B))
	sunxi_usb_disable_hcd(item.val);
	#endif
	wifi_pm_power(0);
#endif /* defined(CONFIG_PLATFORM_ARM_SUN8I) */

}
                                                                                                                                                                                                         rtl8822bu/src/platform/platform_hisilicon_hi3798_sdio.c                                             0000644 0001750 0001750 00000005151 14214766567 021711  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2017 - 2018 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <linux/delay.h>		/* mdelay() */
#include <mach/hardware.h>		/* __io_address(), readl(), writel() */
#include "platform_hisilicon_hi3798_sdio.h"	/* HI_S32() and etc. */

typedef enum hi_GPIO_DIR_E {
	HI_DIR_OUT = 0,
	HI_DIR_IN  = 1,
} HI_GPIO_DIR_E;

#define RTL_REG_ON_GPIO		(4*8 + 3)

#define REG_BASE_CTRL		__io_address(0xf8a20008)

int gpio_wlan_reg_on = RTL_REG_ON_GPIO;
#if 0
module_param(gpio_wlan_reg_on, uint, 0644);
MODULE_PARM_DESC(gpio_wlan_reg_on, "wlan reg_on gpio num (default:gpio4_3)");
#endif

static int hi_gpio_set_value(u32 gpio, u32 value)
{
	HI_S32 s32Status;

	s32Status = HI_DRV_GPIO_SetDirBit(gpio, HI_DIR_OUT);
	if (s32Status != HI_SUCCESS) {
		pr_err("gpio(%d) HI_DRV_GPIO_SetDirBit HI_DIR_OUT failed\n",
			gpio);
		return -1;
	}

	s32Status = HI_DRV_GPIO_WriteBit(gpio, value);
	if (s32Status != HI_SUCCESS) {
		pr_err("gpio(%d) HI_DRV_GPIO_WriteBit value(%d) failed\n",
			gpio, value);
		return -1;
	}

	return 0;
}

static int hisi_wlan_set_carddetect(bool present)
{
	u32 regval;
	u32 mask;


#ifndef CONFIG_HISI_SDIO_ID
	return;
#endif
	pr_info("SDIO ID=%d\n", CONFIG_HISI_SDIO_ID);
#if (CONFIG_HISI_SDIO_ID == 1)
	mask = 1;
#elif (CONFIG_HISI_SDIO_ID == 0)
	mask = 2;
#endif

	regval = readl(REG_BASE_CTRL);
	if (present) {
		pr_info("====== Card detection to detect SDIO card! ======\n");
		/* set card_detect low to detect card */
		regval |= mask;
	} else {
		pr_info("====== Card detection to remove SDIO card! ======\n");
		/* set card_detect high to remove card */
		regval &= ~(mask);
	}
	writel(regval, REG_BASE_CTRL);

	return 0;
}

/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;


	hi_gpio_set_value(gpio_wlan_reg_on, 1);
	mdelay(100);
	hisi_wlan_set_carddetect(1);
	mdelay(2000);
	pr_info("======== set_carddetect delay 2s! ========\n");

	return ret;
}

void platform_wifi_power_off(void)
{
	hisi_wlan_set_carddetect(0);
	mdelay(100);
	hi_gpio_set_value(gpio_wlan_reg_on, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/platform/platform_sprd_sdio.c                                                         0000644 0001750 0001750 00000004000 14214766567 017655  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <drv_types.h>

extern void sdhci_bus_scan(void);
#ifndef ANDROID_2X
extern int sdhci_device_attached(void);
#endif

/*
 * Return:
 *	0:	power on successfully
 *	others:	power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;


#ifdef CONFIG_RTL8188E
	rtw_wifi_gpio_wlan_ctrl(WLAN_POWER_ON);
#endif /* CONFIG_RTL8188E */

	/* Pull up pwd pin, make wifi leave power down mode. */
	rtw_wifi_gpio_init();
	rtw_wifi_gpio_wlan_ctrl(WLAN_PWDN_ON);

#if (MP_DRIVER == 1) && (defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B))
	/* Pull up BT reset pin. */
	rtw_wifi_gpio_wlan_ctrl(WLAN_BT_PWDN_ON);
#endif
	rtw_mdelay_os(5);

	sdhci_bus_scan();
#ifdef CONFIG_RTL8723B
	/* YJ,test,130305 */
	rtw_mdelay_os(1000);
#endif
#ifdef ANDROID_2X
	rtw_mdelay_os(200);
#else /* !ANDROID_2X */
	if (1) {
		int i = 0;

		for (i = 0; i <= 50; i++) {
			msleep(10);
			if (sdhci_device_attached())
				break;
			printk("%s delay times:%d\n", __func__, i);
		}
	}
#endif /* !ANDROID_2X */

	return ret;
}

void platform_wifi_power_off(void)
{
	/* Pull down pwd pin, make wifi enter power down mode. */
	rtw_wifi_gpio_wlan_ctrl(WLAN_PWDN_OFF);
	rtw_mdelay_os(5);
	rtw_wifi_gpio_deinit();

#ifdef CONFIG_RTL8188E
	rtw_wifi_gpio_wlan_ctrl(WLAN_POWER_OFF);
#endif /* CONFIG_RTL8188E */

#ifdef CONFIG_WOWLAN
	if (mmc_host)
		mmc_host->pm_flags &= ~MMC_PM_KEEP_POWER;
#endif /* CONFIG_WOWLAN */
}
rtl8822bu/src/platform/platform_ARM_SUNxI_sdio.c                                                    0000644 0001750 0001750 00000005153 14214766567 020364  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <drv_types.h>

#ifdef CONFIG_MMC_SUNXI_POWER_CONTROL
#ifdef CONFIG_WITS_EVB_V13
	#define SDIOID	0
#else /* !CONFIG_WITS_EVB_V13 */
	#define SDIOID (CONFIG_CHIP_ID == 1123 ? 3 : 1)
#endif /* !CONFIG_WITS_EVB_V13 */

#define SUNXI_SDIO_WIFI_NUM_RTL8189ES  10
extern void sunximmc_rescan_card(unsigned id, unsigned insert);
extern int mmc_pm_get_mod_type(void);
extern int mmc_pm_gpio_ctrl(char *name, int level);
/*
 *	rtl8189es_shdn	= port:PH09<1><default><default><0>
 *	rtl8189es_wakeup	= port:PH10<1><default><default><1>
 *	rtl8189es_vdd_en  = port:PH11<1><default><default><0>
 *	rtl8189es_vcc_en  = port:PH12<1><default><default><0>
 */

int rtl8189es_sdio_powerup(void)
{
	mmc_pm_gpio_ctrl("rtl8189es_vdd_en", 1);
	udelay(100);
	mmc_pm_gpio_ctrl("rtl8189es_vcc_en", 1);
	udelay(50);
	mmc_pm_gpio_ctrl("rtl8189es_shdn", 1);
	return 0;
}

int rtl8189es_sdio_poweroff(void)
{
	mmc_pm_gpio_ctrl("rtl8189es_shdn", 0);
	mmc_pm_gpio_ctrl("rtl8189es_vcc_en", 0);
	mmc_pm_gpio_ctrl("rtl8189es_vdd_en", 0);
	return 0;
}
#endif /* CONFIG_MMC_SUNXI_POWER_CONTROL */

/*
 * Return:
 *	0:	power on successfully
 *	others:	power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;
#ifdef CONFIG_MMC_SUNXI_POWER_CONTROL
	unsigned int mod_sel = mmc_pm_get_mod_type();
#endif /* CONFIG_MMC_SUNXI_POWER_CONTROL */


#ifdef CONFIG_MMC_SUNXI_POWER_CONTROL
	if (mod_sel == SUNXI_SDIO_WIFI_NUM_RTL8189ES) {
		rtl8189es_sdio_powerup();
		sunximmc_rescan_card(SDIOID, 1);
		printk("[rtl8189es] %s: power up, rescan card.\n", __FUNCTION__);
	} else {
		ret = -1;
		printk("[rtl8189es] %s: mod_sel = %d is incorrect.\n", __FUNCTION__, mod_sel);
	}
#endif /* CONFIG_MMC_SUNXI_POWER_CONTROL */

	return ret;
}

void platform_wifi_power_off(void)
{
#ifdef CONFIG_MMC_SUNXI_POWER_CONTROL
	sunximmc_rescan_card(SDIOID, 0);
#ifdef CONFIG_RTL8188E
	rtl8189es_sdio_poweroff();
	printk("[rtl8189es] %s: remove card, power off.\n", __FUNCTION__);
#endif /* CONFIG_RTL8188E */
#endif /* CONFIG_MMC_SUNXI_POWER_CONTROL */
}
                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/platform/platform_zte_zx296716_sdio.h                                                 0000644 0001750 0001750 00000001735 14214766567 020750  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2018 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PLATFORM_ZTE_ZX296716_SDIO_H__
#define __PLATFORM_ZTE_ZX296716_SDIO_H__

extern void sdio_reinit(void);
extern void extern_wifi_set_enable(int val);
#ifdef CONFIG_A16T03_BOARD
extern int sdio_host_is_null(void);
extern void remove_card(void);
#endif /* CONFIG_A16T03_BOARD */

#endif /* __PLATFORM_ZTE_ZX296716_SDIO_H__ */
                                   rtl8822bu/src/platform/platform_hisilicon_hi3798_sdio.h                                             0000644 0001750 0001750 00000002023 14214766567 021711  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2017 - 2018 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PLATFORM_HISILICON_HI3798_SDIO_H__
#define __PLATFORM_HISILICON_HI3798_SDIO_H__

typedef unsigned int	HI_U32;

typedef int		HI_S32;

#define HI_SUCCESS	0
#define HI_FAILURE	(-1)

extern HI_S32 HI_DRV_GPIO_SetDirBit(HI_U32 u32GpioNo, HI_U32 u32DirBit);
extern HI_S32 HI_DRV_GPIO_WriteBit(HI_U32 u32GpioNo, HI_U32 u32BitValue);

#endif /* __PLATFORM_HISILICON_HI3798_SDIO_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             rtl8822bu/src/platform/platform_ARM_WMT_sdio.c                                                      0000644 0001750 0001750 00000002774 14214766567 020073  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <drv_types.h>
#include <mach/wmt_iomux.h>
#include <linux/gpio.h>

extern void wmt_detect_sdio2(void);
extern void force_remove_sdio2(void);

int platform_wifi_power_on(void)
{
	int err = 0;
	err = gpio_request(WMT_PIN_GP62_SUSGPIO1, "wifi_chip_en");
	if (err < 0) {
		printk("request gpio for rtl8188eu failed!\n");
		return err;
	}
	gpio_direction_output(WMT_PIN_GP62_SUSGPIO1, 0);/* pull sus_gpio1 to 0 to open vcc_wifi. */
	printk("power on rtl8189.\n");
	msleep(500);
	wmt_detect_sdio2();
	printk("[rtl8189es] %s: new card, power on.\n", __FUNCTION__);
	return err;
}

void platform_wifi_power_off(void)
{
	force_remove_sdio2();

	gpio_direction_output(WMT_PIN_GP62_SUSGPIO1, 1);/* pull sus_gpio1 to 1 to close vcc_wifi. */
	printk("power off rtl8189.\n");
	gpio_free(WMT_PIN_GP62_SUSGPIO1);
	printk("[rtl8189es] %s: remove card, power off.\n", __FUNCTION__);
}
    rtl8822bu/src/platform/custom_country_chplan.h                                                      0000644 0001750 0001750 00000002025 14214766567 020417  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#error "You have defined CONFIG_CUSTOMIZED_COUNTRY_CHPLAN_MAP to use a customized map of your own instead of the default one"
#error "Before removing these error notifications, please make sure regulatory certification requirements of your target markets"

static const struct country_chplan CUSTOMIZED_country_chplan_map[] = {
	COUNTRY_CHPLAN_ENT("TW", 0x76, 1, 0x3FF), /* Taiwan */
};

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/platform/platform_aml_s905_sdio.c                                                     0000644 0001750 0001750 00000002714 14214766567 020250  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2018 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <linux/printk.h>		/* pr_info(() */
#include <linux/delay.h>		/* msleep() */
#include "platform_aml_s905_sdio.h"	/* sdio_reinit() and etc */


/*
 * Return:
 *	0:	power on successfully
 *	others:	power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;

#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
	ret = wifi_setup_dt();
	if (ret) {
		pr_err("%s: setup dt failed!!(%d)\n", __func__, ret);
		return -1;
	}
#endif /* kernel < 3.14.0 */

#if 0 /* Seems redundancy? Already done before insert driver */
	pr_info("######%s:\n", __func__);
	extern_wifi_set_enable(0);
	msleep(500);
	extern_wifi_set_enable(1);
	msleep(500);
	sdio_reinit();
#endif

	return ret;
}

void platform_wifi_power_off(void)
{
#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
	wifi_teardown_dt();
#endif /* kernel < 3.14.0 */
}
                                                    rtl8822bu/src/platform/platform_ops.c                                                               0000644 0001750 0001750 00000001601 14214766567 016474  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef CONFIG_PLATFORM_OPS
/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;


	return ret;
}

void platform_wifi_power_off(void)
{
}
#endif /* !CONFIG_PLATFORM_OPS */
                                                                                                                               rtl8822bu/src/platform/platform_ops.h                                                               0000644 0001750 0001750 00000001567 14214766567 016514  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PLATFORM_OPS_H__
#define __PLATFORM_OPS_H__

/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void);
void platform_wifi_power_off(void);

#endif /* __PLATFORM_OPS_H__ */
                                                                                                                                         rtl8822bu/src/platform/platform_ARM_SUNnI_sdio.c                                                    0000644 0001750 0001750 00000006672 14214766567 020361  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*
 * Description:
 *	This file can be applied to following platforms:
 *	CONFIG_PLATFORM_ARM_SUN6I
 *	CONFIG_PLATFORM_ARM_SUN7I
 *	CONFIG_PLATFORM_ARM_SUN8I
 */
#include <drv_types.h>
#include <mach/sys_config.h>
#ifdef CONFIG_GPIO_WAKEUP
#include <linux/gpio.h>
#endif

#ifdef CONFIG_MMC
static int sdc_id = -1;
static signed int gpio_eint_wlan = -1;
static u32 eint_wlan_handle = 0;

#if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
extern void sw_mci_rescan_card(unsigned id, unsigned insert);
#elif defined(CONFIG_PLATFORM_ARM_SUN8I)
extern void sunxi_mci_rescan_card(unsigned id, unsigned insert);
#endif

#ifdef CONFIG_PLATFORM_ARM_SUN8I_W5P1
extern int get_rf_mod_type(void);
#else
extern int wifi_pm_get_mod_type(void);
#endif

extern void wifi_pm_power(int on);
#ifdef CONFIG_GPIO_WAKEUP
extern unsigned int oob_irq;
#endif
#endif /* CONFIG_MMC */

/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;

#ifdef CONFIG_MMC
	{
		script_item_u val;
		script_item_value_type_e type;

#ifdef CONFIG_PLATFORM_ARM_SUN8I_W5P1
		unsigned int mod_sel = get_rf_mod_type();
#else
		unsigned int mod_sel = wifi_pm_get_mod_type();
#endif

		type = script_get_item("wifi_para", "wifi_sdc_id", &val);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			RTW_INFO("get wifi_sdc_id failed\n");
			ret = -1;
		} else {
			sdc_id = val.val;
			RTW_INFO("----- %s sdc_id: %d, mod_sel: %d\n", __FUNCTION__, sdc_id, mod_sel);

#if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
			sw_mci_rescan_card(sdc_id, 1);
#elif defined(CONFIG_PLATFORM_ARM_SUN8I)
			sunxi_mci_rescan_card(sdc_id, 1);
#endif
			mdelay(100);
			wifi_pm_power(1);

			RTW_INFO("%s: power up, rescan card.\n", __FUNCTION__);
		}

#ifdef CONFIG_GPIO_WAKEUP
#ifdef CONFIG_PLATFORM_ARM_SUN8I_W5P1
		type = script_get_item("wifi_para", "wl_host_wake", &val);
#else
#ifdef CONFIG_RTL8723B
		type = script_get_item("wifi_para", "rtl8723bs_wl_host_wake", &val);
#endif
#ifdef CONFIG_RTL8188E
		type = script_get_item("wifi_para", "rtl8189es_host_wake", &val);
#endif
#endif /* CONFIG_PLATFORM_ARM_SUN8I_W5P1 */
		if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
			RTW_INFO("No definition of wake up host PIN\n");
			ret = -1;
		} else {
			gpio_eint_wlan = val.gpio.gpio;
#ifdef CONFIG_PLATFORM_ARM_SUN8I
			oob_irq = gpio_to_irq(gpio_eint_wlan);
#endif
		}
#endif /* CONFIG_GPIO_WAKEUP */
	}
#endif /* CONFIG_MMC */

	return ret;
}

void platform_wifi_power_off(void)
{
#ifdef CONFIG_MMC
#if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
	sw_mci_rescan_card(sdc_id, 0);
#elif defined(CONFIG_PLATFORM_ARM_SUN8I)
	sunxi_mci_rescan_card(sdc_id, 0);
#endif
	mdelay(100);
	wifi_pm_power(0);

	RTW_INFO("%s: remove card, power off.\n", __FUNCTION__);
#endif /* CONFIG_MMC */
}
                                                                      rtl8822bu/src/platform/platform_arm_act_sdio.c                                                      0000644 0001750 0001750 00000002511 14214766567 020320  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*
 * Description:
 *	This file can be applied to following platforms:
 *    CONFIG_PLATFORM_ACTIONS_ATM703X
 */
#include <drv_types.h>

#ifdef CONFIG_PLATFORM_ACTIONS_ATM705X
extern int acts_wifi_init(void);
extern void acts_wifi_cleanup(void);
#endif

/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;

#ifdef CONFIG_PLATFORM_ACTIONS_ATM705X
	ret = acts_wifi_init();
	if (unlikely(ret < 0)) {
		pr_err("%s Failed to register the power control driver.\n", __FUNCTION__);
		goto exit;
	}
#endif

exit:
	return ret;
}

void platform_wifi_power_off(void)
{
#ifdef CONFIG_PLATFORM_ACTIONS_ATM705X
	acts_wifi_cleanup();
#endif
}
                                                                                                                                                                                       rtl8822bu/src/platform/platform_rockchips_sdio.c                                                    0000644 0001750 0001750 00000003271 14214766567 020703  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifdef CONFIG_PLATFORM_OPS
#include <linux/delay.h>		/* msleep() */
#include <linux/rfkill-wlan.h>		/* rockchip_wifi_xxx() */


/*
 * Return:
 *	0:	power on successfully
 *	others: power on failed
 */
int platform_wifi_power_on(void)
{
	int ret = 0;


	printk("\n");
	printk("=======================================================\n");
	printk("==== Launching Wi-Fi driver! (Powered by Rockchip) ====\n");
	printk("=======================================================\n");
	printk("Realtek SDIO WiFi driver (Powered by Rockchip) init.\n");
	rockchip_wifi_power(1);
	msleep(100);
	rockchip_wifi_set_carddetect(1);

	return ret;
}

void platform_wifi_power_off(void)
{
	printk("\n");
	printk("=======================================================\n");
	printk("=== Dislaunching Wi-Fi driver! (Powered by Rockchip) ==\n");
	printk("=======================================================\n");
	printk("Realtek SDIO WiFi driver (Powered by Rockchip) init.\n");
	rockchip_wifi_set_carddetect(0);
	msleep(100);
	rockchip_wifi_power(0);
}
#endif /* !CONFIG_PLATFORM_OPS */
                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/platform/platform_RTK_DMP_usb.c                                                       0000644 0001750 0001750 00000001706 14214766567 017712  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#include <drv_types.h>

int platform_wifi_power_on(void)
{
	int ret = 0;
	u32 tmp;
	tmp = readl((volatile unsigned int *)0xb801a608);
	tmp &= 0xffffff00;
	tmp |= 0x55;
	writel(tmp, (volatile unsigned int *)0xb801a608); /* write dummy register for 1055 */
	return ret;
}

void platform_wifi_power_off(void)
{
}
                                                          rtl8822bu/src/Kconfig                                                                               0000644 0001750 0001750 00000000156 14214766567 013306  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 config RTL8822BU
	tristate "Realtek 8822B USB WiFi"
	depends on USB
	---help---
	  Help message of RTL8822BU

                                                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/gcat.note                                                                             0000664 0001750 0001750 00000023541 14214766567 013615  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 //---

make -f Makefile1 clean

----------------------------------ok 

PATH=$PATH:/home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/bin

export STAGING_DIR="/home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/include"

	export CROSS_COMPILE="mipsel-openwrt-linux-"
	export ARCH=mips




make  -C "/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/linux-5.4.154" \
KCFLAGS="-fmacro-prefix-map=/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl=target-mipsel_24kc_musl" \
HOSTCFLAGS="-O2 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/hostpkg/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/host/include \
-Wall -Wmissing-prototypes -Wstrict-prototypes" \
CROSS_COMPILE="mipsel-openwrt-linux-musl-" \
ARCH="mips" \
KBUILD_HAVE_NLS=no KBUILD_BUILD_USER="" \
KBUILD_BUILD_HOST="" \
KBUILD_BUILD_TIMESTAMP="Sun Oct 24 09:01:35 2021" \
KBUILD_BUILD_VERSION="0" HOST_LOADLIBES="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
KBUILD_HOSTLDLIBS="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
CONFIG_SHELL="bash" V=''  cmd_syscalls= \
KBUILD_EXTRA_SYMBOLS="/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812au-ct.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/exfat.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8192euz.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/gpio-button-hotplug.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mac80211.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/8291eu.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mt76.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/demo.symvers" \
KERNELRELEASE=5.4.154  \
M="/home/ai7688/0303a/old/rtl8822_5.8.7" \
NOSTDINC_FLAGS="\
-DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT \
-DBUILD_OPENWRT \
-nostdinc  \
-isystem /home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/lib/gcc/mipsel-openwrt-linux-musl/8.4.0/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-include /home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/backport/backport.h \
" \
modules

-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/include \

-I/home/ai7688/0303a/old/rtl8822_5.7 \
-I/home/ai7688/0303a/old/rtl8822_5.7/include \

-include backport/backport.h \
-include /home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/net/cfg80211.h \
-DCONFIG_CONCURRENT_MODE \



-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
#
-include backport/backport.h \

-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \

-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \




./build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/backports-5.10.68-1/backport-include/backport/backport.h
./staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/backport/backport.h


export STAGING_DIR="/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr"

---------------------------------build no80211
make  -C "/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/linux-5.4.154" \
KCFLAGS="-fmacro-prefix-map=/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl=target-mipsel_24kc_musl" \
HOSTCFLAGS="-O2 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/hostpkg/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/host/include \
-Wall -Wmissing-prototypes -Wstrict-prototypes" \
CROSS_COMPILE="mipsel-openwrt-linux-musl-" \
ARCH="mips" \
KBUILD_HAVE_NLS=no KBUILD_BUILD_USER="" \
KBUILD_BUILD_HOST="" \
KBUILD_BUILD_TIMESTAMP="Sun Oct 24 09:01:35 2021" \
KBUILD_BUILD_VERSION="0" HOST_LOADLIBES="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
KBUILD_HOSTLDLIBS="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
CONFIG_SHELL="bash" V=''  cmd_syscalls= \
KBUILD_EXTRA_SYMBOLS="/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812au-ct.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/exfat.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8192euz.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/gpio-button-hotplug.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mac80211.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/8291eu.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mt76.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/demo.symvers" \
KERNELRELEASE=5.4.154  \
M="/home/ai7688/0303a/old/rtl8822_5.8.7" \
NOSTDINC_FLAGS="\
-DBUILD_OPENWRT \
" \
modules

-DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT \
-nostdinc  \
-isystem /home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/lib/gcc/mipsel-openwrt-linux-musl/8.4.0/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-include /home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/backport/backport.h \

--------------------------------------
make -j1 -C "/home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/linux-5.4.154" KCFLAGS="-fmacro-prefix-map=/home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl=target-mipsel_24kc_musl" HOSTCFLAGS="-O2 -I/home/ai7688/0310/openwrt-b4d7885/staging_dir/host/include -I/home/ai7688/0310/openwrt-b4d7885/staging_dir/hostpkg/include -I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/host/include -Wall -Wmissing-prototypes -Wstrict-prototypes" CROSS_COMPILE="mipsel-openwrt-linux-musl-" ARCH="mips" KBUILD_HAVE_NLS=no KBUILD_BUILD_USER="" KBUILD_BUILD_HOST="" KBUILD_BUILD_TIMESTAMP="Sun Oct 24 09:01:35 2021" KBUILD_BUILD_VERSION="0" HOST_LOADLIBES="-L/home/ai7688/0310/openwrt-b4d7885/staging_dir/host/lib" KBUILD_HOSTLDLIBS="-L/home/ai7688/0310/openwrt-b4d7885/staging_dir/host/lib" CONFIG_SHELL="bash" V=''  cmd_syscalls= KBUILD_EXTRA_SYMBOLS="/home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812au-ct.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812bu.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8192eu.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/gpio-button-hotplug.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mac80211.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mt76.symvers" KERNELRELEASE=5.4.154 \
M="/home/ai7688/0303a/old/rtl8822_5.8.7" \
NOSTDINC_FLAGS="-nostdinc  \
-isystem /home/ai7688/0310/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/bin/../lib/gcc/mipsel-openwrt-linux-musl/8.4.0/include \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-I/home/ai7688//0303a/old/rtl8822_5.8.7 \
-I/home/ai7688//0303a/old/rtl8822_5.8.7/include \
-include backport/backport.h \
-DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT  \
-DCONFIG_CONCURRENT_MODE \
-DBUILD_OPENWRT -DBACKPORT -DCONFIG_LITTLE_ENDIAN \
-DCONFIG_DEBUG -DCONFIG_RTW_DEBUG"  \
modules



                                                                                                                                                               rtl8822bu/src/wlan0dhcp                                                                             0000644 0001750 0001750 00000000446 14214766567 013610  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 #!/bin/bash

var0=`ps aux|awk '/dhclient wlan0/'|awk '$11!="awk"{print $2}'`

kill $var0
cp ifcfg-wlan0 /etc/sysconfig/network-scripts/

dhclient wlan0

var1=`ifconfig wlan0 |awk '/inet/{print $2}'|awk -F: '{print $2}'`


rm -f /etc/sysconfig/network-scripts/ifcfg-wlan0

echo "get ip: $var1"

                                                                                                                                                                                                                          rtl8822bu/src/gcat.note~                                                                            0000664 0001750 0001750 00000023535 14214766567 014016  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 //---

make -f Makefile1 clean

----------------------------------ok 

PATH=$PATH:/home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/bin

export STAGING_DIR="/home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/include"

	export CROSS_COMPILE="mipsel-openwrt-linux-"
	export ARCH=mips




make  -C "/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/linux-5.4.154" \
KCFLAGS="-fmacro-prefix-map=/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl=target-mipsel_24kc_musl" \
HOSTCFLAGS="-O2 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/hostpkg/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/host/include \
-Wall -Wmissing-prototypes -Wstrict-prototypes" \
CROSS_COMPILE="mipsel-openwrt-linux-musl-" \
ARCH="mips" \
KBUILD_HAVE_NLS=no KBUILD_BUILD_USER="" \
KBUILD_BUILD_HOST="" \
KBUILD_BUILD_TIMESTAMP="Sun Oct 24 09:01:35 2021" \
KBUILD_BUILD_VERSION="0" HOST_LOADLIBES="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
KBUILD_HOSTLDLIBS="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
CONFIG_SHELL="bash" V=''  cmd_syscalls= \
KBUILD_EXTRA_SYMBOLS="/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812au-ct.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/exfat.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8192euz.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/gpio-button-hotplug.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mac80211.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/8291eu.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mt76.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/demo.symvers" \
KERNELRELEASE=5.4.154  \
M="/home/ai7688/0303a/old/rtl8822_5.8.7" \
NOSTDINC_FLAGS="\
-DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT \
-DBUILD_OPENWRT \
-nostdinc  \
-isystem /home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/lib/gcc/mipsel-openwrt-linux-musl/8.4.0/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-include /home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/backport/backport.h \
" \
modules

-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/include \

-I/home/ai7688/0303a/old/rtl8822_5.7 \
-I/home/ai7688/0303a/old/rtl8822_5.7/include \

-include backport/backport.h \
-include /home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/net/cfg80211.h \
-DCONFIG_CONCURRENT_MODE \



-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
#
-include backport/backport.h \

-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \

-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \




./build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/backports-5.10.68-1/backport-include/backport/backport.h
./staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/backport/backport.h


export STAGING_DIR="/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr"

---------------------------------build no80211
make  -C "/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/linux-5.4.154" \
KCFLAGS="-fmacro-prefix-map=/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl=target-mipsel_24kc_musl" \
HOSTCFLAGS="-O2 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/hostpkg/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/host/include \
-Wall -Wmissing-prototypes -Wstrict-prototypes" \
CROSS_COMPILE="mipsel-openwrt-linux-musl-" \
ARCH="mips" \
KBUILD_HAVE_NLS=no KBUILD_BUILD_USER="" \
KBUILD_BUILD_HOST="" \
KBUILD_BUILD_TIMESTAMP="Sun Oct 24 09:01:35 2021" \
KBUILD_BUILD_VERSION="0" HOST_LOADLIBES="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
KBUILD_HOSTLDLIBS="-L/home/ai7688/0221/openwrt-b4d7885/staging_dir/host/lib" \
CONFIG_SHELL="bash" V=''  cmd_syscalls= \
KBUILD_EXTRA_SYMBOLS="/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812au-ct.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/exfat.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8192euz.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/gpio-button-hotplug.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mac80211.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/8291eu.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mt76.symvers \
/home/ai7688/0221/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/demo.symvers" \
KERNELRELEASE=5.4.154  \
M="/home/ai7688/0303a/old/rtl8822_5.8.7" \
NOSTDINC_FLAGS="\
-DBUILD_OPENWRT \
" \
modules

-DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT \
-nostdinc  \
-isystem /home/ai7688/0221/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/lib/gcc/mipsel-openwrt-linux-musl/8.4.0/include \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-include /home/ai7688/0221/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/backport/backport.h \

--------------------------------------
make -j1 -C "/home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/linux-5.4.154" KCFLAGS="-fmacro-prefix-map=/home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl=target-mipsel_24kc_musl" HOSTCFLAGS="-O2 -I/home/ai7688/0310/openwrt-b4d7885/staging_dir/host/include -I/home/ai7688/0310/openwrt-b4d7885/staging_dir/hostpkg/include -I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/host/include -Wall -Wmissing-prototypes -Wstrict-prototypes" CROSS_COMPILE="mipsel-openwrt-linux-musl-" ARCH="mips" KBUILD_HAVE_NLS=no KBUILD_BUILD_USER="" KBUILD_BUILD_HOST="" KBUILD_BUILD_TIMESTAMP="Sun Oct 24 09:01:35 2021" KBUILD_BUILD_VERSION="0" HOST_LOADLIBES="-L/home/ai7688/0310/openwrt-b4d7885/staging_dir/host/lib" KBUILD_HOSTLDLIBS="-L/home/ai7688/0310/openwrt-b4d7885/staging_dir/host/lib" CONFIG_SHELL="bash" V=''  cmd_syscalls= KBUILD_EXTRA_SYMBOLS="/home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812au-ct.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8812bu.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/rtl8192eu.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/gpio-button-hotplug.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mac80211.symvers /home/ai7688/0310/openwrt-b4d7885/build_dir/target-mipsel_24kc_musl/linux-ramips_mt76x8/symvers/mt76.symvers" KERNELRELEASE=5.4.154 \
M="/home/ai7688/0303a/old/rtl8822_5.8.7" \
NOSTDINC_FLAGS="-nostdinc  \
-isystem /home/ai7688/0310/openwrt-b4d7885/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl/bin/../lib/gcc/mipsel-openwrt-linux-musl/8.4.0/include \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211-backport/uapi \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211 \
-I/home/ai7688/0310/openwrt-b4d7885/staging_dir/target-mipsel_24kc_musl/usr/include/mac80211/uapi \
-I/home/ai7688//0303a/old/rtl8822_5.8.7 \
-I/home/ai7688//0303a/old/rtl8822_5.8.7/include \
-include backport/backport.h -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT  \
-DBUILD_OPENWRT -DBACKPORT -DCONFIG_LITTLE_ENDIAN\
-DCONFIG_DEBUG -DCONFIG_RTW_DEBUG"  \
modules


-DCONFIG_CONCURRENT_MODE \
                                                                                                                                                                   rtl8822bu/src/include/                                                                              0000755 0001750 0001750 00000000000 14214766567 013424  5                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 rtl8822bu/src/include/rtw_android.h                                                                 0000644 0001750 0001750 00000007226 14214766567 016120  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __RTW_ANDROID_H__
#define __RTW_ANDROID_H__

enum ANDROID_WIFI_CMD {
	ANDROID_WIFI_CMD_START,
	ANDROID_WIFI_CMD_STOP,
	ANDROID_WIFI_CMD_SCAN_ACTIVE,
	ANDROID_WIFI_CMD_SCAN_PASSIVE,
	ANDROID_WIFI_CMD_RSSI,
	ANDROID_WIFI_CMD_LINKSPEED,
	ANDROID_WIFI_CMD_RXFILTER_START,
	ANDROID_WIFI_CMD_RXFILTER_STOP,
	ANDROID_WIFI_CMD_RXFILTER_ADD,
	ANDROID_WIFI_CMD_RXFILTER_REMOVE,
	ANDROID_WIFI_CMD_BTCOEXSCAN_START,
	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP,
	ANDROID_WIFI_CMD_BTCOEXMODE,
	ANDROID_WIFI_CMD_SETSUSPENDMODE,
	ANDROID_WIFI_CMD_SETSUSPENDOPT,
	ANDROID_WIFI_CMD_P2P_DEV_ADDR,
	ANDROID_WIFI_CMD_SETFWPATH,
	ANDROID_WIFI_CMD_SETBAND,
	ANDROID_WIFI_CMD_GETBAND,
	ANDROID_WIFI_CMD_COUNTRY,
	ANDROID_WIFI_CMD_P2P_SET_NOA,
	ANDROID_WIFI_CMD_P2P_GET_NOA,
	ANDROID_WIFI_CMD_P2P_SET_PS,
	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,

	ANDROID_WIFI_CMD_MIRACAST,

#ifdef CONFIG_PNO_SUPPORT
	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
	ANDROID_WIFI_CMD_PNOSETUP_SET,
	ANDROID_WIFI_CMD_PNOENABLE_SET,
	ANDROID_WIFI_CMD_PNODEBUG_SET,
#endif

	ANDROID_WIFI_CMD_MACADDR,

	ANDROID_WIFI_CMD_BLOCK_SCAN,
	ANDROID_WIFI_CMD_BLOCK,

	ANDROID_WIFI_CMD_WFD_ENABLE,
	ANDROID_WIFI_CMD_WFD_DISABLE,

	ANDROID_WIFI_CMD_WFD_SET_TCPPORT,
	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT,
	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE,
	ANDROID_WIFI_CMD_CHANGE_DTIM,
	ANDROID_WIFI_CMD_HOSTAPD_SET_MACADDR_ACL,
	ANDROID_WIFI_CMD_HOSTAPD_ACL_ADD_STA,
	ANDROID_WIFI_CMD_HOSTAPD_ACL_REMOVE_STA,
#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0))
	ANDROID_WIFI_CMD_GTK_REKEY_OFFLOAD,
#endif /* CONFIG_GTK_OL */
	ANDROID_WIFI_CMD_P2P_DISABLE,
	ANDROID_WIFI_CMD_SET_AEK,
	ANDROID_WIFI_CMD_EXT_AUTH_STATUS,
	ANDROID_WIFI_CMD_DRIVERVERSION,
	ANDROID_WIFI_CMD_MAX
};

int rtw_android_cmdstr_to_num(char *cmdstr);
int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);

#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
int rtw_android_pno_enable(struct net_device *net, int pno_enable);
int rtw_android_cfg80211_pno_setup(struct net_device *net,
		   struct cfg80211_ssid *ssid, int n_ssids, int interval);
#endif

#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
int rtw_android_wifictrl_func_add(void);
void rtw_android_wifictrl_func_del(void);
void *wl_android_prealloc(int section, unsigned long size);

int wifi_get_irq_number(unsigned long *irq_flags_ptr);
int wifi_set_power(int on, unsigned long msec);
int wifi_get_mac_addr(unsigned char *buf);
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
void *wifi_get_country_code(char *ccode, u32 flags);
#else /* Linux kernel < 3.18 */
void *wifi_get_country_code(char *ccode);
#endif /* Linux kernel < 3.18 */
#else
static inline int rtw_android_wifictrl_func_add(void)
{
	return 0;
}
static inline void rtw_android_wifictrl_func_del(void) {}
#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */

#ifdef CONFIG_GPIO_WAKEUP
#ifdef CONFIG_PLATFORM_INTEL_BYT
int wifi_configure_gpio(void);
#endif /* CONFIG_PLATFORM_INTEL_BYT */
void wifi_free_gpio(unsigned int gpio);
#endif /* CONFIG_GPIO_WAKEUP */


#endif /* __RTW_ANDROID_H__ */
                                                                                                                                                                                                                                                                                                                                                                          rtl8822bu/src/include/rtw_rf.h                                                                      0000644 0001750 0001750 00000021666 14214766567 015113  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef	__RTW_RF_H_
#define __RTW_RF_H_

#define NumRates	(13)
#define	B_MODE_RATE_NUM	(4)
#define	G_MODE_RATE_NUM	(8)
#define	G_MODE_BASIC_RATE_NUM	(3)
/* slot time for 11g */
#define SHORT_SLOT_TIME					9
#define NON_SHORT_SLOT_TIME				20

#define CENTER_CH_2G_40M_NUM	9
#define CENTER_CH_2G_NUM		14
#define CENTER_CH_5G_20M_NUM	28	/* 20M center channels */
#define CENTER_CH_5G_40M_NUM	14	/* 40M center channels */
#define CENTER_CH_5G_80M_NUM	7	/* 80M center channels */
#define CENTER_CH_5G_160M_NUM	3	/* 160M center channels */
#define CENTER_CH_5G_ALL_NUM	(CENTER_CH_5G_20M_NUM + CENTER_CH_5G_40M_NUM + CENTER_CH_5G_80M_NUM)

#define	MAX_CHANNEL_NUM_2G	CENTER_CH_2G_NUM
#define	MAX_CHANNEL_NUM_5G	CENTER_CH_5G_20M_NUM
#define	MAX_CHANNEL_NUM		(MAX_CHANNEL_NUM_2G + MAX_CHANNEL_NUM_5G)

extern u8 center_ch_2g[CENTER_CH_2G_NUM];
extern u8 center_ch_2g_40m[CENTER_CH_2G_40M_NUM];

u8 center_chs_2g_num(u8 bw);
u8 center_chs_2g(u8 bw, u8 id);

extern u8 center_ch_5g_20m[CENTER_CH_5G_20M_NUM];
extern u8 center_ch_5g_40m[CENTER_CH_5G_40M_NUM];
extern u8 center_ch_5g_20m_40m[CENTER_CH_5G_20M_NUM + CENTER_CH_5G_40M_NUM];
extern u8 center_ch_5g_80m[CENTER_CH_5G_80M_NUM];
extern u8 center_ch_5g_all[CENTER_CH_5G_ALL_NUM];

u8 center_chs_5g_num(u8 bw);
u8 center_chs_5g(u8 bw, u8 id);

u8 rtw_get_scch_by_cch_offset(u8 cch, u8 bw, u8 offset);
u8 rtw_get_scch_by_cch_opch(u8 cch, u8 bw, u8 opch);

u8 rtw_get_op_chs_by_cch_bw(u8 cch, u8 bw, u8 **op_chs, u8 *op_ch_num);

u8 rtw_get_ch_group(u8 ch, u8 *group, u8 *cck_group);

typedef enum _CAPABILITY {
	cESS			= 0x0001,
	cIBSS			= 0x0002,
	cPollable		= 0x0004,
	cPollReq			= 0x0008,
	cPrivacy		= 0x0010,
	cShortPreamble	= 0x0020,
	cPBCC			= 0x0040,
	cChannelAgility	= 0x0080,
	cSpectrumMgnt	= 0x0100,
	cQos			= 0x0200,	/* For HCCA, use with CF-Pollable and CF-PollReq */
	cShortSlotTime	= 0x0400,
	cAPSD			= 0x0800,
	cRM				= 0x1000,	/* RRM (Radio Request Measurement) */
	cDSSS_OFDM	= 0x2000,
	cDelayedBA		= 0x4000,
	cImmediateBA	= 0x8000,
} CAPABILITY, *PCAPABILITY;

enum	_REG_PREAMBLE_MODE {
	PREAMBLE_LONG	= 1,
	PREAMBLE_AUTO	= 2,
	PREAMBLE_SHORT	= 3,
};

#define rf_path_char(path) (((path) >= RF_PATH_MAX) ? 'X' : 'A' + (path))

/* Bandwidth Offset */
#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
#define HAL_PRIME_CHNL_OFFSET_LOWER	1
#define HAL_PRIME_CHNL_OFFSET_UPPER	2

typedef enum _BAND_TYPE {
	BAND_ON_2_4G = 0,
	BAND_ON_5G = 1,
	BAND_MAX,
} BAND_TYPE, *PBAND_TYPE;

#ifdef CONFIG_NARROWBAND_SUPPORTING
enum nb_config {
	RTW_NB_CONFIG_NONE		= 0,
	RTW_NB_CONFIG_WIDTH_5	= 5,
	RTW_NB_CONFIG_WIDTH_10	= 6,
};
#endif

extern const char *const _band_str[];
#define band_str(band) (((band) >= BAND_MAX) ? _band_str[BAND_MAX] : _band_str[(band)])

extern const u8 _band_to_band_cap[];
#define band_to_band_cap(band) (((band) >= BAND_MAX) ? _band_to_band_cap[BAND_MAX] : _band_to_band_cap[(band)])


extern const char *const _ch_width_str[];
#define ch_width_str(bw) (((bw) < CHANNEL_WIDTH_MAX) ? _ch_width_str[(bw)] : "CHANNEL_WIDTH_MAX")

extern const u8 _ch_width_to_bw_cap[];
#define ch_width_to_bw_cap(bw) (((bw) < CHANNEL_WIDTH_MAX) ? _ch_width_to_bw_cap[(bw)] : 0)

/*
 * Represent Extention Channel Offset in HT Capabilities
 * This is available only in 40Mhz mode.
 *   */
typedef enum _EXTCHNL_OFFSET {
	EXTCHNL_OFFSET_NO_EXT = 0,
	EXTCHNL_OFFSET_UPPER = 1,
	EXTCHNL_OFFSET_NO_DEF = 2,
	EXTCHNL_OFFSET_LOWER = 3,
} EXTCHNL_OFFSET, *PEXTCHNL_OFFSET;

typedef enum _VHT_DATA_SC {
	VHT_DATA_SC_DONOT_CARE = 0,
	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
	VHT_DATA_SC_20_RECV1 = 5,
	VHT_DATA_SC_20_RECV2 = 6,
	VHT_DATA_SC_20_RECV3 = 7,
	VHT_DATA_SC_20_RECV4 = 8,
	VHT_DATA_SC_40_UPPER_OF_80MHZ = 9,
	VHT_DATA_SC_40_LOWER_OF_80MHZ = 10,
} VHT_DATA_SC, *PVHT_DATA_SC_E;

typedef enum _PROTECTION_MODE {
	PROTECTION_MODE_AUTO = 0,
	PROTECTION_MODE_FORCE_ENABLE = 1,
	PROTECTION_MODE_FORCE_DISABLE = 2,
} PROTECTION_MODE, *PPROTECTION_MODE;

#define RF_TYPE_VALID(rf_type) (rf_type < RF_TYPE_MAX)

extern const u8 _rf_type_to_rf_tx_cnt[];
#define rf_type_to_rf_tx_cnt(rf_type) (RF_TYPE_VALID(rf_type) ? _rf_type_to_rf_tx_cnt[rf_type] : 0)

extern const u8 _rf_type_to_rf_rx_cnt[];
#define rf_type_to_rf_rx_cnt(rf_type) (RF_TYPE_VALID(rf_type) ? _rf_type_to_rf_rx_cnt[rf_type] : 0)

extern const char *const _rf_type_to_rfpath_str[];
#define rf_type_to_rfpath_str(rf_type) (RF_TYPE_VALID(rf_type) ? _rf_type_to_rfpath_str[rf_type] : "UNKNOWN")

void rf_type_to_default_trx_bmp(enum rf_type rf, enum bb_path *tx, enum bb_path *rx);

enum rf_type trx_num_to_rf_type(u8 tx_num, u8 rx_num);
enum rf_type trx_bmp_to_rf_type(u8 tx_bmp, u8 rx_bmp);
bool rf_type_is_a_in_b(enum rf_type a, enum rf_type b);
u8 rtw_restrict_trx_path_bmp_by_rftype(u8 trx_path_bmp, enum rf_type type, u8 *tx_num, u8 *rx_num);
void tx_path_nss_set_default(enum bb_path txpath_nss[], u8 txpath_num_nss[], u8 txpath);
void tx_path_nss_set_full_tx(enum bb_path txpath_nss[], u8 txpath_num_nss[], u8 txpath);

int rtw_ch2freq(int chan);
int rtw_freq2ch(int freq);
bool rtw_chbw_to_freq_range(u8 ch, u8 bw, u8 offset, u32 *hi, u32 *lo);

struct rf_ctl_t;

typedef enum _REGULATION_TXPWR_LMT {
	TXPWR_LMT_NONE = 0, /* no limit */
	TXPWR_LMT_FCC = 1,
	TXPWR_LMT_MKK = 2,
	TXPWR_LMT_ETSI = 3,
	TXPWR_LMT_IC = 4,
	TXPWR_LMT_KCC = 5,
	TXPWR_LMT_ACMA = 6,
	TXPWR_LMT_CHILE = 7,
	TXPWR_LMT_MEXICO = 8,
	TXPWR_LMT_WW = 9, /* smallest of all available limit, keep last */
} REGULATION_TXPWR_LMT;

extern const char *const _regd_str[];
#define regd_str(regd) (((regd) > TXPWR_LMT_WW) ? _regd_str[TXPWR_LMT_WW] : _regd_str[(regd)])

void txpwr_idx_get_dbm_str(s8 idx, u8 txgi_max, u8 txgi_pdbm, SIZE_T cwidth, char dbm_str[], u8 dbm_str_len);

#define MBM_PDBM 100
#define UNSPECIFIED_MBM 32767 /* maximum of s16 */

void txpwr_mbm_get_dbm_str(s16 mbm, SIZE_T cwidth, char dbm_str[], u8 dbm_str_len);
s16 mb_of_ntx(u8 ntx);

#if CONFIG_TXPWR_LIMIT
struct regd_exc_ent {
	_list list;
	char country[2];
	u8 domain;
	char regd_name[0];
};

void dump_regd_exc_list(void *sel, struct rf_ctl_t *rfctl);
void rtw_regd_exc_add_with_nlen(struct rf_ctl_t *rfctl, const char *country, u8 domain, const char *regd_name, u32 nlen);
void rtw_regd_exc_add(struct rf_ctl_t *rfctl, const char *country, u8 domain, const char *regd_name);
struct regd_exc_ent *_rtw_regd_exc_search(struct rf_ctl_t *rfctl, const char *country, u8 domain);
struct regd_exc_ent *rtw_regd_exc_search(struct rf_ctl_t *rfctl, const char *country, u8 domain);
void rtw_regd_exc_list_free(struct rf_ctl_t *rfctl);

void dump_txpwr_lmt(void *sel, _adapter *adapter);
void rtw_txpwr_lmt_add_with_nlen(struct rf_ctl_t *rfctl, const char *regd_name, u32 nlen
	, u8 band, u8 bw, u8 tlrs, u8 ntx_idx, u8 ch_idx, s8 lmt);
void rtw_txpwr_lmt_add(struct rf_ctl_t *rfctl, const char *regd_name
	, u8 band, u8 bw, u8 tlrs, u8 ntx_idx, u8 ch_idx, s8 lmt);
struct txpwr_lmt_ent *_rtw_txpwr_lmt_get_by_name(struct rf_ctl_t *rfctl, const char *regd_name);
struct txpwr_lmt_ent *rtw_txpwr_lmt_get_by_name(struct rf_ctl_t *rfctl, const char *regd_name);
void rtw_txpwr_lmt_list_free(struct rf_ctl_t *rfctl);
#endif /* CONFIG_TXPWR_LIMIT */

#define BB_GAIN_2G 0
#if CONFIG_IEEE80211_BAND_5GHZ
#define BB_GAIN_5GLB1 1
#define BB_GAIN_5GLB2 2
#define BB_GAIN_5GMB1 3
#define BB_GAIN_5GMB2 4
#define BB_GAIN_5GHB 5
#endif

#if CONFIG_IEEE80211_BAND_5GHZ
#define BB_GAIN_NUM 6
#else
#define BB_GAIN_NUM 1
#endif

int rtw_ch_to_bb_gain_sel(int ch);
void rtw_rf_set_tx_gain_offset(_adapter *adapter, u8 path, s8 offset);
void rtw_rf_apply_tx_gain_offset(_adapter *adapter, u8 ch);

/* only check channel ranges */
#define rtw_is_2g_ch(ch) (ch >= 1 && ch <= 14)
#define rtw_is_5g_ch(ch) ((ch) >= 36 && (ch) <= 177)
#define rtw_is_same_band(a, b) \
	((rtw_is_2g_ch(a) && rtw_is_2g_ch(b)) \
	|| (rtw_is_5g_ch(a) && rtw_is_5g_ch(b)))

#define rtw_is_5g_band1(ch) ((ch) >= 36 && (ch) <= 48)
#define rtw_is_5g_band2(ch) ((ch) >= 52 && (ch) <= 64)
#define rtw_is_5g_band3(ch) ((ch) >= 100 && (ch) <= 144)
#define rtw_is_5g_band4(ch) ((ch) >= 149 && (ch) <= 177)
#define rtw_is_same_5g_band(a, b) \
	((rtw_is_5g_band1(a) && rtw_is_5g_band1(b)) \
	|| (rtw_is_5g_band2(a) && rtw_is_5g_band2(b)) \
	|| (rtw_is_5g_band3(a) && rtw_is_5g_band3(b)) \
	|| (rtw_is_5g_band4(a) && rtw_is_5g_band4(b)))

bool rtw_is_long_cac_range(u32 hi, u32 lo, u8 dfs_region);
bool rtw_is_long_cac_ch(u8 ch, u8 bw, u8 offset, u8 dfs_region);

#endif /* _RTL8711_RF_H_ */
                                                                          rtl8822bu/src/include/pci_ops.h                                                                     0000644 0001750 0001750 00000010310 14214766567 015224  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PCI_OPS_H_
#define __PCI_OPS_H_


#ifdef CONFIG_RTL8188E
	u32	rtl8188ee_init_desc_ring(_adapter *padapter);
	u32	rtl8188ee_free_desc_ring(_adapter *padapter);
	void	rtl8188ee_reset_desc_ring(_adapter *padapter);
	int	rtl8188ee_interrupt(PADAPTER Adapter);
	void	rtl8188ee_xmit_tasklet(void *priv);
	void	rtl8188ee_recv_tasklet(void *priv);
	void	rtl8188ee_prepare_bcn_tasklet(void *priv);
	void	rtl8188ee_set_intf_ops(struct _io_ops	*pops);
	void	rtw8188ee_unmap_beacon_icf(_adapter *padapter);
#endif

#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
	u32	rtl8812ae_init_desc_ring(_adapter *padapter);
	u32	rtl8812ae_free_desc_ring(_adapter *padapter);
	void	rtl8812ae_reset_desc_ring(_adapter *padapter);
	int	rtl8812ae_interrupt(PADAPTER Adapter);
	void	rtl8812ae_xmit_tasklet(void *priv);
	void	rtl8812ae_recv_tasklet(void *priv);
	void	rtl8812ae_prepare_bcn_tasklet(void *priv);
	void	rtl8812ae_set_intf_ops(struct _io_ops	*pops);
	void	rtw8812ae_unmap_beacon_icf(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8192E
	u32	rtl8192ee_init_desc_ring(_adapter *padapter);
	u32	rtl8192ee_free_desc_ring(_adapter *padapter);
	void	rtl8192ee_reset_desc_ring(_adapter *padapter);
	void	rtl8192ee_recv_tasklet(void *priv);
	void	rtl8192ee_prepare_bcn_tasklet(void *priv);
	int	rtl8192ee_interrupt(PADAPTER Adapter);
	void	rtl8192ee_set_intf_ops(struct _io_ops	*pops);
	void	rtw8192ee_unmap_beacon_icf(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8192F
	u32	rtl8192fe_init_desc_ring(_adapter *padapter);
	u32	rtl8192fe_free_desc_ring(_adapter *padapter);
	void	rtl8192fe_reset_desc_ring(_adapter *padapter);
	int	rtl8192fe_interrupt(PADAPTER Adapter);
	void	rtl8192fe_recv_tasklet(void *priv);
	void	rtl8192fe_prepare_bcn_tasklet(void *priv);
	void	rtl8192fe_set_intf_ops(struct _io_ops	*pops);
	u8 check_tx_desc_resource(_adapter *padapter, int prio);
	void	rtl8192fe_unmap_beacon_icf(PADAPTER Adapter);
#endif

#ifdef CONFIG_RTL8723B
	u32	rtl8723be_init_desc_ring(_adapter *padapter);
	u32	rtl8723be_free_desc_ring(_adapter *padapter);
	void	rtl8723be_reset_desc_ring(_adapter *padapter);
	int	rtl8723be_interrupt(PADAPTER Adapter);
	void	rtl8723be_recv_tasklet(void *priv);
	void	rtl8723be_prepare_bcn_tasklet(void *priv);
	void	rtl8723be_set_intf_ops(struct _io_ops	*pops);
	void	rtl8723be_unmap_beacon_icf(PADAPTER Adapter);
#endif

#ifdef CONFIG_RTL8723D
	u32	rtl8723de_init_desc_ring(_adapter *padapter);
	u32	rtl8723de_free_desc_ring(_adapter *padapter);
	void	rtl8723de_reset_desc_ring(_adapter *padapter);
	int	rtl8723de_interrupt(PADAPTER Adapter);
	void	rtl8723de_recv_tasklet(void *priv);
	void	rtl8723de_prepare_bcn_tasklet(void *priv);
	void	rtl8723de_set_intf_ops(struct _io_ops	*pops);
	u8 check_tx_desc_resource(_adapter *padapter, int prio);
	void 	rtl8723de_unmap_beacon_icf(PADAPTER Adapter);
#endif

#ifdef CONFIG_RTL8814A
	u32	rtl8814ae_init_desc_ring(_adapter *padapter);
	u32	rtl8814ae_free_desc_ring(_adapter *padapter);
	void	rtl8814ae_reset_desc_ring(_adapter *padapter);
	int	rtl8814ae_interrupt(PADAPTER Adapter);
	void	rtl8814ae_xmit_tasklet(void *priv);
	void	rtl8814ae_recv_tasklet(void *priv);
	void	rtl8814ae_prepare_bcn_tasklet(void *priv);
	void	rtl8814ae_set_intf_ops(struct _io_ops	*pops);
	void	rtl8814ae_unmap_beacon_icf(PADAPTER Adapter);
#endif

#ifdef CONFIG_RTL8822B
	void rtl8822be_set_intf_ops(struct _io_ops *pops);
#endif

#ifdef CONFIG_RTL8821C
	void rtl8821ce_set_intf_ops(struct _io_ops *pops);
#endif

#ifdef CONFIG_RTL8822C
	void rtl8822ce_set_intf_ops(struct _io_ops *pops);
#endif

#ifdef CONFIG_RTL8814B
	void rtl8814be_set_intf_ops(struct _io_ops *pops);
#endif
#endif
                                                                                                                                                                                                                                                                                                                        rtl8822bu/src/include/osdep_service.h                                                               0000644 0001750 0001750 00000067324 14214766567 016443  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __OSDEP_SERVICE_H_
#define __OSDEP_SERVICE_H_


#define _FAIL					0
#define _SUCCESS				1
#define RTW_RX_HANDLED			2
#define RTW_RFRAME_UNAVAIL		3
#define RTW_RFRAME_PKT_UNAVAIL	4
#define RTW_RBUF_UNAVAIL		5
#define RTW_RBUF_PKT_UNAVAIL	6
#define RTW_SDIO_READ_PORT_FAIL	7
#define RTW_ALREADY				8
#define RTW_RA_RESOLVING		9
#define RTW_BMC_NO_NEED			10
#define RTW_XBUF_UNAVAIL		11
#define RTW_TX_BALANCE			12
#define RTW_TX_WAIT_MORE_FRAME	13

/* #define RTW_STATUS_TIMEDOUT -110 */

#undef _TRUE
#define _TRUE		1

#undef _FALSE
#define _FALSE		0


#ifdef PLATFORM_FREEBSD
	#include <osdep_service_bsd.h>
#endif

#ifdef PLATFORM_LINUX
	#include <linux/version.h>
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
	#include <linux/sched/signal.h>
	#include <linux/sched/types.h>
#endif
	#include <osdep_service_linux.h>
	#include <drv_types_linux.h>
#endif

#ifdef PLATFORM_OS_XP
	#include <osdep_service_xp.h>
	#include <drv_types_xp.h>
#endif

#ifdef PLATFORM_OS_CE
	#include <osdep_service_ce.h>
	#include <drv_types_ce.h>
#endif

/* #include <rtw_byteorder.h> */

#ifndef BIT
	#define BIT(x)	(1 << (x))
#endif

#define CHECK_BIT(a, b) (!!((a) & (b)))

#define BIT0	0x00000001
#define BIT1	0x00000002
#define BIT2	0x00000004
#define BIT3	0x00000008
#define BIT4	0x00000010
#define BIT5	0x00000020
#define BIT6	0x00000040
#define BIT7	0x00000080
#define BIT8	0x00000100
#define BIT9	0x00000200
#define BIT10	0x00000400
#define BIT11	0x00000800
#define BIT12	0x00001000
#define BIT13	0x00002000
#define BIT14	0x00004000
#define BIT15	0x00008000
#define BIT16	0x00010000
#define BIT17	0x00020000
#define BIT18	0x00040000
#define BIT19	0x00080000
#define BIT20	0x00100000
#define BIT21	0x00200000
#define BIT22	0x00400000
#define BIT23	0x00800000
#define BIT24	0x01000000
#define BIT25	0x02000000
#define BIT26	0x04000000
#define BIT27	0x08000000
#define BIT28	0x10000000
#define BIT29	0x20000000
#define BIT30	0x40000000
#define BIT31	0x80000000
#define BIT32	0x0100000000
#define BIT33	0x0200000000
#define BIT34	0x0400000000
#define BIT35	0x0800000000
#define BIT36	0x1000000000

#ifndef GENMASK
#define GENMASK(h, l) \
	(((~0UL) - (1UL << (l)) + 1) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
#endif

extern int RTW_STATUS_CODE(int error_code);

#ifndef RTK_DMP_PLATFORM
	#define CONFIG_USE_VMALLOC
#endif

/* flags used for rtw_mstat_update() */
enum mstat_f {
	/* type: 0x00ff */
	MSTAT_TYPE_VIR = 0x00,
	MSTAT_TYPE_PHY = 0x01,
	MSTAT_TYPE_SKB = 0x02,
	MSTAT_TYPE_USB = 0x03,
	MSTAT_TYPE_MAX = 0x04,

	/* func: 0xff00 */
	MSTAT_FUNC_UNSPECIFIED = 0x00 << 8,
	MSTAT_FUNC_IO = 0x01 << 8,
	MSTAT_FUNC_TX_IO = 0x02 << 8,
	MSTAT_FUNC_RX_IO = 0x03 << 8,
	MSTAT_FUNC_TX = 0x04 << 8,
	MSTAT_FUNC_RX = 0x05 << 8,
	MSTAT_FUNC_CFG_VENDOR = 0x06 << 8,
	MSTAT_FUNC_MAX = 0x07 << 8,
};

#define mstat_tf_idx(flags) ((flags) & 0xff)
#define mstat_ff_idx(flags) (((flags) & 0xff00) >> 8)

typedef enum mstat_status {
	MSTAT_ALLOC_SUCCESS = 0,
	MSTAT_ALLOC_FAIL,
	MSTAT_FREE
} MSTAT_STATUS;

#ifdef DBG_MEM_ALLOC
void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 sz);
void rtw_mstat_dump(void *sel);
bool match_mstat_sniff_rules(const enum mstat_f flags, const size_t size);
void *dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
void *dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
void dbg_rtw_vmfree(void *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);
void *dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
void *dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
void dbg_rtw_mfree(void *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);

struct sk_buff *dbg_rtw_skb_alloc(unsigned int size, const enum mstat_f flags, const char *func, const int line);
void dbg_rtw_skb_free(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
struct sk_buff *dbg_rtw_skb_copy(const struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
struct sk_buff *dbg_rtw_skb_clone(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
int dbg_rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
#ifdef CONFIG_RTW_NAPI
int dbg_rtw_netif_receive_skb(_nic_hdl ndev, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
#ifdef CONFIG_RTW_GRO
gro_result_t dbg_rtw_napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
#endif
#endif /* CONFIG_RTW_NAPI */
void dbg_rtw_skb_queue_purge(struct sk_buff_head *list, enum mstat_f flags, const char *func, int line);
#ifdef CONFIG_USB_HCI
void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma, const enum mstat_f flags, const char *func, const int line);
void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma, const enum mstat_f flags, const char *func, const int line);
#endif /* CONFIG_USB_HCI */

#ifdef CONFIG_USE_VMALLOC
#define rtw_vmalloc(sz)			dbg_rtw_vmalloc((sz), MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
#define rtw_zvmalloc(sz)			dbg_rtw_zvmalloc((sz), MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
#define rtw_vmfree(pbuf, sz)		dbg_rtw_vmfree((pbuf), (sz), MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
#define rtw_vmalloc_f(sz, mstat_f)			dbg_rtw_vmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
#define rtw_zvmalloc_f(sz, mstat_f)		dbg_rtw_zvmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
#define rtw_vmfree_f(pbuf, sz, mstat_f)	dbg_rtw_vmfree((pbuf), (sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
#else /* CONFIG_USE_VMALLOC */
#define rtw_vmalloc(sz)			dbg_rtw_malloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_zvmalloc(sz)			dbg_rtw_zmalloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_vmfree(pbuf, sz)		dbg_rtw_mfree((pbuf), (sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_vmalloc_f(sz, mstat_f)			dbg_rtw_malloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_zvmalloc_f(sz, mstat_f)		dbg_rtw_zmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_vmfree_f(pbuf, sz, mstat_f)	dbg_rtw_mfree((pbuf), (sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#endif /* CONFIG_USE_VMALLOC */
#define rtw_malloc(sz)			dbg_rtw_malloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_zmalloc(sz)			dbg_rtw_zmalloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_mfree(pbuf, sz)		dbg_rtw_mfree((pbuf), (sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_malloc_f(sz, mstat_f)			dbg_rtw_malloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_zmalloc_f(sz, mstat_f)			dbg_rtw_zmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
#define rtw_mfree_f(pbuf, sz, mstat_f)		dbg_rtw_mfree((pbuf), (sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)

#define rtw_skb_alloc(size)	dbg_rtw_skb_alloc((size), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_free(skb)	dbg_rtw_skb_free((skb), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_alloc_f(size, mstat_f)	dbg_rtw_skb_alloc((size), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_free_f(skb, mstat_f)	dbg_rtw_skb_free((skb), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_copy(skb)	dbg_rtw_skb_copy((skb), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_clone(skb)	dbg_rtw_skb_clone((skb), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_copy_f(skb, mstat_f)	dbg_rtw_skb_copy((skb), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_skb_clone_f(skb, mstat_f)	dbg_rtw_skb_clone((skb), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#define rtw_netif_rx(ndev, skb)	dbg_rtw_netif_rx(ndev, skb, MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#ifdef CONFIG_RTW_NAPI
#define rtw_netif_receive_skb(ndev, skb) dbg_rtw_netif_receive_skb(ndev, skb, MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#ifdef CONFIG_RTW_GRO
#define rtw_napi_gro_receive(napi, skb) dbg_rtw_napi_gro_receive(napi, skb, MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#endif
#endif /* CONFIG_RTW_NAPI */
#define rtw_skb_queue_purge(sk_buff_head) dbg_rtw_skb_queue_purge(sk_buff_head, MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
#ifdef CONFIG_USB_HCI
#define rtw_usb_buffer_alloc(dev, size, dma)		dbg_rtw_usb_buffer_alloc((dev), (size), (dma), MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
#define rtw_usb_buffer_free(dev, size, addr, dma)	dbg_rtw_usb_buffer_free((dev), (size), (addr), (dma), MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
#define rtw_usb_buffer_alloc_f(dev, size, dma, mstat_f)			dbg_rtw_usb_buffer_alloc((dev), (size), (dma), ((mstat_f) & 0xff00) | MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
#define rtw_usb_buffer_free_f(dev, size, addr, dma, mstat_f)	dbg_rtw_usb_buffer_free((dev), (size), (addr), (dma), ((mstat_f) & 0xff00) | MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
#endif /* CONFIG_USB_HCI */

#else /* DBG_MEM_ALLOC */
#define rtw_mstat_update(flag, status, sz) do {} while (0)
#define rtw_mstat_dump(sel) do {} while (0)
#define match_mstat_sniff_rules(flags, size) _FALSE
void *_rtw_vmalloc(u32 sz);
void *_rtw_zvmalloc(u32 sz);
void _rtw_vmfree(void *pbuf, u32 sz);
void *_rtw_zmalloc(u32 sz);
void *_rtw_malloc(u32 sz);
void _rtw_mfree(void *pbuf, u32 sz);

struct sk_buff *_rtw_skb_alloc(u32 sz);
void _rtw_skb_free(struct sk_buff *skb);
struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb);
struct sk_buff *_rtw_skb_clone(struct sk_buff *skb);
int _rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb);
#ifdef CONFIG_RTW_NAPI
int _rtw_netif_receive_skb(_nic_hdl ndev, struct sk_buff *skb);
#ifdef CONFIG_RTW_GRO
gro_result_t _rtw_napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb);
#endif
#endif /* CONFIG_RTW_NAPI */
void _rtw_skb_queue_purge(struct sk_buff_head *list);

#ifdef CONFIG_USB_HCI
void *_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma);
void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma);
#endif /* CONFIG_USB_HCI */

#ifdef CONFIG_USE_VMALLOC
#define rtw_vmalloc(sz)			_rtw_vmalloc((sz))
#define rtw_zvmalloc(sz)			_rtw_zvmalloc((sz))
#define rtw_vmfree(pbuf, sz)		_rtw_vmfree((pbuf), (sz))
#define rtw_vmalloc_f(sz, mstat_f)			_rtw_vmalloc((sz))
#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zvmalloc((sz))
#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_vmfree((pbuf), (sz))
#else /* CONFIG_USE_VMALLOC */
#define rtw_vmalloc(sz)			_rtw_malloc((sz))
#define rtw_zvmalloc(sz)			_rtw_zmalloc((sz))
#define rtw_vmfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
#define rtw_vmalloc_f(sz, mstat_f)			_rtw_malloc((sz))
#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zmalloc((sz))
#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_mfree((pbuf), (sz))
#endif /* CONFIG_USE_VMALLOC */
#define rtw_malloc(sz)			_rtw_malloc((sz))
#define rtw_zmalloc(sz)			_rtw_zmalloc((sz))
#define rtw_mfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
#define rtw_malloc_f(sz, mstat_f)			_rtw_malloc((sz))
#define rtw_zmalloc_f(sz, mstat_f)			_rtw_zmalloc((sz))
#define rtw_mfree_f(pbuf, sz, mstat_f)		_rtw_mfree((pbuf), (sz))

#define rtw_skb_alloc(size) _rtw_skb_alloc((size))
#define rtw_skb_free(skb) _rtw_skb_free((skb))
#define rtw_skb_alloc_f(size, mstat_f)	_rtw_skb_alloc((size))
#define rtw_skb_free_f(skb, mstat_f)	_rtw_skb_free((skb))
#define rtw_skb_copy(skb)	_rtw_skb_copy((skb))
#define rtw_skb_clone(skb)	_rtw_skb_clone((skb))
#define rtw_skb_copy_f(skb, mstat_f)	_rtw_skb_copy((skb))
#define rtw_skb_clone_f(skb, mstat_f)	_rtw_skb_clone((skb))
#define rtw_netif_rx(ndev, skb) _rtw_netif_rx(ndev, skb)
#ifdef CONFIG_RTW_NAPI
#define rtw_netif_receive_skb(ndev, skb) _rtw_netif_receive_skb(ndev, skb)
#ifdef CONFIG_RTW_GRO
#define rtw_napi_gro_receive(napi, skb) _rtw_napi_gro_receive(napi, skb)
#endif
#endif /* CONFIG_RTW_NAPI */
#define rtw_skb_queue_purge(sk_buff_head) _rtw_skb_queue_purge(sk_buff_head)
#ifdef CONFIG_USB_HCI
#define rtw_usb_buffer_alloc(dev, size, dma) _rtw_usb_buffer_alloc((dev), (size), (dma))
#define rtw_usb_buffer_free(dev, size, addr, dma) _rtw_usb_buffer_free((dev), (size), (addr), (dma))
#define rtw_usb_buffer_alloc_f(dev, size, dma, mstat_f) _rtw_usb_buffer_alloc((dev), (size), (dma))
#define rtw_usb_buffer_free_f(dev, size, addr, dma, mstat_f) _rtw_usb_buffer_free((dev), (size), (addr), (dma))
#endif /* CONFIG_USB_HCI */
#endif /* DBG_MEM_ALLOC */

extern void	*rtw_malloc2d(int h, int w, size_t size);
extern void	rtw_mfree2d(void *pbuf, int h, int w, int size);

void rtw_os_pkt_free(_pkt *pkt);
_pkt *rtw_os_pkt_copy(_pkt *pkt);
void *rtw_os_pkt_data(_pkt *pkt);
u32 rtw_os_pkt_len(_pkt *pkt);

extern void	_rtw_memcpy(void *dec, const void *sour, u32 sz);
extern void _rtw_memmove(void *dst, const void *src, u32 sz);
extern int	_rtw_memcmp(const void *dst, const void *src, u32 sz);
extern void	_rtw_memset(void *pbuf, int c, u32 sz);

extern void	_rtw_init_listhead(_list *list);
extern u32	rtw_is_list_empty(_list *phead);
extern void	rtw_list_insert_head(_list *plist, _list *phead);
extern void	rtw_list_insert_tail(_list *plist, _list *phead);
void rtw_list_splice(_list *list, _list *head);
void rtw_list_splice_init(_list *list, _list *head);
void rtw_list_splice_tail(_list *list, _list *head);

#ifndef PLATFORM_FREEBSD
extern void	rtw_list_delete(_list *plist);
#endif /* PLATFORM_FREEBSD */

void rtw_hlist_head_init(rtw_hlist_head *h);
void rtw_hlist_add_head(rtw_hlist_node *n, rtw_hlist_head *h);
void rtw_hlist_del(rtw_hlist_node *n);
void rtw_hlist_add_head_rcu(rtw_hlist_node *n, rtw_hlist_head *h);
void rtw_hlist_del_rcu(rtw_hlist_node *n);

extern void	_rtw_init_sema(_sema *sema, int init_val);
extern void	_rtw_free_sema(_sema	*sema);
extern void	_rtw_up_sema(_sema	*sema);
extern u32	_rtw_down_sema(_sema *sema);
extern void	_rtw_mutex_init(_mutex *pmutex);
extern void	_rtw_mutex_free(_mutex *pmutex);
#ifndef PLATFORM_FREEBSD
extern void	_rtw_spinlock_init(_lock *plock);
#endif /* PLATFORM_FREEBSD */
extern void	_rtw_spinlock_free(_lock *plock);
extern void	_rtw_spinlock(_lock	*plock);
extern void	_rtw_spinunlock(_lock	*plock);
extern void	_rtw_spinlock_ex(_lock	*plock);
extern void	_rtw_spinunlock_ex(_lock	*plock);

extern void	_rtw_init_queue(_queue *pqueue);
extern void _rtw_deinit_queue(_queue *pqueue);
extern u32	_rtw_queue_empty(_queue	*pqueue);
extern u32	rtw_end_of_queue_search(_list *queue, _list *pelement);

extern systime _rtw_get_current_time(void);
extern u32	_rtw_systime_to_ms(systime stime);
extern systime _rtw_ms_to_systime(u32 ms);
extern systime _rtw_us_to_systime(u32 us);
extern s32	_rtw_get_passing_time_ms(systime start);
extern s32 _rtw_get_remaining_time_ms(systime end);
extern s32	_rtw_get_time_interval_ms(systime start, systime end);
extern bool _rtw_time_after(systime a, systime b);

#ifdef DBG_SYSTIME
#define rtw_get_current_time() ({systime __stime = _rtw_get_current_time(); __stime;})
#define rtw_systime_to_ms(stime) ({u32 __ms = _rtw_systime_to_ms(stime); typecheck(systime, stime); __ms;})
#define rtw_ms_to_systime(ms) ({systime __stime = _rtw_ms_to_systime(ms); __stime;})
#define rtw_us_to_systime(us) ({systime __stime = _rtw_us_to_systime(us); __stime;})
#define rtw_get_passing_time_ms(start) ({u32 __ms = _rtw_get_passing_time_ms(start); typecheck(systime, start); __ms;})
#define rtw_get_remaining_time_ms(end) ({u32 __ms = _rtw_get_remaining_time_ms(end); typecheck(systime, end); __ms;})
#define rtw_get_time_interval_ms(start, end) ({u32 __ms = _rtw_get_time_interval_ms(start, end); typecheck(systime, start); typecheck(systime, end); __ms;})
#define rtw_time_after(a,b) ({bool __r = _rtw_time_after(a,b); typecheck(systime, a); typecheck(systime, b); __r;})
#define rtw_time_before(a,b) ({bool __r = _rtw_time_after(b, a); typecheck(systime, a); typecheck(systime, b); __r;})
#else
#define rtw_get_current_time() _rtw_get_current_time()
#define rtw_systime_to_ms(stime) _rtw_systime_to_ms(stime)
#define rtw_ms_to_systime(ms) _rtw_ms_to_systime(ms)
#define rtw_us_to_systime(us) _rtw_us_to_systime(us)
#define rtw_get_passing_time_ms(start) _rtw_get_passing_time_ms(start)
#define rtw_get_remaining_time_ms(end) _rtw_get_remaining_time_ms(end)
#define rtw_get_time_interval_ms(start, end) _rtw_get_time_interval_ms(start, end)
#define rtw_time_after(a,b) _rtw_time_after(a,b)
#define rtw_time_before(a,b) _rtw_time_after(b,a)
#endif

extern void	rtw_sleep_schedulable(int ms);

extern void	rtw_msleep_os(int ms);
extern void	rtw_usleep_os(int us);

extern u32	rtw_atoi(u8 *s);

#ifdef DBG_DELAY_OS
#define rtw_mdelay_os(ms) _rtw_mdelay_os((ms), __FUNCTION__, __LINE__)
#define rtw_udelay_os(ms) _rtw_udelay_os((ms), __FUNCTION__, __LINE__)
extern void _rtw_mdelay_os(int ms, const char *func, const int line);
extern void _rtw_udelay_os(int us, const char *func, const int line);
#else
extern void	rtw_mdelay_os(int ms);
extern void	rtw_udelay_os(int us);
#endif

extern void rtw_yield_os(void);


extern void rtw_init_timer(_timer *ptimer, void *padapter, void *pfunc, void *ctx);


__inline static unsigned char _cancel_timer_ex(_timer *ptimer)
{
	u8 bcancelled;

	_cancel_timer(ptimer, &bcancelled);

	return bcancelled;
}

static __inline void thread_enter(char *name)
{
#ifdef PLATFORM_LINUX
	allow_signal(SIGTERM);
#endif
#ifdef PLATFORM_FREEBSD
	printf("%s", "RTKTHREAD_enter");
#endif
}
void thread_exit(_completion *comp);
void _rtw_init_completion(_completion *comp);
void _rtw_wait_for_comp_timeout(_completion *comp);
void _rtw_wait_for_comp(_completion *comp);

static inline bool rtw_thread_stop(_thread_hdl_ th)
{
#ifdef PLATFORM_LINUX
	return kthread_stop(th);
#endif
}
static inline void rtw_thread_wait_stop(void)
{
#ifdef PLATFORM_LINUX
	#if 0
	while (!kthread_should_stop())
		rtw_msleep_os(10);
	#else
	set_current_state(TASK_INTERRUPTIBLE);
	while (!kthread_should_stop()) {
		schedule();
		set_current_state(TASK_INTERRUPTIBLE);
	}
	__set_current_state(TASK_RUNNING);
	#endif
#endif
}

__inline static void flush_signals_thread(void)
{
#ifdef PLATFORM_LINUX
	if (signal_pending(current))
		flush_signals(current);
#endif
}

__inline static _OS_STATUS res_to_status(sint res)
{

#if defined(PLATFORM_LINUX) || defined (PLATFORM_MPIXEL) || defined (PLATFORM_FREEBSD)
	return res;
#endif

#ifdef PLATFORM_WINDOWS

	if (res == _SUCCESS)
		return NDIS_STATUS_SUCCESS;
	else
		return NDIS_STATUS_FAILURE;

#endif

}

__inline static void rtw_dump_stack(void)
{
#ifdef PLATFORM_LINUX
	dump_stack();
#endif
}

#ifdef PLATFORM_LINUX
#define rtw_warn_on(condition) WARN_ON(condition)
#else
#define rtw_warn_on(condition) do {} while (0)
#endif

__inline static int rtw_bug_check(void *parg1, void *parg2, void *parg3, void *parg4)
{
	int ret = _TRUE;

#ifdef PLATFORM_WINDOWS
	if (((uint)parg1) <= 0x7fffffff ||
	    ((uint)parg2) <= 0x7fffffff ||
	    ((uint)parg3) <= 0x7fffffff ||
	    ((uint)parg4) <= 0x7fffffff) {
		ret = _FALSE;
		KeBugCheckEx(0x87110000, (ULONG_PTR)parg1, (ULONG_PTR)parg2, (ULONG_PTR)parg3, (ULONG_PTR)parg4);
	}
#endif

	return ret;

}
#ifdef PLATFORM_LINUX
#define RTW_DIV_ROUND_UP(n, d)	DIV_ROUND_UP(n, d)
#else /* !PLATFORM_LINUX */
#define RTW_DIV_ROUND_UP(n, d)	(((n) + (d - 1)) / d)
#endif /* !PLATFORM_LINUX */

#define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ? 0 : 1)) << 2)

__inline static u32 _RND4(u32 sz)
{

	u32	val;

	val = ((sz >> 2) + ((sz & 3) ? 1 : 0)) << 2;

	return val;

}

__inline static u32 _RND8(u32 sz)
{

	u32	val;

	val = ((sz >> 3) + ((sz & 7) ? 1 : 0)) << 3;

	return val;

}

__inline static u32 _RND128(u32 sz)
{

	u32	val;

	val = ((sz >> 7) + ((sz & 127) ? 1 : 0)) << 7;

	return val;

}

__inline static u32 _RND256(u32 sz)
{

	u32	val;

	val = ((sz >> 8) + ((sz & 255) ? 1 : 0)) << 8;

	return val;

}

__inline static u32 _RND512(u32 sz)
{

	u32	val;

	val = ((sz >> 9) + ((sz & 511) ? 1 : 0)) << 9;

	return val;

}

__inline static u32 bitshift(u32 bitmask)
{
	u32 i;

	for (i = 0; i <= 31; i++)
		if (((bitmask >> i) &  0x1) == 1)
			break;

	return i;
}

static inline int largest_bit(u32 bitmask)
{
	int i;

	for (i = 31; i >= 0; i--)
		if (bitmask & BIT(i))
			break;

	return i;
}

static inline int largest_bit_64(u64 bitmask)
{
	int i;

	for (i = 63; i >= 0; i--)
		if (bitmask & BIT(i))
			break;

	return i;
}

#define rtw_abs(a) (a < 0 ? -a : a)
#define rtw_min(a, b) ((a > b) ? b : a)
#define rtw_is_range_a_in_b(hi_a, lo_a, hi_b, lo_b) (((hi_a) <= (hi_b)) && ((lo_a) >= (lo_b)))
#define rtw_is_range_overlap(hi_a, lo_a, hi_b, lo_b) (((hi_a) > (lo_b)) && ((lo_a) < (hi_b)))

#ifndef MAC_FMT
#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
#endif
#ifndef MAC_ARG
#define MAC_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5]
#endif

bool rtw_macaddr_is_larger(const u8 *a, const u8 *b);

extern void rtw_suspend_lock_init(void);
extern void rtw_suspend_lock_uninit(void);
extern void rtw_lock_suspend(void);
extern void rtw_unlock_suspend(void);
extern void rtw_lock_suspend_timeout(u32 timeout_ms);
extern void rtw_lock_traffic_suspend_timeout(u32 timeout_ms);
extern void rtw_resume_lock_suspend(void);
extern void rtw_resume_unlock_suspend(void);
#ifdef CONFIG_AP_WOWLAN
extern void rtw_softap_lock_suspend(void);
extern void rtw_softap_unlock_suspend(void);
#endif

extern void rtw_set_bit(int nr, unsigned long *addr);
extern void rtw_clear_bit(int nr, unsigned long *addr);
extern int rtw_test_and_clear_bit(int nr, unsigned long *addr);

extern void ATOMIC_SET(ATOMIC_T *v, int i);
extern int ATOMIC_READ(ATOMIC_T *v);
extern void ATOMIC_ADD(ATOMIC_T *v, int i);
extern void ATOMIC_SUB(ATOMIC_T *v, int i);
extern void ATOMIC_INC(ATOMIC_T *v);
extern void ATOMIC_DEC(ATOMIC_T *v);
extern int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
extern int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
extern int ATOMIC_INC_RETURN(ATOMIC_T *v);
extern int ATOMIC_DEC_RETURN(ATOMIC_T *v);
extern bool ATOMIC_INC_UNLESS(ATOMIC_T *v, int u);

/* File operation APIs, just for linux now */
extern int rtw_is_dir_readable(const char *path);
extern int rtw_is_file_readable(const char *path);
extern int rtw_is_file_readable_with_size(const char *path, u32 *sz);
extern int rtw_readable_file_sz_chk(const char *path, u32 sz);
extern int rtw_retrieve_from_file(const char *path, u8 *buf, u32 sz);
extern int rtw_store_to_file(const char *path, u8 *buf, u32 sz);


#ifndef PLATFORM_FREEBSD
extern void rtw_free_netdev(struct net_device *netdev);
#endif /* PLATFORM_FREEBSD */


extern u64 rtw_modular64(u64 x, u64 y);
extern u64 rtw_division64(u64 x, u64 y);
extern u32 rtw_random32(void);

/* Macros for handling unaligned memory accesses */

#define RTW_GET_BE16(a) ((u16) (((a)[0] << 8) | (a)[1]))
#define RTW_PUT_BE16(a, val)			\
	do {					\
		(a)[0] = ((u16) (val)) >> 8;	\
		(a)[1] = ((u16) (val)) & 0xff;	\
	} while (0)

#define RTW_GET_LE16(a) ((u16) (((a)[1] << 8) | (a)[0]))
#define RTW_PUT_LE16(a, val)			\
	do {					\
		(a)[1] = ((u16) (val)) >> 8;	\
		(a)[0] = ((u16) (val)) & 0xff;	\
	} while (0)

#define RTW_GET_BE24(a) ((((u32) (a)[0]) << 16) | (((u32) (a)[1]) << 8) | \
			 ((u32) (a)[2]))
#define RTW_PUT_BE24(a, val)					\
	do {							\
		(a)[0] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
		(a)[2] = (u8) (((u32) (val)) & 0xff);		\
	} while (0)

#define RTW_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
#define RTW_PUT_BE32(a, val)					\
	do {							\
		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
	} while (0)

#define RTW_GET_LE32(a) ((((u32) (a)[3]) << 24) | (((u32) (a)[2]) << 16) | \
			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))
#define RTW_PUT_LE32(a, val)					\
	do {							\
		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
	} while (0)

#define RTW_GET_BE64(a) ((((u64) (a)[0]) << 56) | (((u64) (a)[1]) << 48) | \
			 (((u64) (a)[2]) << 40) | (((u64) (a)[3]) << 32) | \
			 (((u64) (a)[4]) << 24) | (((u64) (a)[5]) << 16) | \
			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))
#define RTW_PUT_BE64(a, val)				\
	do {						\
		(a)[0] = (u8) (((u64) (val)) >> 56);	\
		(a)[1] = (u8) (((u64) (val)) >> 48);	\
		(a)[2] = (u8) (((u64) (val)) >> 40);	\
		(a)[3] = (u8) (((u64) (val)) >> 32);	\
		(a)[4] = (u8) (((u64) (val)) >> 24);	\
		(a)[5] = (u8) (((u64) (val)) >> 16);	\
		(a)[6] = (u8) (((u64) (val)) >> 8);	\
		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
	} while (0)

#define RTW_GET_LE64(a) ((((u64) (a)[7]) << 56) | (((u64) (a)[6]) << 48) | \
			 (((u64) (a)[5]) << 40) | (((u64) (a)[4]) << 32) | \
			 (((u64) (a)[3]) << 24) | (((u64) (a)[2]) << 16) | \
			 (((u64) (a)[1]) << 8) | ((u64) (a)[0]))
#define RTW_PUT_LE64(a, val)					\
	do {							\
		(a)[7] = (u8) ((((u64) (val)) >> 56) & 0xff);	\
		(a)[6] = (u8) ((((u64) (val)) >> 48) & 0xff);	\
		(a)[5] = (u8) ((((u64) (val)) >> 40) & 0xff);	\
		(a)[4] = (u8) ((((u64) (val)) >> 32) & 0xff);	\
		(a)[3] = (u8) ((((u64) (val)) >> 24) & 0xff);	\
		(a)[2] = (u8) ((((u64) (val)) >> 16) & 0xff);	\
		(a)[1] = (u8) ((((u64) (val)) >> 8) & 0xff);	\
		(a)[0] = (u8) (((u64) (val)) & 0xff);		\
	} while (0)

void rtw_buf_free(u8 **buf, u32 *buf_len);
void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len);

struct rtw_cbuf {
	u32 write;
	u32 read;
	u32 size;
	void *bufs[0];
};

bool rtw_cbuf_full(struct rtw_cbuf *cbuf);
bool rtw_cbuf_empty(struct rtw_cbuf *cbuf);
bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf);
void *rtw_cbuf_pop(struct rtw_cbuf *cbuf);
struct rtw_cbuf *rtw_cbuf_alloc(u32 size);
void rtw_cbuf_free(struct rtw_cbuf *cbuf);

struct map_seg_t {
	u16 sa;
	u16 len;
	u8 *c;
};

struct map_t {
	u16 len;
	u16 seg_num;
	u8 init_value;
	struct map_seg_t *segs;
};

#define MAPSEG_ARRAY_ENT(_sa, _len, _c, arg...) \
	{ .sa = _sa, .len = _len, .c = (u8[_len]){ _c, ##arg}, }

#define MAPSEG_PTR_ENT(_sa, _len, _p) \
	{ .sa = _sa, .len = _len, .c = _p, }

#define MAP_ENT(_len, _seg_num, _init_v, _seg, arg...) \
	{ .len = _len, .seg_num = _seg_num, .init_value = _init_v, .segs = (struct map_seg_t[_seg_num]){ _seg, ##arg}, }

int map_readN(const struct map_t *map, u16 offset, u16 len, u8 *buf);
u8 map_read8(const struct map_t *map, u16 offset);

struct blacklist_ent {
	_list list;
	u8 addr[ETH_ALEN];
	systime exp_time;
};

int rtw_blacklist_add(_queue *blist, const u8 *addr, u32 timeout_ms);
int rtw_blacklist_del(_queue *blist, const u8 *addr);
int rtw_blacklist_search(_queue *blist, const u8 *addr);
void rtw_blacklist_flush(_queue *blist);
void dump_blacklist(void *sel, _queue *blist, const char *title);

/* String handler */

BOOLEAN is_null(char c);
BOOLEAN is_all_null(char *c, int len);
BOOLEAN is_eol(char c);
BOOLEAN is_space(char c);
BOOLEAN IsHexDigit(char chTmp);
BOOLEAN is_alpha(char chTmp);
char alpha_to_upper(char c);

int hex2num_i(char c);
int hex2byte_i(const char *hex);
int hexstr2bin(const char *hex, u8 *buf, size_t len);

/*
 * Write formatted output to sized buffer
 */
#ifdef PLATFORM_LINUX
#define rtw_sprintf(buf, size, format, arg...)	snprintf(buf, size, format, ##arg)
#else /* !PLATFORM_LINUX */
#error "NOT DEFINE \"rtw_sprintf\"!!"
#endif /* !PLATFORM_LINUX */

#endif
                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8814a_dm.h                                                                 0000644 0001750 0001750 00000001601 14214766567 015542  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_DM_H__
#define __RTL8814A_DM_H__

void rtl8814_init_dm_priv(PADAPTER Adapter);
void rtl8814_deinit_dm_priv(PADAPTER Adapter);
void rtl8814_InitHalDm(PADAPTER Adapter);
void rtl8814_HalDmWatchDog(PADAPTER Adapter);

#endif
                                                                                                                               rtl8822bu/src/include/sdio_hal.h                                                                    0000644 0001750 0001750 00000002752 14214766567 015365  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __SDIO_HAL_H__
#define __SDIO_HAL_H__

void sd_int_dpc(PADAPTER padapter);
u8 rtw_set_hal_ops(_adapter *padapter);

#ifdef CONFIG_RTL8188E
void rtl8188es_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8723B
void rtl8723bs_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8821A
void rtl8821as_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8192E
void rtl8192es_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8703B
void rtl8703bs_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8723D
void rtl8723ds_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8188F
void rtl8188fs_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8188GTV
void rtl8188gtvs_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8192F
void rtl8192fs_set_hal_ops(PADAPTER padapter);
#endif

#endif /* __SDIO_HAL_H__ */
                      rtl8822bu/src/include/rtw_tdls.h                                                                    0000644 0001750 0001750 00000022456 14214766567 015450  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_TDLS_H_
#define __RTW_TDLS_H_


#ifdef CONFIG_TDLS
/* TDLS STA state */


/* TDLS Diect Link Establishment */
#define	TDLS_STATE_NONE				0x00000000		/* Default state */
#define	TDLS_INITIATOR_STATE		BIT(28)			/* 0x10000000 */
#define	TDLS_RESPONDER_STATE		BIT(29)			/* 0x20000000 */
#define	TDLS_LINKED_STATE			BIT(30)			/* 0x40000000 */
/* TDLS PU Buffer STA */
#define	TDLS_WAIT_PTR_STATE			BIT(24)			/* 0x01000000 */	/* Waiting peer's TDLS_PEER_TRAFFIC_RESPONSE frame */
/* TDLS Check ALive */
#define	TDLS_ALIVE_STATE			BIT(20)			/* 0x00100000 */	/* Check if peer sta is alived. */
/* TDLS Channel Switch */
#define	TDLS_CH_SWITCH_PREPARE_STATE	BIT(15)			/* 0x00008000 */
#define	TDLS_CH_SWITCH_ON_STATE			BIT(16)			/* 0x00010000 */
#define	TDLS_PEER_AT_OFF_STATE			BIT(17)			/* 0x00020000 */	/* Could send pkt on target ch */
#define	TDLS_CH_SW_INITIATOR_STATE		BIT(18)			/* 0x00040000 */	/* Avoid duplicated or unconditional ch. switch rsp. */
#define	TDLS_WAIT_CH_RSP_STATE			BIT(19)			/* 0x00080000 */	/* Wait Ch. response as we are TDLS channel switch initiator */


#define	TDLS_TPK_RESEND_COUNT			86400	/*Unit: seconds */
#define	TDLS_CH_SWITCH_TIME				15
#define	TDLS_CH_SWITCH_TIMEOUT			30
#define	TDLS_CH_SWITCH_OPER_OFFLOAD_TIMEOUT	10
#define	TDLS_SIGNAL_THRESH			0x20
#define	TDLS_WATCHDOG_PERIOD		10	/* Periodically sending tdls discovery request in TDLS_WATCHDOG_PERIOD * 2 sec */
#define	TDLS_HANDSHAKE_TIME			3000
#define	TDLS_PTI_TIME				7000

#define TDLS_CH_SW_STAY_ON_BASE_CHNL_TIMEOUT	20		/* ms */
#define TDLS_CH_SW_MONITOR_TIMEOUT				2000	/*ms */

#define TDLS_MIC_LEN 16
#define WPA_NONCE_LEN 32
#define TDLS_TIMEOUT_LEN 4

enum TDLS_CH_SW_CHNL {
	TDLS_CH_SW_BASE_CHNL = 0,
	TDLS_CH_SW_OFF_CHNL
};

#define TDLS_MIC_CTRL_LEN 2
#define TDLS_FTIE_DATA_LEN (TDLS_MIC_CTRL_LEN + TDLS_MIC_LEN + \
							WPA_NONCE_LEN + WPA_NONCE_LEN)
struct wpa_tdls_ftie {
	u8 ie_type; /* FTIE */
	u8 ie_len;
	union {
		struct {
			u8 mic_ctrl[TDLS_MIC_CTRL_LEN];
			u8 mic[TDLS_MIC_LEN];
			u8 Anonce[WPA_NONCE_LEN]; /* Responder Nonce in TDLS */
			u8 Snonce[WPA_NONCE_LEN]; /* Initiator Nonce in TDLS */
		};
		struct {
			u8 data[TDLS_FTIE_DATA_LEN];
		};
	};
	/* followed by optional elements */
} ;

struct wpa_tdls_lnkid {
	u8 ie_type; /* Link Identifier IE */
	u8 ie_len;
	u8 bssid[ETH_ALEN];
	u8 init_sta[ETH_ALEN];
	u8 resp_sta[ETH_ALEN];
} ;

static u8 TDLS_RSNIE[20] = {	0x01, 0x00,	/* Version shall be set to 1 */
				0x00, 0x0f, 0xac, 0x07,	/* Group sipher suite */
				0x01, 0x00,	/* Pairwise cipher suite count */
	0x00, 0x0f, 0xac, 0x04,	/* Pairwise cipher suite list; CCMP only */
				0x01, 0x00,	/* AKM suite count */
				0x00, 0x0f, 0xac, 0x07,	/* TPK Handshake */
				0x0c, 0x02,
				/* PMKID shall not be present */
			   };

static u8 TDLS_WMMIE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};	/* Qos info all set zero */

static u8 TDLS_WMM_PARAM_IE[] = {0x00, 0x00, 0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00, 0x42, 0x43, 0x5e, 0x00, 0x62, 0x32, 0x2f, 0x00};

static u8 TDLS_EXT_CAPIE[] = {0x00, 0x00, 0x00, 0x50, 0x20, 0x00, 0x00, 0x00};	/* bit(28), bit(30), bit(37) */

/* SRC: Supported Regulatory Classes */
static u8 TDLS_SRC[] = { 0x01, 0x01, 0x02, 0x03, 0x04, 0x0c, 0x16, 0x17, 0x18, 0x19, 0x1b, 0x1c, 0x1d, 0x1e, 0x20, 0x21 };

int check_ap_tdls_prohibited(u8 *pframe, u8 pkt_len);
int check_ap_tdls_ch_switching_prohibited(u8 *pframe, u8 pkt_len);

void rtw_set_tdls_enable(_adapter *padapter, u8 enable);
u8 rtw_is_tdls_enabled(_adapter *padapter);
u8 rtw_is_tdls_sta_existed(_adapter *padapter);
u8 rtw_tdls_is_setup_allowed(_adapter *padapter);
#ifdef CONFIG_TDLS_CH_SW
u8 rtw_tdls_is_chsw_allowed(_adapter *padapter);
#endif

void rtw_tdls_set_link_established(_adapter *adapter, bool en);
void rtw_reset_tdls_info(_adapter *padapter);
int rtw_init_tdls_info(_adapter *padapter);
void rtw_free_tdls_info(struct tdls_info *ptdlsinfo);
void rtw_free_all_tdls_sta(_adapter *padapter, u8 enqueue_cmd);
void rtw_enable_tdls_func(_adapter *padapter);
void rtw_disable_tdls_func(_adapter *padapter, u8 enqueue_cmd);
int issue_nulldata_to_TDLS_peer_STA(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
void rtw_init_tdls_timer(_adapter *padapter, struct sta_info *psta);
void	rtw_cancel_tdls_timer(struct sta_info *psta);
void rtw_tdls_teardown_pre_hdl(_adapter *padapter, struct sta_info *psta);
void rtw_tdls_teardown_post_hdl(_adapter *padapter, struct sta_info *psta, u8 enqueue_cmd);

#ifdef CONFIG_TDLS_CH_SW
void rtw_tdls_set_ch_sw_oper_control(_adapter *padapter, u8 enable);
void rtw_tdls_ch_sw_back_to_base_chnl(_adapter *padapter);
s32 rtw_tdls_do_ch_sw(_adapter *padapter, struct sta_info *ptdls_sta, u8 chnl_type, u8 channel, u8 channel_offset, u16 bwmode, u16 ch_switch_time);
void rtw_tdls_chsw_oper_done(_adapter *padapter);
#endif

#ifdef CONFIG_WFD
int issue_tunneled_probe_req(_adapter *padapter);
int issue_tunneled_probe_rsp(_adapter *padapter, union recv_frame *precv_frame);
#endif /* CONFIG_WFD */
int issue_tdls_dis_req(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
int issue_tdls_setup_req(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, int wait_ack);
int issue_tdls_setup_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
int issue_tdls_setup_cfm(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
int issue_tdls_dis_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, u8 privacy);
int issue_tdls_teardown(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, u8 wait_ack);
int issue_tdls_peer_traffic_rsp(_adapter *padapter, struct sta_info *psta, struct tdls_txmgmt *ptxmgmt);
int issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *psta);
#ifdef CONFIG_TDLS_CH_SW
int issue_tdls_ch_switch_req(_adapter *padapter, struct sta_info *ptdls_sta);
int issue_tdls_ch_switch_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, int wait_ack);
#endif
sint On_TDLS_Dis_Rsp(_adapter *adapter, union recv_frame *precv_frame);
sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
int On_TDLS_Setup_Rsp(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
int On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
int On_TDLS_Dis_Req(_adapter *adapter, union recv_frame *precv_frame);
int On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
int On_TDLS_Peer_Traffic_Indication(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
int On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
#ifdef CONFIG_TDLS_CH_SW
sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame, struct sta_info *ptdls_sta);
void rtw_build_tdls_ch_switch_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tdls_ch_switch_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
#endif
void rtw_build_tdls_setup_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tdls_setup_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tdls_setup_cfm_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tdls_teardown_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tdls_dis_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
void rtw_build_tdls_dis_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, u8 privacy);
void rtw_build_tdls_peer_traffic_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tdls_peer_traffic_indication_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, struct sta_info *ptdls_sta);
void rtw_build_tunneled_probe_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe);
void rtw_build_tunneled_probe_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe);

int rtw_tdls_is_driver_setup(_adapter *padapter);
void rtw_tdls_set_key(_adapter *padapter, struct sta_info *ptdls_sta);
const char *rtw_tdls_action_txt(enum TDLS_ACTION_FIELD action);
#endif /* CONFIG_TDLS */

#endif
                                                                                                                                                                                                                  rtl8822bu/src/include/rtl8723d_lps_poff.h                                                           0000644 0001750 0001750 00000005347 14214766567 016767  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

/******************************************** CONST  ************************/
#define NUM_OF_REGISTER_BANK	13
#define NUM_OF_TOTAL_DWORD (NUM_OF_REGISTER_BANK * 64)
#define TOTAL_LEN_FOR_HIOE ((NUM_OF_TOTAL_DWORD + 1) * 8)
#define LPS_POFF_STATIC_FILE_LEN (TOTAL_LEN_FOR_HIOE + TXDESC_SIZE)
#define LPS_POFF_DYNAMIC_FILE_LEN	(512 + TXDESC_SIZE)
/******************************************** CONST  ************************/

/******************************************** MACRO   ************************/
/* HOIE Entry Definition */
#define SET_HOIE_ENTRY_LOW_DATA(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE),	0, 16, __Value)
#define SET_HOIE_ENTRY_HIGH_DATA(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE), 16, 16, __Value)
#define SET_HOIE_ENTRY_MODE_SELECT(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 0, 1, __Value)
#define SET_HOIE_ENTRY_ADDRESS(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 1, 14, __Value)
#define SET_HOIE_ENTRY_BYTE_MASK(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 15, 4, __Value)
#define SET_HOIE_ENTRY_IO_LOCK(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 19, 1, __Value)
#define SET_HOIE_ENTRY_RD_EN(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 20, 1, __Value)
#define SET_HOIE_ENTRY_WR_EN(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 21, 1, __Value)
#define SET_HOIE_ENTRY_RAW_RW(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 22, 1, __Value)
#define SET_HOIE_ENTRY_RAW(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 23, 1, __Value)
#define SET_HOIE_ENTRY_IO_DELAY(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 24, 8, __Value)

/*********************Function Definition*******************************************/
void rtl8723d_lps_poff_init(PADAPTER padapter);
void rtl8723d_lps_poff_deinit(PADAPTER padapter);
bool rtl8723d_lps_poff_get_txbndy_status(PADAPTER padapter);
void rtl8723d_lps_poff_h2c_ctrl(PADAPTER padapter, u8 enable);
void rtl8723d_lps_poff_set_ps_mode(PADAPTER padapter, bool bEnterLPS);
bool rtl8723d_lps_poff_get_status(PADAPTER padapter);
void rtl8723d_lps_poff_wow(PADAPTER padapter);
                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/nic_spec.h                                                                    0000644 0001750 0001750 00000002326 14214766567 015363  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/


#ifndef __NIC_SPEC_H__
#define __NIC_SPEC_H__

#include <drv_conf.h>

#define RTL8711_MCTRL_		(0x20000)
#define RTL8711_UART_		(0x30000)
#define RTL8711_TIMER_		(0x40000)
#define RTL8711_FINT_		(0x50000)
#define RTL8711_HINT_		(0x50000)
#define RTL8711_GPIO_		(0x60000)
#define RTL8711_WLANCTRL_	(0x200000)
#define RTL8711_WLANFF_		(0xe00000)
#define RTL8711_HCICTRL_	(0x600000)
#define RTL8711_SYSCFG_		(0x620000)
#define RTL8711_SYSCTRL_	(0x620000)
#define RTL8711_MCCTRL_		(0x020000)


#include <rtl8711_regdef.h>

#include <rtl8711_bitdef.h>


#endif /* __RTL8711_SPEC_H__ */
                                                                                                                                                                                                                                                                                                          rtl8822bu/src/include/rtl8188f_spec.h                                                               0000644 0001750 0001750 00000026500 14214766567 016112  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_SPEC_H__
#define __RTL8188F_SPEC_H__

#include <drv_conf.h>


#define HAL_NAV_UPPER_UNIT_8188F		128		/* micro-second */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_RSV_CTRL_8188F				0x001C	/* 3 Byte */
#define REG_BT_WIFI_ANTENNA_SWITCH_8188F	0x0038
#define REG_HSISR_8188F					0x005c
#define REG_PAD_CTRL1_8188F		0x0064
#define REG_AFE_CTRL_4_8188F		0x0078
#define REG_HMEBOX_DBG_0_8188F	0x0088
#define REG_HMEBOX_DBG_1_8188F	0x008A
#define REG_HMEBOX_DBG_2_8188F	0x008C
#define REG_HMEBOX_DBG_3_8188F	0x008E
#define REG_HIMR0_8188F					0x00B0
#define REG_HISR0_8188F					0x00B4
#define REG_HIMR1_8188F					0x00B8
#define REG_HISR1_8188F					0x00BC
#define REG_PMC_DBG_CTRL2_8188F			0x00CC

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_C2HEVT_CMD_ID_8188F	0x01A0
#define REG_C2HEVT_CMD_LEN_8188F	0x01AE
#define REG_WOWLAN_WAKE_REASON 0x01C7
#define REG_WOWLAN_GTK_DBG1	0x630
#define REG_WOWLAN_GTK_DBG2	0x634

#define REG_HMEBOX_EXT0_8188F			0x01F0
#define REG_HMEBOX_EXT1_8188F			0x01F4
#define REG_HMEBOX_EXT2_8188F			0x01F8
#define REG_HMEBOX_EXT3_8188F			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_CONTROL_8188F		0x0286 /* Control the RX DMA. */
#define REG_RXDMA_MODE_CTRL_8188F		0x0290

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8188F		0x0300
#define	REG_INT_MIG_8188F				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_DESA_8188F			0x0308	/* TX Beacon Descriptor Address */
#define	REG_HQ_DESA_8188F				0x0310	/* TX High Queue Descriptor Address */
#define	REG_MGQ_DESA_8188F			0x0318	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_DESA_8188F			0x0320	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_DESA_8188F				0x0328	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_DESA_8188F			0x0330	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_DESA_8188F			0x0338	/* TX BK Queue Descriptor Address */
#define	REG_RX_DESA_8188F				0x0340	/* RX Queue	Descriptor Address */
#define	REG_DBI_WDATA_8188F			0x0348	/* DBI Write Data */
#define	REG_DBI_RDATA_8188F			0x034C	/* DBI Read Data */
#define	REG_DBI_ADDR_8188F				0x0350	/* DBI Address */
#define	REG_DBI_FLAG_8188F				0x0352	/* DBI Read/Write Flag */
#define	REG_MDIO_WDATA_8188F		0x0354	/* MDIO for Write PCIE PHY */
#define	REG_MDIO_RDATA_8188F			0x0356	/* MDIO for Reads PCIE PHY */
#define	REG_MDIO_CTL_8188F			0x0358	/* MDIO for Control */
#define	REG_DBG_SEL_8188F				0x0360	/* Debug Selection Register */
#define	REG_PCIE_HRPWM_8188F			0x0361	/* PCIe RPWM */
#define	REG_PCIE_HCPWM_8188F			0x0363	/* PCIe CPWM */
#define	REG_PCIE_MULTIFET_CTRL_8188F	0x036A	/* PCIE Multi-Fethc Control */

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_TXPKTBUF_BCNQ_BDNY_8188F	0x0424
#define REG_TXPKTBUF_MGQ_BDNY_8188F	0x0425
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8188F	0x045D
#ifdef CONFIG_WOWLAN
#define REG_TXPKTBUF_IV_LOW             0x0484
#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_AMPDU_BURST_MODE_8188F	0x04BC

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_SECONDARY_CCA_CTRL_8188F	0x0577

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */


/* ************************************************************
 * SDIO Bus Specification
 * ************************************************************ */

/* -----------------------------------------------------
 * SDIO CMD Address Mapping
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * I/O bus domain (Host)
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * SDIO register
 * ----------------------------------------------------- */
#define SDIO_REG_HIQ_FREEPG_8188F		0x0020
#define SDIO_REG_MID_FREEPG_8188F		0x0022
#define SDIO_REG_LOW_FREEPG_8188F		0x0024
#define SDIO_REG_PUB_FREEPG_8188F		0x0026
#define SDIO_REG_EXQ_FREEPG_8188F		0x0028
#define SDIO_REG_AC_OQT_FREEPG_8188F	0x002A
#define SDIO_REG_NOAC_OQT_FREEPG_8188F	0x002B

#define SDIO_REG_HCPWM1_8188F			0x0038

/* ****************************************************************************
 *	8188 Regsiter Bit and Content definition
 * **************************************************************************** */

/* 2 HSISR
 * interrupt mask which needs to clear */
#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
		HSISR_SPS_OCP_INT |\
		HSISR_RON_INT |\
		HSISR_PDNINT |\
		HSISR_GPIO9_INT)

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */


/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define BIT_USB_RXDMA_AGG_EN	BIT(31)
#define RXDMA_AGG_MODE_EN		BIT(1)

#ifdef CONFIG_WOWLAN
#define RXPKT_RELEASE_POLL		BIT(16)
#define RXDMA_IDLE				BIT(17)
#define RW_RELEASE_EN			BIT(18)
#endif

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */

/* ----------------------------------------------------------------------------
 * 8188F REG_CCK_CHECK						(offset 0x454)
 * ---------------------------------------------------------------------------- */
#define BIT_BCN_PORT_SEL		BIT(5)

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */

/* ----------------------------------------------------------------------------
 * 8195 IMR/ISR bits						(offset 0xB0,  8bits)
 * ---------------------------------------------------------------------------- */
#define	IMR_DISABLED_8188F					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define	IMR_TIMER2_8188F					BIT(31)		/* Timeout interrupt 2 */
#define	IMR_TIMER1_8188F					BIT(30)		/* Timeout interrupt 1	 */
#define	IMR_PSTIMEOUT_8188F				BIT(29)		/* Power Save Time Out Interrupt */
#define	IMR_GTINT4_8188F					BIT(28)		/* When GTIMER4 expires, this bit is set to 1	 */
#define	IMR_GTINT3_8188F					BIT(27)		/* When GTIMER3 expires, this bit is set to 1	 */
#define	IMR_TXBCN0ERR_8188F				BIT(26)		/* Transmit Beacon0 Error			 */
#define	IMR_TXBCN0OK_8188F				BIT(25)		/* Transmit Beacon0 OK			 */
#define	IMR_TSF_BIT32_TOGGLE_8188F		BIT(24)		/* TSF Timer BIT(32) toggle indication interrupt			 */
#define	IMR_BCNDMAINT0_8188F				BIT(20)		/* Beacon DMA Interrupt 0			 */
#define	IMR_BCNDERR0_8188F				BIT(16)		/* Beacon Queue DMA OK0			 */
#define	IMR_HSISR_IND_ON_INT_8188F		BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define	IMR_BCNDMAINT_E_8188F			BIT(14)		/* Beacon DMA Interrupt Extension for Win7			 */
#define	IMR_ATIMEND_8188F				BIT(12)		/* CTWidnow End or ATIM Window End */
#define	IMR_C2HCMD_8188F					BIT(10)		/* CPU to Host Command INT Status, Write 1 clear	 */
#define	IMR_CPWM2_8188F					BIT(9)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_CPWM_8188F					BIT(8)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_HIGHDOK_8188F				BIT(7)			/* High Queue DMA OK	 */
#define	IMR_MGNTDOK_8188F				BIT(6)			/* Management Queue DMA OK	 */
#define	IMR_BKDOK_8188F					BIT(5)			/* AC_BK DMA OK		 */
#define	IMR_BEDOK_8188F					BIT(4)			/* AC_BE DMA OK	 */
#define	IMR_VIDOK_8188F					BIT(3)			/* AC_VI DMA OK		 */
#define	IMR_VODOK_8188F					BIT(2)			/* AC_VO DMA OK	 */
#define	IMR_RDU_8188F					BIT(1)			/* Rx Descriptor Unavailable	 */
#define	IMR_ROK_8188F					BIT(0)			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define	IMR_BCNDMAINT7_8188F				BIT(27)		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT6_8188F				BIT(26)		/* Beacon DMA Interrupt 6 */
#define	IMR_BCNDMAINT5_8188F				BIT(25)		/* Beacon DMA Interrupt 5 */
#define	IMR_BCNDMAINT4_8188F				BIT(24)		/* Beacon DMA Interrupt 4 */
#define	IMR_BCNDMAINT3_8188F				BIT(23)		/* Beacon DMA Interrupt 3 */
#define	IMR_BCNDMAINT2_8188F				BIT(22)		/* Beacon DMA Interrupt 2 */
#define	IMR_BCNDMAINT1_8188F				BIT(21)		/* Beacon DMA Interrupt 1 */
#define	IMR_BCNDOK7_8188F					BIT(20)		/* Beacon Queue DMA OK Interrupt 7 */
#define	IMR_BCNDOK6_8188F					BIT(19)		/* Beacon Queue DMA OK Interrupt 6 */
#define	IMR_BCNDOK5_8188F					BIT(18)		/* Beacon Queue DMA OK Interrupt 5 */
#define	IMR_BCNDOK4_8188F					BIT(17)		/* Beacon Queue DMA OK Interrupt 4 */
#define	IMR_BCNDOK3_8188F					BIT(16)		/* Beacon Queue DMA OK Interrupt 3 */
#define	IMR_BCNDOK2_8188F					BIT(15)		/* Beacon Queue DMA OK Interrupt 2 */
#define	IMR_BCNDOK1_8188F					BIT(14)		/* Beacon Queue DMA OK Interrupt 1 */
#define	IMR_ATIMEND_E_8188F				BIT(13)		/* ATIM Window End Extension for Win7 */
#define	IMR_TXERR_8188F					BIT(11)		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define	IMR_RXERR_8188F					BIT(10)		/* Rx Error Flag INT Status, Write 1 clear */
#define	IMR_TXFOVW_8188F					BIT(9)			/* Transmit FIFO Overflow */
#define	IMR_RXFOVW_8188F					BIT(8)			/* Receive FIFO Overflow */

#ifdef CONFIG_PCI_HCI
/* #define IMR_RX_MASK		(IMR_ROK_8188F|IMR_RDU_8188F|IMR_RXFOVW_8188F) */
#define IMR_TX_MASK			(IMR_VODOK_8188F | IMR_VIDOK_8188F | IMR_BEDOK_8188F | IMR_BKDOK_8188F | IMR_MGNTDOK_8188F | IMR_HIGHDOK_8188F)

#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8188F | IMR_TXBCN0OK_8188F | IMR_TXBCN0ERR_8188F | IMR_BCNDERR0_8188F)

#define RT_AC_INT_MASKS	(IMR_VIDOK_8188F | IMR_VODOK_8188F | IMR_BEDOK_8188F | IMR_BKDOK_8188F)
#endif

#endif /* __RTL8188F_SPEC_H__ */
                                                                                                                                                                                                rtl8822bu/src/include/hal_btcoex_wifionly.h                                                         0000644 0001750 0001750 00000006470 14214766567 017634  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HALBTC_WIFIONLY_H__
#define __HALBTC_WIFIONLY_H__

#include <drv_types.h>
#include <hal_data.h>

/* Define the ICs that support wifi only cfg in coex. codes */
#if defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8822C) || defined(CONFIG_RTL8814B)
#define CONFIG_BTCOEX_SUPPORT_WIFI_ONLY_CFG 1
#else
#define CONFIG_BTCOEX_SUPPORT_WIFI_ONLY_CFG 0
#endif

/* Define the ICs that support hal btc common file structure */
#if defined(CONFIG_RTL8822C) || (defined(CONFIG_RTL8192F) && defined(CONFIG_BT_COEXIST))
#define CONFIG_BTCOEX_SUPPORT_BTC_CMN 1
#else
#define CONFIG_BTCOEX_SUPPORT_BTC_CMN 0
#endif

#if (CONFIG_BTCOEX_SUPPORT_WIFI_ONLY_CFG == 1)

typedef enum _WIFIONLY_CHIP_INTERFACE {
	WIFIONLY_INTF_UNKNOWN	= 0,
	WIFIONLY_INTF_PCI		= 1,
	WIFIONLY_INTF_USB		= 2,
	WIFIONLY_INTF_SDIO		= 3,
	WIFIONLY_INTF_MAX
} WIFIONLY_CHIP_INTERFACE, *PWIFIONLY_CHIP_INTERFACE;

typedef enum _WIFIONLY_CUSTOMER_ID {
	CUSTOMER_NORMAL			= 0,
	CUSTOMER_HP_1			= 1
} WIFIONLY_CUSTOMER_ID, *PWIFIONLY_CUSTOMER_ID;

struct wifi_only_haldata {
	u16		customer_id;
	u8		efuse_pg_antnum;
	u8		efuse_pg_antpath;
	u8		rfe_type;
	u8		ant_div_cfg;
};

struct wifi_only_cfg {
	void *Adapter;
	struct wifi_only_haldata	haldata_info;
	WIFIONLY_CHIP_INTERFACE	chip_interface;
};

void halwifionly_write1byte(void *pwifionlyContext, u32 RegAddr, u8 Data);
void halwifionly_write2byte(void *pwifionlyContext, u32 RegAddr, u16 Data);
void halwifionly_write4byte(void *pwifionlyContext, u32 RegAddr, u32 Data);
u8 halwifionly_read1byte(void *pwifionlyContext, u32 RegAddr);
u16 halwifionly_read2byte(void *pwifionlyContext, u32 RegAddr);
u32 halwifionly_read4byte(void *pwifionlyContext, u32 RegAddr);
void halwifionly_bitmaskwrite1byte(void *pwifionlyContext, u32 regAddr, u8 bitMask, u8 data);
void halwifionly_phy_set_rf_reg(void *pwifionlyContext, enum rf_path eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
void halwifionly_phy_set_bb_reg(void *pwifionlyContext, u32 RegAddr, u32 BitMask, u32 Data);
void hal_btcoex_wifionly_switchband_notify(PADAPTER padapter);
void hal_btcoex_wifionly_scan_notify(PADAPTER padapter);
void hal_btcoex_wifionly_connect_notify(PADAPTER padapter);
void hal_btcoex_wifionly_hw_config(PADAPTER padapter);
void hal_btcoex_wifionly_initlizevariables(PADAPTER padapter);
void hal_btcoex_wifionly_AntInfoSetting(PADAPTER padapter);
#else
#define hal_btcoex_wifionly_switchband_notify(padapter)
#define hal_btcoex_wifionly_scan_notify(padapter)
#define hal_btcoex_wifionly_connect_notify(padapter)
#define hal_btcoex_wifionly_hw_config(padapter)
#define hal_btcoex_wifionly_initlizevariables(padapter)
#define hal_btcoex_wifionly_AntInfoSetting(padapter)
#endif

#endif
                                                                                                                                                                                                        rtl8822bu/src/include/gspi_ops_linux.h                                                              0000644 0001750 0001750 00000001322 14214766567 016635  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __SDIO_OPS_LINUX_H__
#define __SDIO_OPS_LINUX_H__

#endif
                                                                                                                                                                                                                                                                                                              rtl8822bu/src/include/osdep_service_ce.h                                                            0000644 0001750 0001750 00000010657 14214766567 017107  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __OSDEP_CE_SERVICE_H_
#define __OSDEP_CE_SERVICE_H_


#include <ndis.h>
#include <ntddndis.h>

#ifdef CONFIG_SDIO_HCI
#include "SDCardDDK.h"
#endif

#ifdef CONFIG_USB_HCI
#include <usbdi.h>
#endif

typedef HANDLE 	_sema;
typedef	LIST_ENTRY	_list;
typedef NDIS_STATUS _OS_STATUS;

typedef NDIS_SPIN_LOCK	_lock;

typedef HANDLE 		_rwlock; //Mutex

typedef u32	_irqL;

typedef NDIS_HANDLE  _nic_hdl;

struct rtw_timer_list {
	NDIS_MINIPORT_TIMER ndis_timer;
	void (*function)(void *);
	void *arg;
};

struct	__queue	{
	LIST_ENTRY	queue;
	_lock	lock;
};

typedef	NDIS_PACKET	_pkt;
typedef NDIS_BUFFER	_buffer;
typedef struct	__queue	_queue;

typedef HANDLE 	_thread_hdl_;
typedef DWORD thread_return;
typedef void*	thread_context;
typedef NDIS_WORK_ITEM _workitem;



#define SEMA_UPBND	(0x7FFFFFFF)   //8192

__inline static _list *get_prev(_list	*list)
{
	return list->Blink;
}
	
__inline static _list *get_next(_list	*list)
{
	return list->Flink;
}

__inline static _list	*get_list_head(_queue	*queue)
{
	return (&(queue->queue));
}

#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)

__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
{
	NdisAcquireSpinLock(plock);
}

__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
{
	NdisReleaseSpinLock(plock);
}

__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
{
	NdisDprAcquireSpinLock(plock);	
}

__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
{
	NdisDprReleaseSpinLock(plock);	
}


__inline static void _enter_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
{
	WaitForSingleObject(*prwlock, INFINITE );

}

__inline static void _exit_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
{
	ReleaseMutex(*prwlock);
}

__inline static void rtw_list_delete(_list *plist)
{
	RemoveEntryList(plist);
	InitializeListHead(plist);
}

static inline void timer_hdl(
	IN PVOID SystemSpecific1,
	IN PVOID FunctionContext,
	IN PVOID SystemSpecific2,
	IN PVOID SystemSpecific3)
{
	_timer *timer = (_timer *)FunctionContext;

	timer->function(timer->arg);
}

static inline void _init_timer(_timer *ptimer, _nic_hdl nic_hdl, void *pfunc, void *cntx)
{
	ptimer->function = pfunc;
	ptimer->arg = cntx;
	NdisMInitializeTimer(&ptimer->ndis_timer, nic_hdl, timer_hdl, ptimer);
}

static inline void _set_timer(_timer *ptimer, u32 delay_time)
{
	NdisMSetTimer(ptimer, delay_time);
}

static inline void _cancel_timer(_timer *ptimer, u8 *bcancelled)
{
	NdisMCancelTimer(ptimer, bcancelled);
}

__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
{

	NdisInitializeWorkItem(pwork, pfunc, cntx);
}

__inline static void _set_workitem(_workitem *pwork)
{
	NdisScheduleWorkItem(pwork);
}

#define ATOMIC_INIT(i)  { (i) }

//
// Global Mutex: can only be used at PASSIVE level.
//

#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
{                                                               \
    while (NdisInterlockedIncrement((PULONG)&(_MutexCounter)) != 1)\
    {                                                           \
        NdisInterlockedDecrement((PULONG)&(_MutexCounter));        \
        NdisMSleep(10000);                          \
    }                                                           \
}

#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
{                                                               \
    NdisInterlockedDecrement((PULONG)&(_MutexCounter));              \
}

// limitation of path length
#define PATH_LENGTH_MAX MAX_PATH

//Atomic integer operations
#define ATOMIC_T LONG

#define NDEV_FMT "%s"
#define NDEV_ARG(ndev) ""
#define ADPT_FMT "%s"
#define ADPT_ARG(adapter) ""
#define FUNC_NDEV_FMT "%s"
#define FUNC_NDEV_ARG(ndev) __func__
#define FUNC_ADPT_FMT "%s"
#define FUNC_ADPT_ARG(adapter) __func__

#define STRUCT_PACKED


#endif

                                                                                 rtl8822bu/src/include/rtl8723b_sreset.h                                                             0000644 0001750 0001750 00000001631 14214766567 016452  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8723B_SRESET_H_
#define _RTL8723B_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8723b_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8723b_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                       rtl8822bu/src/include/rtw_rm.h                                                                      0000644 0001750 0001750 00000004464 14214766567 015117  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __RTW_RM_H_
#define __RTW_RM_H_

u8 rm_post_event_hdl(_adapter *padapter, u8 *pbuf);

#define RM_TIMER_NUM 		32
#define RM_ALL_MEAS		BIT(1)
#define RM_ID_FOR_ALL(aid)	((aid<<16)|RM_ALL_MEAS)

#define RM_CAP_ARG(x) ((u8 *)(x))[4], ((u8 *)(x))[3], ((u8 *)(x))[2], ((u8 *)(x))[1], ((u8 *)(x))[0]
#define RM_CAP_FMT "%02x %02x%02x %02x%02x"

/* remember to modify rm_event_name() when adding new event */
enum RM_EV_ID {
	RM_EV_state_in,
	RM_EV_busy_timer_expire,
	RM_EV_delay_timer_expire,
	RM_EV_meas_timer_expire,
	RM_EV_retry_timer_expire,
	RM_EV_repeat_delay_expire,
	RM_EV_request_timer_expire,
	RM_EV_wait_report,
	RM_EV_start_meas,
	RM_EV_survey_done,
	RM_EV_recv_rep,
	RM_EV_cancel,
	RM_EV_state_out,
	RM_EV_max
};

struct rm_event {
	u32 rmid;
	enum RM_EV_ID evid;
	_list list;
};

#ifdef CONFIG_RTW_80211K

struct rm_clock {
	struct rm_obj *prm;
	ATOMIC_T counter;
	enum RM_EV_ID evid;
};

struct rm_priv {
	u8 enable;
	_queue ev_queue;
	_queue rm_queue;
	_timer rm_timer;

	struct rm_clock clock[RM_TIMER_NUM];
	u8 rm_en_cap_def[5];
	u8 rm_en_cap_assoc[5];

	/* rm debug */
	void *prm_sel;
};

int rtw_init_rm(_adapter *padapter);
int rtw_free_rm_priv(_adapter *padapter);

unsigned int rm_on_action(_adapter *padapter, union recv_frame *precv_frame);
void RM_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
void rtw_ap_parse_sta_rm_en_cap(_adapter *padapter,
	struct sta_info *psta, struct rtw_ieee802_11_elems *elems);

int rm_post_event(_adapter *padapter, u32 rmid, enum RM_EV_ID evid);
void rm_handler(_adapter *padapter, struct rm_event *pev);

u8 rm_add_nb_req(_adapter *padapter, struct sta_info *psta);

#endif /*CONFIG_RTW_80211K */
#endif /* __RTW_RM_H_ */
                                                                                                                                                                                                            rtl8822bu/src/include/sta_info.h                                                                    0000644 0001750 0001750 00000046054 14214766567 015410  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __STA_INFO_H_
#define __STA_INFO_H_

#include <cmn_info/rtw_sta_info.h>

#define IBSS_START_MAC_ID	2
#define NUM_STA MACID_NUM_SW_LIMIT

#ifndef CONFIG_RTW_MACADDR_ACL
	#define CONFIG_RTW_MACADDR_ACL 1
#endif

#ifndef CONFIG_RTW_PRE_LINK_STA
	#define CONFIG_RTW_PRE_LINK_STA 0
#endif

#define NUM_ACL 16

#define RTW_ACL_PERIOD_DEV 0
#define RTW_ACL_PERIOD_BSS 1
#define RTW_ACL_PERIOD_NUM 2

#define RTW_ACL_MODE_DISABLED				0
#define RTW_ACL_MODE_ACCEPT_UNLESS_LISTED	1
#define RTW_ACL_MODE_DENY_UNLESS_LISTED		2
#define RTW_ACL_MODE_MAX					3

#if CONFIG_RTW_MACADDR_ACL
extern const char *const _acl_period_str[RTW_ACL_PERIOD_NUM];
#define acl_period_str(mode) (((mode) >= RTW_ACL_PERIOD_NUM) ? "INVALID" : _acl_period_str[(mode)])
extern const char *const _acl_mode_str[RTW_ACL_MODE_MAX];
#define acl_mode_str(mode) (((mode) >= RTW_ACL_MODE_MAX) ? "INVALID" : _acl_mode_str[(mode)])
#endif

#ifndef RTW_PRE_LINK_STA_NUM
	#define RTW_PRE_LINK_STA_NUM 8
#endif

struct pre_link_sta_node_t {
	u8 valid;
	u8 addr[ETH_ALEN];
};

struct pre_link_sta_ctl_t {
	_lock lock;
	u8 num;
	struct pre_link_sta_node_t node[RTW_PRE_LINK_STA_NUM];
};

#ifdef CONFIG_TDLS
#define MAX_ALLOWED_TDLS_STA_NUM	4
#endif

enum sta_info_update_type {
	STA_INFO_UPDATE_NONE = 0,
	STA_INFO_UPDATE_BW = BIT(0),
	STA_INFO_UPDATE_RATE = BIT(1),
	STA_INFO_UPDATE_PROTECTION_MODE = BIT(2),
	STA_INFO_UPDATE_CAP = BIT(3),
	STA_INFO_UPDATE_HT_CAP = BIT(4),
	STA_INFO_UPDATE_VHT_CAP = BIT(5),
	STA_INFO_UPDATE_ALL = STA_INFO_UPDATE_BW
			      | STA_INFO_UPDATE_RATE
			      | STA_INFO_UPDATE_PROTECTION_MODE
			      | STA_INFO_UPDATE_CAP
			      | STA_INFO_UPDATE_HT_CAP
			      | STA_INFO_UPDATE_VHT_CAP,
	STA_INFO_UPDATE_MAX
};

struct rtw_wlan_acl_node {
	_list		        list;
	u8       addr[ETH_ALEN];
	u8       valid;
};

struct wlan_acl_pool {
	int mode;
	int num;
	struct rtw_wlan_acl_node aclnode[NUM_ACL];
	_queue	acl_node_q;
};

struct	stainfo_stats	{
	systime last_rx_time;

	u64 rx_mgnt_pkts;
	u64 rx_beacon_pkts;
	u64 rx_probereq_pkts;
	u64 rx_probersp_pkts; /* unicast to self */
	u64 rx_probersp_bm_pkts;
	u64 rx_probersp_uo_pkts; /* unicast to others */
	u64 rx_ctrl_pkts;
	u64 rx_data_pkts;
	u64 rx_data_bc_pkts;
	u64 rx_data_mc_pkts;
	u64 rx_data_qos_pkts[TID_NUM]; /* unicast only */

	u64	last_rx_mgnt_pkts;
	u64 last_rx_beacon_pkts;
	u64 last_rx_probereq_pkts;
	u64 last_rx_probersp_pkts; /* unicast to self */
	u64 last_rx_probersp_bm_pkts;
	u64 last_rx_probersp_uo_pkts; /* unicast to others */
	u64	last_rx_ctrl_pkts;
	u64	last_rx_data_pkts;
	u64 last_rx_data_bc_pkts;
	u64 last_rx_data_mc_pkts;
	u64 last_rx_data_qos_pkts[TID_NUM]; /* unicast only */

#ifdef CONFIG_TDLS
	u64 rx_tdls_disc_rsp_pkts;
	u64 last_rx_tdls_disc_rsp_pkts;
#endif

	u64	rx_bytes;
	u64	rx_bc_bytes;
	u64	rx_mc_bytes;
	u64	last_rx_bytes;
	u64 last_rx_bc_bytes;
	u64 last_rx_mc_bytes;
	u64	rx_drops; /* TBD */
	u32 rx_tp_kbits;
	u32 smooth_rx_tp_kbits;

	u64	tx_pkts;
	u64	last_tx_pkts;

	u64	tx_bytes;
	u64	last_tx_bytes;
	u64 tx_drops; /* TBD */
	u32 tx_tp_kbits;
	u32 smooth_tx_tp_kbits;

#ifdef CONFIG_LPS_CHK_BY_TP
	u64 acc_tx_bytes;
	u64 acc_rx_bytes;
#endif

	/* unicast only */
	u64 last_rx_data_uc_pkts; /* For Read & Clear requirement in proc_get_rx_stat() */
	u32 duplicate_cnt;	/* Read & Clear, in proc_get_rx_stat() */
	u32 rxratecnt[128];	/* Read & Clear, in proc_get_rx_stat() */
	u32 tx_ok_cnt;		/* Read & Clear, in proc_get_tx_stat() */
	u32 tx_fail_cnt;	/* Read & Clear, in proc_get_tx_stat() */
	u32 tx_retry_cnt;	/* Read & Clear, in proc_get_tx_stat() */
#ifdef CONFIG_RTW_MESH
	u32 rx_hwmp_pkts;
	u32 last_rx_hwmp_pkts;
#endif
};

#ifndef DBG_SESSION_TRACKER
#define DBG_SESSION_TRACKER 0
#endif

/* session tracker status */
#define ST_STATUS_NONE		0
#define ST_STATUS_CHECK		BIT0
#define ST_STATUS_ESTABLISH	BIT1
#define ST_STATUS_EXPIRE	BIT2

#define ST_EXPIRE_MS (10 * 1000)

struct session_tracker {
	_list list; /* session_tracker_queue */
	u32 local_naddr;
	u16 local_port;
	u32 remote_naddr;
	u16 remote_port;
	systime set_time;
	u8 status;
};

/* session tracker cmd */
#define ST_CMD_ADD 0
#define ST_CMD_DEL 1
#define ST_CMD_CHK 2

struct st_cmd_parm {
	u8 cmd;
	struct sta_info *sta;
	u32 local_naddr; /* TODO: IPV6 */
	u16 local_port;
	u32 remote_naddr; /* TODO: IPV6 */
	u16 remote_port;
};

typedef bool (*st_match_rule)(_adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);

struct st_register {
	u8 s_proto;
	st_match_rule rule;
};

#define SESSION_TRACKER_REG_ID_WFD 0
#define SESSION_TRACKER_REG_ID_NUM 1

struct st_ctl_t {
	struct st_register reg[SESSION_TRACKER_REG_ID_NUM];
	_queue tracker_q;
};

void rtw_st_ctl_init(struct st_ctl_t *st_ctl);
void rtw_st_ctl_deinit(struct st_ctl_t *st_ctl);
void rtw_st_ctl_register(struct st_ctl_t *st_ctl, u8 st_reg_id, struct st_register *reg);
void rtw_st_ctl_unregister(struct st_ctl_t *st_ctl, u8 st_reg_id);
bool rtw_st_ctl_chk_reg_s_proto(struct st_ctl_t *st_ctl, u8 s_proto);
bool rtw_st_ctl_chk_reg_rule(struct st_ctl_t *st_ctl, _adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
void rtw_st_ctl_rx(struct sta_info *sta, u8 *ehdr_pos);
void dump_st_ctl(void *sel, struct st_ctl_t *st_ctl);

#ifdef CONFIG_TDLS
struct TDLS_PeerKey {
	u8 kck[16]; /* TPK-KCK */
	u8 tk[16]; /* TPK-TK; only CCMP will be used */
} ;
#endif /* CONFIG_TDLS */

#ifdef DBG_RX_DFRAME_RAW_DATA
struct sta_recv_dframe_info {

	u8 sta_data_rate;
	u8 sta_sgi;
	u8 sta_bw_mode;
	s8 sta_mimo_signal_strength[4];
	s8 sta_RxPwr[4];
	u8 sta_ofdm_snr[4];
};
#endif

#ifdef CONFIG_RTW_MESH
struct mesh_plink_ent;
struct rtw_ewma_err_rate {
	unsigned long internal;
};

/* Mesh airtime link metrics parameters */
struct rtw_atlm_param {
	struct rtw_ewma_err_rate err_rate; /* Now is PACKET error rate */
	u16 data_rate; /* The unit is 100Kbps */
	u16 total_pkt;
	u16 overhead; /* Channel access overhead */
};
#endif

struct sta_info {

	_lock	lock;
	_list	list; /* free_sta_queue */
	_list	hash_list; /* sta_hash */
	/* _list asoc_list; */ /* 20061114 */
	/* _list sleep_list; */ /* sleep_q */
	/* _list wakeup_list; */ /* wakeup_q */
	_adapter *padapter;
	struct cmn_sta_info cmn;

	struct sta_xmit_priv sta_xmitpriv;
	struct sta_recv_priv sta_recvpriv;

#ifdef DBG_RX_DFRAME_RAW_DATA
	struct sta_recv_dframe_info  sta_dframe_info;
	struct sta_recv_dframe_info  sta_dframe_info_bmc;
#endif
	_queue sleep_q;
	unsigned int sleepq_len;

	uint state;
	uint qos_option;
	u16 hwseq;

#ifdef CONFIG_RTW_80211K
	u8 rm_en_cap[5];
	u8 rm_diag_token;
#endif /* CONFIG_RTW_80211K */

	uint	ieee8021x_blocked;	/* 0: allowed, 1:blocked */
	uint	dot118021XPrivacy; /* aes, tkip... */
	union Keytype	dot11tkiptxmickey;
	union Keytype	dot11tkiprxmickey;
	union Keytype	dot118021x_UncstKey;
	union pn48		dot11txpn;			/* PN48 used for Unicast xmit */
	union pn48		dot11rxpn;			/* PN48 used for Unicast recv. */
#ifdef CONFIG_RTW_MESH
	/* peer's GTK, RX only */
	u8 group_privacy;
	u8 gtk_bmp;
	union Keytype gtk;
	union pn48 gtk_pn;
	#ifdef CONFIG_IEEE80211W
	/* peer's IGTK, RX only */
	u8 igtk_bmp;
	u8 igtk_id;
	union Keytype igtk;
	union pn48 igtk_pn;
	#endif /* CONFIG_IEEE80211W */
#endif /* CONFIG_RTW_MESH */
#ifdef CONFIG_GTK_OL
	u8 kek[RTW_KEK_LEN];
	u8 kck[RTW_KCK_LEN];
	u8 replay_ctr[RTW_REPLAY_CTR_LEN];
#endif /* CONFIG_GTK_OL */
#ifdef CONFIG_IEEE80211W
	_timer dot11w_expire_timer;
#endif /* CONFIG_IEEE80211W */

	u8	bssrateset[16];
	u32	bssratelen;

	u8	cts2self;
	u8	rtsen;

	u8	init_rate;
	u8	wireless_mode;	/* NETWORK_TYPE */

	struct stainfo_stats sta_stats;

#ifdef CONFIG_TDLS
	u32	tdls_sta_state;
	u8	SNonce[32];
	u8	ANonce[32];
	u32	TDLS_PeerKey_Lifetime;
	u32	TPK_count;
	_timer	TPK_timer;
	struct TDLS_PeerKey	tpk;
#ifdef CONFIG_TDLS_CH_SW
	u16	ch_switch_time;
	u16	ch_switch_timeout;
	/* u8	option; */
	_timer	ch_sw_timer;
	_timer	delay_timer;
	_timer	stay_on_base_chnl_timer;
	_timer	ch_sw_monitor_timer;
#endif
	_timer handshake_timer;
	u8 alive_count;
	_timer	pti_timer;
	u8	TDLS_RSNIE[20];	/* Save peer's RSNIE, used for sending TDLS_SETUP_RSP */
#endif /* CONFIG_TDLS */

	/* for A-MPDU TX, ADDBA timeout check	 */
	_timer addba_retry_timer;

	/* for A-MPDU Rx reordering buffer control */
	struct recv_reorder_ctrl recvreorder_ctrl[TID_NUM];
	ATOMIC_T continual_no_rx_packet[TID_NUM];
	/* for A-MPDU Tx */
	/* unsigned char		ampdu_txen_bitmap; */
	u16	BA_starting_seqctrl[16];


#ifdef CONFIG_80211N_HT
	struct ht_priv	htpriv;
#endif

#ifdef CONFIG_80211AC_VHT
	struct vht_priv	vhtpriv;
#endif

	/* Notes:	 */
	/* STA_Mode: */
	/* curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO	 */
	/* scan_q: AP CAP/INFO */

	/* AP_Mode: */
	/* curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO */
	/* sta_info: (AP & STA) CAP/INFO */

	unsigned int expire_to;

#ifdef CONFIG_AP_MODE

	_list asoc_list;
	_list auth_list;

	unsigned int auth_seq;
	unsigned int authalg;
	unsigned char chg_txt[128];

	u16 capability;
	int flags;

	int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
	int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
	int wpa_group_cipher;
	int wpa2_group_cipher;
	int wpa_pairwise_cipher;
	int wpa2_pairwise_cipher;

	u32 akm_suite_type;

	u8 bpairwise_key_installed;
#ifdef CONFIG_RTW_80211R
	u8 ft_pairwise_key_installed;
#endif

#ifdef CONFIG_NATIVEAP_MLME
	u8 wpa_ie[32];

	u8 nonerp_set;
	u8 no_short_slot_time_set;
	u8 no_short_preamble_set;
	u8 no_ht_gf_set;
	u8 no_ht_set;
	u8 ht_20mhz_set;
	u8 ht_40mhz_intolerant;
#endif /* CONFIG_NATIVEAP_MLME */

#ifdef CONFIG_ATMEL_RC_PATCH
	u8 flag_atmel_rc;
#endif

	u8 qos_info;

	u8 max_sp_len;
	u8 uapsd_bk;/* BIT(0): Delivery enabled, BIT(1): Trigger enabled */
	u8 uapsd_be;
	u8 uapsd_vi;
	u8 uapsd_vo;

	u8 has_legacy_ac;
	unsigned int sleepq_ac_len;

#ifdef CONFIG_P2P
	/* p2p priv data */
	u8 is_p2p_device;
	u8 p2p_status_code;

	/* p2p client info */
	u8 dev_addr[ETH_ALEN];
	/* u8 iface_addr[ETH_ALEN]; */ /* = hwaddr[ETH_ALEN] */
	u8 dev_cap;
	u16 config_methods;
	u8 primary_dev_type[8];
	u8 num_of_secdev_type;
	u8 secdev_types_list[32];/* 32/8 == 4; */
	u16 dev_name_len;
	u8 dev_name[32];
#endif /* CONFIG_P2P */

#ifdef CONFIG_WFD
	u8 op_wfd_mode;
#endif

#ifdef CONFIG_TX_MCAST2UNI
	u8 under_exist_checking;
#endif /* CONFIG_TX_MCAST2UNI */

	u8 keep_alive_trycnt;

#ifdef CONFIG_AUTO_AP_MODE
	u8 isrc; /* this device is rc */
	u16 pid; /* pairing id */
#endif

#endif /* CONFIG_AP_MODE	 */

#ifdef CONFIG_RTW_MESH
	struct mesh_plink_ent *plink;

	u8 local_mps;
	u8 peer_mps;
	u8 nonpeer_mps;

	struct rtw_atlm_param metrics;
	/* The reference for nexthop_lookup */
	BOOLEAN alive;
#endif

#ifdef CONFIG_IOCTL_CFG80211
	u8 *pauth_frame;
	u32 auth_len;
	u8 *passoc_req;
	u32 assoc_req_len;
#endif

	u8		IOTPeer;			/* Enum value.	HT_IOT_PEER_E */
#ifdef CONFIG_LPS_PG
	u8		lps_pg_rssi_lv;
#endif

	/* To store the sequence number of received management frame */
	u16 RxMgmtFrameSeqNum;

	struct st_ctl_t st_ctl;
	u8 max_agg_num_minimal_record; /*keep minimal tx desc max_agg_num setting*/
	u8 curr_rx_rate;
	u8 curr_rx_rate_bmc;
#ifdef CONFIG_RTS_FULL_BW
	bool vendor_8812;
#endif

	/*
	 * Vaiables for queuing TX pkt a short period of time
	 * to wait something ready.
	 */
	u8 tx_q_enable;
	struct __queue tx_queue;
	_workitem tx_q_work;
};

#ifdef CONFIG_RTW_MESH
#define STA_SET_MESH_PLINK(sta, link) (sta)->plink = link
#else
#define STA_SET_MESH_PLINK(sta, link) do {} while (0)
#endif

#define sta_tx_pkts(sta) \
	(sta->sta_stats.tx_pkts)

#define sta_last_tx_pkts(sta) \
	(sta->sta_stats.last_tx_pkts)

#define sta_rx_pkts(sta) \
	(sta->sta_stats.rx_mgnt_pkts \
	 + sta->sta_stats.rx_ctrl_pkts \
	 + sta->sta_stats.rx_data_pkts)

#define sta_last_rx_pkts(sta) \
	(sta->sta_stats.last_rx_mgnt_pkts \
	 + sta->sta_stats.last_rx_ctrl_pkts \
	 + sta->sta_stats.last_rx_data_pkts)

#define sta_rx_data_pkts(sta) (sta->sta_stats.rx_data_pkts)
#define sta_last_rx_data_pkts(sta) (sta->sta_stats.last_rx_data_pkts)

#define sta_rx_data_uc_pkts(sta) (sta->sta_stats.rx_data_pkts - sta->sta_stats.rx_data_bc_pkts - sta->sta_stats.rx_data_mc_pkts)
#define sta_last_rx_data_uc_pkts(sta) (sta->sta_stats.last_rx_data_pkts - sta->sta_stats.last_rx_data_bc_pkts - sta->sta_stats.last_rx_data_mc_pkts)

#define sta_rx_data_qos_pkts(sta, i) \
	(sta->sta_stats.rx_data_qos_pkts[i])

#define sta_last_rx_data_qos_pkts(sta, i) \
	(sta->sta_stats.last_rx_data_qos_pkts[i])

#define sta_rx_mgnt_pkts(sta) \
	(sta->sta_stats.rx_mgnt_pkts)

#define sta_last_rx_mgnt_pkts(sta) \
	(sta->sta_stats.last_rx_mgnt_pkts)

#define sta_rx_beacon_pkts(sta) \
	(sta->sta_stats.rx_beacon_pkts)

#define sta_last_rx_beacon_pkts(sta) \
	(sta->sta_stats.last_rx_beacon_pkts)

#define sta_rx_probereq_pkts(sta) \
	(sta->sta_stats.rx_probereq_pkts)

#define sta_last_rx_probereq_pkts(sta) \
	(sta->sta_stats.last_rx_probereq_pkts)

#define sta_rx_probersp_pkts(sta) \
	(sta->sta_stats.rx_probersp_pkts)

#define sta_last_rx_probersp_pkts(sta) \
	(sta->sta_stats.last_rx_probersp_pkts)

#define sta_rx_probersp_bm_pkts(sta) \
	(sta->sta_stats.rx_probersp_bm_pkts)

#define sta_last_rx_probersp_bm_pkts(sta) \
	(sta->sta_stats.last_rx_probersp_bm_pkts)

#define sta_rx_probersp_uo_pkts(sta) \
	(sta->sta_stats.rx_probersp_uo_pkts)

#define sta_last_rx_probersp_uo_pkts(sta) \
	(sta->sta_stats.last_rx_probersp_uo_pkts)

#ifdef CONFIG_RTW_MESH
#define update_last_rx_hwmp_pkts(sta) \
	do { \
		sta->sta_stats.last_rx_hwmp_pkts = sta->sta_stats.rx_hwmp_pkts; \
	} while(0)
#else
#define update_last_rx_hwmp_pkts(sta) do {} while(0)
#endif

#define sta_update_last_rx_pkts(sta) \
	do { \
		int __i; \
		\
		sta->sta_stats.last_rx_mgnt_pkts = sta->sta_stats.rx_mgnt_pkts; \
		sta->sta_stats.last_rx_beacon_pkts = sta->sta_stats.rx_beacon_pkts; \
		sta->sta_stats.last_rx_probereq_pkts = sta->sta_stats.rx_probereq_pkts; \
		sta->sta_stats.last_rx_probersp_pkts = sta->sta_stats.rx_probersp_pkts; \
		sta->sta_stats.last_rx_probersp_bm_pkts = sta->sta_stats.rx_probersp_bm_pkts; \
		sta->sta_stats.last_rx_probersp_uo_pkts = sta->sta_stats.rx_probersp_uo_pkts; \
		sta->sta_stats.last_rx_ctrl_pkts = sta->sta_stats.rx_ctrl_pkts; \
		update_last_rx_hwmp_pkts(sta); \
		\
		sta->sta_stats.last_rx_data_pkts = sta->sta_stats.rx_data_pkts; \
		sta->sta_stats.last_rx_data_bc_pkts = sta->sta_stats.rx_data_bc_pkts; \
		sta->sta_stats.last_rx_data_mc_pkts = sta->sta_stats.rx_data_mc_pkts; \
		for (__i = 0; __i < TID_NUM; __i++) \
			sta->sta_stats.last_rx_data_qos_pkts[__i] = sta->sta_stats.rx_data_qos_pkts[__i]; \
	} while (0)

#define STA_RX_PKTS_ARG(sta) \
	sta->sta_stats.rx_mgnt_pkts \
	, sta->sta_stats.rx_ctrl_pkts \
	, sta->sta_stats.rx_data_pkts

#define STA_LAST_RX_PKTS_ARG(sta) \
	sta->sta_stats.last_rx_mgnt_pkts \
	, sta->sta_stats.last_rx_ctrl_pkts \
	, sta->sta_stats.last_rx_data_pkts

#define STA_RX_PKTS_DIFF_ARG(sta) \
	sta->sta_stats.rx_mgnt_pkts - sta->sta_stats.last_rx_mgnt_pkts \
	, sta->sta_stats.rx_ctrl_pkts - sta->sta_stats.last_rx_ctrl_pkts \
	, sta->sta_stats.rx_data_pkts - sta->sta_stats.last_rx_data_pkts

#define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"

#define sta_rx_uc_bytes(sta) (sta->sta_stats.rx_bytes - sta->sta_stats.rx_bc_bytes - sta->sta_stats.rx_mc_bytes)
#define sta_last_rx_uc_bytes(sta) (sta->sta_stats.last_rx_bytes - sta->sta_stats.last_rx_bc_bytes - sta->sta_stats.last_rx_mc_bytes)

#ifdef CONFIG_WFD
#define STA_OP_WFD_MODE(sta) (sta)->op_wfd_mode
#define STA_SET_OP_WFD_MODE(sta, mode) (sta)->op_wfd_mode = (mode)
#else
#define STA_OP_WFD_MODE(sta) 0
#define STA_SET_OP_WFD_MODE(sta, mode) do {} while (0)
#endif

#define AID_BMP_LEN(max_aid) ((max_aid + 1) / 8 + (((max_aid + 1) % 8) ? 1 : 0))

struct	sta_priv {

	u8 *pallocated_stainfo_buf;
	u8 *pstainfo_buf;
	_queue	free_sta_queue;

	_lock sta_hash_lock;
	_list   sta_hash[NUM_STA];
	int asoc_sta_count;
	_queue sleep_q;
	_queue wakeup_q;

	_adapter *padapter;

	u32 adhoc_expire_to;

	int rx_chk_limit;

#ifdef CONFIG_AP_MODE
	_list asoc_list;
	_list auth_list;
	_lock asoc_list_lock;
	_lock auth_list_lock;
	u8 asoc_list_cnt;
	u8 auth_list_cnt;

	unsigned int auth_to;  /* sec, time to expire in authenticating. */
	unsigned int assoc_to; /* sec, time to expire before associating. */
	unsigned int expire_to; /* sec , time to expire after associated. */

	/*
	* pointers to STA info; based on allocated AID or NULL if AID free
	* AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
	*/
	struct sta_info **sta_aid;
	u16 max_aid;
	u16 started_aid; /* started AID for allocation search */
	bool rr_aid; /* round robin AID allocation, will modify started_aid */
	u8 aid_bmp_len; /* in byte */
	u8 *sta_dz_bitmap;
	u8 *tim_bitmap;

	u16 max_num_sta;

#if CONFIG_RTW_MACADDR_ACL
	struct wlan_acl_pool acl_list[RTW_ACL_PERIOD_NUM];
#endif

	#if CONFIG_RTW_PRE_LINK_STA
	struct pre_link_sta_ctl_t pre_link_sta_ctl;
	#endif

#endif /* CONFIG_AP_MODE */

#ifdef CONFIG_ATMEL_RC_PATCH
	u8 atmel_rc_pattern[6];
#endif
	u8 c2h_sta_mac[ETH_ALEN];
	u8 c2h_adapter_id;
	struct submit_ctx *gotc2h;
};


__inline static u32 wifi_mac_hash(const u8 *mac)
{
	u32 x;

	x = mac[0];
	x = (x << 2) ^ mac[1];
	x = (x << 2) ^ mac[2];
	x = (x << 2) ^ mac[3];
	x = (x << 2) ^ mac[4];
	x = (x << 2) ^ mac[5];

	x ^= x >> 8;
	x  = x & (NUM_STA - 1);

	return x;
}


extern u32	_rtw_init_sta_priv(struct sta_priv *pstapriv);
extern u32	_rtw_free_sta_priv(struct sta_priv *pstapriv);

#define stainfo_offset_valid(offset) (offset < NUM_STA && offset >= 0)
int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta);
struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset);

extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, const u8 *hwaddr);
extern u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta);
extern void rtw_free_all_stainfo(_adapter *padapter);
extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr);
extern u32 rtw_init_bcmc_stainfo(_adapter *padapter);
extern struct sta_info *rtw_get_bcmc_stainfo(_adapter *padapter);

#ifdef CONFIG_AP_MODE
u16 rtw_aid_alloc(_adapter *adapter, struct sta_info *sta);
void dump_aid_status(void *sel, _adapter *adapter);
#endif

#if CONFIG_RTW_MACADDR_ACL
extern u8 rtw_access_ctrl(_adapter *adapter, const u8 *mac_addr);
void dump_macaddr_acl(void *sel, _adapter *adapter);
#endif

bool rtw_is_pre_link_sta(struct sta_priv *stapriv, u8 *addr);
#if CONFIG_RTW_PRE_LINK_STA
struct sta_info *rtw_pre_link_sta_add(struct sta_priv *stapriv, u8 *hwaddr);
void rtw_pre_link_sta_del(struct sta_priv *stapriv, u8 *hwaddr);
void rtw_pre_link_sta_ctl_reset(struct sta_priv *stapriv);
void rtw_pre_link_sta_ctl_init(struct sta_priv *stapriv);
void rtw_pre_link_sta_ctl_deinit(struct sta_priv *stapriv);
void dump_pre_link_sta_ctl(void *sel, struct sta_priv *stapriv);
#endif /* CONFIG_RTW_PRE_LINK_STA */

#endif /* _STA_INFO_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtl8812a_hal.h                                                                0000644 0001750 0001750 00000035303 14214766567 015712  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_HAL_H__
#define __RTL8812A_HAL_H__

/* #include "hal_com.h" */
#include "hal_data.h"

/* include HAL Related header after HAL Related compiling flags */
#include "rtl8812a_spec.h"
#include "rtl8812a_rf.h"
#include "rtl8812a_dm.h"
#include "rtl8812a_recv.h"
#include "rtl8812a_xmit.h"
#include "rtl8812a_cmd.h"
#include "rtl8812a_led.h"
#include "Hal8812PwrSeq.h"
#include "Hal8821APwrSeq.h" /* for 8821A/8811A */
#include "Hal8812PhyReg.h"
#include "Hal8812PhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
#include "rtl8812a_sreset.h"
#endif

/* ---------------------------------------------------------------------
 *		RTL8812 Power Configuration CMDs for PCIe interface
 * --------------------------------------------------------------------- */
#define Rtl8812_NIC_PWR_ON_FLOW				rtl8812_power_on_flow
#define Rtl8812_NIC_RF_OFF_FLOW				rtl8812_radio_off_flow
#define Rtl8812_NIC_DISABLE_FLOW				rtl8812_card_disable_flow
#define Rtl8812_NIC_ENABLE_FLOW				rtl8812_card_enable_flow
#define Rtl8812_NIC_SUSPEND_FLOW				rtl8812_suspend_flow
#define Rtl8812_NIC_RESUME_FLOW				rtl8812_resume_flow
#define Rtl8812_NIC_PDN_FLOW					rtl8812_hwpdn_flow
#define Rtl8812_NIC_LPS_ENTER_FLOW			rtl8812_enter_lps_flow
#define Rtl8812_NIC_LPS_LEAVE_FLOW				rtl8812_leave_lps_flow

/* ---------------------------------------------------------------------
 *		RTL8821 Power Configuration CMDs for PCIe interface
 * --------------------------------------------------------------------- */
#define Rtl8821A_NIC_PWR_ON_FLOW				rtl8821A_power_on_flow
#define Rtl8821A_NIC_RF_OFF_FLOW				rtl8821A_radio_off_flow
#define Rtl8821A_NIC_DISABLE_FLOW				rtl8821A_card_disable_flow
#define Rtl8821A_NIC_ENABLE_FLOW				rtl8821A_card_enable_flow
#define Rtl8821A_NIC_SUSPEND_FLOW				rtl8821A_suspend_flow
#define Rtl8821A_NIC_RESUME_FLOW				rtl8821A_resume_flow
#define Rtl8821A_NIC_PDN_FLOW					rtl8821A_hwpdn_flow
#define Rtl8821A_NIC_LPS_ENTER_FLOW			rtl8821A_enter_lps_flow
#define Rtl8821A_NIC_LPS_LEAVE_FLOW			rtl8821A_leave_lps_flow


#if 1 /* download firmware related data structure */
#define FW_SIZE_8812			0x8000 /* Compatible with RTL8723 Maximal RAM code size 24K.   modified to 32k, TO compatible with 92d maximal fw size 32k */
#define FW_START_ADDRESS		0x1000
#define FW_END_ADDRESS		0x5FFF



typedef struct _RT_FIRMWARE_8812 {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_SIZE_8812];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8812, *PRT_FIRMWARE_8812;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
#define IS_FW_HEADER_EXIST_8812(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8812(_pFwHdr) & 0xFFF0) == 0x9500)

#define IS_FW_HEADER_EXIST_8821(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8812(_pFwHdr) & 0xFFF0) == 0x2100)
/* *****************************************************
 *					Firmware Header(8-byte alinment required)
 * *****************************************************
 * --- LONG WORD 0 ---- */
#define GET_FIRMWARE_HDR_SIGNATURE_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16) /* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
#define GET_FIRMWARE_HDR_CATEGORY_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) /* AP/NIC and USB/PCI */
#define GET_FIRMWARE_HDR_FUNCTION_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 24, 8) /* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
#define GET_FIRMWARE_HDR_VERSION_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)/* FW Version */
#define GET_FIRMWARE_HDR_SUB_VER_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) /* FW Subversion, default 0x00 */
#define GET_FIRMWARE_HDR_RSVD1_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8)

/* --- LONG WORD 1 ---- */
#define GET_FIRMWARE_HDR_MONTH_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 8) /* Release time Month field */
#define GET_FIRMWARE_HDR_DATE_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 8, 8) /* Release time Date field */
#define GET_FIRMWARE_HDR_HOUR_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 16, 8)/* Release time Hour field */
#define GET_FIRMWARE_HDR_MINUTE_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+8, 24, 8)/* Release time Minute field */
#define GET_FIRMWARE_HDR_ROMCODE_SIZE_8812(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+12, 0, 16)/* The size of RAM code */
#define GET_FIRMWARE_HDR_RSVD2_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 16, 16)

/* --- LONG WORD 2 ---- */
#define GET_FIRMWARE_HDR_SVN_IDX_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+16, 0, 32)/* The SVN entry index */
#define GET_FIRMWARE_HDR_RSVD3_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 0, 32)

/* --- LONG WORD 3 ---- */
#define GET_FIRMWARE_HDR_RSVD4_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 0, 32)
#define GET_FIRMWARE_HDR_RSVD5_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)

#endif /* download firmware related data structure */


#define DRIVER_EARLY_INT_TIME_8812		0x05
#define BCN_DMA_ATIME_INT_TIME_8812		0x02

/* for 8812
 * TX 128K, RX 16K, Page size 512B for TX, 128B for RX */
#define MAX_RX_DMA_BUFFER_SIZE_8812	0x3E80 /* RX 16K */

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8812	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8812	0x0	/* 0B */
#endif
#define RX_DMA_BOUNDARY_8812		(MAX_RX_DMA_BUFFER_SIZE_8812 - RX_DMA_RESERVED_SIZE_8812 - 1)

#define PAGE_SIZE_TX_8812A PAGE_SIZE_512

/* Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8812A
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/
#define BCNQ_PAGE_NUM_8812		(MAX_BEACON_LEN / PAGE_SIZE_TX_8812A + 6) /*0x07*/

/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:1,GTK EXT MEM:1, AOAC rpt: 1,PNO: 6
 * NS offload: 1 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8812	0x08
#else
	#define WOWLAN_PAGE_NUM_8812	0x00
#endif


#ifdef CONFIG_BEAMFORMER_FW_NDPA
	#define FW_NDPA_PAGE_NUM	0x02
#else
	#define FW_NDPA_PAGE_NUM	0x00
#endif

#ifdef DBG_FW_DEBUG_MSG_PKT
	#define FW_DBG_MSG_PKT_PAGE_NUM_8812	0x01
#else
	#define FW_DBG_MSG_PKT_PAGE_NUM_8812	0x00
#endif /*DBG_FW_DEBUG_MSG_PKT*/

#define TX_TOTAL_PAGE_NUMBER_8812	(0xFF - BCNQ_PAGE_NUM_8812 - WOWLAN_PAGE_NUM_8812 - FW_NDPA_PAGE_NUM - FW_DBG_MSG_PKT_PAGE_NUM_8812)
#define TX_PAGE_BOUNDARY_8812			(TX_TOTAL_PAGE_NUMBER_8812 + 1)

#define TX_PAGE_BOUNDARY_WOWLAN_8812		(0xFF - BCNQ_PAGE_NUM_8812 - WOWLAN_PAGE_NUM_8812 + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8812	TX_TOTAL_PAGE_NUMBER_8812
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8812		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8812 + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8812 */
#define NORMAL_PAGE_NUM_LPQ_8812				0x10
#define NORMAL_PAGE_NUM_HPQ_8812			0x10
#define NORMAL_PAGE_NUM_NPQ_8812			0x00

#define WMM_NORMAL_PAGE_NUM_HPQ_8812		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8812		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8812		0x20


/* for 8821A
 * TX 64K, RX 16K, Page size 256B for TX, 128B for RX */
#define PAGE_SIZE_TX_8821A					256
#define PAGE_SIZE_RX_8821A					128

#define MAX_RX_DMA_BUFFER_SIZE_8821			0x3E80 /* RX 16K */

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8821	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8821	0x0	/* 0B */
#endif
#define RX_DMA_BOUNDARY_8821		(MAX_RX_DMA_BUFFER_SIZE_8821 - RX_DMA_RESERVED_SIZE_8821 - 1)

/* Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8821A
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/

#define BCNQ_PAGE_NUM_8821		(MAX_BEACON_LEN / PAGE_SIZE_TX_8821A + 6) /*0x08*/


/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:1,GTK EXT MEM:1, PNO: 6 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8821	0x06
#else
	#define WOWLAN_PAGE_NUM_8821	0x00
#endif

#define TX_TOTAL_PAGE_NUMBER_8821	(0xFF - BCNQ_PAGE_NUM_8821 - WOWLAN_PAGE_NUM_8821)
#define TX_PAGE_BOUNDARY_8821				(TX_TOTAL_PAGE_NUMBER_8821 + 1)
/* #define TX_PAGE_BOUNDARY_WOWLAN_8821		0xE0 */

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8821	TX_TOTAL_PAGE_NUMBER_8821
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8821		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8821 + 1)


/* (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER */
#define NORMAL_PAGE_NUM_LPQ_8821			0x08/* 0x10 */
#define NORMAL_PAGE_NUM_HPQ_8821		0x08/* 0x10 */
#define NORMAL_PAGE_NUM_NPQ_8821		0x00
#define NORMAL_PAGE_NUM_EPQ_8821			0x04

#define WMM_NORMAL_PAGE_NUM_HPQ_8821		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8821		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8821		0x20
#define WMM_NORMAL_PAGE_NUM_EPQ_8821		0x00

#define MCC_NORMAL_PAGE_NUM_HPQ_8821		0x10
#define MCC_NORMAL_PAGE_NUM_LPQ_8821		0x10
#define MCC_NORMAL_PAGE_NUM_NPQ_8821		0x10

#define	EFUSE_HIDDEN_812AU					0
#define	EFUSE_HIDDEN_812AU_VS				1
#define	EFUSE_HIDDEN_812AU_VL				2
#define	EFUSE_HIDDEN_812AU_VN				3

#if 0
#define EFUSE_REAL_CONTENT_LEN_JAGUAR		1024
#define HWSET_MAX_SIZE_JAGUAR					1024
#else
#define EFUSE_REAL_CONTENT_LEN_JAGUAR		512
#define HWSET_MAX_SIZE_JAGUAR					512
#endif

#define EFUSE_MAX_BANK_8812A					2
#define EFUSE_MAP_LEN_JAGUAR					512
#define EFUSE_MAX_SECTION_JAGUAR				64
#define EFUSE_MAX_WORD_UNIT_JAGUAR			4
#define EFUSE_IC_ID_OFFSET_JAGUAR				506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define AVAILABLE_EFUSE_ADDR_8812(addr)	(addr < EFUSE_REAL_CONTENT_LEN_JAGUAR)
/* <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
 * 9bytes + 1byt + 5bytes and pre 1byte.
 * For worst case:
 * | 2byte|----8bytes----|1byte|--7bytes--|  */ /* 92D */
#define EFUSE_OOB_PROTECT_BYTES_JAGUAR		18	/* PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte. */
#define EFUSE_PROTECT_BYTES_BANK_JAGUAR		16

#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

/* #define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? _TRUE : _FALSE) */

/* #define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) ) */
#define HAL_EFUSE_MEMORY

/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define BANK_NUM			2
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
#define EFUSE_BT_REAL_CONTENT_LEN	\
	(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)
#define EFUSE_BT_MAP_LEN		1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION		(EFUSE_BT_MAP_LEN / 8)
#define EFUSE_PROTECT_BYTES_BANK	16

#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_BT_REAL_CONTENT_LEN)

#ifdef CONFIG_FILE_FWIMG
extern char *rtw_fw_file_path;
#ifdef CONFIG_WOWLAN
extern char *rtw_fw_wow_file_path;
#endif
#ifdef CONFIG_MP_INCLUDED
extern char *rtw_fw_mp_bt_file_path;
#endif
#endif


/* rtl8812_hal_init.c */
void	_8051Reset8812(PADAPTER padapter);
s32	FirmwareDownload8812(PADAPTER Adapter, BOOLEAN bUsedWoWLANFw);
void	InitializeFirmwareVars8812(PADAPTER padapter);

s32	_LLTWrite_8812A(PADAPTER Adapter, u32 address, u32 data);
s32	InitLLTTable8812A(PADAPTER padapter, u8 txpktbuf_bndy);
void InitRDGSetting8812A(PADAPTER padapter);

void CheckAutoloadState8812A(PADAPTER padapter);

/* EFuse */
u8	GetEEPROMSize8812A(PADAPTER padapter);
void InitPGData8812A(PADAPTER padapter);
void	Hal_EfuseParseIDCode8812A(PADAPTER padapter, u8 *hwinfo);
void	Hal_ReadPROMVersion8812A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_ReadTxPowerInfo8812A(PADAPTER padapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);
void	Hal_ReadBoardType8812A(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_ReadThermalMeter_8812A(PADAPTER	Adapter, u8 *PROMContent, BOOLEAN	AutoloadFail);
void	Hal_ReadChannelPlan8812A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_EfuseParseXtal_8812A(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_ReadAntennaDiversity8812A(PADAPTER pAdapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
void	Hal_ReadAmplifierType_8812A(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	Hal_ReadPAType_8821A(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	Hal_ReadRFEType_8812A(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	Hal_EfuseParseBTCoexistInfo8812A(PADAPTER Adapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	hal_ReadUsbType_8812AU(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
#ifdef CONFIG_MP_INCLUDED
int	FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
#endif
void	Hal_ReadRemoteWakeup_8812A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);

BOOLEAN HalDetectPwrDownMode8812(PADAPTER Adapter);
void Hal_EfuseParseKFreeData_8821A(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);

#ifdef CONFIG_WOWLAN
void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void _InitBeaconParameters_8812A(PADAPTER padapter);
void SetBeaconRelatedRegisters8812A(PADAPTER padapter);

void ReadRFType8812A(PADAPTER padapter);
void InitDefaultValue8821A(PADAPTER padapter);

u8 SetHwReg8812A(PADAPTER padapter, u8 variable, u8 *pval);
void GetHwReg8812A(PADAPTER padapter, u8 variable, u8 *pval);
u8 SetHalDefVar8812A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8812A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
void rtl8812_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8812a(_adapter *adapter);
void init_hal_spec_8821a(_adapter *adapter);

u32 upload_txpktbuf_8812au(_adapter *adapter, u8 *buf, u32 buflen);

void rtl8812_start_thread(PADAPTER padapter);
void rtl8812_stop_thread(PADAPTER padapter);

#ifdef CONFIG_PCI_HCI
BOOLEAN	InterruptRecognized8812AE(PADAPTER Adapter);
void	UpdateInterruptMask8812AE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
void	InitTRXDescHwAddress8812AE(PADAPTER Adapter);
#endif

#ifdef CONFIG_BT_COEXIST
void rtl8812a_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
#endif

void
Hal_PatchwithJaguar_8812(
		PADAPTER				Adapter,
		RT_MEDIA_STATUS		MediaStatus
);

#endif /* __RTL8188E_HAL_H__ */
                                                                                                                                                                                                                                                                                                                             rtl8822bu/src/include/rtl8821a_spec.h                                                               0000644 0001750 0001750 00000006570 14214766567 016104  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8821A_SPEC_H__
#define __RTL8821A_SPEC_H__

#include <drv_conf.h>
/* This file should based on "hal_com_reg.h" */
#include <hal_com_reg.h>
/* Because 8812a and 8821a is the same serial,
 * most of 8821a register definitions are the same as 8812a. */
#include <rtl8812a_spec.h>


/* ************************************************************
 * 8821A Regsiter offset definition
 * ************************************************************ */

/* ************************************************************
 * MAC register
 * ************************************************************ */

/* -----------------------------------------------------
 *	0x0000h ~ 0x00FFh	System Configuration
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 * ----------------------------------------------------- */
#define REG_WOWLAN_WAKE_REASON          REG_MCUTST_WOWLAN

/* -----------------------------------------------------
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *	0x0300h ~ 0x03FFh	PCIe
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 * ----------------------------------------------------- */


/* ************************************************************
 * SDIO Bus Specification
 * ************************************************************ */

/* -----------------------------------------------------
 * SDIO CMD Address Mapping
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * I/O bus domain (Host)
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * SDIO register
 * ----------------------------------------------------- */
#define SDIO_REG_FREE_TXPG2		0x024
#define SDIO_REG_HCPWM1_8821A	0x025

/* ************************************************************
 * Regsiter Bit and Content definition
 * ************************************************************ */

#endif /* __RTL8821A_SPEC_H__ */
                                                                                                                                        rtl8822bu/src/include/rtl8710b_spec.h                                                               0000644 0001750 0001750 00000041550 14214766567 016077  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_SPEC_H__
#define __RTL8710B_SPEC_H__

#include <drv_conf.h>


#define HAL_NAV_UPPER_UNIT_8710B		128		/* micro-second */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_SYS_ISO_CTRL_8710B			0x0000	/* 2 Byte */
#define REG_APS_FSMCO_8710B			0x0004	/* 4 Byte */
#define REG_SYS_CLKR_8710B				0x0008	/* 2 Byte */
#define REG_9346CR_8710B				0x000A	/* 2 Byte */
#define REG_EE_VPD_8710B				0x000C	/* 2 Byte */
#define REG_AFE_MISC_8710B				0x0010	/* 1 Byte */
#define REG_SPS0_CTRL_8710B				0x0011	/* 7 Byte */
#define REG_SPS_OCP_CFG_8710B			0x0018	/* 4 Byte */
#define REG_RSV_CTRL_8710B				0x001C	/* 3 Byte */
#define REG_RF_CTRL_8710B				0x001F	/* 1 Byte */
#define REG_LPLDO_CTRL_8710B			0x0023	/* 1 Byte */
#define REG_AFE_XTAL_CTRL_8710B		0x0024	/* 4 Byte */
#define REG_AFE_PLL_CTRL_8710B			0x0028	/* 4 Byte */
#define REG_MAC_PLL_CTRL_EXT_8710B		0x002c	/* 4 Byte */
#define REG_EFUSE_CTRL_8710B			0x0030
#define REG_EFUSE_TEST_8710B			0x0034
#define REG_PWR_DATA_8710B				0x0038
#define REG_CAL_TIMER_8710B				0x003C
#define REG_ACLK_MON_8710B				0x003E
#define REG_GPIO_MUXCFG_8710B			0x0040
#define REG_GPIO_IO_SEL_8710B			0x0042
#define REG_MAC_PINMUX_CFG_8710B		0x0043
#define REG_GPIO_PIN_CTRL_8710B			0x0044
#define REG_GPIO_INTM_8710B				0x0048
#define REG_LEDCFG0_8710B				0x004C
#define REG_LEDCFG1_8710B				0x004D
#define REG_LEDCFG2_8710B				0x004E
#define REG_LEDCFG3_8710B				0x004F
#define REG_FSIMR_8710B					0x0050
#define REG_FSISR_8710B					0x0054
#define REG_HSIMR_8710B					0x0058
#define REG_HSISR_8710B					0x005c
#define REG_GPIO_EXT_CTRL				0x0060
#define REG_PAD_CTRL1_8710B		0x0064
#define REG_MULTI_FUNC_CTRL_8710B		0x0068
#define REG_GPIO_STATUS_8710B			0x006C
#define REG_SDIO_CTRL_8710B				0x0070
#define REG_OPT_CTRL_8710B				0x0074
#define REG_AFE_CTRL_4_8710B		0x0078
#define REG_MCUFWDL_8710B				0x0080
#define REG_8051FW_CTRL_8710B			0x0080
#define REG_HMEBOX_DBG_0_8710B	0x0088
#define REG_HMEBOX_DBG_1_8710B	0x008A
#define REG_HMEBOX_DBG_2_8710B	0x008C
#define REG_HMEBOX_DBG_3_8710B	0x008E
#define REG_WLLPS_CTRL		0x0090

#define REG_PMC_DBG_CTRL2_8710B			0x00CC
#define	REG_EFUSE_BURN_GNT_8710B		0x00CF
#define REG_HPON_FSM_8710B				0x00EC
#define REG_SYS_CFG1_8710B				0x00F0
#define REG_SYS_CFG_8710B				0x00FC
#define REG_ROM_VERSION					0x00FD

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_C2HEVT_CMD_ID_8710B	0x01A0
#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
#define REG_C2HEVT_CMD_LEN_8710B        0x01AE
#define REG_C2HEVT_CLEAR_8710B			0x01AF
#define REG_MCUTST_1_8710B				0x01C0
#define REG_WOWLAN_WAKE_REASON 0x01C7
#define REG_FMETHR_8710B				0x01C8
#define REG_HMETFR_8710B				0x01CC
#define REG_HMEBOX_0_8710B				0x01D0
#define REG_HMEBOX_1_8710B				0x01D4
#define REG_HMEBOX_2_8710B				0x01D8
#define REG_HMEBOX_3_8710B				0x01DC
#define REG_LLT_INIT_8710B				0x01E0
#define REG_HMEBOX_EXT0_8710B			0x01F0
#define REG_HMEBOX_EXT1_8710B			0x01F4
#define REG_HMEBOX_EXT2_8710B			0x01F8
#define REG_HMEBOX_EXT3_8710B			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RQPN_8710B					0x0200
#define REG_FIFOPAGE_8710B				0x0204
#define REG_DWBCN0_CTRL_8710B			REG_TDECTRL
#define REG_TXDMA_OFFSET_CHK_8710B	0x020C
#define REG_TXDMA_STATUS_8710B		0x0210
#define REG_RQPN_NPQ_8710B			0x0214
#define REG_DWBCN1_CTRL_8710B			0x0228


/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_AGG_PG_TH_8710B		0x0280
#define REG_FW_UPD_RDPTR_8710B		0x0284 /* FW shall update this register before FW write RXPKT_RELEASE_POLL to 1 */
#define REG_RXDMA_CONTROL_8710B		0x0286 /* Control the RX DMA. */
#define REG_RXDMA_STATUS_8710B			0x0288
#define REG_RXDMA_MODE_CTRL_8710B		0x0290
#define REG_EARLY_MODE_CONTROL_8710B	0x02BC
#define REG_RSVD5_8710B					0x02F0
#define REG_RSVD6_8710B					0x02F4

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8710B			0x0300
#define	REG_INT_MIG_8710B				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_TXBD_DESA_8710B		0x0308	/* TX Beacon Descriptor Address */
#define	REG_MGQ_TXBD_DESA_8710B			0x0310	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_TXBD_DESA_8710B			0x0318	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_TXBD_DESA_8710B			0x0320	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_TXBD_DESA_8710B			0x0328	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_TXBD_DESA_8710B			0x0330	/* TX BK Queue Descriptor Address */
#define	REG_RXQ_RXBD_DESA_8710B			0x0338	/* RX Queue	Descriptor Address */
#define REG_HI0Q_TXBD_DESA_8710B		0x0340
#define REG_HI1Q_TXBD_DESA_8710B		0x0348
#define REG_HI2Q_TXBD_DESA_8710B		0x0350
#define REG_HI3Q_TXBD_DESA_8710B		0x0358
#define REG_HI4Q_TXBD_DESA_8710B		0x0360
#define REG_HI5Q_TXBD_DESA_8710B		0x0368
#define REG_HI6Q_TXBD_DESA_8710B		0x0370
#define REG_HI7Q_TXBD_DESA_8710B		0x0378
#define	REG_MGQ_TXBD_NUM_8710B			0x0380
#define	REG_RX_RXBD_NUM_8710B			0x0382
#define	REG_VOQ_TXBD_NUM_8710B			0x0384
#define	REG_VIQ_TXBD_NUM_8710B			0x0386
#define	REG_BEQ_TXBD_NUM_8710B			0x0388
#define	REG_BKQ_TXBD_NUM_8710B			0x038A
#define	REG_HI0Q_TXBD_NUM_8710B			0x038C
#define	REG_HI1Q_TXBD_NUM_8710B			0x038E
#define	REG_HI2Q_TXBD_NUM_8710B			0x0390
#define	REG_HI3Q_TXBD_NUM_8710B			0x0392
#define	REG_HI4Q_TXBD_NUM_8710B			0x0394
#define	REG_HI5Q_TXBD_NUM_8710B			0x0396
#define	REG_HI6Q_TXBD_NUM_8710B			0x0398
#define	REG_HI7Q_TXBD_NUM_8710B			0x039A
#define	REG_TSFTIMER_HCI_8710B			0x039C
#define	REG_BD_RW_PTR_CLR_8710B			0x039C

/* Read Write Point */
#define	REG_VOQ_TXBD_IDX_8710B			0x03A0
#define	REG_VIQ_TXBD_IDX_8710B			0x03A4
#define	REG_BEQ_TXBD_IDX_8710B			0x03A8
#define	REG_BKQ_TXBD_IDX_8710B			0x03AC
#define	REG_MGQ_TXBD_IDX_8710B			0x03B0
#define	REG_RXQ_TXBD_IDX_8710B			0x03B4
#define	REG_HI0Q_TXBD_IDX_8710B			0x03B8
#define	REG_HI1Q_TXBD_IDX_8710B			0x03BC
#define	REG_HI2Q_TXBD_IDX_8710B			0x03C0
#define	REG_HI3Q_TXBD_IDX_8710B			0x03C4
#define	REG_HI4Q_TXBD_IDX_8710B			0x03C8
#define	REG_HI5Q_TXBD_IDX_8710B			0x03CC
#define	REG_HI6Q_TXBD_IDX_8710B			0x03D0
#define	REG_HI7Q_TXBD_IDX_8710B			0x03D4

#define	REG_PCIE_HCPWM_8710BE			0x03D8 /* ?????? */
#define	REG_PCIE_HRPWM_8710BE			0x03DC	/* PCIe RPWM  ?????? */
#define	REG_DBI_WDATA_V1_8710B			0x03E8
#define	REG_DBI_RDATA_V1_8710B			0x03EC
#define	REG_DBI_FLAG_V1_8710B			0x03F0
#define REG_MDIO_V1_8710B				0x03F4
#define REG_PCIE_MIX_CFG_8710B			0x03F8
#define REG_HCI_MIX_CFG_8710B			0x03FC

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_VOQ_INFORMATION_8710B		0x0400
#define REG_VIQ_INFORMATION_8710B		0x0404
#define REG_BEQ_INFORMATION_8710B		0x0408
#define REG_BKQ_INFORMATION_8710B		0x040C
#define REG_MGQ_INFORMATION_8710B		0x0410
#define REG_HGQ_INFORMATION_8710B		0x0414
#define REG_BCNQ_INFORMATION_8710B	0x0418
#define REG_TXPKT_EMPTY_8710B			0x041A

#define REG_FWHW_TXQ_CTRL_8710B		0x0420
#define REG_HWSEQ_CTRL_8710B			0x0423
#define REG_TXPKTBUF_BCNQ_BDNY_8710B	0x0424
#define REG_TXPKTBUF_MGQ_BDNY_8710B	0x0425
#define REG_LIFECTRL_CTRL_8710B			0x0426
#define REG_MULTI_BCNQ_OFFSET_8710B	0x0427
#define REG_SPEC_SIFS_8710B				0x0428
#define REG_RL_8710B						0x042A
#define REG_TXBF_CTRL_8710B				0x042C
#define REG_DARFRC_8710B				0x0430
#define REG_RARFRC_8710B				0x0438
#define REG_RRSR_8710B					0x0440
#define REG_ARFR0_8710B					0x0444
#define REG_ARFR1_8710B					0x044C
#define REG_CCK_CHECK_8710B				0x0454
#define REG_AMPDU_MAX_TIME_8710B		0x0456
#define REG_TXPKTBUF_BCNQ_BDNY1_8710B	0x0457

#define REG_AMPDU_MAX_LENGTH_8710B	0x0458
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8710B	0x045D
#define REG_NDPA_OPT_CTRL_8710B		0x045F
#define REG_FAST_EDCA_CTRL_8710B		0x0460
#define REG_RD_RESP_PKT_TH_8710B		0x0463
#define REG_DATA_SC_8710B				0x0483
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW             0x0484
	#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_TXRPT_START_OFFSET		0x04AC
#define REG_POWER_STAGE1_8710B		0x04B4
#define REG_POWER_STAGE2_8710B		0x04B8
#define REG_AMPDU_BURST_MODE_8710B	0x04BC
#define REG_PKT_VO_VI_LIFE_TIME_8710B	0x04C0
#define REG_PKT_BE_BK_LIFE_TIME_8710B	0x04C2
#define REG_STBC_SETTING_8710B			0x04C4
#define REG_HT_SINGLE_AMPDU_8710B		0x04C7
#define REG_PROT_MODE_CTRL_8710B		0x04C8
#define REG_MAX_AGGR_NUM_8710B		0x04CA
#define REG_RTS_MAX_AGGR_NUM_8710B	0x04CB
#define REG_BAR_MODE_CTRL_8710B		0x04CC
#define REG_RA_TRY_RATE_AGG_LMT_8710B	0x04CF
#define REG_MACID_PKT_DROP0_8710B		0x04D0
#define REG_MACID_PKT_SLEEP_8710B		0x04D4

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_EDCA_VO_PARAM_8710B		0x0500
#define REG_EDCA_VI_PARAM_8710B		0x0504
#define REG_EDCA_BE_PARAM_8710B		0x0508
#define REG_EDCA_BK_PARAM_8710B		0x050C
#define REG_BCNTCFG_8710B				0x0510
#define REG_PIFS_8710B					0x0512
#define REG_RDG_PIFS_8710B				0x0513
#define REG_SIFS_CTX_8710B				0x0514
#define REG_SIFS_TRX_8710B				0x0516
#define REG_AGGR_BREAK_TIME_8710B		0x051A
#define REG_SLOT_8710B					0x051B
#define REG_TX_PTCL_CTRL_8710B			0x0520
#define REG_TXPAUSE_8710B				0x0522
#define REG_DIS_TXREQ_CLR_8710B		0x0523
#define REG_RD_CTRL_8710B				0x0524
/*
 * Format for offset 540h-542h:
 *	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
 *	[7:4]:   Reserved.
 *	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
 *	[23:20]: Reserved
 * Description:
 *	              |
 * |<--Setup--|--Hold------------>|
 *	--------------|----------------------
 * |
 * TBTT
 * Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
 * Described by Designer Tim and Bruce, 2011-01-14.
 *   */
#define REG_TBTT_PROHIBIT_8710B			0x0540
#define REG_RD_NAV_NXT_8710B			0x0544
#define REG_NAV_PROT_LEN_8710B			0x0546
#define REG_BCN_CTRL_8710B				0x0550
#define REG_BCN_CTRL_1_8710B			0x0551
#define REG_MBID_NUM_8710B				0x0552
#define REG_DUAL_TSF_RST_8710B			0x0553
#define REG_BCN_INTERVAL_8710B			0x0554
#define REG_DRVERLYINT_8710B			0x0558
#define REG_BCNDMATIM_8710B			0x0559
#define REG_ATIMWND_8710B				0x055A
#define REG_USTIME_TSF_8710B			0x055C
#define REG_BCN_MAX_ERR_8710B			0x055D
#define REG_RXTSF_OFFSET_CCK_8710B		0x055E
#define REG_RXTSF_OFFSET_OFDM_8710B	0x055F
#define REG_TSFTR_8710B					0x0560
#define REG_CTWND_8710B					0x0572
#define REG_SECONDARY_CCA_CTRL_8710B	0x0577
#define REG_PSTIMER_8710B				0x0580
#define REG_TIMER0_8710B				0x0584
#define REG_TIMER1_8710B				0x0588
#define REG_ACMHWCTRL_8710B			0x05C0
#define REG_SCH_TXCMD_8710B			0x05F8

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#define REG_MAC_CR_8710B				0x0600
#define REG_TCR_8710B					0x0604
#define REG_RCR_8710B					0x0608
#define REG_RX_PKT_LIMIT_8710B			0x060C
#define REG_RX_DLK_TIME_8710B			0x060D
#define REG_RX_DRVINFO_SZ_8710B		0x060F

#define REG_MACID_8710B					0x0610
#define REG_BSSID_8710B					0x0618
#define REG_MAR_8710B					0x0620
#define REG_MBIDCAMCFG_8710B			0x0628
#define REG_WOWLAN_GTK_DBG1	0x630
#define REG_WOWLAN_GTK_DBG2	0x634

#define REG_USTIME_EDCA_8710B			0x0638
#define REG_MAC_SPEC_SIFS_8710B		0x063A
#define REG_RESP_SIFP_CCK_8710B			0x063C
#define REG_RESP_SIFS_OFDM_8710B		0x063E
#define REG_ACKTO_8710B					0x0640
#define REG_CTS2TO_8710B				0x0641
#define REG_EIFS_8710B					0x0642

#define REG_NAV_UPPER_8710B			0x0652	/* unit of 128 */
#define REG_TRXPTCL_CTL_8710B			0x0668

/* Security */
#define REG_CAMCMD_8710B				0x0670
#define REG_CAMWRITE_8710B				0x0674
#define REG_CAMREAD_8710B				0x0678
#define REG_CAMDBG_8710B				0x067C
#define REG_SECCFG_8710B				0x0680

/* Power */
#define REG_WOW_CTRL_8710B				0x0690
#define REG_PS_RX_INFO_8710B			0x0692
#define REG_UAPSD_TID_8710B				0x0693
#define REG_WKFMCAM_CMD_8710B			0x0698
#define REG_WKFMCAM_NUM_8710B			0x0698
#define REG_WKFMCAM_RWD_8710B			0x069C
#define REG_RXFLTMAP0_8710B				0x06A0
#define REG_RXFLTMAP1_8710B				0x06A2
#define REG_RXFLTMAP2_8710B				0x06A4
#define REG_BCN_PSR_RPT_8710B			0x06A8
#define REG_BT_COEX_TABLE_8710B		0x06C0
#define REG_BFMER0_INFO_8710B			0x06E4
#define REG_BFMER1_INFO_8710B			0x06EC
#define REG_CSI_RPT_PARAM_BW20_8710B	0x06F4
#define REG_CSI_RPT_PARAM_BW40_8710B	0x06F8
#define REG_CSI_RPT_PARAM_BW80_8710B	0x06FC

/* Hardware Port 2 */
#define REG_MACID1_8710B				0x0700
#define REG_BSSID1_8710B				0x0708
#define REG_BFMEE_SEL_8710B				0x0714
#define REG_SND_PTCL_CTRL_8710B		0x0718

/* LTR */
#define REG_LTR_CTRL_BASIC_8710B		0x07A4
#define REG_LTR_IDLE_LATENCY_V1_8710B		0x0798
#define REG_LTR_ACTIVE_LATENCY_V1_8710B		0x079C

/* LTE_COEX */
#define REG_LTECOEX_CTRL			0x07C0
#define REG_LTECOEX_WRITE_DATA		0x07C4
#define REG_LTECOEX_READ_DATA		0x07C8
#define REG_LTECOEX_PATH_CONTROL	0x70

/* Other */
#define REG_USB_ACCESS_TIMEOUT 0xFE4C

/* -----------------------------------------------------
 * SYSON_REG_SPEC
 * ----------------------------------------------------- */
#define SYSON_REG_BASE_ADDR_8710B 0x40000000
#define REG_SYS_XTAL_CTRL0	0x0060
#define REG_SYS_SYSTEM_CFG0 0x1F0
#define REG_SYS_SYSTEM_CFG1 0x1F4
#define REG_SYS_SYSTEM_CFG2 0x1F8
#define REG_SYS_EEPROM_CTRL0 0x0E0


/* -----------------------------------------------------
 * Indirect_R/W_SPEC
 * ----------------------------------------------------- */
#define NORMAL_REG_READ_OFFSET 0x83000000
#define NORMAL_REG_WRITE_OFFSET 0x84000000
#define EFUSE_READ_OFFSET 0x85000000
#define EFUSE_WRITE_OFFSET 0x86000000


/* -----------------------------------------------------
 * PAGE0_WLANON_REG_SPEC
 * ----------------------------------------------------- */
#define PAGE0_OFFSET 0x0 // WLANON_PAGE0_REG needs to add an offset.



/* ****************************************************************************
 *	8723 Regsiter Bit and Content definition
 * **************************************************************************** */
 
 /* -----------------------------------------------------
 * REG_SYS_SYSTEM_CFG0 
 * ----------------------------------------------------- */
#define BIT_RTL_ID_8710B BIT(16)

#define BIT_MASK_CHIP_VER_8710B 0xf
#define BIT_GET_CHIP_VER_8710B(x) ((x) & BIT_MASK_CHIP_VER_8710B)

#define BIT_SHIFT_VENDOR_ID_8710B 4
#define BIT_MASK_VENDOR_ID_8710B 0xf
#define BIT_GET_VENDOR_ID_8710B(x) (((x) >> BIT_SHIFT_VENDOR_ID_8710B) & BIT_MASK_VENDOR_ID_8710B)

 /* -----------------------------------------------------
 * REG_SYS_SYSTEM_CFG1 
 * ----------------------------------------------------- */
#define BIT_SPSLDO_SEL_8710B BIT(25)

 /* -----------------------------------------------------
 * REG_SYS_SYSTEM_CFG2 
 * ----------------------------------------------------- */
#define BIT_MASK_RF_RL_ID_8710B 0xf
#define BIT_GET_RF_RL_ID_8710B(x) ((x) & BIT_MASK_RF_RL_ID_8710B)

 /* -----------------------------------------------------
 * REG_SYS_SYSTEM_CFG2 
 * ----------------------------------------------------- */
#define BIT_EERPOMSEL_8710B BIT(4)
#define BIT_AUTOLOAD_SUS_8710B BIT(5)


 /* -----------------------------------------------------
 * Other
 * ----------------------------------------------------- */


#define BIT_USB_RXDMA_AGG_EN	BIT(31)
#define RXDMA_AGG_MODE_EN		BIT(1)

#ifdef CONFIG_WOWLAN
	#define RXPKT_RELEASE_POLL		BIT(16)
	#define RXDMA_IDLE				BIT(17)
	#define RW_RELEASE_EN			BIT(18)
#endif

/* 2 HSISR
 * interrupt mask which needs to clear */
#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
		HSISR_SPS_OCP_INT |\
		HSISR_RON_INT |\
		HSISR_PDNINT |\
		HSISR_GPIO9_INT)

#ifdef CONFIG_RF_POWER_TRIM
	#ifdef CONFIG_RTL8710B
		#define EEPROM_RF_GAIN_OFFSET			0xC1
	#endif

	#define EEPROM_RF_GAIN_VAL				0x1F6
#endif /*CONFIG_RF_POWER_TRIM*/

#endif /* __RTL8710B_SPEC_H__ */
                                                                                                                                                        rtl8822bu/src/include/rtw_pwrctrl.h                                                                 0000644 0001750 0001750 00000042711 14214766567 016173  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_PWRCTRL_H_
#define __RTW_PWRCTRL_H_


#define FW_PWR0	0
#define FW_PWR1	1
#define FW_PWR2	2
#define FW_PWR3	3


#define HW_PWR0	7
#define HW_PWR1	6
#define HW_PWR2	2
#define HW_PWR3	0
#define HW_PWR4	8

#define FW_PWRMSK	0x7


#define XMIT_ALIVE	BIT(0)
#define RECV_ALIVE	BIT(1)
#define CMD_ALIVE	BIT(2)
#define EVT_ALIVE	BIT(3)
#ifdef CONFIG_BT_COEXIST
#define BTCOEX_ALIVE	BIT(4)
#endif /* CONFIG_BT_COEXIST */

#ifdef CONFIG_WOWLAN
	#ifdef CONFIG_PLATFORM_ANDROID_INTEL_X86
		/* TCP/ICMP/UDP multicast with specific IP addr */
		#define DEFAULT_PATTERN_NUM 4
	#else
		/* TCP/ICMP */
		#define DEFAULT_PATTERN_NUM 3
	#endif

#ifdef CONFIG_WOW_PATTERN_HW_CAM	/* Frame Mask Cam number for pattern match */
#define MAX_WKFM_CAM_NUM	12
#else
#define MAX_WKFM_CAM_NUM	16
#endif

#define MAX_WKFM_SIZE	16 /* (16 bytes for WKFM bit mask, 16*8 = 128 bits) */
#define MAX_WKFM_PATTERN_SIZE	128

/*
 * MAX_WKFM_PATTERN_STR_LEN : the max. length of wow pattern string
 *	e.g. echo 00:01:02:...:7f > /proc/net/rtl88x2bu/wlan0/wow_pattern_info
 *	- each byte of pattern is represented as 2-bytes ascii : MAX_WKFM_PATTERN_SIZE * 2
 *	- the number of common ':' in pattern string : MAX_WKFM_PATTERN_SIZE - 1
 *	- 1 byte '\n'(0x0a) is generated at the end when we use echo command
 *	so total max. length is (MAX_WKFM_PATTERN_SIZE * 3)
 */
#define MAX_WKFM_PATTERN_STR_LEN (MAX_WKFM_PATTERN_SIZE * 3)

#define WKFMCAM_ADDR_NUM 6
#define WKFMCAM_SIZE 24 /* each entry need 6*4 bytes */
enum pattern_type {
	PATTERN_BROADCAST = 0,
	PATTERN_MULTICAST,
	PATTERN_UNICAST,
	PATTERN_VALID,
	PATTERN_INVALID,
};

typedef struct rtl_priv_pattern {
	int len;
	char content[MAX_WKFM_PATTERN_SIZE];
	char mask[MAX_WKFM_SIZE];
} rtl_priv_pattern_t;

#endif /* CONFIG_WOWLAN */

enum Power_Mgnt {
	PS_MODE_ACTIVE	= 0	,
	PS_MODE_MIN			,
	PS_MODE_MAX			,
	PS_MODE_DTIM			,	/* PS_MODE_SELF_DEFINED */
	PS_MODE_VOIP			,
	PS_MODE_UAPSD_WMM	,
	PS_MODE_UAPSD			,
	PS_MODE_IBSS			,
	PS_MODE_WWLAN		,
	PM_Radio_Off			,
	PM_Card_Disable		,
	PS_MODE_NUM,
};

enum lps_level {
	LPS_NORMAL = 0,
	LPS_LCLK,
	LPS_PG,
	LPS_LEVEL_MAX,
};

#ifdef CONFIG_PNO_SUPPORT
#define MAX_PNO_LIST_COUNT 16
#define MAX_SCAN_LIST_COUNT 14	/* 2.4G only */
#define MAX_HIDDEN_AP 8		/* 8 hidden AP */
#endif

/*
	BIT[2:0] = HW state
	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
	BIT[4] = sub-state
*/

#define PS_DPS				BIT(0)
#define PS_LCLK				(PS_DPS)
#define PS_RF_OFF			BIT(1)
#define PS_ALL_ON			BIT(2)
#define PS_ST_ACTIVE		BIT(3)

#define PS_ISR_ENABLE		BIT(4)
#define PS_IMR_ENABLE		BIT(5)
#define PS_ACK				BIT(6)
#define PS_TOGGLE			BIT(7)

#define PS_STATE_MASK		(0x0F)
#define PS_STATE_HW_MASK	(0x07)
#define PS_SEQ_MASK			(0xc0)

#define PS_STATE(x)		(PS_STATE_MASK & (x))
#define PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
#define PS_SEQ(x)		(PS_SEQ_MASK & (x))

#define PS_STATE_S0		(PS_DPS)
#define PS_STATE_S1		(PS_LCLK)
#define PS_STATE_S2		(PS_RF_OFF)
#define PS_STATE_S3		(PS_ALL_ON)
#define PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))


#define PS_IS_RF_ON(x)	((x) & (PS_ALL_ON))
#define PS_IS_ACTIVE(x)	((x) & (PS_ST_ACTIVE))
#define CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))


struct reportpwrstate_parm {
	unsigned char mode;
	unsigned char state; /* the CPWM value */
	unsigned short rsvd;
};


typedef _sema _pwrlock;


__inline static void _init_pwrlock(_pwrlock *plock)
{
	_rtw_init_sema(plock, 1);
}

__inline static void _free_pwrlock(_pwrlock *plock)
{
	_rtw_free_sema(plock);
}


__inline static void _enter_pwrlock(_pwrlock *plock)
{
	_rtw_down_sema(plock);
}


__inline static void _exit_pwrlock(_pwrlock *plock)
{
	_rtw_up_sema(plock);
}

#define LPS_DELAY_MS	1000 /* 1 sec */

#define EXE_PWR_NONE	0x01
#define EXE_PWR_IPS		0x02
#define EXE_PWR_LPS		0x04

/* RF state. */
typedef enum _rt_rf_power_state {
	rf_on,		/* RF is on after RFSleep or RFOff */
	rf_sleep,	/* 802.11 Power Save mode */
	rf_off,		/* HW/SW Radio OFF or Inactive Power Save */
	/* =====Add the new RF state above this line===== */
	rf_max
} rt_rf_power_state;

/* ASPM OSC Control bit, added by Roger, 2013.03.29. */
#define	RT_PCI_ASPM_OSC_IGNORE		0	 /* PCI ASPM ignore OSC control in default */
#define	RT_PCI_ASPM_OSC_ENABLE		BIT0 /* PCI ASPM controlled by OS according to ACPI Spec 5.0 */
#define	RT_PCI_ASPM_OSC_DISABLE		BIT1 /* PCI ASPM controlled by driver or BIOS, i.e., force enable ASPM */


enum _PS_BBRegBackup_ {
	PSBBREG_RF0 = 0,
	PSBBREG_RF1,
	PSBBREG_RF2,
	PSBBREG_AFE0,
	PSBBREG_TOTALCNT
};

enum { /* for ips_mode */
	IPS_NONE = 0,
	IPS_NORMAL,
	IPS_LEVEL_2,
	IPS_NUM
};

/* Design for pwrctrl_priv.ips_deny, 32 bits for 32 reasons at most */
typedef enum _PS_DENY_REASON {
	PS_DENY_DRV_INITIAL = 0,
	PS_DENY_SCAN,
	PS_DENY_JOIN,
	PS_DENY_DISCONNECT,
	PS_DENY_SUSPEND,
	PS_DENY_IOCTL,
	PS_DENY_MGNT_TX,
	PS_DENY_MONITOR_MODE,
	PS_DENY_BEAMFORMING,		/* Beamforming */
	PS_DENY_DRV_REMOVE = 30,
	PS_DENY_OTHERS = 31
} PS_DENY_REASON;

#ifdef CONFIG_PNO_SUPPORT
typedef struct pno_nlo_info {
	u32 fast_scan_period;				/* Fast scan period */
	u8	ssid_num;				/* number of entry */
	u8	hidden_ssid_num;
	u32	slow_scan_period;			/* slow scan period */
	u32	fast_scan_iterations;			/* Fast scan iterations */
	u8	ssid_length[MAX_PNO_LIST_COUNT];	/* SSID Length Array */
	u8	ssid_cipher_info[MAX_PNO_LIST_COUNT];	/* Cipher information for security */
	u8	ssid_channel_info[MAX_PNO_LIST_COUNT];	/* channel information */
	u8	loc_probe_req[MAX_HIDDEN_AP];		/* loc_probeReq */
} pno_nlo_info_t;

typedef struct pno_ssid {
	u32		SSID_len;
	u8		SSID[32];
} pno_ssid_t;

typedef struct pno_ssid_list {
	pno_ssid_t	node[MAX_PNO_LIST_COUNT];
} pno_ssid_list_t;

typedef struct pno_scan_channel_info {
	u8	channel;
	u8	tx_power;
	u8	timeout;
	u8	active;				/* set 1 means active scan, or pasivite scan. */
} pno_scan_channel_info_t;

typedef struct pno_scan_info {
	u8	enableRFE;			/* Enable RFE */
	u8	period_scan_time;		/* exclusive with fast_scan_period and slow_scan_period */
	u8	periodScan;			/* exclusive with fast_scan_period and slow_scan_period */
	u8	orig_80_offset;			/* original channel 80 offset */
	u8	orig_40_offset;			/* original channel 40 offset */
	u8	orig_bw;			/* original bandwidth */
	u8	orig_ch;			/* original channel */
	u8	channel_num;			/* number of channel */
	u64	rfe_type;			/* rfe_type && 0x00000000000000ff */
	pno_scan_channel_info_t ssid_channel_info[MAX_SCAN_LIST_COUNT];
} pno_scan_info_t;
#endif /* CONFIG_PNO_SUPPORT */

#ifdef CONFIG_LPS_POFF
/* Driver context for LPS 32K Close IO Power */
typedef struct lps_poff_info {
	bool	bEn;
	u8	*pStaticFile;
	u8	*pDynamicFile;
	u32	ConfFileOffset;
	u32	tx_bndy_static;
	u32	tx_bndy_dynamic;
	u16	ConfLenForPTK;
	u16	ConfLenForGTK;
	ATOMIC_T bEnterPOFF;
	ATOMIC_T bTxBoundInProgress;
	ATOMIC_T bSetPOFFParm;
} lps_poff_info_t;
#endif /*CONFIG_LPS_POFF*/

struct aoac_report {
	u8 iv[8];
	u8 replay_counter_eapol_key[8];
	u8 group_key[32];
	u8 key_index;
	u8 security_type;
	u8 wow_pattern_idx;
	u8 version_info;
	u8 rekey_ok:1;
	u8 dummy:7;
	u8 reserved[3];
	u8 rxptk_iv[8];
	u8 rxgtk_iv[4][8];
};

struct rsvd_page_cache_t;

struct pwrctrl_priv {
	_pwrlock	lock;
	_pwrlock	check_32k_lock;
	volatile u8 rpwm; /* requested power state for fw */
	volatile u8 cpwm; /* fw current power state. updated when 1. read from HCPWM 2. driver lowers power level */
	volatile u8 tog; /* toggling */
	volatile u8 cpwm_tog; /* toggling */
	u8 rpwm_retry;

	u8	pwr_mode;
	u8	smart_ps;
	u8	bcn_ant_mode;
	u8	dtim;
#ifdef CONFIG_LPS_CHK_BY_TP
	u8	lps_chk_by_tp;
	u16	lps_tx_tp_th;/*Mbps*/
	u16	lps_rx_tp_th;/*Mbps*/
	u16	lps_bi_tp_th;/*Mbps*//*TRX TP*/
	int	lps_chk_cnt_th;
	int	lps_chk_cnt;
	u32	lps_tx_pkts;
	u32	lps_rx_pkts;

#endif

#ifdef CONFIG_WMMPS_STA
	u8 wmm_smart_ps;
#endif /* CONFIG_WMMPS_STA */	

	u32	alives;
	_workitem cpwm_event;
	_workitem dma_event; /*for handle un-synchronized tx dma*/
#ifdef CONFIG_LPS_RPWM_TIMER
	u8 brpwmtimeout;
	_workitem rpwmtimeoutwi;
	_timer pwr_rpwm_timer;
#endif /* CONFIG_LPS_RPWM_TIMER */
	u8	bpower_saving; /* for LPS/IPS */

	u8	b_hw_radio_off;
	u8	reg_rfoff;
	u8	reg_pdnmode; /* powerdown mode */
	u32	rfoff_reason;

	uint	ips_enter_cnts;
	uint	ips_leave_cnts;
	uint	lps_enter_cnts;
	uint	lps_leave_cnts;

	u8	ips_mode;
	u8	ips_org_mode;
	u8	ips_mode_req; /* used to accept the mode setting request, will update to ipsmode later */
	uint bips_processing;
	systime ips_deny_time; /* will deny IPS when system time is smaller than this */
	u8 pre_ips_type;/* 0: default flow, 1: carddisbale flow */

	/* ps_deny: if 0, power save is free to go; otherwise deny all kinds of power save. */
	/* Use PS_DENY_REASON to decide reason. */
	/* Don't access this variable directly without control function, */
	/* and this variable should be protected by lock. */
	u32 ps_deny;

	u8 ps_processing; /* temporarily used to mark whether in rtw_ps_processor */

	u8 fw_psmode_iface_id;
	u8	bLeisurePs;
	u8	LpsIdleCount;
	u8	power_mgnt;
	u8	org_power_mgnt;
	u8	bFwCurrentInPSMode;
	systime	lps_deny_time; /* will deny LPS when system time is smaller than this */
	s32		pnp_current_pwr_state;
	u8		pnp_bstop_trx;

	#ifdef CONFIG_AUTOSUSPEND
	int		ps_flag; /* used by autosuspend */
	u8		bInternalAutoSuspend;
	#endif
	u8		bInSuspend;
#ifdef CONFIG_BT_COEXIST
	u8		bAutoResume;
	u8		autopm_cnt;
#endif
	u8		bSupportRemoteWakeup;
	u8		wowlan_wake_reason;
	u8		wowlan_last_wake_reason;
	u8		wowlan_ap_mode;
	u8		wowlan_mode;
	u8		wowlan_p2p_mode;
	u8		wowlan_pno_enable;
	u8		wowlan_in_resume;

#ifdef CONFIG_GPIO_WAKEUP
	u8		is_high_active;
#endif /* CONFIG_GPIO_WAKEUP */
	u8		hst2dev_high_active;
#ifdef CONFIG_WOWLAN
	bool		default_patterns_en;
#ifdef CONFIG_IPV6
	u8		wowlan_ns_offload_en;
#endif /*CONFIG_IPV6*/
	u8		wowlan_txpause_status;
	u8		wowlan_pattern_idx;
	u64		wowlan_fw_iv;
	struct rtl_priv_pattern	patterns[MAX_WKFM_CAM_NUM];
#ifdef CONFIG_PNO_SUPPORT
	u8		pno_inited;
	pno_nlo_info_t	*pnlo_info;
	pno_scan_info_t	*pscan_info;
	pno_ssid_list_t	*pno_ssid_list;
#endif /* CONFIG_PNO_SUPPORT */
#ifdef CONFIG_WOW_PATTERN_HW_CAM
	_mutex	wowlan_pattern_cam_mutex;
#endif
	u8		wowlan_aoac_rpt_loc;
	struct aoac_report wowlan_aoac_rpt;
	u8		wowlan_power_mgmt;
	u8		wowlan_lps_level;
	#ifdef CONFIG_LPS_1T1R
	u8		wowlan_lps_1t1r;
	#endif
#endif /* CONFIG_WOWLAN */
	_timer	pwr_state_check_timer;
	int		pwr_state_check_interval;
	u8		pwr_state_check_cnts;


	rt_rf_power_state	rf_pwrstate;/* cur power state, only for IPS */
	/* rt_rf_power_state	current_rfpwrstate; */
	rt_rf_power_state	change_rfpwrstate;

	u8		bHWPowerdown; /* power down mode selection. 0:radio off, 1:power down */
	u8		bHWPwrPindetect; /* come from registrypriv.hwpwrp_detect. enable power down function. 0:disable, 1:enable */
	u8		bkeepfwalive;
	u8		brfoffbyhw;
	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];

#ifdef CONFIG_RESUME_IN_WORKQUEUE
	struct workqueue_struct *rtw_workqueue;
	_workitem resume_work;
#endif

#ifdef CONFIG_HAS_EARLYSUSPEND
	struct early_suspend early_suspend;
	u8 do_late_resume;
#endif /* CONFIG_HAS_EARLYSUSPEND */

#ifdef CONFIG_ANDROID_POWER
	android_early_suspend_t early_suspend;
	u8 do_late_resume;
#endif

#ifdef CONFIG_LPS_POFF
	lps_poff_info_t	*plps_poff_info;
#endif
	u8 lps_level_bk;
	u8 lps_level; /*LPS_NORMAL,LPA_CG,LPS_PG*/
#ifdef CONFIG_LPS_1T1R
	u8 lps_1t1r_bk;
	u8 lps_1t1r;
#endif
#ifdef CONFIG_LPS_PG
	struct rsvd_page_cache_t lpspg_info;
#ifdef CONFIG_RTL8822C
	struct rsvd_page_cache_t lpspg_dpk_info;
	struct rsvd_page_cache_t lpspg_iqk_info;
#endif
#endif
	u8 current_lps_hw_port_id;

#ifdef CONFIG_RTW_CFGVEDNOR_LLSTATS
	systime radio_on_start_time;
	systime pwr_saving_start_time;
	u32 pwr_saving_time;
	u32 on_time;
	u32 tx_time;
	u32 rx_time;
#endif /* CONFIG_RTW_CFGVEDNOR_LLSTATS */

#ifdef CONFIG_LPS_ACK
	struct submit_ctx lps_ack_sctx;
	s8 lps_ack_status;
	_mutex lps_ack_mutex;
#endif /* CONFIG_LPS_ACK */
};

#define rtw_get_ips_mode_req(pwrctl) \
	(pwrctl)->ips_mode_req

#define rtw_ips_mode_req(pwrctl, ips_mode) \
	(pwrctl)->ips_mode_req = (ips_mode)

#define RTW_PWR_STATE_CHK_INTERVAL 2000

#define _rtw_set_pwr_state_check_timer(pwrctl, ms) \
	do { \
		/*RTW_INFO("%s _rtw_set_pwr_state_check_timer(%p, %d)\n", __FUNCTION__, (pwrctl), (ms));*/ \
		_set_timer(&(pwrctl)->pwr_state_check_timer, (ms)); \
	} while (0)

#define rtw_set_pwr_state_check_timer(pwrctl) \
	_rtw_set_pwr_state_check_timer((pwrctl), (pwrctl)->pwr_state_check_interval)

extern void rtw_init_pwrctrl_priv(_adapter *adapter);
extern void rtw_free_pwrctrl_priv(_adapter *adapter);

#ifdef CONFIG_LPS_LCLK
s32 rtw_register_task_alive(PADAPTER, u32 task);
void rtw_unregister_task_alive(PADAPTER, u32 task);
extern s32 rtw_register_tx_alive(PADAPTER padapter);
extern void rtw_unregister_tx_alive(PADAPTER padapter);
extern s32 rtw_register_rx_alive(PADAPTER padapter);
extern void rtw_unregister_rx_alive(PADAPTER padapter);
extern s32 rtw_register_cmd_alive(PADAPTER padapter);
extern void rtw_unregister_cmd_alive(PADAPTER padapter);
extern s32 rtw_register_evt_alive(PADAPTER padapter);
extern void rtw_unregister_evt_alive(PADAPTER padapter);
extern void cpwm_int_hdl(PADAPTER padapter, struct reportpwrstate_parm *preportpwrstate);
extern void LPS_Leave_check(PADAPTER padapter);
#endif

extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
extern void LeaveAllPowerSaveModeDirect(PADAPTER Adapter);
#ifdef CONFIG_IPS
void _ips_enter(_adapter *padapter);
void ips_enter(_adapter *padapter);
int _ips_leave(_adapter *padapter);
int ips_leave(_adapter *padapter);
#endif

void rtw_ps_processor(_adapter *padapter);

#ifdef CONFIG_AUTOSUSPEND
int autoresume_enter(_adapter *padapter);
#endif
#ifdef SUPPORT_HW_RFOFF_DETECTED
rt_rf_power_state RfOnOffDetect(PADAPTER pAdapter);
#endif


#ifdef DBG_CHECK_FW_PS_STATE
int rtw_fw_ps_state(PADAPTER padapter);
#endif

#ifdef CONFIG_LPS
extern const char * const LPS_CTRL_PHYDM;
void LPS_Enter(PADAPTER padapter, const char *msg);
void LPS_Leave(PADAPTER padapter, const char *msg);
void rtw_leave_lps_and_chk(_adapter *padapter, u8 ps_mode);
#ifdef CONFIG_CHECK_LEAVE_LPS
#ifdef CONFIG_LPS_CHK_BY_TP
void traffic_check_for_leave_lps_by_tp(PADAPTER padapter, u8 tx, struct sta_info *sta);
#endif
void traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets);
#endif /*CONFIG_CHECK_LEAVE_LPS*/
void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);
void rtw_set_fw_in_ips_mode(PADAPTER padapter, u8 enable);
u8 rtw_set_rpwm(_adapter *padapter, u8 val8);
#ifdef CONFIG_WOWLAN
void rtw_wow_lps_level_decide(_adapter *adapter, u8 wow_en);
#endif /* CONFIG_WOWLAN */
#endif /* CONFIG_LPS */

#ifdef CONFIG_RESUME_IN_WORKQUEUE
void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv);
#endif /* CONFIG_RESUME_IN_WORKQUEUE */

#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv);
bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv);
void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable);
void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv);
void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv);
#else
#define rtw_is_earlysuspend_registered(pwrpriv) _FALSE
#define rtw_is_do_late_resume(pwrpriv) _FALSE
#define rtw_set_do_late_resume(pwrpriv, enable) do {} while (0)
#define rtw_register_early_suspend(pwrpriv) do {} while (0)
#define rtw_unregister_early_suspend(pwrpriv) do {} while (0)
#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */

u8 rtw_interface_ps_func(_adapter *padapter, HAL_INTF_PS_FUNC efunc_id, u8 *val);
void rtw_set_ips_deny(_adapter *padapter, u32 ms);
int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller);
#define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __FUNCTION__)
#define rtw_pwr_wakeup_ex(adapter, ips_deffer_ms) _rtw_pwr_wakeup(adapter, ips_deffer_ms, __FUNCTION__)
int rtw_pm_set_ips(_adapter *padapter, u8 mode);
int rtw_pm_set_lps(_adapter *padapter, u8 mode);
int rtw_pm_set_lps_level(_adapter *padapter, u8 level);
#ifdef CONFIG_LPS_1T1R
int rtw_pm_set_lps_1t1r(_adapter *padapter, u8 en);
#endif
void rtw_set_lps_deny(_adapter *adapter, u32 ms);
#ifdef CONFIG_WOWLAN
int rtw_pm_set_wow_lps(_adapter *padapter, u8 mode);
int rtw_pm_set_wow_lps_level(_adapter *padapter, u8 level);
#ifdef CONFIG_LPS_1T1R
int rtw_pm_set_wow_lps_1t1r(_adapter *padapter, u8 en);
#endif
#endif /* CONFIG_WOWLAN */

void rtw_ps_deny(PADAPTER padapter, PS_DENY_REASON reason);
void rtw_ps_deny_cancel(PADAPTER padapter, PS_DENY_REASON reason);
u32 rtw_ps_deny_get(PADAPTER padapter);

#if defined(CONFIG_WOWLAN)
void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
void rtw_get_sec_iv(PADAPTER padapter, u8 *pcur_dot11txpn, u8 *StaAddr);
bool rtw_wowlan_parser_pattern_cmd(u8 *input, char *pattern,
				int *pattern_len, char *bit_mask);
void rtw_wow_pattern_sw_reset(_adapter *adapter);
u8 rtw_set_default_pattern(_adapter *adapter);
void rtw_wow_pattern_sw_dump(_adapter *adapter);
#endif /* CONFIG_WOWLAN */
void rtw_ssmps_enter(_adapter *adapter, struct sta_info *sta);
void rtw_ssmps_leave(_adapter *adapter, struct sta_info *sta);
#endif /* __RTL871X_PWRCTRL_H_ */
                                                       rtl8822bu/src/include/rtl8192e_led.h                                                                0000644 0001750 0001750 00000002517 14214766567 015720  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_LED_H__
#define __RTL8192E_LED_H__

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8192eu_InitSwLeds(PADAPTER padapter);
	void rtl8192eu_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
	void rtl8192ee_InitSwLeds(PADAPTER padapter);
	void rtl8192ee_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
	void rtl8192es_InitSwLeds(PADAPTER padapter);
	void rtl8192es_DeInitSwLeds(PADAPTER padapter);
#endif

#endif
#endif/*CONFIG_RTW_SW_LED*/
                                                                                                                                                                                 rtl8822bu/src/include/rtl8812a_recv.h                                                               0000644 0001750 0001750 00000017141 14214766567 016105  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_RECV_H__
#define __RTL8812A_RECV_H__

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
				#define MAX_RECVBUF_SZ (rtw_rtkm_get_buff_size()) /*depend rtkm*/
			#else
				#define MAX_RECVBUF_SZ (32768)  /*32k*/
			#endif
			/* #define MAX_RECVBUF_SZ (24576) */ /* 24k */
			/* #define MAX_RECVBUF_SZ (20480) */ /* 20K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			/* #define MAX_RECVBUF_SZ (15360) */ /* 15k < 16k */
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
			#ifdef CONFIG_PLATFORM_NOVATEK_NT72668
				#undef MAX_RECVBUF_SZ
				#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
			#endif /* CONFIG_PLATFORM_NOVATEK_NT72668 */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI)

	#define MAX_RECVBUF_SZ (RX_DMA_BOUNDARY_8821 + 1)

#endif


/* Rx smooth factor */
#define Rx_Smooth_Factor (20)

/* DWORD 0 */
#define SET_RX_STATUS_DESC_PKT_LEN_8812(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_8812(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_8812(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

#define GET_RX_STATUS_DESC_PKT_LEN_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICV_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8812(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_LAST_SEG_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 28, 1)
#define GET_RX_STATUS_DESC_FIRST_SEG_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 29, 1)
#define GET_RX_STATUS_DESC_EOR_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_OWN_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_8812(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_TID_8812(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_AMSDU_8812(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_A1_FIT_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
#define GET_RX_STATUS_DESC_CHKERR_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_IPVER_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_IS_TCPUDP__8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_CHK_VLD_8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_MC_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_8812(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_8812(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#define GET_RX_STATUS_DESC_RX_IS_QOS_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8812(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_RPT_SEL_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_HTC_8812(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_8812(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#ifdef CONFIG_USB_RX_AGGREGATION
#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8812(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
#endif
#define GET_RX_STATUS_DESC_PATTERN_MATCH_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_MATCH_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_MATCH_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

/* DWORD 6 */
#define GET_RX_STATUS_DESC_SPLCP_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 1)
#define GET_RX_STATUS_DESC_LDPC_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 1, 1)
#define GET_RX_STATUS_DESC_STBC_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 2, 1)
#define GET_RX_STATUS_DESC_BW_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 4, 2)

/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

#define GET_RX_STATUS_DESC_BUFF_ADDR_8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
#define GET_RX_STATUS_DESC_BUFF_ADDR64_8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)

#define SET_RX_STATUS_DESC_BUFF_ADDR_8812(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)


#ifdef CONFIG_SDIO_HCI
s32 InitRecvPriv8821AS(PADAPTER padapter);
void FreeRecvPriv8821AS(PADAPTER padapter);
#endif /* CONFIG_SDIO_HCI */

#ifdef CONFIG_USB_HCI
void rtl8812au_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
s32 rtl8812au_init_recv_priv(PADAPTER padapter);
void rtl8812au_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_PCI_HCI
s32 rtl8812ae_init_recv_priv(PADAPTER padapter);
void rtl8812ae_free_recv_priv(PADAPTER padapter);
#endif

void rtl8812_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8812A_RECV_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/sdio_ops_xp.h                                                                 0000644 0001750 0001750 00000003432 14214766567 016125  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _SDIO_OPS_XP_H_
#define _SDIO_OPS_XP_H_

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>
#include <osdep_intf.h>


#ifdef PLATFORM_OS_XP


extern u8 sdbus_cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);


extern void sdbus_cmd52w_xp(struct intf_priv *pintfpriv, u32 addr, u8 val8);


uint sdbus_read_blocks_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);

extern uint sdbus_read_bytes_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);


extern uint sdbus_write_blocks_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf, u8 async);

extern uint sdbus_write_bytes_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
extern u8 sdbus_func1cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
extern void sdbus_func1cmd52w_xp(struct intf_priv *pintfpriv, u32 addr, u8 val8);
extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt, void *pdata);
extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt, void *pdata);
extern void sdio_read_int(_adapter *padapter, u32 addr, u8 sz, void *pdata);

#endif

#endif
                                                                                                                                                                                                                                      rtl8822bu/src/include/pci_hal.h                                                                     0000644 0001750 0001750 00000003115 14214766567 015174  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PCI_HAL_H__
#define __PCI_HAL_H__

#ifdef CONFIG_RTL8188E
	void rtl8188ee_set_hal_ops(_adapter *padapter);
#endif

#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
	void rtl8812ae_set_hal_ops(_adapter *padapter);
#endif

#if defined(CONFIG_RTL8192E)
	void rtl8192ee_set_hal_ops(_adapter *padapter);
#endif

#if defined(CONFIG_RTL8192F)
	void rtl8192fe_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8723B
	void rtl8723be_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8723D
	void rtl8723de_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8814A
	void rtl8814ae_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8822B
	void rtl8822be_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8822C
	void rtl8822ce_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8814B
	void rtl8814be_set_hal_ops(PADAPTER padapter);
#endif

u8 rtw_set_hal_ops(_adapter *padapter);

#endif /* __PCIE_HAL_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/basic_types.h                                                                 0000644 0001750 0001750 00000025003 14214766567 016102  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __BASIC_TYPES_H__
#define __BASIC_TYPES_H__


#define SUCCESS	0
#define FAIL	(-1)

#ifndef TRUE
	#define _TRUE	1
#else
	#define _TRUE	TRUE
#endif

#ifndef FALSE
	#define _FALSE	0
#else
	#define _FALSE	FALSE
#endif

#ifdef PLATFORM_WINDOWS

	typedef signed char s8;
	typedef unsigned char u8;

	typedef signed short s16;
	typedef unsigned short u16;

	typedef signed long s32;
	typedef unsigned long u32;

	typedef unsigned int	uint;
	typedef	signed int		sint;


	typedef signed long long s64;
	typedef unsigned long long u64;

	#ifdef NDIS50_MINIPORT

		#define NDIS_MAJOR_VERSION       5
		#define NDIS_MINOR_VERSION       0

	#endif

	#ifdef NDIS51_MINIPORT

		#define NDIS_MAJOR_VERSION       5
		#define NDIS_MINOR_VERSION       1

	#endif

	typedef NDIS_PROC proc_t;

	typedef LONG atomic_t;

#endif


#ifdef PLATFORM_LINUX
	#include <linux/version.h>
	#include <linux/types.h>
	#include <linux/module.h>
	#include <linux/kernel.h>
	#include <linux/init.h>
	#include <linux/utsname.h>

	typedef	signed int sint;

#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
typedef _Bool bool;

enum {
	false	= 0,
	true	= 1
};
#endif

	typedef void (*proc_t)(void *);

	typedef	__kernel_size_t	SIZE_T;
	typedef	__kernel_ssize_t	SSIZE_T;
	#define FIELD_OFFSET(s, field)	((SSIZE_T)&((s *)(0))->field)

#define NDIS_OID uint
#endif /*PLATFORM_LINUX*/


#ifdef PLATFORM_FREEBSD

	typedef signed char s8;
	typedef unsigned char u8;

	typedef signed short s16;
	typedef unsigned short u16;

	typedef signed int s32;
	typedef unsigned int u32;

	typedef unsigned int	uint;
	typedef	signed int		sint;
	typedef long atomic_t;

	typedef signed long long s64;
	typedef unsigned long long u64;

	typedef u32 dma_addr_t;

	typedef void (*proc_t)(void *);

	typedef unsigned int __kernel_size_t;
	typedef int __kernel_ssize_t;

	typedef	__kernel_size_t	SIZE_T;
	typedef	__kernel_ssize_t	SSIZE_T;
	#define FIELD_OFFSET(s, field)	((SSIZE_T)&((s *)(0))->field)

#endif

#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)

#define SIZE_PTR SIZE_T
#define SSIZE_PTR SSIZE_T

/*
* Continuous bits starting from least significant bit
* Example:
* BIT_LEN_MASK_32(0) => 0x00000000
* BIT_LEN_MASK_32(1) => 0x00000001
* BIT_LEN_MASK_32(2) => 0x00000003
* BIT_LEN_MASK_32(32) => 0xFFFFFFFF
*/
#define BIT_LEN_MASK_32(__BitLen) ((u32)(0xFFFFFFFF >> (32 - (__BitLen))))
#define BIT_LEN_MASK_16(__BitLen) ((u16)(0xFFFF >> (16 - (__BitLen))))
#define BIT_LEN_MASK_8(__BitLen) ((u8)(0xFF >> (8 - (__BitLen))))

/*
* Continuous bits starting from least significant bit
* Example:
* BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
* BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
*/
#define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) ((u32)(BIT_LEN_MASK_32(__BitLen) << (__BitOffset)))
#define BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) ((u16)(BIT_LEN_MASK_16(__BitLen) << (__BitOffset)))
#define BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) ((u8)(BIT_LEN_MASK_8(__BitLen) << (__BitOffset)))

/*
* Convert LE data to host byte order
*/
#define EF1Byte (u8)
#define EF2Byte le16_to_cpu
#define EF4Byte le32_to_cpu

/*
* Read LE data from memory to host byte order
*/
#define ReadLE4Byte(_ptr)	le32_to_cpu(*((u32 *)(_ptr)))
#define ReadLE2Byte(_ptr)	le16_to_cpu(*((u16 *)(_ptr)))
#define ReadLE1Byte(_ptr)	(*((u8 *)(_ptr)))

/*
* Read BE data from memory to host byte order
*/
#define ReadBEE4Byte(_ptr)	be32_to_cpu(*((u32 *)(_ptr)))
#define ReadBE2Byte(_ptr)	be16_to_cpu(*((u16 *)(_ptr)))
#define ReadBE1Byte(_ptr)	(*((u8 *)(_ptr)))

/*
* Write host byte order data to memory in LE order
*/
#define WriteLE4Byte(_ptr, _val)	((*((u32 *)(_ptr))) = cpu_to_le32(_val))
#define WriteLE2Byte(_ptr, _val)	((*((u16 *)(_ptr))) = cpu_to_le16(_val))
#define WriteLE1Byte(_ptr, _val)	((*((u8 *)(_ptr))) = ((u8)(_val)))

/*
* Write host byte order data to memory in BE order
*/
#define WriteBE4Byte(_ptr, _val)	((*((u32 *)(_ptr))) = cpu_to_be32(_val))
#define WriteBE2Byte(_ptr, _val)	((*((u16 *)(_ptr))) = cpu_to_be16(_val))
#define WriteBE1Byte(_ptr, _val)	((*((u8 *)(_ptr))) = ((u8)(_val)))

/*
* Return 4-byte value in host byte ordering from 4-byte pointer in litten-endian system.
*/
#define LE_P4BYTE_TO_HOST_4BYTE(__pStart) (le32_to_cpu(*((u32 *)(__pStart))))
#define LE_P2BYTE_TO_HOST_2BYTE(__pStart) (le16_to_cpu(*((u16 *)(__pStart))))
#define LE_P1BYTE_TO_HOST_1BYTE(__pStart) ((*((u8 *)(__pStart))))

/*
* Return 4-byte value in host byte ordering from 4-byte pointer in big-endian system.
*/
#define BE_P4BYTE_TO_HOST_4BYTE(__pStart) (be32_to_cpu(*((u32 *)(__pStart))))
#define BE_P2BYTE_TO_HOST_2BYTE(__pStart) (be16_to_cpu(*((u16 *)(__pStart))))
#define BE_P1BYTE_TO_HOST_1BYTE(__pStart) ((*((u8 *)(__pStart))))

/*
* Translate subfield (continuous bits in little-endian) of 4-byte value in LE byte to
* 4-byte value in host byte ordering.
*/
#define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
	((LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_32(__BitLen))

#define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
	((LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_16(__BitLen))

#define LE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
	((LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_8(__BitLen))

/*
* Translate subfield (continuous bits in big-endian) of 4-byte value in BE byte to
* 4-byte value in host byte ordering.
*/
#define BE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
	((BE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_32(__BitLen))

#define BE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
	((BE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_16(__BitLen))

#define BE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
	((BE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_8(__BitLen))

/*
* Mask subfield (continuous bits in little-endian) of 4-byte value in LE byte oredering
* and return the result in 4-byte value in host byte ordering.
*/
#define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
	(LE_P4BYTE_TO_HOST_4BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)))

#define LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
	(LE_P2BYTE_TO_HOST_2BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)))

#define LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
	(LE_P1BYTE_TO_HOST_1BYTE(__pStart) & ((u8)(~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen))))

/*
* Mask subfield (continuous bits in big-endian) of 4-byte value in BE byte oredering
* and return the result in 4-byte value in host byte ordering.
*/
#define BE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
	(BE_P4BYTE_TO_HOST_4BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)))

#define BE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
	(BE_P2BYTE_TO_HOST_2BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)))

#define BE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
	(BE_P1BYTE_TO_HOST_1BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen)))

/*
* Set subfield of little-endian 4-byte value to specified value.
*/
#define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
	do { \
		if (__BitOffset == 0 && __BitLen == 32) \
			WriteLE4Byte(__pStart, __Value); \
		else { \
			WriteLE4Byte(__pStart, \
				LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
				| \
				((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
			); \
		} \
	} while (0)

#define SET_BITS_TO_LE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
	do { \
		if (__BitOffset == 0 && __BitLen == 16) \
			WriteLE2Byte(__pStart, __Value); \
		else { \
			WriteLE2Byte(__pStart, \
				LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
				| \
				((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
			); \
		} \
	} while (0)

#define SET_BITS_TO_LE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
	do { \
		if (__BitOffset == 0 && __BitLen == 8) \
			WriteLE1Byte(__pStart, __Value); \
		else { \
			WriteLE1Byte(__pStart, \
				LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
				| \
				((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
			); \
		} \
	} while (0)

/*
* Set subfield of big-endian 4-byte value to specified value.
*/
#define SET_BITS_TO_BE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
	do { \
		if (__BitOffset == 0 && __BitLen == 32) \
			WriteBE4Byte(__pStart, __Value); \
		else { \
			WriteBE4Byte(__pStart, \
				BE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
				| \
				((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
			); \
		} \
	} while (0)

#define SET_BITS_TO_BE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
	do { \
		if (__BitOffset == 0 && __BitLen == 16) \
			WriteBE2Byte(__pStart, __Value); \
		else { \
			WriteBE2Byte(__pStart, \
				BE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
				| \
				((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
			); \
		} \
	} while (0)

#define SET_BITS_TO_BE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
	do { \
		if (__BitOffset == 0 && __BitLen == 8) \
			WriteBE1Byte(__pStart, __Value); \
		else { \
			WriteBE1Byte(__pStart, \
				BE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
				| \
				((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
			); \
		} \
	} while (0)

/* Get the N-bytes aligment offset from the current length */
#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))

typedef unsigned char	BOOLEAN, *PBOOLEAN, boolean;

#define TEST_FLAG(__Flag, __testFlag)		(((__Flag) & (__testFlag)) != 0)
#define SET_FLAG(__Flag, __setFlag)			((__Flag) |= __setFlag)
#define CLEAR_FLAG(__Flag, __clearFlag)		((__Flag) &= ~(__clearFlag))
#define CLEAR_FLAGS(__Flag)					((__Flag) = 0)
#define TEST_FLAGS(__Flag, __testFlags)		(((__Flag) & (__testFlags)) == (__testFlags))

#endif /* __BASIC_TYPES_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             rtl8822bu/src/include/rtl8822cu_hal.h                                                               0000755 0001750 0001750 00000003451 14214766567 016104  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822CU_HAL_H_
#define _RTL8822CU_HAL_H_

#ifdef CONFIG_USB_HCI
	#include <drv_types.h>		/* PADAPTER */

	#ifdef CONFIG_USB_HCI
		#ifdef USB_PACKET_OFFSET_SZ
			#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
		#else
			#define PACKET_OFFSET_SZ (8)
		#endif
		#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
	#endif

	/* undefine MAX_RECVBUF_SZ from rtl8822c_hal.h  */
	#ifdef MAX_RECVBUF_SZ
		#undef MAX_RECVBUF_SZ
	#endif

	/* recv_buffer must be large than usb agg size */
	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			#ifdef CONFIG_PLATFORM_NOVATEK_NT72668
				#define MAX_RECVBUF_SZ (15360) /* 15k */
				#elif defined(CONFIG_PLATFORM_HISILICON)
				/* use 16k to workaround for HISILICON platform */
				#define MAX_RECVBUF_SZ (16384)
			#else
				#define MAX_RECVBUF_SZ (32768)
			#endif
		#else
			#define MAX_RECVBUF_SZ (4000)
		#endif
	#endif /* !MAX_RECVBUF_SZ */

	/* rtl8822cu_ops.c */
	void rtl8822cu_set_hal_ops(PADAPTER padapter);
	void rtl8822cu_set_hw_type(struct dvobj_priv *pdvobj);

	/* rtl8822cu_io.c */
	void rtl8822cu_set_intf_ops(struct _io_ops *pops);

#endif /* CONFIG_USB_HCI */


#endif /* _RTL8822CU_HAL_H_ */
                                                                                                                                                                                                                       rtl8822bu/src/include/sdio_ops_linux.h                                                              0000644 0001750 0001750 00000005051 14214766567 016634  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __SDIO_OPS_LINUX_H__
#define __SDIO_OPS_LINUX_H__

#ifndef RTW_HALMAC
u8 sd_f0_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
void sd_f0_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err);

s32 _sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
s32 _sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
s32 sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
s32 sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);

u8 _sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
u8 sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
u16 sd_read16(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
u32 _sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
u32 sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
void sd_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err);
void sd_write16(struct intf_hdl *pintfhdl, u32 addr, u16 v, s32 *err);
void _sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err);
void sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err);
#endif /* RTW_HALMAC */

bool rtw_is_sdio30(_adapter *adapter);

/* The unit of return value is Hz */
static inline u32 rtw_sdio_get_clock(struct dvobj_priv *d)
{
	return d->intf_data.clock;
}

s32 _sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
s32 sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
s32 _sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
s32 sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);

void rtw_sdio_set_irq_thd(struct dvobj_priv *dvobj, _thread_hdl_ thd_hdl);
int __must_check rtw_sdio_raw_read(struct dvobj_priv *d, unsigned int addr,
				void *buf, size_t len, bool fixed);
int __must_check rtw_sdio_raw_write(struct dvobj_priv *d, unsigned int addr,
				void *buf, size_t len, bool fixed);

#endif /* __SDIO_OPS_LINUX_H__ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtw_mcc.h                                                                     0000644 0001750 0001750 00000022075 14214766567 015241  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifdef CONFIG_MCC_MODE

#ifndef _RTW_MCC_H_
#define _RTW_MCC_H_

#include <drv_types.h> /* PADAPTER */

#define MCC_STATUS_PROCESS_MCC_START_SETTING BIT0
#define MCC_STATUS_PROCESS_MCC_STOP_SETTING BIT1
#define MCC_STATUS_NEED_MCC BIT2
#define MCC_STATUS_DOING_MCC BIT3


#define MCC_SWCH_FW_EARLY_TIME 10 /* ms */
#define MCC_EXPIRE_TIME 50 /* ms */
#define MCC_TOLERANCE_TIME 2 /* 2*2 = 4s */
#define MCC_UPDATE_PARAMETER_THRESHOLD 5 /* ms */

#define MCC_ROLE_STA_GC_MGMT_QUEUE_MACID 0
#define MCC_ROLE_SOFTAP_GO_MGMT_QUEUE_MACID 1

/* Lower for stop, Higher for start */
#define MCC_SETCMD_STATUS_STOP_DISCONNECT 0x0
#define MCC_SETCMD_STATUS_STOP_SCAN_START 0x1
#define MCC_SETCMD_STATUS_START_CONNECT 0x80
#define MCC_SETCMD_STATUS_START_SCAN_DONE 0x81

/*
* depenad platform or customer requirement(TP unit:Mbps),
* must be provided by PM or sales or product document
* too large value means not to limit tx bytes (current for ap mode)
* NOTE: following values ref from test results
*/
#define MCC_AP_BW20_TARGET_TX_TP (300)
#define MCC_AP_BW40_TARGET_TX_TP (300)
#define MCC_AP_BW80_TARGET_TX_TP (300)
#define MCC_STA_BW20_TARGET_TX_TP (35)
#define MCC_STA_BW40_TARGET_TX_TP (70)
#define MCC_STA_BW80_TARGET_TX_TP (140)
#define MCC_SINGLE_TX_CRITERIA 5 /* Mbps */

#define MAX_MCC_NUM 2
#define DBG_MCC_REG_NUM 4
#define DBG_MCC_RF_REG_NUM 1

#define MCC_STOP(adapter) (adapter->mcc_adapterpriv.mcc_tx_stop)
#define MCC_EN(adapter) (adapter_to_dvobj(adapter)->mcc_objpriv.en_mcc)
#define adapter_to_mccobjpriv(adapter) (&(adapter_to_dvobj(adapter)->mcc_objpriv))
#define SET_MCC_EN_FLAG(adapter, flag)\
	do { \
		adapter_to_dvobj(adapter)->mcc_objpriv.en_mcc = (flag); \
	} while (0)
#define SET_MCC_DURATION(adapter, val)\
	do { \
		adapter_to_dvobj(adapter)->mcc_objpriv.duration = (val); \
	} while (0)
#define SET_MCC_RUNTIME_DURATION(adapter, flag)\
	do { \
		adapter_to_dvobj(adapter)->mcc_objpriv.enable_runtime_duration = (flag); \
	} while (0)

#define SET_MCC_PHYDM_OFFLOAD(adapter, flag)\
	do { \
		adapter_to_dvobj(adapter)->mcc_objpriv.mcc_phydm_offload = (flag); \
	} while (0)

#ifdef CONFIG_MCC_PHYDM_OFFLOAD
enum mcc_cfg_phydm_ops {
	MCC_CFG_PHYDM_OFFLOAD = 0,
	MCC_CFG_PHYDM_RF_CH,
	MCC_CFG_PHYDM_ADD_CLIENT,
	MCC_CFG_PHYDM_REMOVE_CLIENT,
	MCC_CFG_PHYDM_START,
	MCC_CFG_PHYDM_STOP,
	MCC_CFG_PHYDM_DUMP,
	MCC_CFG_PHYDM_MAX,
};
#endif

enum rtw_mcc_cmd_id {
	MCC_CMD_WK_CID = 0,
	MCC_SET_DURATION_WK_CID,
	MCC_GET_DBG_REG_WK_CID,
	#ifdef CONFIG_MCC_PHYDM_OFFLOAD
	MCC_SET_PHYDM_OFFLOAD_WK_CID,
	#endif
};

/* Represent Channel Tx Null setting */
enum mcc_channel_tx_null {
	MCC_ENABLE_TX_NULL = 0,
	MCC_DISABLE_TX_NULL = 1,
};

/* Represent C2H Report setting */
enum mcc_c2h_report {
	MCC_C2H_REPORT_DISABLE = 0,
	MCC_C2H_REPORT_FAIL_STATUS = 1,
	MCC_C2H_REPORT_ALL_STATUS = 2,
};

/* Represent Channel Scan */
enum mcc_channel_scan {
	MCC_CHIDX = 0,
	MCC_SCANCH_RSVD_LOC = 1,
};

/* Represent FW status report of channel switch */
enum mcc_status_rpt {
	MCC_RPT_SUCCESS = 0,
	MCC_RPT_TXNULL_FAIL = 1,
	MCC_RPT_STOPMCC = 2,
	MCC_RPT_READY = 3,
	MCC_RPT_SWICH_CHANNEL_NOTIFY = 7,
	MCC_RPT_UPDATE_NOA_START_TIME = 8,
	MCC_RPT_TSF = 9,
	MCC_RPT_MAX,
};

enum mcc_role {
	MCC_ROLE_STA = 0,
	MCC_ROLE_AP = 1,
	MCC_ROLE_GC = 2,
	MCC_ROLE_GO = 3,
	MCC_ROLE_MAX,
};

struct mcc_iqk_backup {
	u16 TX_X;
	u16 TX_Y;
	u16 RX_X;
	u16 RX_Y;
};

enum mcc_duration_setting {
	MCC_DURATION_MAPPING = 0,
	MCC_DURATION_DIRECET = 1,
};

enum mcc_sched_mode {
	MCC_FAIR_SCHEDULE = 0,
	MCC_FAVOR_STA = 1,
	MCC_FAVOR_P2P = 2,
};

/*  mcc data for adapter */
struct mcc_adapter_priv {
	u8 order;		/* FW document, softap/AP must be 0 */
	enum mcc_role role;			/* MCC role(AP,STA,GO,GC) */
	u8 mcc_duration; /* channel stay period, UNIT:1TU */

	/* flow control */
	u8 mcc_tx_stop;				/* check if tp stop or not */
	u8 mcc_tp_limit;				/* check if tp limit or not */
	u32 mcc_target_tx_bytes_to_port;		/* customer require  */
	u32 mcc_tx_bytes_to_port;	/* already tx to tx fifo (write port) */

	/* data from kernel to check if enqueue data or netif stop queue */
	u32 mcc_tp;
	u64 mcc_tx_bytes_from_kernel;
	u64 mcc_last_tx_bytes_from_kernel;

	/* Backup IQK value for MCC */
	struct mcc_iqk_backup mcc_iqk_arr[MAX_RF_PATH];

	/* mgmt queue macid to avoid RA issue */
	u8 mgmt_queue_macid;

	/* set macid bitmap to let fw know which macid should be tx pause */
	/* all interface share total 16 macid */
	u16 mcc_macid_bitmap;

	/* use for NoA start time (unit: mircoseconds) */
	u32 noa_start_time;

	u8 p2p_go_noa_ie[MAX_P2P_IE_LEN];
	u32 p2p_go_noa_ie_len;
	u64 tsf;
#ifdef CONFIG_TDLS
	u8 backup_tdls_en;
#endif /* CONFIG_TDLS */

	u8 null_early;
	u8 null_rty_num;
};

struct mcc_obj_priv {
	u8 en_mcc; /* enable MCC or not */
	u8 duration; /* store duration(%) from registry, for primary adapter */
	u8 interval;
	u8 start_time;
	u8 mcc_c2h_status;
	u8 cur_mcc_success_cnt; /* used for check mcc switch channel success */
	u8 prev_mcc_success_cnt; /* used for check mcc switch channel success */
	u8 mcc_tolerance_time; /* used for detect mcc switch channel success */
	u8 mcc_loc_rsvd_paga[MAX_MCC_NUM];  /* mcc rsvd page */
	u8 mcc_status; /* mcc status stop or start .... */
	u8 policy_index;
	u8 mcc_stop_threshold;
	u8 current_order;
	u8 last_tsfdiff;
	systime mcc_launch_time; /* mcc launch time, used for starting detect mcc switch channel success */
	_mutex mcc_mutex;
	_lock mcc_lock;
	PADAPTER iface[MAX_MCC_NUM]; /* by order, use for mcc parameter cmd */
	struct submit_ctx mcc_sctx;
	struct submit_ctx mcc_tsf_req_sctx;
	_mutex mcc_tsf_req_mutex;
	u8 mcc_tsf_req_sctx_order; /* record current order for mcc_tsf_req_sctx */
#ifdef CONFIG_MCC_MODE_V2
	u8 mcc_iqk_value_rsvd_page[3];
#endif /* CONFIG_MCC_MODE_V2 */
	u8 mcc_pwr_idx_rsvd_page[MAX_MCC_NUM];
	u8 enable_runtime_duration;
	/* for LG */
	u8 mchan_sched_mode;

	_mutex mcc_dbg_reg_mutex;
	u32 dbg_reg[DBG_MCC_REG_NUM];
	u32 dbg_reg_val[DBG_MCC_REG_NUM];
	u32 dbg_rf_reg[DBG_MCC_RF_REG_NUM];
	u32 dbg_rf_reg_val[DBG_MCC_RF_REG_NUM][MAX_RF_PATH];
	u8 mcc_phydm_offload;
};

/* backup IQK val */
void rtw_hal_mcc_restore_iqk_val(PADAPTER padapter);

/* check mcc status */
u8 rtw_hal_check_mcc_status(PADAPTER padapter, u8 mcc_status);

/* set mcc status */
void rtw_hal_set_mcc_status(PADAPTER padapter, u8 mcc_status);

/* clear mcc status */
void rtw_hal_clear_mcc_status(PADAPTER padapter, u8 mcc_status);

/* dl mcc rsvd page */
u8 rtw_hal_dl_mcc_fw_rsvd_page(_adapter *adapter, u8 *pframe, u16 *index
	, u8 tx_desc, u32 page_size, u8 *total_page_num, RSVDPAGE_LOC *rsvd_page_loc, u8 *page_num);

/* handle C2H */
void rtw_hal_mcc_c2h_handler(PADAPTER padapter, u8 buflen, u8 *tmpBuf);

/* switch channel successfully or not */
void rtw_hal_mcc_sw_status_check(PADAPTER padapter);

/* change some scan flags under site survey */
u8 rtw_hal_mcc_change_scan_flag(PADAPTER padapter, u8 *ch, u8 *bw, u8 *offset);

/* record data kernel TX to driver to check MCC concurrent TX  */
void rtw_hal_mcc_calc_tx_bytes_from_kernel(PADAPTER padapter, u32 len);

/* record data to port to let driver do flow ctrl  */
void rtw_hal_mcc_calc_tx_bytes_to_port(PADAPTER padapter, u32 len);

/* check stop write port or not  */
u8 rtw_hal_mcc_stop_tx_bytes_to_port(PADAPTER padapter);

u8 rtw_hal_set_mcc_setting_scan_start(PADAPTER padapter);

u8 rtw_hal_set_mcc_setting_scan_complete(PADAPTER padapter);

u8 rtw_hal_set_mcc_setting_start_bss_network(PADAPTER padapter, u8 chbw_grouped);

u8 rtw_hal_set_mcc_setting_disconnect(PADAPTER padapter);

u8 rtw_hal_set_mcc_setting_join_done_chk_ch(PADAPTER padapter);

u8 rtw_hal_set_mcc_setting_chk_start_clnt_join(PADAPTER padapter, u8 *ch, u8 *bw, u8 *offset, u8 chbw_allow);

void rtw_hal_dump_mcc_info(void *sel, struct dvobj_priv *dvobj);

void update_mcc_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);

u8 rtw_hal_mcc_link_status_chk(_adapter *padapter, const char *msg);

void rtw_hal_mcc_issue_null_data(_adapter *padapter, u8 chbw_allow, u8 ps_mode);

u8 *rtw_hal_mcc_append_go_p2p_ie(PADAPTER padapter, u8 *pframe, u32 *len);

void rtw_hal_dump_mcc_policy_table(void *sel);

void rtw_hal_mcc_update_macid_bitmap(PADAPTER padapter, int mac_id, u8 add);

void rtw_hal_mcc_process_noa(PADAPTER padapter);

void rtw_hal_mcc_parameter_init(PADAPTER padapter);

u8 rtw_mcc_cmd_hdl(PADAPTER adapter, u8 type, const u8 *val);

u8 rtw_set_mcc_duration_cmd(_adapter *adapter, u8 type, u8 val);
#ifdef CONFIG_MCC_PHYDM_OFFLOAD
u8 rtw_set_mcc_phydm_offload_enable_cmd(PADAPTER adapter, u8 enable, u8 enqueue);
#endif /* CONFIG_MCC_PHYDM_OFFLOAD */
#endif /* _RTW_MCC_H_ */
#endif /* CONFIG_MCC_MODE */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/rtl8821ce_hal.h                                                               0000755 0001750 0001750 00000001511 14214766567 016056  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8821CE_HAL_H_
#define _RTL8821CE_HAL_H_

#include <drv_types.h>		/* PADAPTER */

/* rtl8821ce_ops.c */
void rtl8821ce_set_hal_ops(PADAPTER);

#endif /* _RTL8821CE_HAL_H_ */
                                                                                                                                                                                       rtl8822bu/src/include/rtl8814a_rf.h                                                                 0000644 0001750 0001750 00000001563 14214766567 015560  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_RF_H__
#define __RTL8814A_RF_H__

void
PHY_RF6052SetBandwidth8814A(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);


int
PHY_RF6052_Config_8814A(
		PADAPTER	Adapter);

#endif/* __RTL8188E_RF_H__ */
                                                                                                                                             rtl8822bu/src/include/usb_hal.h                                                                     0000644 0001750 0001750 00000003614 14214766567 015216  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __USB_HAL_H__
#define __USB_HAL_H__

int usb_init_recv_priv(_adapter *padapter, u16 ini_in_buf_sz);
void usb_free_recv_priv(_adapter *padapter, u16 ini_in_buf_sz);
#ifdef CONFIG_FW_C2H_REG
void usb_c2h_hisr_hdl(_adapter *adapter, u8 *buf);
#endif

u8 rtw_set_hal_ops(_adapter *padapter);

#ifdef CONFIG_RTL8188E
void rtl8188eu_set_hal_ops(_adapter *padapter);
#endif

#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
void rtl8812au_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8192E
void rtl8192eu_set_hal_ops(_adapter *padapter);
#endif


#ifdef CONFIG_RTL8723B
void rtl8723bu_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8814A
void rtl8814au_set_hal_ops(_adapter *padapter);
#endif /* CONFIG_RTL8814A */

#ifdef CONFIG_RTL8188F
void rtl8188fu_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8188GTV
void rtl8188gtvu_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8703B
void rtl8703bu_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8723D
void rtl8723du_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8710B
void rtl8710bu_set_hal_ops(_adapter *padapter);
#endif

#ifdef CONFIG_RTL8192F
void rtl8192fu_set_hal_ops(_adapter *padapter);
#endif /* CONFIG_RTL8192F */

#endif /* __USB_HAL_H__ */
                                                                                                                    rtl8822bu/src/include/rtl8723b_xmit.h                                                               0000755 0001750 0001750 00000047043 14214766567 016140  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_XMIT_H__
#define __RTL8723B_XMIT_H__


#define MAX_TID (15)


#ifndef __INC_HAL8723BDESC_H
	#define __INC_HAL8723BDESC_H

	#define RX_STATUS_DESC_SIZE_8723B		24
	#define RX_DRV_INFO_SIZE_UNIT_8723B 8


	/* DWORD 0 */
	#define SET_RX_STATUS_DESC_PKT_LEN_8723B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
	#define SET_RX_STATUS_DESC_EOR_8723B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
	#define SET_RX_STATUS_DESC_OWN_8723B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

	#define GET_RX_STATUS_DESC_PKT_LEN_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
	#define GET_RX_STATUS_DESC_CRC32_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
	#define GET_RX_STATUS_DESC_ICV_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
	#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
	#define GET_RX_STATUS_DESC_SECURITY_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
	#define GET_RX_STATUS_DESC_QOS_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
	#define GET_RX_STATUS_DESC_SHIFT_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
	#define GET_RX_STATUS_DESC_PHY_STATUS_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
	#define GET_RX_STATUS_DESC_SWDEC_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
	#define GET_RX_STATUS_DESC_LAST_SEG_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 28, 1)
	#define GET_RX_STATUS_DESC_FIRST_SEG_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 29, 1)
	#define GET_RX_STATUS_DESC_EOR_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
	#define GET_RX_STATUS_DESC_OWN_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

	/* DWORD 1 */
	#define GET_RX_STATUS_DESC_MACID_8723B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
	#define GET_RX_STATUS_DESC_TID_8723B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
	#define GET_RX_STATUS_DESC_AMSDU_8723B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
	#define GET_RX_STATUS_DESC_RXID_MATCH_8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
	#define GET_RX_STATUS_DESC_PAGGR_8723B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
	#define GET_RX_STATUS_DESC_A1_FIT_8723B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
	#define GET_RX_STATUS_DESC_CHKERR_8723B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
	#define GET_RX_STATUS_DESC_IPVER_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
	#define GET_RX_STATUS_DESC_IS_TCPUDP__8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
	#define GET_RX_STATUS_DESC_CHK_VLD_8723B(__pRxDesc)	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
	#define GET_RX_STATUS_DESC_PAM_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
	#define GET_RX_STATUS_DESC_PWR_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
	#define GET_RX_STATUS_DESC_MORE_DATA_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
	#define GET_RX_STATUS_DESC_MORE_FRAG_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
	#define GET_RX_STATUS_DESC_TYPE_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
	#define GET_RX_STATUS_DESC_MC_8723B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
	#define GET_RX_STATUS_DESC_BC_8723B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

	/* DWORD 2 */
	#define GET_RX_STATUS_DESC_SEQ_8723B(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
	#define GET_RX_STATUS_DESC_FRAG_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
	#define GET_RX_STATUS_DESC_RX_IS_QOS_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
	#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8723B(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
	#define GET_RX_STATUS_DESC_RPT_SEL_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)

	/* DWORD 3 */
	#define GET_RX_STATUS_DESC_RX_RATE_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
	#define GET_RX_STATUS_DESC_HTC_8723B(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
	#define GET_RX_STATUS_DESC_EOSP_8723B(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
	#define GET_RX_STATUS_DESC_BSSID_FIT_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
	#ifdef CONFIG_USB_RX_AGGREGATION
		#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8723B(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
	#endif
	#define GET_RX_STATUS_DESC_PATTERN_MATCH_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
	#define GET_RX_STATUS_DESC_UNICAST_MATCH_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
	#define GET_RX_STATUS_DESC_MAGIC_MATCH_8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

	/* DWORD 6 */
	#define GET_RX_STATUS_DESC_SPLCP_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 1)
	#define GET_RX_STATUS_DESC_LDPC_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 1, 1)
	#define GET_RX_STATUS_DESC_STBC_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 2, 1)
	#define GET_RX_STATUS_DESC_BW_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 4, 2)

	/* DWORD 5 */
	#define GET_RX_STATUS_DESC_TSFL_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

	#define GET_RX_STATUS_DESC_BUFF_ADDR_8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
	#define GET_RX_STATUS_DESC_BUFF_ADDR64_8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)

	#define SET_RX_STATUS_DESC_BUFF_ADDR_8723B(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)


	/* Dword 0 */
	#define GET_TX_DESC_OWN_8723B(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

	#define SET_TX_DESC_PKT_SIZE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
	#define SET_TX_DESC_OFFSET_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
	#define SET_TX_DESC_BMC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
	#define SET_TX_DESC_HTC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
	#define SET_TX_DESC_LAST_SEG_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
	#define SET_TX_DESC_FIRST_SEG_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
	#define SET_TX_DESC_LINIP_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
	#define SET_TX_DESC_NO_ACM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
	#define SET_TX_DESC_GF_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
	#define SET_TX_DESC_OWN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

	/* Dword 1 */
	#define SET_TX_DESC_MACID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
	#define SET_TX_DESC_QUEUE_SEL_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
	#define SET_TX_DESC_RDG_NAV_EXT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
	#define SET_TX_DESC_LSIG_TXOP_EN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
	#define SET_TX_DESC_PIFS_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
	#define SET_TX_DESC_RATE_ID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
	#define SET_TX_DESC_EN_DESC_ID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
	#define SET_TX_DESC_SEC_TYPE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
	#define SET_TX_DESC_PKT_OFFSET_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)


	/* Dword 2 */
	#define SET_TX_DESC_PAID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
	#define SET_TX_DESC_CCA_RTS_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
	#define SET_TX_DESC_AGG_ENABLE_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
	#define SET_TX_DESC_RDG_ENABLE_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
	#define SET_TX_DESC_AGG_BREAK_8723B(__pTxDesc, __Value)				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
	#define SET_TX_DESC_MORE_FRAG_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
	#define SET_TX_DESC_RAW_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
	#define SET_TX_DESC_SPE_RPT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
	#define SET_TX_DESC_AMPDU_DENSITY_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
	#define SET_TX_DESC_BT_INT_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
	#define SET_TX_DESC_GID_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)


	/* Dword 3 */
	#define SET_TX_DESC_WHEADER_LEN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
	#define SET_TX_DESC_CHK_EN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
	#define SET_TX_DESC_EARLY_MODE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
	#define SET_TX_DESC_HWSEQ_SEL_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
	#define SET_TX_DESC_USE_RATE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
	#define SET_TX_DESC_DISABLE_RTS_FB_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
	#define SET_TX_DESC_DISABLE_FB_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
	#define SET_TX_DESC_CTS2SELF_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
	#define SET_TX_DESC_RTS_ENABLE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
	#define SET_TX_DESC_HW_RTS_ENABLE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
	#define SET_TX_DESC_NAV_USE_HDR_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
	#define SET_TX_DESC_USE_MAX_LEN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
	#define SET_TX_DESC_MAX_AGG_NUM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
	#define SET_TX_DESC_NDPA_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
	#define SET_TX_DESC_AMPDU_MAX_TIME_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

	/* Dword 4 */
	#define SET_TX_DESC_TX_RATE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
	#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
	#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
	#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
	#define SET_TX_DESC_DATA_RETRY_LIMIT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
	#define SET_TX_DESC_RTS_RATE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)


	/* Dword 5 */
	#define SET_TX_DESC_DATA_SC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
	#define SET_TX_DESC_DATA_SHORT_8723B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
	#define SET_TX_DESC_DATA_BW_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
	#define SET_TX_DESC_DATA_LDPC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
	#define SET_TX_DESC_DATA_STBC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
	#define SET_TX_DESC_CTROL_STBC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
	#define SET_TX_DESC_RTS_SHORT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
	#define SET_TX_DESC_RTS_SC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)


	/* Dword 6 */
	#define SET_TX_DESC_SW_DEFINE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
	#define SET_TX_DESC_MBSSID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
	#define SET_TX_DESC_ANTSEL_A_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
	#define SET_TX_DESC_ANTSEL_B_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
	#define SET_TX_DESC_ANTSEL_C_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
	#define SET_TX_DESC_ANTSEL_D_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)

	/* Dword 7 */
	#ifdef CONFIG_PCI_HCI
		#define SET_TX_DESC_TX_BUFFER_SIZE_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
	#endif
	#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
		#define SET_TX_DESC_TX_DESC_CHECKSUM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
	#endif
	#define SET_TX_DESC_USB_TXAGG_NUM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
	#ifdef CONFIG_SDIO_HCI
		#define SET_TX_DESC_SDIO_TXSEQ_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
	#endif

	/* Dword 8 */
	#define SET_TX_DESC_HWSEQ_EN_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)

	/* Dword 9 */
	#define SET_TX_DESC_SEQ_8723B(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)

	/* Dword 10 */
	#define SET_TX_DESC_TX_BUFFER_ADDRESS_8723B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
	#define GET_TX_DESC_TX_BUFFER_ADDRESS_8723B(__pTxDesc)	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)

	/* Dword 11 */
	#define SET_TX_DESC_NEXT_DESC_ADDRESS_8723B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)


	#define SET_EARLYMODE_PKTNUM_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
	#define SET_EARLYMODE_LEN0_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
	#define SET_EARLYMODE_LEN1_1_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
	#define SET_EARLYMODE_LEN1_2_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
	#define SET_EARLYMODE_LEN2_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
	#define SET_EARLYMODE_LEN3_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)

#endif
/* -----------------------------------------------------------
 *
 *	Rate
 *
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC8723B_RATE1M				0x00
#define DESC8723B_RATE2M				0x01
#define DESC8723B_RATE5_5M				0x02
#define DESC8723B_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC8723B_RATE6M				0x04
#define DESC8723B_RATE9M				0x05
#define DESC8723B_RATE12M				0x06
#define DESC8723B_RATE18M				0x07
#define DESC8723B_RATE24M				0x08
#define DESC8723B_RATE36M				0x09
#define DESC8723B_RATE48M				0x0a
#define DESC8723B_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC8723B_RATEMCS0				0x0c
#define DESC8723B_RATEMCS1				0x0d
#define DESC8723B_RATEMCS2				0x0e
#define DESC8723B_RATEMCS3				0x0f
#define DESC8723B_RATEMCS4				0x10
#define DESC8723B_RATEMCS5				0x11
#define DESC8723B_RATEMCS6				0x12
#define DESC8723B_RATEMCS7				0x13
#define DESC8723B_RATEMCS8				0x14
#define DESC8723B_RATEMCS9				0x15
#define DESC8723B_RATEMCS10		0x16
#define DESC8723B_RATEMCS11		0x17
#define DESC8723B_RATEMCS12		0x18
#define DESC8723B_RATEMCS13		0x19
#define DESC8723B_RATEMCS14		0x1a
#define DESC8723B_RATEMCS15		0x1b
#define DESC8723B_RATEVHTSS1MCS0		0x2c
#define DESC8723B_RATEVHTSS1MCS1		0x2d
#define DESC8723B_RATEVHTSS1MCS2		0x2e
#define DESC8723B_RATEVHTSS1MCS3		0x2f
#define DESC8723B_RATEVHTSS1MCS4		0x30
#define DESC8723B_RATEVHTSS1MCS5		0x31
#define DESC8723B_RATEVHTSS1MCS6		0x32
#define DESC8723B_RATEVHTSS1MCS7		0x33
#define DESC8723B_RATEVHTSS1MCS8		0x34
#define DESC8723B_RATEVHTSS1MCS9		0x35
#define DESC8723B_RATEVHTSS2MCS0		0x36
#define DESC8723B_RATEVHTSS2MCS1		0x37
#define DESC8723B_RATEVHTSS2MCS2		0x38
#define DESC8723B_RATEVHTSS2MCS3		0x39
#define DESC8723B_RATEVHTSS2MCS4		0x3a
#define DESC8723B_RATEVHTSS2MCS5		0x3b
#define DESC8723B_RATEVHTSS2MCS6		0x3c
#define DESC8723B_RATEVHTSS2MCS7		0x3d
#define DESC8723B_RATEVHTSS2MCS8		0x3e
#define DESC8723B_RATEVHTSS2MCS9		0x3f


#define	RX_HAL_IS_CCK_RATE_8723B(pDesc)\
	(GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE1M || \
	 GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE2M || \
	 GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE5_5M || \
	 GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE11M)


void rtl8723b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
void rtl8723b_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8723bs_init_xmit_priv(PADAPTER padapter);
	void rtl8723bs_free_xmit_priv(PADAPTER padapter);
	s32 rtl8723bs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723bs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8723bs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723bs_xmit_buf_handler(PADAPTER padapter);
	thread_return rtl8723bs_xmit_thread(thread_context context);
	#define hal_xmit_handler rtl8723bs_xmit_buf_handler
#endif

#ifdef CONFIG_USB_HCI
	s32 rtl8723bu_xmit_buf_handler(PADAPTER padapter);
	#define hal_xmit_handler rtl8723bu_xmit_buf_handler


	s32 rtl8723bu_init_xmit_priv(PADAPTER padapter);
	void rtl8723bu_free_xmit_priv(PADAPTER padapter);
	s32 rtl8723bu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723bu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	 rtl8723bu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	/* s32 rtl8812au_xmit_buf_handler(PADAPTER padapter); */
	void rtl8723bu_xmit_tasklet(void *priv);
	s32 rtl8723bu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
	void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8723be_init_xmit_priv(PADAPTER padapter);
	void rtl8723be_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8723be_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	void	rtl8723be_xmitframe_resume(_adapter *padapter);
	s32 rtl8723be_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723be_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8723be_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8723be_xmit_tasklet(void *priv);
#endif

u8	BWMapping_8723B(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_8723B(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             rtl8822bu/src/include/ethernet.h                                                                    0000644 0001750 0001750 00000003037 14214766567 015416  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*! \file */
#ifndef __INC_ETHERNET_H
#define __INC_ETHERNET_H

#define ETHERNET_ADDRESS_LENGTH				6		/* !< Ethernet Address Length */
#define ETHERNET_HEADER_SIZE				14		/* !< Ethernet Header Length */
#define LLC_HEADER_SIZE						6		/* !< LLC Header Length */
#define TYPE_LENGTH_FIELD_SIZE				2		/* !< Type/Length Size */
#define MINIMUM_ETHERNET_PACKET_SIZE		60		/* !< Minimum Ethernet Packet Size */
#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	/* !< Maximum Ethernet Packet Size */

#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01) != 0)		/* !< Is Multicast Address? */
#define RT_ETH_IS_BROADCAST(_pAddr)	(\
		((u8 *)(_pAddr))[0] == 0xff	&&		\
		((u8 *)(_pAddr))[1] == 0xff	&&		\
		((u8 *)(_pAddr))[2] == 0xff	&&		\
		((u8 *)(_pAddr))[3] == 0xff	&&		\
		((u8 *)(_pAddr))[4] == 0xff	&&		\
		((u8 *)(_pAddr))[5] == 0xff)	/* !< Is Broadcast Address? */


#endif /*  #ifndef __INC_ETHERNET_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/sdio_osintf.h                                                                 0000644 0001750 0001750 00000001315 14214766567 016115  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __SDIO_OSINTF_H__
#define __SDIO_OSINTF_H__


#endif
                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/gspi_hal.h                                                                    0000644 0001750 0001750 00000001727 14214766567 015372  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __GSPI_HAL_H__
#define __GSPI_HAL_H__


void spi_int_dpc(PADAPTER padapter, u32 sdio_hisr);
u8 rtw_set_hal_ops(_adapter *padapter);

#ifdef CONFIG_RTL8188E
	void rtl8188es_set_hal_ops(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8723B
	void rtl8723bs_set_hal_ops(PADAPTER padapter);
#endif

#endif /* __GSPI_HAL_H__ */
                                         rtl8822bu/src/include/rtl8188e_cmd.h                                                                0000644 0001750 0001750 00000012024 14214766567 015716  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_CMD_H__
#define __RTL8188E_CMD_H__

#if 0
enum cmd_msg_element_id {
	NONE_CMDMSG_EID,
	AP_OFFLOAD_EID = 0,
	SET_PWRMODE_EID = 1,
	JOINBSS_RPT_EID = 2,
	RSVD_PAGE_EID = 3,
	RSSI_4_EID = 4,
	RSSI_SETTING_EID = 5,
	MACID_CONFIG_EID = 6,
	MACID_PS_MODE_EID = 7,
	P2P_PS_OFFLOAD_EID = 8,
	SELECTIVE_SUSPEND_ROF_CMD = 9,
	P2P_PS_CTW_CMD_EID = 32,
	MAX_CMDMSG_EID
};
#else
typedef enum _RTL8188E_H2C_CMD_ID {
	/* Class Common */
	H2C_COM_RSVD_PAGE			= 0x00,
	H2C_COM_MEDIA_STATUS_RPT	= 0x01,
	H2C_COM_SCAN					= 0x02,
	H2C_COM_KEEP_ALIVE			= 0x03,
	H2C_COM_DISCNT_DECISION		= 0x04,
#ifndef CONFIG_WOWLAN
	H2C_COM_WWLAN				= 0x05,
#endif
	H2C_COM_INIT_OFFLOAD			= 0x06,
	H2C_COM_REMOTE_WAKE_CTL	= 0x07,
	H2C_COM_AP_OFFLOAD			= 0x08,
	H2C_COM_BCN_RSVD_PAGE		= 0x09,
	H2C_COM_PROB_RSP_RSVD_PAGE	= 0x0A,

	/* Class PS */
	H2C_PS_PWR_MODE				= 0x20,
	H2C_PS_TUNE_PARA				= 0x21,
	H2C_PS_TUNE_PARA_2			= 0x22,
	H2C_PS_LPS_PARA				= 0x23,
	H2C_PS_P2P_OFFLOAD			= 0x24,

	/* Class DM */
	H2C_DM_MACID_CFG				= 0x40,
	H2C_DM_TXBF					= 0x41,
	H2C_RSSI_REPORT				= 0x42,
	/* Class BT */
	H2C_BT_COEX_MASK				= 0x60,
	H2C_BT_COEX_GPIO_MODE		= 0x61,
	H2C_BT_DAC_SWING_VAL			= 0x62,
	H2C_BT_PSD_RST				= 0x63,

	/* Class Remote WakeUp */
#ifdef CONFIG_WOWLAN
	H2C_COM_WWLAN				= 0x80,
	H2C_COM_REMOTE_WAKE_CTRL	= 0x81,
	H2C_COM_AOAC_GLOBAL_INFO	= 0x82,
	H2C_COM_AOAC_RSVD_PAGE		= 0x83,
#endif

	/* Class */
	/* H2C_RESET_TSF				=0xc0, */
} RTL8188E_H2C_CMD_ID;

#endif


struct cmd_msg_parm {
	u8 eid; /* element id */
	u8 sz; /* sz */
	u8 buf[6];
};

enum {
	PWRS
};

typedef struct _SETPWRMODE_PARM {
	u8 Mode;/* 0:Active,1:LPS,2:WMMPS */
	/* u8 RLBM:4; */ /* 0:Min,1:Max,2: User define */
	u8 SmartPS_RLBM;/* LPS=0:PS_Poll,1:PS_Poll,2:NullData,WMM=0:PS_Poll,1:NullData */
	u8 AwakeInterval;	/* unit: beacon interval */
	u8 bAllQueueUAPSD;
	u8 PwrState;/* AllON(0x0c),RFON(0x04),RFOFF(0x00) */
} SETPWRMODE_PARM, *PSETPWRMODE_PARM;

struct H2C_SS_RFOFF_PARAM {
	u8 ROFOn; /* 1: on, 0:off */
	u16 gpio_period; /* unit: 1024 us */
} __attribute__((packed));


typedef struct JOINBSSRPT_PARM_88E {
	u8 OpMode;	/* RT_MEDIA_STATUS */
#ifdef CONFIG_WOWLAN
	u8 MacID;       /* MACID */
#endif /* CONFIG_WOWLAN */
} JOINBSSRPT_PARM_88E, *PJOINBSSRPT_PARM_88E;

#if 0
/* move to hal_com_h2c.h */
typedef struct _RSVDPAGE_LOC_88E {
	u8 LocProbeRsp;
	u8 LocPsPoll;
	u8 LocNullData;
	u8 LocQosNull;
	u8 LocBTQosNull;
#ifdef CONFIG_WOWLAN
	u8 LocRemoteCtrlInfo;
	u8 LocArpRsp;
	u8 LocNbrAdv;
	u8 LocGTKRsp;
	u8 LocGTKInfo;
	u8 LocProbeReq;
	u8 LocNetList;
#endif /* CONFIG_WOWLAN	 */
} RSVDPAGE_LOC_88E, *PRSVDPAGE_LOC_88E;
#endif

/* host message to firmware cmd */
void rtl8188e_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8188e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
s32 FillH2CCmd_88E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
/* u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period); */
u8 GetTxBufferRsvdPageNum8188E(_adapter *padapter, bool wowlan);


#ifdef CONFIG_P2P
	void rtl8188e_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

/* #define H2C_8188E_RSVDPAGE_LOC_LEN      5 */
/* #define H2C_8188E_AOAC_RSVDPAGE_LOC_LEN 7 */

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 *   */
#if 0
	/* move to hal_com_h2c.h
	* _RSVDPAGE_LOC_CMD_0x00 */
	#define SET_8188E_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)     SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
	#define SET_8188E_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)            SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
	#define SET_8188E_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)     SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
	#define SET_8188E_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)     SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
	/*  AOAC_RSVDPAGE_LOC_0x83 */
	#define SET_8188E_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(__pH2CCmd, __Value)        SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
	#define SET_8188E_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(__pH2CCmd, __Value)                  SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#endif
#endif/* __RTL8188E_CMD_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8703b_recv.h                                                               0000644 0001750 0001750 00000004757 14214766567 016116  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_RECV_H__
#define __RTL8703B_RECV_H__

#define RECV_BLK_SZ 512
#define RECV_BLK_CNT 16
#define RECV_BLK_TH RECV_BLK_CNT

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
			#else
				#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
			#endif
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)

	#define MAX_RECVBUF_SZ (RX_DMA_SIZE_8703B - RX_DMA_RESERVED_SIZE_8703B)

#endif

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

#ifdef CONFIG_SDIO_HCI
	#ifndef CONFIG_SDIO_RX_COPY
		#undef MAX_RECVBUF_SZ
		#define MAX_RECVBUF_SZ	(RX_DMA_SIZE_8703B - RX_DMA_RESERVED_SIZE_8703B)
	#endif /* !CONFIG_SDIO_RX_COPY */
#endif /* CONFIG_SDIO_HCI */

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8703bs_init_recv_priv(PADAPTER padapter);
	void rtl8703bs_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_USB_HCI
	int rtl8703bu_init_recv_priv(_adapter *padapter);
	void rtl8703bu_free_recv_priv(_adapter *padapter);
	void rtl8703bu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8703be_init_recv_priv(PADAPTER padapter);
	void rtl8703be_free_recv_priv(PADAPTER padapter);
#endif

void rtl8703b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8703B_RECV_H__ */
                 rtl8822bu/src/include/Hal8710BPhyReg.h                                                              0000644 0001750 0001750 00000106034 14214766567 016046  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8710BPHYREG_H__
#define __INC_HAL8710BPHYREG_H__

#define		rSYM_WLBT_PAPE_SEL		0x64
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other definition for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC // RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rTxAGC_B_Rate18_06				0x830
#define		rTxAGC_B_Rate54_24				0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00			0x83c

#define		rTxAGC_B_Mcs07_Mcs04			0x848
#define		rTxAGC_B_Mcs11_Mcs08			0x84c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rTxAGC_B_Mcs15_Mcs12			0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now // RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define	rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC // RF BW Setting?? */
#define	rFPGA1_TxBlock				0x904	/* Useless now */
#define	rFPGA1_DebugSelect			0x908	/* Useless now */
#define	rFPGA1_TxInfo				0x90c	/* Useless now // Status report?? */
#define	rDPDT_control				0x92c
#define	rfe_ctrl_anta_src				0x930
#define	rS0S1_PathSwitch			0x948
#define	rBBrx_DFIR					0x954

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now // Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now // Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport			0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA						0xb00
#define rPdp_AntA_4						0xb04
#define rPdp_AntA_8						0xb08
#define rPdp_AntA_C						0xb0c
#define rPdp_AntA_10					0xb10
#define rPdp_AntA_14					0xb14
#define rPdp_AntA_18					0xb18
#define rPdp_AntA_1C					0xb1c
#define rPdp_AntA_20					0xb20
#define rPdp_AntA_24					0xb24

#define rConfig_Pmpd_AntA				0xb28
#define rConfig_ram64x16				0xb2c

#define rBndA							0xb30
#define rHssiPar						0xb34

#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c

#define rPdp_AntB						0xb70
#define rPdp_AntB_4						0xb74
#define rPdp_AntB_8						0xb78
#define rPdp_AntB_C						0xb7c
#define rPdp_AntB_10					0xb80
#define rPdp_AntB_14					0xb84
#define rPdp_AntB_18					0xb88
#define rPdp_AntB_1C					0xb8c
#define rPdp_AntB_20					0xb90
#define rPdp_AntB_24					0xb94

#define rConfig_Pmpd_AntB				0xb98

#define rBndB							0xba0

#define rAPK							0xbd8
#define rPm_Rx0_AntA					0xbdc
#define rPm_Rx1_AntA					0xbe0
#define rPm_Rx2_AntA					0xbe4
#define rPm_Rx3_AntA					0xbe8
#define rPm_Rx0_AntB					0xbec
#define rPm_Rx1_AntB					0xbf0
#define rPm_Rx2_AntB					0xbf4
#define rPm_Rx3_AntB					0xbf8
/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imbalance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	// DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00			0xe10
#define		rTxAGC_A_Mcs07_Mcs04			0xe14
#define		rTxAGC_A_Mcs11_Mcs08			0xe18
#define		rTxAGC_A_Mcs15_Mcs12			0xe1c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/* */

#define		RF_IQADJ_G1				0x01	/* */
#define		RF_IQADJ_G2				0x02	/* */
#define		RF_BS_PA_APSET_G1_G4		0x03
#define		RF_BS_PA_APSET_G5_G8		0x04
#define		RF_POW_TRSW				0x05	/* */

#define		RF_GAIN_RX					0x06	/* */
#define		RF_GAIN_TX					0x07	/* */

#define		RF_TXM_IDAC				0x08	/* */
#define		RF_IPA_G					0x09	/* */
#define		RF_TXBIAS_G				0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A					0x0C	/* */
#define		RF_TXBIAS_A				0x0D
#define		RF_BS_PA_APSET_G9_G11	0x0E
#define		RF_BS_IQGEN				0x0F	/* */

#define		RF_MODE1					0x10	/* */
#define		RF_MODE2					0x11	/* */

#define		RF_RX_AGC_HP				0x12	/* */
#define		RF_TX_AGC					0x13	/* */
#define		RF_BIAS						0x14	/* */
#define		RF_IPA						0x15	/* */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/* */
#define		RF_MODE_AG				0x18	/* */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/* */

#define		RF_RX_G1					0x1A	/* */
#define		RF_RX_G2					0x1B	/* */

#define		RF_RX_BB2					0x1C	/* */
#define		RF_RX_BB1					0x1D	/* */

#define		RF_RCK1					0x1E	/* */
#define		RF_RCK2					0x1F	/* */

#define		RF_TX_G1					0x20	/* */
#define		RF_TX_G2					0x21	/* */
#define		RF_TX_G3					0x22	/* */

#define		RF_TX_BB1					0x23	/* */

#define		RF_T_METER					0x24	/* */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define	RF_TX_BIAS_A				0x35
#define	RF_TX_BIAS_D				0x36
#define	RF_LOBF_9					0x38
#define	RF_RXRF_A3					0x3C	/*	 */
#define	RF_TRSW					0x3F

#define	RF_TXRF_A2					0x41
#define	RF_T_METER_88E				0x42
#define	RF_TXPA_G4					0x46
#define	RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define	RF_WE_LUT					0xEF
#define	RF_S0S1					0xB0

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
#define		RF_TX_GAIN_OFFSET_8710B(_val) (abs((_val)) | (((_val) > 0) ? BIT(4) : 0))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bAntennaSelect		0x0300

#define		bXBTxAGC                 0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                 0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI              0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength         0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV              0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW               0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           0x1000	/* Useless now */
#define		bCCKSampleRate            0x8       /* 0: 44MHz, 1:88MHz     */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode				0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble			0x8	/* Useless */
#define		bCCKAntDiversity		0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate				0x3000
#define		bCCKDCCancel			0x0800
#define		bCCKISICancel			0x0400
#define		bCCKMatchFilter			0x0200
#define		bCCKEqualizer			0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart			0x300000
#define		bCCKCCACount			0x080000
#define		bCCKcs_lim				0x070000
#define		bCCKBistMode			0x80000000
#define		bCCKCCAMask			0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset			0xf0
#define		bCCKRxDCOffset			0xf
#define		bCCKCCAMode			0xc000
#define		bCCKFalseCS_lim			0x3f00
#define		bCCKCS_ratio			0xc00000
#define		bCCKCorgBit_sel			0x300000
#define		bCCKPD_lim				0x0f0000
#define		bCCKNewCCA			0x80000000
#define		bCCKRxHPofIG			0x8000
#define		bCCKRxIG				0x7f00
#define		bCCKLNAPolarity			0x800000
#define		bCCKRx1stGain			0x7f0000
#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC			0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType	0x0300
#define		bCCKRxDAGCEn			0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0				0x3f0000
#define		bCCKTxC1				0x3f000000
#define		bCCKTxC2				0x3f
#define		bCCKTxC3				0x3f00
#define		bCCKTxC4				0x3f0000
#define		bCCKTxC5				0x3f000000
#define		bCCKTxC6				0x3f
#define		bCCKTxC7				0x3f00
#define		bCCKDebugPort			0xff0000
#define		bCCKDACDebug			0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI				0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel			0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF				0x3	/* Useless */
#define		bShift_L					0xc0
#define		bGI_TH					0xc
#define		bRxPathA				0x1
#define		bRxPathB				0x2
#define		bRxPathC				0x4
#define		bRxPathD				0x8
#define		bTxPathA				0x1
#define		bTxPathB				0x2
#define		bTxPathC				0x4
#define		bTxPathD				0x8
#define		bTRSSIFreq				0x200
#define		bADCBackoff				0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode			0x1800000
#define		bRxDCNFType			0xe000000
#define		bRXIQImb_A				0x3ff
#define		bRXIQImb_B				0xfc00
#define		bRXIQImb_C				0x3f0000
#define		bRXIQImb_D				0xffc00000
#define		bDC_dc_Notch			0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH					0xf
#define		bPD_TH_Opt2			0xc000
#define		bPWED_TH				0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option				0x1000
#define		bMF_Win_L				0xe000
#define		bBW_Search_L			0x30000
#define		bwin_enh_L				0xc0000
#define		bBW_TH					0x700000
#define		bED_TH2				0x3800000
#define		bBW_option				0x4000000
#define		bRatio_TH				0x18000000
#define		bWindow_L				0xe0000000
#define		bSBD_Option				0x1
#define		bFrame_TH				0x1c
#define		bFS_Option				0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune				0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2			0x7
#define		bFrame_GI2_TH			0x38
#define		bGI2_Sync_en			0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum				0x1
#define		bCFOAcc				0x2
#define		bCFOStartOffset			0xc
#define		bCFOLookBack			0x70
#define		bCFOSumWeight			0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A				0x3ff
#define		bTXIQImb_B				0xfc00
#define		bTXIQImb_C				0x3f0000
#define		bTXIQImb_D				0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode			0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption			0x20000
#define		bCCADropThres			0xfff00000
#define		bEDCCA_H				0xf
#define		bEDCCA_L				0xf0
#define		bLambda_ED			0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn				0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En			0x10000000
#define		bRxQuickAGCEn			0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift				0x7f
#define		bTRSW_Tri_Only			0x80
#define		bPowerThres			0x300
#define		bRxAGCEn				0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin				0x4
#define		bRxHP_Ini				0x7
#define		bRxHP_TRLNA			0x70
#define		bRxHP_RSSI				0x700
#define		bRxHP_BBP1				0x7000
#define		bRxHP_BBP2				0x70000
#define		bRxHP_BBP3				0x700000
#define		bRSSI_H					0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW			0x7
#define		bRxSettle_LNA			0x38
#define		bRxSettle_RSSI			0x1c0
#define		bRxSettle_BBP			0xe00
#define		bRxSettle_RxHP			0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI			0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final				0x7000000
#define		bRxHTSettle_BBP			0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn			0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin			0x80000
#define		bRxHTAGCEn				0x100000
#define		bRxHTDAGCEn			0x200000
#define		bRxHTRxHP_BBP			0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH			0x3
#define		bRxPWRatioEn			0x4
#define		bRxMFHold				0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH			0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L			0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH				0xc0000000
#define		bDFSCnt0				0xff
#define		bDFSCnt1				0xff00
#define		bDFSFlag				0xf0000
#define		bMFWeightSum			0x300000
#define		bMinIdxTH				0x7f000000
#define		bDAFormat				0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain				0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn				0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss					0x20
#define		bCFOAntSumD			0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet			0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn				0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re		0x3f
#define		bSigTone_Im		0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail	0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail	0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync	0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength	12   /* total */
#define		bShortCFOFLength	11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength	11
#define		bLongCFOFLength	11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW			0x1
#define		bRxSC				0x6
#define		bRx_HT				0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg	0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain				0x3f
#define		bTableSel			0x40
#define		bTRSW				0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st				0xff
#define		bCSI2nd				0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd			0xff000000
#define		bSIGEVM			0xff
#define		bPWDB				0xff00
#define		bSGIEN				0x10000

#define		bSFactorQAM1		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode			0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType		0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO			0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC					0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF		0x20000
#define		bComChCFO			0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz			0x100000
#define		bUChCfg				0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C	0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW		0x18
#define		bRTL8256_RxLPFBW		0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW		0xc	/* Useless */
#define		bRTL8258_RxLPFBW		0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0				0x1	/* Useless */
#define		bByte1				0x2
#define		bByte2				0x4
#define		bByte3				0x8
#define		bWord0				0x3
#define		bWord1				0xc
#define		bDWord				0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1			0xff00
#define		bMaskByte2			0xff0000
#define		bMaskByte3			0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord			0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes		0xffffff00
#define		bMask12Bits			0xfff
#define		bMaskH4Bits			0xf0000000
#define		bMaskOFDM_D		0xffc00000
#define		bMaskCCK			0x3f3f3f3f


#define		bEnable			0x1	/* Useless */
#define		bDisable		0x0

#define		LeftAntenna		0x0	/* Useless */
#define		RightAntenna	0x1

#define		tCheckTxStatus		500   /* 500ms // Useless */
#define		tUpdateRxCounter	100   /* 100ms */

#define		rateCCK		0	/* Useless */
#define		rateOFDM	1
#define		rateHT		2

/* define Register-End */
#define		bPMAC_End			0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtl8710b_hal.h                                                                0000644 0001750 0001750 00000021556 14214766567 015715  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_HAL_H__
#define __RTL8710B_HAL_H__

#include "hal_data.h"

#include "rtl8710b_spec.h"
#include "rtl8710b_rf.h"
#include "rtl8710b_dm.h"
#include "rtl8710b_recv.h"
#include "rtl8710b_xmit.h"
#include "rtl8710b_cmd.h"
#include "rtl8710b_led.h"
#include "Hal8710BPwrSeq.h"
#include "Hal8710BPhyReg.h"
#include "Hal8710BPhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8710b_sreset.h"
#endif
#ifdef CONFIG_LPS_POFF
	#include "rtl8710b_lps_poff.h"
#endif

#define FW_8710B_SIZE		0x8000
#define FW_8710B_START_ADDRESS	0x1000
#define FW_8710B_END_ADDRESS	0x1FFF /* 0x5FFF */

typedef struct _RT_FIRMWARE {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_8710B_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8710B, *PRT_FIRMWARE_8710B;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
typedef struct _RT_8710B_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u16		Subversion;	/* FW Subversion, default 0x00 */

	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u16		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8710B_FIRMWARE_HDR, *PRT_8710B_FIRMWARE_HDR;

#define DRIVER_EARLY_INT_TIME_8710B		0x05
#define BCN_DMA_ATIME_INT_TIME_8710B		0x02

/* for 8710B
 * TX 32K, RX 16K, Page size 128B for TX, 8B for RX */
#define PAGE_SIZE_TX_8710B			128
#define PAGE_SIZE_RX_8710B			8

#define TX_DMA_SIZE_8710B			0x8000	/* 32K(TX) */
#define RX_DMA_SIZE_8710B			0x4000	/* 16K(RX) */

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8710B	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8710B	0x80	/* 128B, reserved for tx report */
#endif
#define RX_DMA_BOUNDARY_8710B\
	(RX_DMA_SIZE_8710B - RX_DMA_RESERVED_SIZE_8710B - 1)


/* Note: We will divide number of page equally for each queue other than public queue! */

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8710B
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/
#define BCNQ_PAGE_NUM_8710B	(MAX_BEACON_LEN/PAGE_SIZE_TX_8710B + 6) /*0x08*/


/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt 1, PNO: 6
 * NS offload: 2 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8710B	0x0b
#else
	#define WOWLAN_PAGE_NUM_8710B	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
	#undef WOWLAN_PAGE_NUM_8710B
	#define WOWLAN_PAGE_NUM_8710B	0x15
#endif

#ifdef CONFIG_AP_WOWLAN
	#define AP_WOWLAN_PAGE_NUM_8710B	0x02
#endif

#define TX_TOTAL_PAGE_NUMBER_8710B\
	(0xFF - BCNQ_PAGE_NUM_8710B -WOWLAN_PAGE_NUM_8710B)
#define TX_PAGE_BOUNDARY_8710B		(TX_TOTAL_PAGE_NUMBER_8710B + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8710B	TX_TOTAL_PAGE_NUMBER_8710B
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8710B\
	(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8710B + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8710B */
#define NORMAL_PAGE_NUM_HPQ_8710B		0x0C
#define NORMAL_PAGE_NUM_LPQ_8710B		0x02
#define NORMAL_PAGE_NUM_NPQ_8710B		0x02
#define NORMAL_PAGE_NUM_EPQ_8710B		0x04

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8710B		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8710B		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8710B		0x20
#define WMM_NORMAL_PAGE_NUM_EPQ_8710B		0x00


#include "HalVerDef.h"
#include "hal_com.h"

#define EFUSE_OOB_PROTECT_BYTES (96 + 1)

#define HAL_EFUSE_MEMORY
#define HWSET_MAX_SIZE_8710B                512
#define EFUSE_REAL_CONTENT_LEN_8710B        512
#define EFUSE_MAP_LEN_8710B                 512
#define EFUSE_MAX_SECTION_8710B             64

/* For some inferiority IC purpose. added by Roger, 2009.09.02.*/
#define EFUSE_IC_ID_OFFSET			506
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8710B)

#define EFUSE_ACCESS_ON	0x69
#define EFUSE_ACCESS_OFF	0x00

#define   PACKAGE_QFN32_S           0
#define   PACKAGE_QFN48M_S        1    //definiton 8188GU Dongle Package, Efuse Physical Address 0xF8 = 0xFE
#define   PACKAGE_QFN48_S  	       2
#define   PACKAGE_QFN64_S  	       3     
#define   PACKAGE_QFN32_U  		4    
#define   PACKAGE_QFN48M_U  	5   //definiton 8188GU Dongle Package, Efuse Physical Address 0xF8 = 0xEE
#define   PACKAGE_QFN48_U  		6 
#define   PACKAGE_QFN68_U  		7

typedef enum _PACKAGE_TYPE_E
{
    PACKAGE_DEFAULT,
    PACKAGE_QFN68,
    PACKAGE_TFBGA90,
    PACKAGE_TFBGA80,
    PACKAGE_TFBGA79
}PACKAGE_TYPE_E;

#define INCLUDE_MULTI_FUNC_GPS(_Adapter) \
	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

#ifdef CONFIG_FILE_FWIMG
	extern char *rtw_fw_file_path;
	extern char *rtw_fw_wow_file_path;
	#ifdef CONFIG_MP_INCLUDED
		extern char *rtw_fw_mp_bt_file_path;
	#endif /* CONFIG_MP_INCLUDED */
#endif /* CONFIG_FILE_FWIMG */

/* rtl8710b_hal_init.c */
s32 rtl8710b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void rtl8710b_FirmwareSelfReset(PADAPTER padapter);
void rtl8710b_InitializeFirmwareVars(PADAPTER padapter);

void rtl8710b_InitAntenna_Selection(PADAPTER padapter);
void rtl8710b_DeinitAntenna_Selection(PADAPTER padapter);
void rtl8710b_CheckAntenna_Selection(PADAPTER padapter);
void rtl8710b_init_default_value(PADAPTER padapter);


u32 indirect_read32_8710b(PADAPTER padapter, u32 regaddr);
void indirect_write32_8710b(PADAPTER padapter, u32 regaddr, u32 data);
u32 hal_query_syson_reg_8710b(PADAPTER padapter, u32 regaddr, u32 bitmask);
void hal_set_syson_reg_8710b(PADAPTER padapter, u32 regaddr, u32 bitmask, u32 data);
#define HAL_SetSYSOnReg hal_set_syson_reg_8710b


/* EFuse */
u8 GetEEPROMSize8710B(PADAPTER padapter);

#if 0
void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
void Hal_EfuseParseTxPowerInfo_8710B(PADAPTER padapter,
				     u8 *PROMContent, BOOLEAN AutoLoadFail);
void Hal_EfuseParseEEPROMVer_8710B(PADAPTER padapter,
				   u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParsePackageType_8710B(PADAPTER pAdapter,
				     u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseChnlPlan_8710B(PADAPTER padapter,
				  u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID_8710B(PADAPTER padapter,
				    u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseAntennaDiversity_8710B(PADAPTER padapter,
		u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseXtal_8710B(PADAPTER pAdapter,
			      u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseThermalMeter_8710B(PADAPTER padapter,
				      u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseBoardType_8710B(PADAPTER Adapter,
				   u8	*PROMContent, BOOLEAN AutoloadFail);
#endif

void rtl8710b_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8710b(_adapter *adapter);
u8 SetHwReg8710B(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8710B(PADAPTER padapter, u8 variable, u8 *val);
u8 SetHalDefVar8710B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8710B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);

/* register */
void rtl8710b_InitBeaconParameters(PADAPTER padapter);
void rtl8710b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
void _8051Reset8710(PADAPTER padapter);

void rtl8710b_start_thread(_adapter *padapter);
void rtl8710b_stop_thread(_adapter *padapter);

#ifdef CONFIG_GPIO_WAKEUP
	void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
#endif

void CCX_FwC2HTxRpt_8710b(PADAPTER padapter, u8 *pdata, u8 len);

u8 MRateToHwRate8710B(u8 rate);
u8 HwRateToMRate8710B(u8 rate);

#ifdef CONFIG_USB_HCI
	void rtl8710b_cal_txdesc_chksum(struct tx_desc *ptxdesc);
#endif


#endif
                                                                                                                                                  rtl8822bu/src/include/ieee80211.h                                                                   0000644 0001750 0001750 00000167671 14214766567 015122  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __IEEE80211_H
#define __IEEE80211_H

#define MGMT_QUEUE_NUM 5

#define ETH_ALEN	6
#define ETH_TYPE_LEN		2
#define PAYLOAD_TYPE_LEN	1

#define NET80211_TU_TO_US	1024		/* unit:us */
#define DEFAULT_BCN_INTERVAL 100 /* 100 ms */

#ifdef CONFIG_AP_MODE

#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)

/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
enum {
	RTL871X_HOSTAPD_FLUSH = 1,
	RTL871X_HOSTAPD_ADD_STA = 2,
	RTL871X_HOSTAPD_REMOVE_STA = 3,
	RTL871X_HOSTAPD_GET_INFO_STA = 4,
	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
	RTL871X_HOSTAPD_GET_WPAIE_STA = 5,
	RTL871X_SET_ENCRYPTION = 6,
	RTL871X_GET_ENCRYPTION = 7,
	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
	RTL871X_HOSTAPD_GET_RID = 9,
	RTL871X_HOSTAPD_SET_RID = 10,
	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
	RTL871X_HOSTAPD_MLME = 13,
	RTL871X_HOSTAPD_SCAN_REQ = 14,
	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
	RTL871X_HOSTAPD_SET_BEACON = 16,
	RTL871X_HOSTAPD_SET_WPS_BEACON = 17,
	RTL871X_HOSTAPD_SET_WPS_PROBE_RESP = 18,
	RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP = 19,
	RTL871X_HOSTAPD_SET_HIDDEN_SSID = 20,
	RTL871X_HOSTAPD_SET_MACADDR_ACL = 21,
	RTL871X_HOSTAPD_ACL_ADD_STA = 22,
	RTL871X_HOSTAPD_ACL_REMOVE_STA = 23,
};

/* STA flags */
#define WLAN_STA_AUTH BIT(0)
#define WLAN_STA_ASSOC BIT(1)
#define WLAN_STA_PS BIT(2)
#define WLAN_STA_TIM BIT(3)
#define WLAN_STA_PERM BIT(4)
#define WLAN_STA_AUTHORIZED BIT(5)
#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
#define WLAN_STA_SHORT_PREAMBLE BIT(7)
#define WLAN_STA_PREAUTH BIT(8)
#define WLAN_STA_WME BIT(9)
#define WLAN_STA_MFP BIT(10)
#define WLAN_STA_HT BIT(11)
#define WLAN_STA_WPS BIT(12)
#define WLAN_STA_MAYBE_WPS BIT(13)
#define WLAN_STA_VHT BIT(14)
#define WLAN_STA_NONERP BIT(31)

#endif

#define IEEE_CMD_SET_WPA_PARAM			1
#define IEEE_CMD_SET_WPA_IE				2
#define IEEE_CMD_SET_ENCRYPTION			3
#define IEEE_CMD_MLME						4

#define IEEE_PARAM_WPA_ENABLED				1
#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
#define IEEE_PARAM_DROP_UNENCRYPTED			3
#define IEEE_PARAM_PRIVACY_INVOKED			4
#define IEEE_PARAM_AUTH_ALGS					5
#define IEEE_PARAM_IEEE_802_1X				6
#define IEEE_PARAM_WPAX_SELECT				7

#define AUTH_ALG_OPEN_SYSTEM			0x1
#define AUTH_ALG_SHARED_KEY			0x2
#define AUTH_ALG_LEAP				0x00000004

#define IEEE_MLME_STA_DEAUTH				1
#define IEEE_MLME_STA_DISASSOC			2

#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7


#define	IEEE_CRYPT_ALG_NAME_LEN			16

#define WPA_CIPHER_NONE	BIT(0)
#define WPA_CIPHER_WEP40	BIT(1)
#define WPA_CIPHER_WEP104 BIT(2)
#define WPA_CIPHER_TKIP	BIT(3)
#define WPA_CIPHER_CCMP	BIT(4)



#define WPA_SELECTOR_LEN 4
extern u8 RTW_WPA_OUI_TYPE[] ;
extern u16 RTW_WPA_VERSION ;
extern u8 WPA_AUTH_KEY_MGMT_NONE[];
extern u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[];
extern u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
extern u8 WPA_CIPHER_SUITE_NONE[];
extern u8 WPA_CIPHER_SUITE_WEP40[];
extern u8 WPA_CIPHER_SUITE_TKIP[];
extern u8 WPA_CIPHER_SUITE_WRAP[];
extern u8 WPA_CIPHER_SUITE_CCMP[];
extern u8 WPA_CIPHER_SUITE_WEP104[];


#define RSN_HEADER_LEN 4
#define RSN_SELECTOR_LEN 4

extern u16 RSN_VERSION_BSD;
extern u8 RSN_CIPHER_SUITE_NONE[];
extern u8 RSN_CIPHER_SUITE_WEP40[];
extern u8 RSN_CIPHER_SUITE_TKIP[];
extern u8 RSN_CIPHER_SUITE_WRAP[];
extern u8 RSN_CIPHER_SUITE_CCMP[];
extern u8 RSN_CIPHER_SUITE_WEP104[];

/* AKM suite type */
extern u8 WLAN_AKM_8021X[];
extern u8 WLAN_AKM_PSK[];
extern u8 WLAN_AKM_FT_8021X[];
extern u8 WLAN_AKM_FT_PSK[];
extern u8 WLAN_AKM_8021X_SHA256[];
extern u8 WLAN_AKM_PSK_SHA256[];
extern u8 WLAN_AKM_TDLS[];
extern u8 WLAN_AKM_SAE[];
extern u8 WLAN_AKM_FT_OVER_SAE[];
extern u8 WLAN_AKM_8021X_SUITE_B[];
extern u8 WLAN_AKM_8021X_SUITE_B_192[];
extern u8 WLAN_AKM_FILS_SHA256[];
extern u8 WLAN_AKM_FILS_SHA384[];
extern u8 WLAN_AKM_FT_FILS_SHA256[];
extern u8 WLAN_AKM_FT_FILS_SHA384[];

#define WLAN_AKM_TYPE_8021X BIT(0)
#define WLAN_AKM_TYPE_PSK BIT(1)
#define WLAN_AKM_TYPE_FT_8021X BIT(2)
#define WLAN_AKM_TYPE_FT_PSK BIT(3)
#define WLAN_AKM_TYPE_8021X_SHA256 BIT(4)
#define WLAN_AKM_TYPE_PSK_SHA256 BIT(5)
#define WLAN_AKM_TYPE_TDLS BIT(6)
#define WLAN_AKM_TYPE_SAE BIT(7)
#define WLAN_AKM_TYPE_FT_OVER_SAE BIT(8)
#define WLAN_AKM_TYPE_8021X_SUITE_B BIT(9)
#define WLAN_AKM_TYPE_8021X_SUITE_B_192 BIT(10)
#define WLAN_AKM_TYPE_FILS_SHA256 BIT(11)
#define WLAN_AKM_TYPE_FILS_SHA384 BIT(12)
#define WLAN_AKM_TYPE_FT_FILS_SHA256 BIT(13)
#define WLAN_AKM_TYPE_FT_FILS_SHA384 BIT(14)

/* IEEE 802.11i */
#define PMKID_LEN 16
#define PMK_LEN 32
#define PMK_LEN_SUITE_B_192 48
#define PMK_LEN_MAX 48
#define WPA_REPLAY_COUNTER_LEN 8
#define WPA_NONCE_LEN 32
#define WPA_KEY_RSC_LEN 8
#define WPA_GMK_LEN 32
#define WPA_GTK_MAX_LEN 32

/* IEEE 802.11, 8.5.2 EAPOL-Key frames */
#define WPA_KEY_INFO_TYPE_MASK ((u16) (BIT(0) | BIT(1) | BIT(2)))
#define WPA_KEY_INFO_TYPE_AKM_DEFINED 0
#define WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 BIT(0)
#define WPA_KEY_INFO_TYPE_HMAC_SHA1_AES BIT(1)
#define WPA_KEY_INFO_TYPE_AES_128_CMAC 3
#define WPA_KEY_INFO_KEY_TYPE BIT(3) /* 1 = Pairwise, 0 = Group key */
/* bit4..5 is used in WPA, but is reserved in IEEE 802.11i/RSN */
#define WPA_KEY_INFO_KEY_INDEX_MASK (BIT(4) | BIT(5))
#define WPA_KEY_INFO_KEY_INDEX_SHIFT 4
#define WPA_KEY_INFO_INSTALL BIT(6) /* pairwise */
#define WPA_KEY_INFO_TXRX BIT(6) /* group */
#define WPA_KEY_INFO_ACK BIT(7)
#define WPA_KEY_INFO_MIC BIT(8)
#define WPA_KEY_INFO_SECURE BIT(9)
#define WPA_KEY_INFO_ERROR BIT(10)
#define WPA_KEY_INFO_REQUEST BIT(11)
#define WPA_KEY_INFO_ENCR_KEY_DATA BIT(12) /* IEEE 802.11i/RSN only */
#define WPA_KEY_INFO_SMK_MESSAGE BIT(13)

struct ieee802_1x_hdr {
	u8 version;
	u8 type;
	u16 length;
	/* followed by length octets of data */
};

struct wpa_eapol_key {
	u8 type;
	/* Note: key_info, key_length, and key_data_length are unaligned */
	u8 key_info[2]; /* big endian */
	u8 key_length[2]; /* big endian */
	u8 replay_counter[WPA_REPLAY_COUNTER_LEN];
	u8 key_nonce[WPA_NONCE_LEN];
	u8 key_iv[16];
	u8 key_rsc[WPA_KEY_RSC_LEN];
	u8 key_id[8]; /* Reserved in IEEE 802.11i/RSN */
	u8 key_mic[16];
	u8 key_data_length[2]; /* big endian */
	/* followed by key_data_length bytes of key_data */
};

typedef enum _RATEID_IDX_ {
	RATEID_IDX_BGN_40M_2SS = 0,
	RATEID_IDX_BGN_40M_1SS = 1,
	RATEID_IDX_BGN_20M_2SS_BN = 2,
	RATEID_IDX_BGN_20M_1SS_BN = 3,
	RATEID_IDX_GN_N2SS = 4,
	RATEID_IDX_GN_N1SS = 5,
	RATEID_IDX_BG = 6,
	RATEID_IDX_G = 7,
	RATEID_IDX_B = 8,
	RATEID_IDX_VHT_2SS = 9,
	RATEID_IDX_VHT_1SS = 10,
	RATEID_IDX_MIX1 = 11,
	RATEID_IDX_MIX2 = 12,
	RATEID_IDX_VHT_3SS = 13,
	RATEID_IDX_BGN_3SS = 14,
	RATEID_IDX_BGN_4SS = 15,
	RATEID_IDX_VHT_4SS = 16,
} RATEID_IDX, *PRATEID_IDX;

typedef enum _RATR_TABLE_MODE {
	RATR_INX_WIRELESS_NGB = 0,	/* BGN 40 Mhz 2SS 1SS */
	RATR_INX_WIRELESS_NG = 1,		/* GN or N */
	RATR_INX_WIRELESS_NB = 2,		/* BGN 20 Mhz 2SS 1SS  or BN */
	RATR_INX_WIRELESS_N = 3,
	RATR_INX_WIRELESS_GB = 4,
	RATR_INX_WIRELESS_G = 5,
	RATR_INX_WIRELESS_B = 6,
	RATR_INX_WIRELESS_MC = 7,
	RATR_INX_WIRELESS_AC_N = 8,
} RATR_TABLE_MODE, *PRATR_TABLE_MODE;


enum NETWORK_TYPE {
	WIRELESS_INVALID = 0,
	/* Sub-Element */
	WIRELESS_11B = BIT(0), /* tx: cck only , rx: cck only, hw: cck */
	WIRELESS_11G = BIT(1), /* tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm */
	WIRELESS_11A = BIT(2), /* tx: ofdm only, rx: ofdm only, hw: ofdm only */
	WIRELESS_11_24N = BIT(3), /* tx: MCS only, rx: MCS & cck, hw: MCS & cck */
	WIRELESS_11_5N = BIT(4), /* tx: MCS only, rx: MCS & ofdm, hw: ofdm only */
	WIRELESS_AUTO = BIT(5),
	WIRELESS_11AC = BIT(6),

	/* Combination */
	/* Type for current wireless mode */
	WIRELESS_11BG = (WIRELESS_11B | WIRELESS_11G), /* tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm */
	WIRELESS_11G_24N = (WIRELESS_11G | WIRELESS_11_24N), /* tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm */
	WIRELESS_11A_5N = (WIRELESS_11A | WIRELESS_11_5N), /* tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
	WIRELESS_11B_24N = (WIRELESS_11B | WIRELESS_11_24N), /* tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck */
	WIRELESS_11BG_24N = (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N), /* tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck */
	WIRELESS_11_24AC = (WIRELESS_11B | WIRELESS_11G | WIRELESS_11AC),
	WIRELESS_11_5AC = (WIRELESS_11A | WIRELESS_11AC),


	/* Type for registry default wireless mode */
	WIRELESS_11AGN = (WIRELESS_11A | WIRELESS_11G | WIRELESS_11_24N | WIRELESS_11_5N), /* tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
	WIRELESS_11ABGN = (WIRELESS_11A | WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N | WIRELESS_11_5N),
	WIRELESS_MODE_24G = (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N),
	WIRELESS_MODE_5G = (WIRELESS_11A | WIRELESS_11_5N | WIRELESS_11AC),
	WIRELESS_MODE_MAX = (WIRELESS_11A | WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N | WIRELESS_11_5N | WIRELESS_11AC),
};

#define SUPPORTED_24G_NETTYPE_MSK WIRELESS_MODE_24G
#define SUPPORTED_5G_NETTYPE_MSK WIRELESS_MODE_5G

#define IsLegacyOnly(NetType)  ((NetType) == ((NetType) & (WIRELESS_11BG | WIRELESS_11A)))

#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? _TRUE : _FALSE)
#define is_supported_5g(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? _TRUE : _FALSE)

#define IsEnableHWCCK(NetType) IsSupported24G(NetType)
#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G | WIRELESS_11_24N | SUPPORTED_5G_NETTYPE_MSK) ? _TRUE : _FALSE)

#define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
#define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
#define IsSupportedRxHT(NetType) IsEnableHWOFDM(NetType)

#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? _TRUE : _FALSE)
#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G | WIRELESS_11A) ? _TRUE : _FALSE)
#define is_supported_ht(NetType) ((NetType) & (WIRELESS_11_24N | WIRELESS_11_5N) ? _TRUE : _FALSE)

#define is_supported_vht(NetType) ((NetType) & (WIRELESS_11AC) ? _TRUE : _FALSE)





typedef struct ieee_param {
	u32 cmd;
	u8 sta_addr[ETH_ALEN];
	union {
		struct {
			u8 name;
			u32 value;
		} wpa_param;
		struct {
			u32 len;
			u8 reserved[32];
			u8 data[0];
		} wpa_ie;
		struct {
			int command;
			int reason_code;
		} mlme;
		struct {
			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
			u8 set_tx;
			u32 err;
			u8 idx;
			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
			u16 key_len;
			u8 key[0];
		} crypt;
#ifdef CONFIG_AP_MODE
		struct {
			u16 aid;
			u16 capability;
			int flags;
			u8 tx_supp_rates[16];
			struct rtw_ieee80211_ht_cap ht_cap;
		} add_sta;
		struct {
			u8	reserved[2];/* for set max_num_sta */
			u8	buf[0];
		} bcn_ie;
#endif

	} u;
} ieee_param;

#ifdef CONFIG_AP_MODE
typedef struct ieee_param_ex {
	u32 cmd;
	u8 sta_addr[ETH_ALEN];
	u8 data[0];
} ieee_param_ex;

struct sta_data {
	u16 aid;
	u16 capability;
	int flags;
	u32 sta_set;
	u8 tx_supp_rates[16];
	u32 tx_supp_rates_len;
	struct rtw_ieee80211_ht_cap ht_cap;
	u64	rx_pkts;
	u64	rx_bytes;
	u64	rx_drops;
	u64	tx_pkts;
	u64	tx_bytes;
	u64	tx_drops;
};
#endif


#if WIRELESS_EXT < 17
	#define IW_QUAL_QUAL_INVALID   0x10
	#define IW_QUAL_LEVEL_INVALID  0x20
	#define IW_QUAL_NOISE_INVALID  0x40
	#define IW_QUAL_QUAL_UPDATED   0x1
	#define IW_QUAL_LEVEL_UPDATED  0x2
	#define IW_QUAL_NOISE_UPDATED  0x4
#endif

#define IEEE80211_DATA_LEN		2304
/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
   6.2.1.1.2.

   The figure in section 7.1.2 suggests a body size of up to 2312
   bytes is allowed, which is a bit confusing, I suspect this
   represents the 2304 bytes of real data, plus a possible 8 bytes of
   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */


#define IEEE80211_HLEN			30
#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)


/* this is stolen from ipw2200 driver */
#define IEEE_IBSS_MAC_HASH_SIZE 31

struct ieee_ibss_seq {
	u8 mac[ETH_ALEN];
	u16 seq_num;
	u16 frag_num;
	unsigned long packet_time;
	_list	list;
};

#if defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)

struct rtw_ieee80211_hdr {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[ETH_ALEN];
	u8 addr2[ETH_ALEN];
	u8 addr3[ETH_ALEN];
	u16 seq_ctl;
	u8 addr4[ETH_ALEN];
} __attribute__((packed));

struct rtw_ieee80211_hdr_3addr {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[ETH_ALEN];
	u8 addr2[ETH_ALEN];
	u8 addr3[ETH_ALEN];
	u16 seq_ctl;
} __attribute__((packed));


struct rtw_ieee80211_hdr_qos {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[ETH_ALEN];
	u8 addr2[ETH_ALEN];
	u8 addr3[ETH_ALEN];
	u16 seq_ctl;
	u8 addr4[ETH_ALEN];
	u16	qc;
}  __attribute__((packed));

struct rtw_ieee80211_hdr_3addr_qos {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[ETH_ALEN];
	u8 addr2[ETH_ALEN];
	u8 addr3[ETH_ALEN];
	u16 seq_ctl;
	u16     qc;
}  __attribute__((packed));

struct eapol {
	u8 snap[6];
	u16 ethertype;
	u8 version;
	u8 type;
	u16 length;
} __attribute__((packed));

struct rtw_ieee80211s_hdr {
	u8 flags;
	u8 ttl;
	u32 seqnum;
	u8 eaddr1[ETH_ALEN];
	u8 eaddr2[ETH_ALEN];
} __attribute__((packed));

/**
 * struct rtw_ieee80211_rann_ie
 *
 * This structure refers to "Root Announcement information element"
 */
 struct rtw_ieee80211_rann_ie {
	u8 rann_flags;
	u8 rann_hopcount;
	u8 rann_ttl;
	u8 rann_addr[ETH_ALEN];
	u32 rann_seq;
	u32 rann_interval;
	u32 rann_metric;
} __attribute__((packed));
#endif

enum eap_type {
	EAP_PACKET = 0,
	EAPOL_START,
	EAPOL_LOGOFF,
	EAPOL_KEY,
	EAPOL_ENCAP_ASF_ALERT
};

#define IEEE80211_3ADDR_LEN 24
#define IEEE80211_4ADDR_LEN 30
#define IEEE80211_FCS_LEN    4

#define MIN_FRAG_THRESHOLD     256U
#define	MAX_FRAG_THRESHOLD     2346U

/* Frame control field constants */
#define RTW_IEEE80211_FCTL_VERS		0x0003
#define RTW_IEEE80211_FCTL_FTYPE		0x000c
#define RTW_IEEE80211_FCTL_STYPE		0x00f0
#define RTW_IEEE80211_FCTL_TODS		0x0100
#define RTW_IEEE80211_FCTL_FROMDS	0x0200
#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
#define RTW_IEEE80211_FCTL_RETRY		0x0800
#define RTW_IEEE80211_FCTL_PM		0x1000
#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
#define RTW_IEEE80211_FCTL_PROTECTED	0x4000
#define RTW_IEEE80211_FCTL_ORDER		0x8000
#define RTW_IEEE80211_FCTL_CTL_EXT	0x0f00

#define RTW_IEEE80211_FTYPE_MGMT		0x0000
#define RTW_IEEE80211_FTYPE_CTL		0x0004
#define RTW_IEEE80211_FTYPE_DATA		0x0008
#define RTW_IEEE80211_FTYPE_EXT		0x000c

/* management */
#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
#define RTW_IEEE80211_STYPE_ASSOC_RESP	0x0010
#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
#define RTW_IEEE80211_STYPE_BEACON		0x0080
#define RTW_IEEE80211_STYPE_ATIM		0x0090
#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
#define RTW_IEEE80211_STYPE_AUTH		0x00B0
#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
#define RTW_IEEE80211_STYPE_ACTION		0x00D0

/* control */
#define RTW_IEEE80211_STYPE_CTL_EXT		0x0060
#define RTW_IEEE80211_STYPE_BACK_REQ		0x0080
#define RTW_IEEE80211_STYPE_BACK		0x0090
#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
#define RTW_IEEE80211_STYPE_RTS		0x00B0
#define RTW_IEEE80211_STYPE_CTS		0x00C0
#define RTW_IEEE80211_STYPE_ACK		0x00D0
#define RTW_IEEE80211_STYPE_CFEND		0x00E0
#define RTW_IEEE80211_STYPE_CFENDACK		0x00F0

/* data */
#define RTW_IEEE80211_STYPE_DATA		0x0000
#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
#define RTW_IEEE80211_STYPE_CFACK		0x0050
#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
#define RTW_IEEE80211_STYPE_QOS_DATA		0x0080
#define RTW_IEEE80211_STYPE_QOS_DATA_CFACK		0x0090
#define RTW_IEEE80211_STYPE_QOS_DATA_CFPOLL		0x00A0
#define RTW_IEEE80211_STYPE_QOS_DATA_CFACKPOLL	0x00B0
#define RTW_IEEE80211_STYPE_QOS_NULLFUNC	0x00C0
#define RTW_IEEE80211_STYPE_QOS_CFACK		0x00D0
#define RTW_IEEE80211_STYPE_QOS_CFPOLL		0x00E0
#define RTW_IEEE80211_STYPE_QOS_CFACKPOLL	0x00F0

/* sequence control field */
#define RTW_IEEE80211_SCTL_FRAG	0x000F
#define RTW_IEEE80211_SCTL_SEQ	0xFFF0


#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)

/* QoS,QOS */
#define NORMAL_ACK			0
#define NO_ACK				1
#define NON_EXPLICIT_ACK	2
#define BLOCK_ACK			3

#ifndef ETH_P_PAE
	#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
#endif /* ETH_P_PAE */

#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */

#define ETH_P_ECONET	0x0018

#ifndef ETH_P_80211_RAW
	#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
#endif

/* IEEE 802.11 defines */

#define P80211_OUI_LEN 3

#if defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)

struct ieee80211_snap_hdr {

	u8    dsap;   /* always 0xAA */
	u8    ssap;   /* always 0xAA */
	u8    ctrl;   /* always 0x03 */
	u8    oui[P80211_OUI_LEN];    /* organizational universal id */

} __attribute__((packed));

#endif

#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)

#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)

#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)

#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)

/* Authentication algorithms */
#define WLAN_AUTH_OPEN 0
#define WLAN_AUTH_SHARED_KEY 1
#define WLAN_AUTH_SAE 3

#define WLAN_AUTH_CHALLENGE_LEN 128

#define WLAN_CAPABILITY_BSS (1<<0)
#define WLAN_CAPABILITY_IBSS (1<<1)
#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
#define WLAN_CAPABILITY_PRIVACY (1<<4)
#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
#define WLAN_CAPABILITY_PBCC (1<<6)
#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)

/* Status codes */
#define WLAN_STATUS_SUCCESS 0
#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
#define WLAN_STATUS_CAPS_UNSUPPORTED 10
#define WLAN_STATUS_REASSOC_NO_ASSOC 11
#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
#define WLAN_STATUS_CHALLENGE_FAIL 15
#define WLAN_STATUS_AUTH_TIMEOUT 16
#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
#define WLAN_STATUS_ASSOC_DENIED_RATES 18
/* 802.11b */
#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21

/* Reason codes */
#define WLAN_REASON_UNSPECIFIED 1
#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
#define WLAN_REASON_DEAUTH_LEAVING 3
#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
#define WLAN_REASON_DISASSOC_AP_BUSY 5
#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
#define WLAN_REASON_MESH_PEER_CANCELED 52
#define WLAN_REASON_MESH_MAX_PEERS 53
#define WLAN_REASON_MESH_CONFIG 54
#define WLAN_REASON_MESH_CLOSE 55
#define WLAN_REASON_MESH_MAX_RETRIES 56 
#define WLAN_REASON_MESH_CONFIRM_TIMEOUT 57
#define WLAN_REASON_MESH_INVALID_GTK 58
#define WLAN_REASON_MESH_INCONSISTENT_PARAM 59
#define WLAN_REASON_MESH_INVALID_SECURITY 60
#define WLAN_REASON_MESH_PATH_NOPROXY 61
#define WLAN_REASON_MESH_PATH_NOFORWARD 62
#define WLAN_REASON_MESH_PATH_DEST_UNREACHABLE 63
#define WLAN_REASON_MAC_EXISTS_IN_MBSS 64
#define WLAN_REASON_MESH_CHAN_REGULATORY 65
#define WLAN_REASON_MESH_CHAN 66
#define WLAN_REASON_SA_QUERY_TIMEOUT 65532
#define WLAN_REASON_ACTIVE_ROAM 65533
#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
#define WLAN_REASON_EXPIRATION_CHK 65535

#define WLAN_REASON_IS_PRIVATE(reason) ( \
	reason == WLAN_REASON_EXPIRATION_CHK \
	|| reason == WLAN_REASON_JOIN_WRONG_CHANNEL \
	|| reason == WLAN_REASON_ACTIVE_ROAM \
	|| reason == WLAN_REASON_SA_QUERY_TIMEOUT \
	)

/* Information Element IDs */
#define WLAN_EID_SSID 0
#define WLAN_EID_SUPP_RATES 1
#define WLAN_EID_FH_PARAMS 2
#define WLAN_EID_DS_PARAMS 3
#define WLAN_EID_CF_PARAMS 4
#define WLAN_EID_TIM 5
#define WLAN_EID_IBSS_PARAMS 6
#define WLAN_EID_CHALLENGE 16
/* EIDs defined by IEEE 802.11h - START */
#define WLAN_EID_PWR_CONSTRAINT 32
#define WLAN_EID_PWR_CAPABILITY 33
#define WLAN_EID_TPC_REQUEST 34
#define WLAN_EID_TPC_REPORT 35
#define WLAN_EID_SUPPORTED_CHANNELS 36
#define WLAN_EID_CHANNEL_SWITCH 37
#define WLAN_EID_MEASURE_REQUEST 38
#define WLAN_EID_MEASURE_REPORT 39
#define WLAN_EID_QUITE 40
#define WLAN_EID_IBSS_DFS 41
/* EIDs defined by IEEE 802.11h - END */
#define WLAN_EID_ERP_INFO 42
#define WLAN_EID_HT_CAP 45
#define WLAN_EID_RSN 48
#define WLAN_EID_EXT_SUPP_RATES 50
#define WLAN_EID_MOBILITY_DOMAIN 54
#define WLAN_EID_FAST_BSS_TRANSITION 55
#define WLAN_EID_TIMEOUT_INTERVAL 56
#define WLAN_EID_RIC_DATA 57
#define WLAN_EID_HT_OPERATION 61
#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
#define WLAN_EID_20_40_BSS_COEXISTENCE 72
#define WLAN_EID_20_40_BSS_INTOLERANT 73
#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
#define WLAN_EID_MMIE 76
#define WLAN_EID_MESH_CONFIG 113
#define WLAN_EID_MESH_ID 114
#define WLAN_EID_MPM 117
#define	WLAN_EID_RANN 126
#define	WLAN_EID_PREQ 130
#define	WLAN_EID_PREP 131
#define	WLAN_EID_PERR 132
#define WLAN_EID_AMPE 139
#define WLAN_EID_MIC 140
#define WLAN_EID_VENDOR_SPECIFIC 221
#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
#define WLAN_EID_VHT_CAPABILITY 191
#define WLAN_EID_VHT_OPERATION 192
#define WLAN_EID_VHT_OP_MODE_NOTIFY 199
#define WLAN_EID_EXTENSION 255
#define WLAN_EID_EXT_OWE_DH_PARAM 32

#define IEEE80211_MGMT_HDR_LEN 24
#define IEEE80211_DATA_HDR3_LEN 24
#define IEEE80211_DATA_HDR4_LEN 30


#define IEEE80211_STATMASK_SIGNAL (1<<0)
#define IEEE80211_STATMASK_RSSI (1<<1)
#define IEEE80211_STATMASK_NOISE (1<<2)
#define IEEE80211_STATMASK_RATE (1<<3)
#define IEEE80211_STATMASK_WEMASK 0x7


#define IEEE80211_CCK_MODULATION    (1<<0)
#define IEEE80211_OFDM_MODULATION   (1<<1)

#define IEEE80211_24GHZ_BAND     (1<<0)
#define IEEE80211_52GHZ_BAND     (1<<1)

#define IEEE80211_CCK_RATE_LEN		4
#define IEEE80211_NUM_OFDM_RATESLEN	8


#define IEEE80211_CCK_RATE_1MB		        0x02
#define IEEE80211_CCK_RATE_2MB		        0x04
#define IEEE80211_CCK_RATE_5MB		        0x0B
#define IEEE80211_CCK_RATE_11MB		        0x16
#define IEEE80211_OFDM_RATE_LEN		8
#define IEEE80211_OFDM_RATE_6MB		        0x0C
#define IEEE80211_OFDM_RATE_9MB		        0x12
#define IEEE80211_OFDM_RATE_12MB		0x18
#define IEEE80211_OFDM_RATE_18MB		0x24
#define IEEE80211_OFDM_RATE_24MB		0x30
#define IEEE80211_OFDM_RATE_36MB		0x48
#define IEEE80211_OFDM_RATE_48MB		0x60
#define IEEE80211_OFDM_RATE_54MB		0x6C
#define IEEE80211_BASIC_RATE_MASK		0x80

#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)

#define IEEE80211_CCK_RATES_MASK	        0x0000000F
#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
		IEEE80211_CCK_RATE_2MB_MASK)
#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
		IEEE80211_CCK_RATE_5MB_MASK | \
		IEEE80211_CCK_RATE_11MB_MASK)

#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
		IEEE80211_OFDM_RATE_12MB_MASK | \
		IEEE80211_OFDM_RATE_24MB_MASK)
#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
		IEEE80211_OFDM_RATE_9MB_MASK  | \
		IEEE80211_OFDM_RATE_18MB_MASK | \
		IEEE80211_OFDM_RATE_36MB_MASK | \
		IEEE80211_OFDM_RATE_48MB_MASK | \
		IEEE80211_OFDM_RATE_54MB_MASK)
#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
				      IEEE80211_CCK_DEFAULT_RATES_MASK)

#define IEEE80211_NUM_OFDM_RATES	    8
#define IEEE80211_NUM_CCK_RATES	            4
#define IEEE80211_OFDM_SHIFT_MASK_A         4


enum MGN_RATE {
	MGN_1M		= 0x02,
	MGN_2M		= 0x04,
	MGN_5_5M	= 0x0B,
	MGN_6M		= 0x0C,
	MGN_9M		= 0x12,
	MGN_11M	= 0x16,
	MGN_12M	= 0x18,
	MGN_18M	= 0x24,
	MGN_24M	= 0x30,
	MGN_36M	= 0x48,
	MGN_48M	= 0x60,
	MGN_54M	= 0x6C,
	MGN_MCS32	= 0x7F,
	MGN_MCS0,
	MGN_MCS1,
	MGN_MCS2,
	MGN_MCS3,
	MGN_MCS4,
	MGN_MCS5,
	MGN_MCS6,
	MGN_MCS7,
	MGN_MCS8,
	MGN_MCS9,
	MGN_MCS10,
	MGN_MCS11,
	MGN_MCS12,
	MGN_MCS13,
	MGN_MCS14,
	MGN_MCS15,
	MGN_MCS16,
	MGN_MCS17,
	MGN_MCS18,
	MGN_MCS19,
	MGN_MCS20,
	MGN_MCS21,
	MGN_MCS22,
	MGN_MCS23,
	MGN_MCS24,
	MGN_MCS25,
	MGN_MCS26,
	MGN_MCS27,
	MGN_MCS28,
	MGN_MCS29,
	MGN_MCS30,
	MGN_MCS31,
	MGN_VHT1SS_MCS0,
	MGN_VHT1SS_MCS1,
	MGN_VHT1SS_MCS2,
	MGN_VHT1SS_MCS3,
	MGN_VHT1SS_MCS4,
	MGN_VHT1SS_MCS5,
	MGN_VHT1SS_MCS6,
	MGN_VHT1SS_MCS7,
	MGN_VHT1SS_MCS8,
	MGN_VHT1SS_MCS9,
	MGN_VHT2SS_MCS0,
	MGN_VHT2SS_MCS1,
	MGN_VHT2SS_MCS2,
	MGN_VHT2SS_MCS3,
	MGN_VHT2SS_MCS4,
	MGN_VHT2SS_MCS5,
	MGN_VHT2SS_MCS6,
	MGN_VHT2SS_MCS7,
	MGN_VHT2SS_MCS8,
	MGN_VHT2SS_MCS9,
	MGN_VHT3SS_MCS0,
	MGN_VHT3SS_MCS1,
	MGN_VHT3SS_MCS2,
	MGN_VHT3SS_MCS3,
	MGN_VHT3SS_MCS4,
	MGN_VHT3SS_MCS5,
	MGN_VHT3SS_MCS6,
	MGN_VHT3SS_MCS7,
	MGN_VHT3SS_MCS8,
	MGN_VHT3SS_MCS9,
	MGN_VHT4SS_MCS0,
	MGN_VHT4SS_MCS1,
	MGN_VHT4SS_MCS2,
	MGN_VHT4SS_MCS3,
	MGN_VHT4SS_MCS4,
	MGN_VHT4SS_MCS5,
	MGN_VHT4SS_MCS6,
	MGN_VHT4SS_MCS7,
	MGN_VHT4SS_MCS8,
	MGN_VHT4SS_MCS9,
	MGN_UNKNOWN
};

#define IS_HT_RATE(_rate)	((_rate) >= MGN_MCS0 && (_rate) <= MGN_MCS31)
#define IS_VHT_RATE(_rate)	((_rate) >= MGN_VHT1SS_MCS0 && (_rate) <= MGN_VHT4SS_MCS9)
#define IS_CCK_RATE(_rate)	((_rate) == MGN_1M || (_rate) == MGN_2M || (_rate) == MGN_5_5M || (_rate) == MGN_11M)
#define IS_OFDM_RATE(_rate)	((_rate) >= MGN_6M && (_rate) <= MGN_54M  && (_rate) != MGN_11M)

#define IS_HT1SS_RATE(_rate) ((_rate) >= MGN_MCS0 && (_rate) <= MGN_MCS7)
#define IS_HT2SS_RATE(_rate) ((_rate) >= MGN_MCS8 && (_rate) <= MGN_MCS15)
#define IS_HT3SS_RATE(_rate) ((_rate) >= MGN_MCS16 && (_rate) <= MGN_MCS23)
#define IS_HT4SS_RATE(_rate) ((_rate) >= MGN_MCS24 && (_rate) <= MGN_MCS31)

#define IS_VHT1SS_RATE(_rate) ((_rate) >= MGN_VHT1SS_MCS0 && (_rate) <= MGN_VHT1SS_MCS9)
#define IS_VHT2SS_RATE(_rate) ((_rate) >= MGN_VHT2SS_MCS0 && (_rate) <= MGN_VHT2SS_MCS9)
#define IS_VHT3SS_RATE(_rate) ((_rate) >= MGN_VHT3SS_MCS0 && (_rate) <= MGN_VHT3SS_MCS9)
#define IS_VHT4SS_RATE(_rate) ((_rate) >= MGN_VHT4SS_MCS0 && (_rate) <= MGN_VHT4SS_MCS9)

#define IS_1T_RATE(_rate)	(IS_CCK_RATE((_rate)) || IS_OFDM_RATE((_rate)) || IS_HT1SS_RATE((_rate)) || IS_VHT1SS_RATE((_rate)))
#define IS_2T_RATE(_rate)	(IS_HT2SS_RATE((_rate)) || IS_VHT2SS_RATE((_rate)))
#define IS_3T_RATE(_rate)	(IS_HT3SS_RATE((_rate)) || IS_VHT3SS_RATE((_rate)))
#define IS_4T_RATE(_rate)	(IS_HT4SS_RATE((_rate)) || IS_VHT4SS_RATE((_rate)))

#define MGN_RATE_STR(_rate) \
	(_rate == MGN_1M) ? "CCK_1M" : \
	(_rate == MGN_2M) ? "CCK_2M" : \
	(_rate == MGN_5_5M) ? "CCK_5.5M" : \
	(_rate == MGN_11M) ? "CCK_11M" : \
	(_rate == MGN_6M) ? "OFDM_6M" : \
	(_rate == MGN_9M) ? "OFDM_9M" : \
	(_rate == MGN_12M) ? "OFDM_12M" : \
	(_rate == MGN_18M) ? "OFDM_18M" : \
	(_rate == MGN_24M) ? "OFDM_24M" : \
	(_rate == MGN_36M) ? "OFDM_36M" : \
	(_rate == MGN_48M) ? "OFDM_48M" : \
	(_rate == MGN_54M) ? "OFDM_54M" : \
	(_rate == MGN_MCS32) ? "MCS32" : \
	(_rate == MGN_MCS0) ? "MCS0" : \
	(_rate == MGN_MCS1) ? "MCS1" : \
	(_rate == MGN_MCS2) ? "MCS2" : \
	(_rate == MGN_MCS3) ? "MCS3" : \
	(_rate == MGN_MCS4) ? "MCS4" : \
	(_rate == MGN_MCS5) ? "MCS5" : \
	(_rate == MGN_MCS6) ? "MCS6" : \
	(_rate == MGN_MCS7) ? "MCS7" : \
	(_rate == MGN_MCS8) ? "MCS8" : \
	(_rate == MGN_MCS9) ? "MCS9" : \
	(_rate == MGN_MCS10) ? "MCS10" : \
	(_rate == MGN_MCS11) ? "MCS11" : \
	(_rate == MGN_MCS12) ? "MCS12" : \
	(_rate == MGN_MCS13) ? "MCS13" : \
	(_rate == MGN_MCS14) ? "MCS14" : \
	(_rate == MGN_MCS15) ? "MCS15" : \
	(_rate == MGN_MCS16) ? "MCS16" : \
	(_rate == MGN_MCS17) ? "MCS17" : \
	(_rate == MGN_MCS18) ? "MCS18" : \
	(_rate == MGN_MCS19) ? "MCS19" : \
	(_rate == MGN_MCS20) ? "MCS20" : \
	(_rate == MGN_MCS21) ? "MCS21" : \
	(_rate == MGN_MCS22) ? "MCS22" : \
	(_rate == MGN_MCS23) ? "MCS23" : \
	(_rate == MGN_MCS24) ? "MCS24" : \
	(_rate == MGN_MCS25) ? "MCS25" : \
	(_rate == MGN_MCS26) ? "MCS26" : \
	(_rate == MGN_MCS27) ? "MCS27" : \
	(_rate == MGN_MCS28) ? "MCS28" : \
	(_rate == MGN_MCS29) ? "MCS29" : \
	(_rate == MGN_MCS30) ? "MCS30" : \
	(_rate == MGN_MCS31) ? "MCS31" : \
	(_rate == MGN_VHT1SS_MCS0) ? "VHT1SMCS0" : \
	(_rate == MGN_VHT1SS_MCS1) ? "VHT1SMCS1" : \
	(_rate == MGN_VHT1SS_MCS2) ? "VHT1SMCS2" : \
	(_rate == MGN_VHT1SS_MCS3) ? "VHT1SMCS3" : \
	(_rate == MGN_VHT1SS_MCS4) ? "VHT1SMCS4" : \
	(_rate == MGN_VHT1SS_MCS5) ? "VHT1SMCS5" : \
	(_rate == MGN_VHT1SS_MCS6) ? "VHT1SMCS6" : \
	(_rate == MGN_VHT1SS_MCS7) ? "VHT1SMCS7" : \
	(_rate == MGN_VHT1SS_MCS8) ? "VHT1SMCS8" : \
	(_rate == MGN_VHT1SS_MCS9) ? "VHT1SMCS9" : \
	(_rate == MGN_VHT2SS_MCS0) ? "VHT2SMCS0" : \
	(_rate == MGN_VHT2SS_MCS1) ? "VHT2SMCS1" : \
	(_rate == MGN_VHT2SS_MCS2) ? "VHT2SMCS2" : \
	(_rate == MGN_VHT2SS_MCS3) ? "VHT2SMCS3" : \
	(_rate == MGN_VHT2SS_MCS4) ? "VHT2SMCS4" : \
	(_rate == MGN_VHT2SS_MCS5) ? "VHT2SMCS5" : \
	(_rate == MGN_VHT2SS_MCS6) ? "VHT2SMCS6" : \
	(_rate == MGN_VHT2SS_MCS7) ? "VHT2SMCS7" : \
	(_rate == MGN_VHT2SS_MCS8) ? "VHT2SMCS8" : \
	(_rate == MGN_VHT2SS_MCS9) ? "VHT2SMCS9" : \
	(_rate == MGN_VHT3SS_MCS0) ? "VHT3SMCS0" : \
	(_rate == MGN_VHT3SS_MCS1) ? "VHT3SMCS1" : \
	(_rate == MGN_VHT3SS_MCS2) ? "VHT3SMCS2" : \
	(_rate == MGN_VHT3SS_MCS3) ? "VHT3SMCS3" : \
	(_rate == MGN_VHT3SS_MCS4) ? "VHT3SMCS4" : \
	(_rate == MGN_VHT3SS_MCS5) ? "VHT3SMCS5" : \
	(_rate == MGN_VHT3SS_MCS6) ? "VHT3SMCS6" : \
	(_rate == MGN_VHT3SS_MCS7) ? "VHT3SMCS7" : \
	(_rate == MGN_VHT3SS_MCS8) ? "VHT3SMCS8" : \
	(_rate == MGN_VHT3SS_MCS9) ? "VHT3SMCS9" : \
	(_rate == MGN_VHT4SS_MCS0) ? "VHT4SMCS0" : \
	(_rate == MGN_VHT4SS_MCS1) ? "VHT4SMCS1" : \
	(_rate == MGN_VHT4SS_MCS2) ? "VHT4SMCS2" : \
	(_rate == MGN_VHT4SS_MCS3) ? "VHT4SMCS3" : \
	(_rate == MGN_VHT4SS_MCS4) ? "VHT4SMCS4" : \
	(_rate == MGN_VHT4SS_MCS5) ? "VHT4SMCS5" : \
	(_rate == MGN_VHT4SS_MCS6) ? "VHT4SMCS6" : \
	(_rate == MGN_VHT4SS_MCS7) ? "VHT4SMCS7" : \
	(_rate == MGN_VHT4SS_MCS8) ? "VHT4SMCS8" : \
	(_rate == MGN_VHT4SS_MCS9) ? "VHT4SMCS9" : "UNKNOWN"

typedef enum _RATE_SECTION {
	CCK = 0,
	OFDM = 1,
	HT_MCS0_MCS7 = 2,
	HT_MCS8_MCS15 = 3,
	HT_MCS16_MCS23 = 4,
	HT_MCS24_MCS31 = 5,
	HT_1SS = HT_MCS0_MCS7,
	HT_2SS = HT_MCS8_MCS15,
	HT_3SS = HT_MCS16_MCS23,
	HT_4SS = HT_MCS24_MCS31,
	VHT_1SSMCS0_1SSMCS9 = 6,
	VHT_2SSMCS0_2SSMCS9 = 7,
	VHT_3SSMCS0_3SSMCS9 = 8,
	VHT_4SSMCS0_4SSMCS9 = 9,
	VHT_1SS = VHT_1SSMCS0_1SSMCS9,
	VHT_2SS = VHT_2SSMCS0_2SSMCS9,
	VHT_3SS = VHT_3SSMCS0_3SSMCS9,
	VHT_4SS = VHT_4SSMCS0_4SSMCS9,
	RATE_SECTION_NUM,
} RATE_SECTION;

RATE_SECTION mgn_rate_to_rs(enum MGN_RATE rate);

const char *rate_section_str(u8 section);

#define IS_CCK_RATE_SECTION(section) ((section) == CCK)
#define IS_OFDM_RATE_SECTION(section) ((section) == OFDM)
#define IS_HT_RATE_SECTION(section) ((section) >= HT_1SS && (section) <= HT_4SS)
#define IS_VHT_RATE_SECTION(section) ((section) >= VHT_1SS && (section) <= VHT_4SS)

#define IS_1T_RATE_SECTION(section) ((section) == CCK || (section) == OFDM || (section) == HT_1SS || (section) == VHT_1SS)
#define IS_2T_RATE_SECTION(section) ((section) == HT_2SS || (section) == VHT_2SS)
#define IS_3T_RATE_SECTION(section) ((section) == HT_3SS || (section) == VHT_3SS)
#define IS_4T_RATE_SECTION(section) ((section) == HT_4SS || (section) == VHT_4SS)

extern u8 mgn_rates_cck[];
extern u8 mgn_rates_ofdm[];
extern u8 mgn_rates_mcs0_7[];
extern u8 mgn_rates_mcs8_15[];
extern u8 mgn_rates_mcs16_23[];
extern u8 mgn_rates_mcs24_31[];
extern u8 mgn_rates_vht1ss[];
extern u8 mgn_rates_vht2ss[];
extern u8 mgn_rates_vht3ss[];
extern u8 mgn_rates_vht4ss[];

struct rate_section_ent {
	u8 tx_num; /* value of RF_TX_NUM */
	u8 rate_num;
	u8 *rates;
};

extern struct rate_section_ent rates_by_sections[];

#define rate_section_to_tx_num(section) (rates_by_sections[(section)].tx_num)
#define rate_section_rate_num(section) (rates_by_sections[(section)].rate_num)

/* NOTE: This data is for statistical purposes; not all hardware provides this
 *       information for frames received.  Not setting these will not cause
 *       any adverse affects. */
struct ieee80211_rx_stats {
	/* u32 mac_time[2]; */
	s8 rssi;
	u8 signal;
	u8 noise;
	u8 received_channel;
	u16 rate; /* in 100 kbps */
	/* u8 control; */
	u8 mask;
	u8 freq;
	u16 len;
};

/* IEEE 802.11 requires that STA supports concurrent reception of at least
 * three fragmented frames. This define can be increased to support more
 * concurrent frames, but it should be noted that each entry can consume about
 * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
#define IEEE80211_FRAG_CACHE_LEN 4

struct ieee80211_frag_entry {
	u32 first_frag_time;
	uint seq;
	uint last_frag;
	uint qos;   /* jackson */
	uint tid;	/* jackson */
	struct sk_buff *skb;
	u8 src_addr[ETH_ALEN];
	u8 dst_addr[ETH_ALEN];
};

#ifndef PLATFORM_FREEBSD /* Baron BSD has already defined */
struct ieee80211_stats {
	uint tx_unicast_frames;
	uint tx_multicast_frames;
	uint tx_fragments;
	uint tx_unicast_octets;
	uint tx_multicast_octets;
	uint tx_deferred_transmissions;
	uint tx_single_retry_frames;
	uint tx_multiple_retry_frames;
	uint tx_retry_limit_exceeded;
	uint tx_discards;
	uint rx_unicast_frames;
	uint rx_multicast_frames;
	uint rx_fragments;
	uint rx_unicast_octets;
	uint rx_multicast_octets;
	uint rx_fcs_errors;
	uint rx_discards_no_buffer;
	uint tx_discards_wrong_sa;
	uint rx_discards_undecryptable;
	uint rx_message_in_msg_fragments;
	uint rx_message_in_bad_msg_fragments;
};
#endif /* PLATFORM_FREEBSD */
struct ieee80211_softmac_stats {
	uint rx_ass_ok;
	uint rx_ass_err;
	uint rx_probe_rq;
	uint tx_probe_rs;
	uint tx_beacons;
	uint rx_auth_rq;
	uint rx_auth_rs_ok;
	uint rx_auth_rs_err;
	uint tx_auth_rq;
	uint no_auth_rs;
	uint no_ass_rs;
	uint tx_ass_rq;
	uint rx_ass_rq;
	uint tx_probe_rq;
	uint reassoc;
	uint swtxstop;
	uint swtxawake;
};

#define SEC_KEY_1         (1<<0)
#define SEC_KEY_2         (1<<1)
#define SEC_KEY_3         (1<<2)
#define SEC_KEY_4         (1<<3)
#define SEC_ACTIVE_KEY    (1<<4)
#define SEC_AUTH_MODE     (1<<5)
#define SEC_UNICAST_GROUP (1<<6)
#define SEC_LEVEL         (1<<7)
#define SEC_ENABLED       (1<<8)

#define SEC_LEVEL_0      0 /* None */
#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
#define SEC_LEVEL_3      4 /* Level 2 + CCMP */

#define WEP_KEYS 4
#define WEP_KEY_LEN 13
#define BIP_MAX_KEYID 5
#define BIP_AAD_SIZE  20

#if defined(PLATFORM_LINUX)
struct ieee80211_security {
	u16 active_key:2,
	    enabled:1,
	    auth_mode:2,
	    auth_algo:4,
	    unicast_uses_group:1;
	u8 key_sizes[WEP_KEYS];
	u8 keys[WEP_KEYS][WEP_KEY_LEN];
	u8 level;
	u16 flags;
} __attribute__((packed));

#endif

/*

 802.11 data frame from AP

      ,-------------------------------------------------------------------.
Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
      |------|------|---------|---------|---------|------|---------|------|
Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
      |      | tion | (BSSID) |         |         | ence |  data   |      |
      `-------------------------------------------------------------------'

Total: 28-2340 bytes

*/

struct ieee80211_header_data {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	u16 seq_ctrl;
};

#define BEACON_PROBE_SSID_ID_POSITION 12

/* Management Frame Information Element Types */
#define MFIE_TYPE_SSID       0
#define MFIE_TYPE_RATES      1
#define MFIE_TYPE_FH_SET     2
#define MFIE_TYPE_DS_SET     3
#define MFIE_TYPE_CF_SET     4
#define MFIE_TYPE_TIM        5
#define MFIE_TYPE_IBSS_SET   6
#define MFIE_TYPE_CHALLENGE  16
#define MFIE_TYPE_ERP        42
#define MFIE_TYPE_RSN	     48
#define MFIE_TYPE_RATES_EX   50
#define MFIE_TYPE_GENERIC    221

#if defined(PLATFORM_LINUX)
struct ieee80211_info_element_hdr {
	u8 id;
	u8 len;
} __attribute__((packed));

struct ieee80211_info_element {
	u8 id;
	u8 len;
	u8 data[0];
} __attribute__((packed));
#endif


/*
 * These are the data types that can make up management packets
 *
	u16 auth_algorithm;
	u16 auth_sequence;
	u16 beacon_interval;
	u16 capability;
	u8 current_ap[ETH_ALEN];
	u16 listen_interval;
	struct {
		u16 association_id:14, reserved:2;
	} __attribute__ ((packed));
	u32 time_stamp[2];
	u16 reason;
	u16 status;
*/

#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
#define IEEE80211_DEFAULT_BASIC_RATE 10


#if defined(PLATFORM_LINUX)
struct ieee80211_authentication {
	struct ieee80211_header_data header;
	u16 algorithm;
	u16 transaction;
	u16 status;
	/* struct ieee80211_info_element_hdr info_element; */
} __attribute__((packed));


struct ieee80211_probe_response {
	struct ieee80211_header_data header;
	u32 time_stamp[2];
	u16 beacon_interval;
	u16 capability;
	struct ieee80211_info_element info_element;
} __attribute__((packed));

struct ieee80211_probe_request {
	struct ieee80211_header_data header;
	/*struct ieee80211_info_element info_element;*/
} __attribute__((packed));

struct ieee80211_assoc_request_frame {
	struct rtw_ieee80211_hdr_3addr header;
	u16 capability;
	u16 listen_interval;
	/* u8 current_ap[ETH_ALEN]; */
	struct ieee80211_info_element_hdr info_element;
} __attribute__((packed));

struct ieee80211_assoc_response_frame {
	struct rtw_ieee80211_hdr_3addr header;
	u16 capability;
	u16 status;
	u16 aid;
	/*	struct ieee80211_info_element info_element;  supported rates  */
} __attribute__((packed));
#endif

struct ieee80211_txb {
	u8 nr_frags;
	u8 encrypted;
	u16 reserved;
	u16 frag_size;
	u16 payload_size;
	struct sk_buff *fragments[0];
};


/* SWEEP TABLE ENTRIES NUMBER*/
#define MAX_SWEEP_TAB_ENTRIES		  42
#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
 * only use 8, and then use extended rates for the remaining supported
 * rates.  Other APs, however, stick all of their supported rates on the
 * main rates information element... */
#define MAX_RATES_LENGTH                  ((u8)12)
#define MAX_RATES_EX_LENGTH               ((u8)16)
#define MAX_NETWORK_COUNT                  128
#define IEEE80211_SOFTMAC_SCAN_TIME	  400
/* (HZ / 2) */
#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)

#define CRC_LENGTH                 4U

#define MAX_WPA_IE_LEN (256)
#define MAX_WPS_IE_LEN (512)
#define MAX_OWE_IE_LEN (128)
#define MAX_P2P_IE_LEN (256)
#define MAX_WFD_IE_LEN (128)

#define NETWORK_EMPTY_ESSID (1<<0)
#define NETWORK_HAS_OFDM    (1<<1)
#define NETWORK_HAS_CCK     (1<<2)

#define IEEE80211_DTIM_MBCAST 4
#define IEEE80211_DTIM_UCAST 2
#define IEEE80211_DTIM_VALID 1
#define IEEE80211_DTIM_INVALID 0

#define IEEE80211_PS_DISABLED 0
#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
#define IW_ESSID_MAX_SIZE 32
#if 0
struct ieee80211_network {
	/* These entries are used to identify a unique network */
	u8 bssid[ETH_ALEN];
	u8 channel;
	/* Ensure null-terminated for any debug msgs */
	u8 ssid[IW_ESSID_MAX_SIZE + 1];
	u8 ssid_len;
	u8	rssi;	/* relative signal strength */
	u8	sq;		/* signal quality */

	/* These are network statistics */
	/* struct ieee80211_rx_stats stats; */
	u16 capability;
	u16	aid;
	u8 rates[MAX_RATES_LENGTH];
	u8 rates_len;
	u8 rates_ex[MAX_RATES_EX_LENGTH];
	u8 rates_ex_len;

	u8 edca_parmsets[18];

	u8 mode;
	u8 flags;
	u8 time_stamp[8];
	u16 beacon_interval;
	u16 listen_interval;
	u16 atim_window;
	u8 wpa_ie[MAX_WPA_IE_LEN];
	size_t wpa_ie_len;
	u8 rsn_ie[MAX_WPA_IE_LEN];
	size_t rsn_ie_len;
	u8 country[6];
	u8 dtim_period;
	u8 dtim_data;
	u8 power_constraint;
	u8 qosinfo;
	u8 qbssload[5];
	u8 network_type;
	int join_res;
	unsigned long	last_scanned;
};
#endif
/*
join_res:
-1: authentication fail
-2: association fail
> 0: TID
*/

#ifndef PLATFORM_FREEBSD /* Baron BSD has already defined */

enum ieee80211_state {

	/* the card is not linked at all */
	IEEE80211_NOLINK = 0,

	/* IEEE80211_ASSOCIATING* are for BSS client mode
	 * the driver shall not perform RX filtering unless
	 * the state is LINKED.
	 * The driver shall just check for the state LINKED and
	 * defaults to NOLINK for ALL the other states (including
	 * LINKED_SCANNING)
	 */

	/* the association procedure will start (wq scheduling)*/
	IEEE80211_ASSOCIATING,
	IEEE80211_ASSOCIATING_RETRY,

	/* the association procedure is sending AUTH request*/
	IEEE80211_ASSOCIATING_AUTHENTICATING,

	/* the association procedure has successfully authentcated
	 * and is sending association request
	 */
	IEEE80211_ASSOCIATING_AUTHENTICATED,

	/* the link is ok. the card associated to a BSS or linked
	 * to a ibss cell or acting as an AP and creating the bss
	 */
	IEEE80211_LINKED,

	/* same as LINKED, but the driver shall apply RX filter
	 * rules as we are in NO_LINK mode. As the card is still
	 * logically linked, but it is doing a syncro site survey
	 * then it will be back to LINKED state.
	 */
	IEEE80211_LINKED_SCANNING,

};
#endif /* PLATFORM_FREEBSD */

#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
#define DEFAULT_FTS 2346
#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
#define MAC_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5]
#define MAC_SFMT "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx"
#define MAC_SARG(x) ((u8*)(x)),((u8*)(x)) + 1,((u8*)(x)) + 2,((u8*)(x)) + 3,((u8*)(x)) + 4,((u8*)(x)) + 5
#define IP_FMT "%d.%d.%d.%d"
#define IP_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3]
#define PORT_FMT "%u"
#define PORT_ARG(x) ntohs(*((u16 *)(x)))

#define is_multicast_mac_addr(Addr) ((((Addr[0]) & 0x01) == 0x01) && ((Addr[0]) != 0xff))
#define is_broadcast_mac_addr(Addr) ((((Addr[0]) & 0xff) == 0xff) && (((Addr[1]) & 0xff) == 0xff) && \
	(((Addr[2]) & 0xff) == 0xff) && (((Addr[3]) & 0xff) == 0xff) && (((Addr[4]) & 0xff) == 0xff) && \
				     (((Addr[5]) & 0xff) == 0xff))
#define is_zero_mac_addr(Addr)	((Addr[0] == 0x00) && (Addr[1] == 0x00) && (Addr[2] == 0x00) &&   \
                (Addr[3] == 0x00) && (Addr[4] == 0x00) && (Addr[5] == 0x00))


#define CFG_IEEE80211_RESERVE_FCS (1<<0)
#define CFG_IEEE80211_COMPUTE_FCS (1<<1)

typedef struct tx_pending_t {
	int frag;
	struct ieee80211_txb *txb;
} tx_pending_t;



#define TID_NUM	16

#define IEEE_A            (1<<0)
#define IEEE_B            (1<<1)
#define IEEE_G            (1<<2)
#define IEEE_MODE_MASK    (IEEE_A | IEEE_B | IEEE_G)

/* Baron move to ieee80211.c */
int ieee80211_is_empty_essid(const char *essid, int essid_len);
int ieee80211_get_hdrlen(u16 fc);

#if 0
	/* Action frame categories (IEEE 802.11-2007, 7.3.1.11, Table 7-24) */
	#define WLAN_ACTION_SPECTRUM_MGMT 0
	#define WLAN_ACTION_QOS 1
	#define WLAN_ACTION_DLS 2
	#define WLAN_ACTION_BLOCK_ACK 3
	#define WLAN_ACTION_RADIO_MEASUREMENT 5
	#define WLAN_ACTION_FT 6
	#define WLAN_ACTION_SA_QUERY 8
	#define WLAN_ACTION_WMM 17
#endif


/* Action category code */
enum rtw_ieee80211_category {
	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	RTW_WLAN_CATEGORY_QOS = 1,
	RTW_WLAN_CATEGORY_DLS = 2,
	RTW_WLAN_CATEGORY_BACK = 3,
	RTW_WLAN_CATEGORY_PUBLIC = 4, /* IEEE 802.11 public action frames */
	RTW_WLAN_CATEGORY_RADIO_MEAS = 5,
	RTW_WLAN_CATEGORY_FT = 6,
	RTW_WLAN_CATEGORY_HT = 7,
	RTW_WLAN_CATEGORY_SA_QUERY = 8,
	RTW_WLAN_CATEGORY_WNM = 10,
	RTW_WLAN_CATEGORY_UNPROTECTED_WNM = 11, /* add for CONFIG_IEEE80211W, none 11w also can use */
	RTW_WLAN_CATEGORY_TDLS = 12,
	RTW_WLAN_CATEGORY_MESH = 13,
	RTW_WLAN_CATEGORY_MULTIHOP = 14,
	RTW_WLAN_CATEGORY_SELF_PROTECTED = 15,
	RTW_WLAN_CATEGORY_WMM = 17,
	RTW_WLAN_CATEGORY_VHT = 21,
	RTW_WLAN_CATEGORY_P2P = 0x7f,/* P2P action frames */
};

#define CATEGORY_IS_GROUP_PRIVACY(cat) \
	(cat == RTW_WLAN_CATEGORY_MESH || cat == RTW_WLAN_CATEGORY_MULTIHOP)

#define CATEGORY_IS_NON_ROBUST(cat) \
	(cat == RTW_WLAN_CATEGORY_PUBLIC \
	|| cat == RTW_WLAN_CATEGORY_HT \
	|| cat == RTW_WLAN_CATEGORY_UNPROTECTED_WNM \
	|| cat == RTW_WLAN_CATEGORY_SELF_PROTECTED \
	|| cat == RTW_WLAN_CATEGORY_VHT \
	|| cat == RTW_WLAN_CATEGORY_P2P)

#define CATEGORY_IS_ROBUST(cat) !CATEGORY_IS_NON_ROBUST(cat)

/* SPECTRUM_MGMT action code */
enum rtw_ieee80211_spectrum_mgmt_actioncode {
	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
};

/* SELF_PROTECTED action code */
enum rtw_ieee80211_self_protected_actioncode {
	RTW_ACT_SELF_PROTECTED_RSVD = 0,
	RTW_ACT_SELF_PROTECTED_MESH_OPEN = 1,
	RTW_ACT_SELF_PROTECTED_MESH_CONF = 2,
	RTW_ACT_SELF_PROTECTED_MESH_CLOSE = 3,
	RTW_ACT_SELF_PROTECTED_MESH_GK_INFORM = 4,
	RTW_ACT_SELF_PROTECTED_MESH_GK_ACK = 5,
	RTW_ACT_SELF_PROTECTED_NUM,
};

/* MESH action code */
enum rtw_ieee80211_mesh_actioncode {
	RTW_ACT_MESH_LINK_METRIC_REPORT,
	RTW_ACT_MESH_HWMP_PATH_SELECTION,
	RTW_ACT_MESH_GATE_ANNOUNCEMENT,
	RTW_ACT_MESH_CONGESTION_CONTROL_NOTIFICATION,
	RTW_ACT_MESH_MCCA_SETUP_REQUEST,
	RTW_ACT_MESH_MCCA_SETUP_REPLY,
	RTW_ACT_MESH_MCCA_ADVERTISEMENT_REQUEST,
	RTW_ACT_MESH_MCCA_ADVERTISEMENT,
	RTW_ACT_MESH_MCCA_TEARDOWN,
	RTW_ACT_MESH_TBTT_ADJUSTMENT_REQUEST,
	RTW_ACT_MESH_TBTT_ADJUSTMENT_RESPONSE,
};

enum _PUBLIC_ACTION {
	ACT_PUBLIC_BSSCOEXIST = 0, /* 20/40 BSS Coexistence */
	ACT_PUBLIC_DSE_ENABLE = 1,
	ACT_PUBLIC_DSE_DEENABLE = 2,
	ACT_PUBLIC_DSE_REG_LOCATION = 3,
	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
	ACT_PUBLIC_DSE_MSR_REQ = 5,
	ACT_PUBLIC_DSE_MSR_RPRT = 6,
	ACT_PUBLIC_MP = 7, /* Measurement Pilot */
	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
	ACT_PUBLIC_VENDOR = 9, /* for WIFI_DIRECT */
	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
	ACT_PUBLIC_LOCATION_TRACK = 15,
	ACT_PUBLIC_MAX
};

#ifdef CONFIG_TDLS
enum TDLS_ACTION_FIELD {
	TDLS_SETUP_REQUEST = 0,
	TDLS_SETUP_RESPONSE = 1,
	TDLS_SETUP_CONFIRM = 2,
	TDLS_TEARDOWN = 3,
	TDLS_PEER_TRAFFIC_INDICATION = 4,
	TDLS_CHANNEL_SWITCH_REQUEST = 5,
	TDLS_CHANNEL_SWITCH_RESPONSE = 6,
	TDLS_PEER_PSM_REQUEST = 7,
	TDLS_PEER_PSM_RESPONSE = 8,
	TDLS_PEER_TRAFFIC_RESPONSE = 9,
	TDLS_DISCOVERY_REQUEST = 10,
	TDLS_DISCOVERY_RESPONSE = 14,	/* it's used in public action frame */
};

#define	TUNNELED_PROBE_REQ	15
#define	TUNNELED_PROBE_RSP	16
#endif /* CONFIG_TDLS */

/* BACK action code */
enum rtw_ieee80211_back_actioncode {
	RTW_WLAN_ACTION_ADDBA_REQ = 0,
	RTW_WLAN_ACTION_ADDBA_RESP = 1,
	RTW_WLAN_ACTION_DELBA = 2,
};

/* HT features action code */
enum rtw_ieee80211_ht_actioncode {
	RTW_WLAN_ACTION_HT_NOTI_CHNL_WIDTH = 0,
	RTW_WLAN_ACTION_HT_SM_PS = 1,
	RTW_WLAN_ACTION_HT_PSMP = 2,
	RTW_WLAN_ACTION_HT_SET_PCO_PHASE = 3,
	RTW_WLAN_ACTION_HT_CSI = 4,
	RTW_WLAN_ACTION_HT_NON_COMPRESS_BEAMFORMING = 5,
	RTW_WLAN_ACTION_HT_COMPRESS_BEAMFORMING = 6,
	RTW_WLAN_ACTION_HT_ASEL_FEEDBACK = 7,
};

/* BACK (block-ack) parties */
enum rtw_ieee80211_back_parties {
	RTW_WLAN_BACK_RECIPIENT = 0,
	RTW_WLAN_BACK_INITIATOR = 1,
	RTW_WLAN_BACK_TIMER = 2,
};

/*20/40 BSS Coexistence element */
#define RTW_WLAN_20_40_BSS_COEX_INFO_REQ            BIT(0)
#define RTW_WLAN_20_40_BSS_COEX_40MHZ_INTOL         BIT(1)
#define RTW_WLAN_20_40_BSS_COEX_20MHZ_WIDTH_REQ     BIT(2)
#define RTW_WLAN_20_40_BSS_COEX_OBSS_EXEMPT_REQ     BIT(3)
#define RTW_WLAN_20_40_BSS_COEX_OBSS_EXEMPT_GRNT    BIT(4)

/* VHT features action code */
enum rtw_ieee80211_vht_actioncode {
	RTW_WLAN_ACTION_VHT_COMPRESSED_BEAMFORMING = 0,
	RTW_WLAN_ACTION_VHT_GROUPID_MANAGEMENT = 1,
	RTW_WLAN_ACTION_VHT_OPMODE_NOTIFICATION = 2,
};

/*IEEE 802.11r action code*/
#ifdef CONFIG_RTW_80211R
enum rtw_ieee80211_ft_actioncode {
	RTW_WLAN_ACTION_FT_RESV,
	RTW_WLAN_ACTION_FT_REQ,
	RTW_WLAN_ACTION_FT_RSP,
	RTW_WLAN_ACTION_FT_CONF,
	RTW_WLAN_ACTION_FT_ACK,
	RTW_WLAN_ACTION_FT_MAX,
};
#endif

#ifdef CONFIG_RTW_WNM
enum rtw_ieee80211_wnm_actioncode {
	RTW_WLAN_ACTION_WNM_BTM_QUERY = 6,
	RTW_WLAN_ACTION_WNM_BTM_REQ = 7,
	RTW_WLAN_ACTION_WNM_BTM_RSP = 8,
};
#endif

#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
				* 00:50:F2 */
#ifndef PLATFORM_FREEBSD /* Baron BSD has defined */
	#define WME_OUI_TYPE 2
#endif /* PLATFORM_FREEBSD */
#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
#define WME_VERSION 1

#define WME_ACTION_CODE_SETUP_REQUEST 0
#define WME_ACTION_CODE_SETUP_RESPONSE 1
#define WME_ACTION_CODE_TEARDOWN 2

#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
#define WME_SETUP_RESPONSE_STATUS_REFUSED 3

#define WME_TSPEC_DIRECTION_UPLINK 0
#define WME_TSPEC_DIRECTION_DOWNLINK 1
#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3


#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */

#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */

enum rtw_ieee80211_rann_flags {
	RTW_RANN_FLAG_IS_GATE = 1 << 0,
};

/**
 * enum rtw_ieee80211_preq_flags - mesh PREQ element flags
 *
 * @RTW_IEEE80211_PREQ_IS_GATE_FLAG: Gate Announcement subfield
 * @RTW_IEEE80211_PREQ_PROACTIVE_PREP_FLAG: proactive PREP subfield
 */
enum rtw_ieee80211_preq_flags {
	RTW_IEEE80211_PREQ_IS_GATE_FLAG = 1 << 0,
	RTW_IEEE80211_PREQ_PROACTIVE_PREP_FLAG	= 1 << 2,
};

/**
 * enum rtw_ieee80211_preq_target_flags - mesh PREQ element per target flags
 *
 * @RTW_IEEE80211_PREQ_TO_FLAG: target only subfield
 * @RTW_IEEE80211_PREQ_USN_FLAG: unknown target HWMP sequence number subfield
 */
enum rtw_ieee80211_preq_target_flags {
	RTW_IEEE80211_PREQ_TO_FLAG	= 1<<0,
	RTW_IEEE80211_PREQ_USN_FLAG	= 1<<2,
};

/**
 * enum rtw_ieee80211_root_mode_identifier - root mesh STA mode identifier
 *
 * These attribute are used by dot11MeshHWMPRootMode to set root mesh STA mode
 *
 * @RTW_IEEE80211_ROOTMODE_NO_ROOT: the mesh STA is not a root mesh STA (default)
 * @RTW_IEEE80211_ROOTMODE_ROOT: the mesh STA is a root mesh STA if greater than
 *	this value
 * @RTW_IEEE80211_PROACTIVE_PREQ_NO_PREP: the mesh STA is a root mesh STA supports
 *	the proactive PREQ with proactive PREP subfield set to 0
 * @RTW_IEEE80211_PROACTIVE_PREQ_WITH_PREP: the mesh STA is a root mesh STA
 *	supports the proactive PREQ with proactive PREP subfield set to 1
 * @RTW_IEEE80211_PROACTIVE_RANN: the mesh STA is a root mesh STA supports
 *	the proactive RANN
 */
enum rtw_ieee80211_root_mode_identifier {
	RTW_IEEE80211_ROOTMODE_NO_ROOT = 0,
	RTW_IEEE80211_ROOTMODE_ROOT = 1,
	RTW_IEEE80211_PROACTIVE_PREQ_NO_PREP = 2,
	RTW_IEEE80211_PROACTIVE_PREQ_WITH_PREP = 3,
	RTW_IEEE80211_PROACTIVE_RANN = 4,
};

/**
 * enum rtw_ieee80211_channel_flags - channel flags
 *
 * Channel flags set by the regulatory control code.
 *
 * @RTW_IEEE80211_CHAN_DISABLED: This channel is disabled.
 * @RTW_IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted
 *      on this channel.
 * @RTW_IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
 * @RTW_IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
 * @RTW_IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
 *      is not permitted.
 * @RTW_IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
 *      is not permitted.
 */
enum rtw_ieee80211_channel_flags {
	RTW_IEEE80211_CHAN_DISABLED         = 1 << 0,
	RTW_IEEE80211_CHAN_PASSIVE_SCAN     = 1 << 1,
	RTW_IEEE80211_CHAN_NO_IBSS          = 1 << 2,
	RTW_IEEE80211_CHAN_RADAR            = 1 << 3,
	RTW_IEEE80211_CHAN_NO_HT40PLUS      = 1 << 4,
	RTW_IEEE80211_CHAN_NO_HT40MINUS     = 1 << 5,
};

#define RTW_IEEE80211_CHAN_NO_HT40 \
	(RTW_IEEE80211_CHAN_NO_HT40PLUS | RTW_IEEE80211_CHAN_NO_HT40MINUS)

/* Represent channel details, subset of ieee80211_channel */
struct rtw_ieee80211_channel {
	/* enum ieee80211_band band; */
	/* u16 center_freq; */
	u16 hw_value;
	u32 flags;
	/* int max_antenna_gain; */
	/* int max_power; */
	/* int max_reg_power; */
	/* bool beacon_found; */
	/* u32 orig_flags; */
	/* int orig_mag; */
	/* int orig_mpwr; */
};

#define CHAN_FMT \
	/*"band:%d, "*/ \
	/*"center_freq:%u, "*/ \
	"hw_value:%u, " \
	"flags:0x%08x" \
	/*"max_antenna_gain:%d\n"*/ \
	/*"max_power:%d\n"*/ \
	/*"max_reg_power:%d\n"*/ \
	/*"beacon_found:%u\n"*/ \
	/*"orig_flags:0x%08x\n"*/ \
	/*"orig_mag:%d\n"*/ \
	/*"orig_mpwr:%d\n"*/

#define CHAN_ARG(channel) \
	/*(channel)->band*/ \
	/*, (channel)->center_freq*/ \
	(channel)->hw_value \
	, (channel)->flags \
	/*, (channel)->max_antenna_gain*/ \
	/*, (channel)->max_power*/ \
	/*, (channel)->max_reg_power*/ \
	/*, (channel)->beacon_found*/ \
	/*, (channel)->orig_flags*/ \
	/*, (channel)->orig_mag*/ \
	/*, (channel)->orig_mpwr*/ \

/* Parsed Information Elements */
struct rtw_ieee802_11_elems {
	u8 *ssid;
	u8 ssid_len;
	u8 *supp_rates;
	u8 supp_rates_len;
	u8 *fh_params;
	u8 fh_params_len;
	u8 *ds_params;
	u8 ds_params_len;
	u8 *cf_params;
	u8 cf_params_len;
	u8 *tim;
	u8 tim_len;
	u8 *ibss_params;
	u8 ibss_params_len;
	u8 *challenge;
	u8 challenge_len;
	u8 *erp_info;
	u8 erp_info_len;
	u8 *ext_supp_rates;
	u8 ext_supp_rates_len;
	u8 *wpa_ie;
	u8 wpa_ie_len;
	u8 *rsn_ie;
	u8 rsn_ie_len;
	u8 *wme;
	u8 wme_len;
	u8 *wme_tspec;
	u8 wme_tspec_len;
	u8 *wps_ie;
	u8 wps_ie_len;
	u8 *power_cap;
	u8 power_cap_len;
	u8 *supp_channels;
	u8 supp_channels_len;
	u8 *mdie;
	u8 mdie_len;
	u8 *ftie;
	u8 ftie_len;
	u8 *timeout_int;
	u8 timeout_int_len;
	u8 *ht_capabilities;
	u8 ht_capabilities_len;
	u8 *ht_operation;
	u8 ht_operation_len;
	u8 *vendor_ht_cap;
	u8 vendor_ht_cap_len;
	u8 *vht_capabilities;
	u8 vht_capabilities_len;
	u8 *vht_operation;
	u8 vht_operation_len;
	u8 *vht_op_mode_notify;
	u8 vht_op_mode_notify_len;
	u8 *rm_en_cap;
	u8 rm_en_cap_len;
#ifdef CONFIG_RTW_MESH
	u8 *preq;
	u8 preq_len;
	u8 *prep;
	u8 prep_len;
	u8 *perr;
	u8 perr_len;
	u8 *rann;
	u8 rann_len;
#endif
};

typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;

ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
				struct rtw_ieee802_11_elems *elems,
				int show_errors);

u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
u8 *rtw_set_ie(u8 *pbuf, sint index, uint len, const u8 *source, uint *frlen);

enum secondary_ch_offset {
	SCN = 0, /* no secondary channel */
	SCA = 1, /* secondary channel above */
	SCB = 3,  /* secondary channel below */
};
u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset);
u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset);
u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode, u8 new_ch, u8 ch_switch_cnt);
u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset);
u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl, u8 flags, u16 reason, u16 precedence);

u8 *rtw_get_ie(const u8 *pbuf, sint index, sint *len, sint limit);
u8 rtw_update_rate_bymode(WLAN_BSSID_EX *pbss_network, u32 mode);

u8 *rtw_get_ie_ex(const u8 *in_ie, uint in_len, u8 eid, const u8 *oui, u8 oui_len, u8 *ie, uint *ielen);
int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len);

void rtw_set_supported_rate(u8 *SupportedRates, uint mode) ;

#define GET_RSN_CAP_MFP_OPTION(cap)	LE_BITS_TO_2BYTE(((u8 *)(cap)), 6, 2)

#define MFP_NO			0
#define MFP_INVALID		1
#define MFP_OPTIONAL	2
#define MFP_REQUIRED	3

struct rsne_info {
	u8 *gcs;
	u16 pcs_cnt;
	u8 *pcs_list;
	u16 akm_cnt;
	u8 *akm_list;
	u8 *cap;
	u16 pmkid_cnt;
	u8 *pmkid_list;
	u8 *gmcs;

	u8 err;
};
int rtw_rsne_info_parse(const u8 *ie, uint ie_len, struct rsne_info *info);

unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
int rtw_get_wpa_cipher_suite(u8 *s);
int rtw_get_wpa2_cipher_suite(u8 *s);
int rtw_get_wapi_ie(u8 *in_ie, uint in_len, u8 *wapi_ie, u16 *wapi_len);
int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, u32 *akm);
int rtw_parse_wpa2_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, u32 *akm, u8 *mfp_opt);

int rtw_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len, u8 *wpa_ie, u16 *wpa_len);

u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, enum bss_type frame_type);
u8 *rtw_get_wps_ie(const u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id , u8 *buf_attr, u32 *len_attr);
u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id , u8 *buf_content, uint *len_content);

u8 *rtw_get_owe_ie(const u8 *in_ie, uint in_len, u8 *owe_ie, uint *owe_ielen);

/**
 * for_each_ie - iterate over continuous IEs
 * @ie:
 * @buf:
 * @buf_len:
 */
#define for_each_ie(ie, buf, buf_len) \
	for (ie = (void *)buf; (((u8 *)ie) - ((u8 *)buf) + 1) < buf_len; ie = (void *)(((u8 *)ie) + *(((u8 *)ie)+1) + 2))

void dump_ies(void *sel, const u8 *buf, u32 buf_len);

#ifdef CONFIG_80211N_HT
#define HT_SC_OFFSET_MAX 4
extern const char *const _ht_sc_offset_str[];
#define ht_sc_offset_str(sc) (((sc) >= HT_SC_OFFSET_MAX) ? _ht_sc_offset_str[2] : _ht_sc_offset_str[(sc)])

void dump_ht_cap_ie_content(void *sel, const u8 *buf, u32 buf_len);
#endif

void dump_wps_ie(void *sel, const u8 *ie, u32 ie_len);

void rtw_ies_get_chbw(u8 *ies, int ies_len, u8 *ch, u8 *bw, u8 *offset, u8 ht, u8 vht);

void rtw_bss_get_chbw(WLAN_BSSID_EX *bss, u8 *ch, u8 *bw, u8 *offset, u8 ht, u8 vht);

bool rtw_is_chbw_grouped(u8 ch_a, u8 bw_a, u8 offset_a
	, u8 ch_b, u8 bw_b, u8 offset_b);
void rtw_sync_chbw(u8 *req_ch, u8 *req_bw, u8 *req_offset
	, u8 *g_ch, u8 *g_bw, u8 *g_offset);

u32 rtw_get_p2p_merged_ies_len(u8 *in_ie, u32 in_len);
int rtw_p2p_merge_ies(u8 *in_ie, u32 in_len, u8 *merge_ie);
void dump_p2p_ie(void *sel, const u8 *ie, u32 ie_len);
u8 *rtw_get_p2p_ie(const u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen);
u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id, u8 *buf_attr, u32 *len_attr);
u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id, u8 *buf_content, uint *len_content);
u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr);
uint rtw_del_p2p_ie(u8 *ies, uint ies_len_ori, const char *msg);
uint rtw_del_p2p_attr(u8 *ie, uint ielen_ori, u8 attr_id);
u8 *rtw_bss_ex_get_p2p_ie(WLAN_BSSID_EX *bss_ex, u8 *p2p_ie, uint *p2p_ielen);
void rtw_bss_ex_del_p2p_ie(WLAN_BSSID_EX *bss_ex);
void rtw_bss_ex_del_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);

void dump_wfd_ie(void *sel, const u8 *ie, u32 ie_len);
u8 *rtw_get_wfd_ie(const u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
u8 *rtw_get_wfd_attr(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *buf_attr, u32 *len_attr);
u8 *rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *buf_content, uint *len_content);
uint rtw_del_wfd_ie(u8 *ies, uint ies_len_ori, const char *msg);
uint rtw_del_wfd_attr(u8 *ie, uint ielen_ori, u8 attr_id);
u8 *rtw_bss_ex_get_wfd_ie(WLAN_BSSID_EX *bss_ex, u8 *wfd_ie, uint *wfd_ielen);
void rtw_bss_ex_del_wfd_ie(WLAN_BSSID_EX *bss_ex);
void rtw_bss_ex_del_wfd_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);

uint	rtw_get_rateset_len(u8	*rateset);

struct registry_priv;
int rtw_generate_ie(struct registry_priv *pregistrypriv);

int rtw_get_bit_value_from_ieee_value(u8 val);

uint	rtw_is_cckrates_included(u8 *rate);

uint	rtw_is_cckratesonly_included(u8 *rate);
uint rtw_get_cckrate_size(u8 *rate,u32 rate_length);
int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);

u8 rtw_check_invalid_mac_address(u8 *mac_addr, u8 check_local_bit);
void rtw_macaddr_cfg(u8 *out, const u8 *hw_mac_addr);

u16 rtw_ht_mcs_rate(u8 bw_40MHz, u8 short_GI, unsigned char *MCS_rate);
u8	rtw_ht_mcsset_to_nss(u8 *supp_mcs_set);
u32	rtw_ht_mcs_set_to_bitmap(u8 *mcs_set, u8 nss);

int rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8 *category, u8 *action);
const char *action_public_str(u8 action);

u8 key_2char2num(u8 hch, u8 lch);
u8 str_2char2num(u8 hch, u8 lch);
void macstr2num(u8 *dst, u8 *src);
u8 convert_ip_addr(u8 hch, u8 mch, u8 lch);
int wifirate2_ratetbl_inx(unsigned char rate);


#endif /* IEEE80211_H */
                                                                       rtl8822bu/src/include/rtl8821cs_hal.h                                                               0000644 0001750 0001750 00000001507 14214766567 016076  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8821CS_HAL_H_
#define _RTL8821CS_HAL_H_

#include <drv_types.h>		/* PADAPTER */

/* rtl8821cs_ops.c */
u8 rtl8821cs_set_hal_ops(PADAPTER);

#endif /* _RTL8821CS_HAL_H_ */
                                                                                                                                                                                         rtl8822bu/src/include/hal_com_led.h                                                                 0000644 0001750 0001750 00000036031 14214766567 016026  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_COMMON_LED_H_
#define __HAL_COMMON_LED_H_

#define NO_LED 0
#define HW_LED 1

#ifdef CONFIG_RTW_LED
#define MSECS(t)        (HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)

/* ********************************************************************************
 *	LED Behavior Constant.
 * ********************************************************************************
 * Default LED behavior.
 *   */
#define LED_BLINK_NORMAL_INTERVAL	100
#define LED_BLINK_SLOWLY_INTERVAL	200
#define LED_BLINK_LONG_INTERVAL	400
#define LED_INITIAL_INTERVAL		1800

/* LED Customerization */

/* NETTRONIX */
#define LED_BLINK_NORMAL_INTERVAL_NETTRONIX	100
#define LED_BLINK_SLOWLY_INTERVAL_NETTRONIX	2000

/* PORNET */
#define LED_BLINK_SLOWLY_INTERVAL_PORNET	1000
#define LED_BLINK_NORMAL_INTERVAL_PORNET	100
#define LED_BLINK_FAST_INTERVAL_BITLAND		30

/* AzWave. */
#define LED_CM2_BLINK_ON_INTERVAL		250
#define LED_CM2_BLINK_OFF_INTERVAL		4750
#define LED_CM8_BLINK_OFF_INTERVAL		3750	/* for QMI */

/* RunTop */
#define LED_RunTop_BLINK_INTERVAL		300

/* ALPHA */
#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
#define LED_BLINK_NO_LINK_INTERVAL_ALPHA_500MS 500 /* add by ylb 20121012 for customer led for alpha */
#define LED_BLINK_LINK_INTERVAL_ALPHA		500	/* 500 */
#define LED_BLINK_SCAN_INTERVAL_ALPHA		180	/* 150 */
#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000

/* 111122 by hpfan: Customized for Xavi */
#define LED_CM11_BLINK_INTERVAL			300
#define LED_CM11_LINK_ON_INTERVEL		3000

/* Netgear */
#define LED_BLINK_LINK_INTERVAL_NETGEAR		500
#define LED_BLINK_LINK_SLOWLY_INTERVAL_NETGEAR		1000

#define LED_WPS_BLINK_OFF_INTERVAL_NETGEAR		100
#define LED_WPS_BLINK_ON_INTERVAL_NETGEAR		500

/* Belkin AC950 */
#define LED_BLINK_LINK_INTERVAL_ON_BELKIN		200
#define LED_BLINK_LINK_INTERVAL_OFF_BELKIN		100
#define LED_BLINK_ERROR_INTERVAL_BELKIN		100

/* by chiyokolin for Azurewave */
#define LED_CM12_BLINK_INTERVAL_5Mbps		160
#define LED_CM12_BLINK_INTERVAL_10Mbps		80
#define LED_CM12_BLINK_INTERVAL_20Mbps		50
#define LED_CM12_BLINK_INTERVAL_40Mbps		40
#define LED_CM12_BLINK_INTERVAL_80Mbps		30
#define LED_CM12_BLINK_INTERVAL_MAXMbps		25

/* Dlink */
#define	LED_BLINK_NO_LINK_INTERVAL		1000
#define	LED_BLINK_LINK_IDEL_INTERVAL		100

#define	LED_BLINK_SCAN_ON_INTERVAL		30
#define	LED_BLINK_SCAN_OFF_INTERVAL		300

#define LED_WPS_BLINK_ON_INTERVAL_DLINK		30
#define LED_WPS_BLINK_OFF_INTERVAL_DLINK			300
#define LED_WPS_BLINK_LINKED_ON_INTERVAL_DLINK			5000

/* ********************************************************************************
 * LED object.
 * ******************************************************************************** */

typedef enum _LED_CTL_MODE {
	LED_CTL_POWER_ON = 1,
	LED_CTL_LINK = 2,
	LED_CTL_NO_LINK = 3,
	LED_CTL_TX = 4, /* unspecific data TX, including single & group addressed */
	LED_CTL_RX = 5, /* unspecific data RX, including single & group addressed */
	LED_CTL_UC_TX = 6, /* single addressed data TX */
	LED_CTL_UC_RX = 7, /* single addressed data RX */
	LED_CTL_BMC_TX = 8, /* group addressed data TX */
	LED_CTL_BMC_RX = 9, /* group addressed data RX */
	LED_CTL_SITE_SURVEY = 10,
	LED_CTL_POWER_OFF = 11,
	LED_CTL_START_TO_LINK = 12,
	LED_CTL_START_WPS = 13,
	LED_CTL_STOP_WPS = 14,
	LED_CTL_START_WPS_BOTTON = 15, /* added for runtop */
	LED_CTL_STOP_WPS_FAIL = 16, /* added for ALPHA	 */
	LED_CTL_STOP_WPS_FAIL_OVERLAP = 17, /* added for BELKIN */
	LED_CTL_CONNECTION_NO_TRANSFER = 18,
} LED_CTL_MODE;

typedef	enum _LED_STATE {
	LED_UNKNOWN = 0,
	RTW_LED_ON = 1,
	RTW_LED_OFF = 2,
	LED_BLINK_NORMAL = 3,
	LED_BLINK_SLOWLY = 4,
	LED_BLINK_POWER_ON = 5,
	LED_BLINK_SCAN = 6,	/* LED is blinking during scanning period, the # of times to blink is depend on time for scanning. */
	LED_BLINK_NO_LINK = 7, /* LED is blinking during no link state. */
	LED_BLINK_StartToBlink = 8, /* Customzied for Sercomm Printer Server case */
	LED_BLINK_TXRX = 9,
	LED_BLINK_WPS = 10,	/* LED is blinkg during WPS communication */
	LED_BLINK_WPS_STOP = 11,	/* for ALPHA */
	LED_BLINK_WPS_STOP_OVERLAP = 12,	/* for BELKIN */
	LED_BLINK_RUNTOP = 13,	/* Customized for RunTop */
	LED_BLINK_CAMEO = 14,
	LED_BLINK_XAVI = 15,
	LED_BLINK_ALWAYS_ON = 16,
	LED_BLINK_LINK_IN_PROCESS = 17,  /* Customized for Belkin AC950 */
	LED_BLINK_AUTH_ERROR = 18,  /* Customized for Belkin AC950 */
	LED_BLINK_Azurewave_5Mbps = 19,
	LED_BLINK_Azurewave_10Mbps = 20,
	LED_BLINK_Azurewave_20Mbps = 21,
	LED_BLINK_Azurewave_40Mbps = 22,
	LED_BLINK_Azurewave_80Mbps = 23,
	LED_BLINK_Azurewave_MAXMbps = 24,
	LED_BLINK_LINK_IDEL = 25,
	LED_BLINK_WPS_LINKED = 26,
} LED_STATE;

typedef enum _LED_PIN {
	LED_PIN_GPIO0,
	LED_PIN_LED0,
	LED_PIN_LED1,
	LED_PIN_LED2
} LED_PIN;


/* ********************************************************************************
 * PCIE LED Definition.
 * ******************************************************************************** */
#ifdef CONFIG_PCI_HCI
typedef	enum _LED_STRATEGY_PCIE {
	/* start from 2 */
	SW_LED_MODE_UC_TRX_ONLY = 2,
	SW_LED_MODE0, /* SW control 1 LED via GPIO0. It is default option. */
	SW_LED_MODE1, /* SW control for PCI Express */
	SW_LED_MODE2, /* SW control for Cameo. */
	SW_LED_MODE3, /* SW contorl for RunTop. */
	SW_LED_MODE4, /* SW control for Netcore */
	SW_LED_MODE5, /* added by vivi, for led new mode, DLINK */
	SW_LED_MODE6, /* added by vivi, for led new mode, PRONET */
	SW_LED_MODE7, /* added by chiyokolin, for Lenovo, PCI Express Minicard Spec Rev.1.2 spec */
	SW_LED_MODE8, /* added by chiyokolin, for QMI */
	SW_LED_MODE9, /* added by chiyokolin, for BITLAND-LENOVO, PCI Express Minicard Spec Rev.1.1	 */
	SW_LED_MODE10, /* added by chiyokolin, for Edimax-ASUS */
	SW_LED_MODE11,	/* added by hpfan, for Xavi */
	SW_LED_MODE12,	/* added by chiyokolin, for Azurewave */
} LED_STRATEGY_PCIE, *PLED_STRATEGY_PCIE;

typedef struct _LED_PCIE {
	PADAPTER		padapter;

	LED_PIN			LedPin;	/* Identify how to implement this SW led. */

	LED_STATE		CurrLedState; /* Current LED state. */
	BOOLEAN			bLedOn; /* TRUE if LED is ON, FALSE if LED is OFF. */

	BOOLEAN			bLedBlinkInProgress; /* TRUE if it is blinking, FALSE o.w.. */
	BOOLEAN			bLedWPSBlinkInProgress; /* TRUE if it is blinking, FALSE o.w.. */

	BOOLEAN			bLedSlowBlinkInProgress;/* added by vivi, for led new mode */
	u32				BlinkTimes; /* Number of times to toggle led state for blinking. */
	LED_STATE		BlinkingLedState; /* Next state for blinking, either LED_ON or LED_OFF are. */

	_timer			BlinkTimer; /* Timer object for led blinking. */
} LED_PCIE, *PLED_PCIE;

typedef struct _LED_PCIE	LED_DATA, *PLED_DATA;
typedef enum _LED_STRATEGY_PCIE	LED_STRATEGY, *PLED_STRATEGY;

void
LedControlPCIE(
		PADAPTER		Adapter,
		LED_CTL_MODE		LedAction
);

void
gen_RefreshLedState(
		PADAPTER		Adapter);

/* ********************************************************************************
 * USB  LED Definition.
 * ******************************************************************************** */
#elif defined(CONFIG_USB_HCI)

#define IS_LED_WPS_BLINKING(_LED_USB)	(((PLED_USB)_LED_USB)->CurrLedState == LED_BLINK_WPS \
		|| ((PLED_USB)_LED_USB)->CurrLedState == LED_BLINK_WPS_STOP \
		|| ((PLED_USB)_LED_USB)->bLedWPSBlinkInProgress)

#define IS_LED_BLINKING(_LED_USB)	(((PLED_USB)_LED_USB)->bLedWPSBlinkInProgress \
		|| ((PLED_USB)_LED_USB)->bLedScanBlinkInProgress)


typedef	enum _LED_STRATEGY_USB {
	/* start from 2 */
	SW_LED_MODE_UC_TRX_ONLY = 2,
	SW_LED_MODE0, /* SW control 1 LED via GPIO0. It is default option. */
	SW_LED_MODE1, /* 2 LEDs, through LED0 and LED1. For ALPHA. */
	SW_LED_MODE2, /* SW control 1 LED via GPIO0, customized for AzWave 8187 minicard. */
	SW_LED_MODE3, /* SW control 1 LED via GPIO0, customized for Sercomm Printer Server case. */
	SW_LED_MODE4, /* for Edimax / Belkin */
	SW_LED_MODE5, /* for Sercomm / Belkin	 */
	SW_LED_MODE6,	/* for 88CU minicard, porting from ce SW_LED_MODE7 */
	SW_LED_MODE7,	/* for Netgear special requirement */
	SW_LED_MODE8, /* for LC */
	SW_LED_MODE9, /* for Belkin AC950 */
	SW_LED_MODE10, /* for Netgear A6200V2 */
	SW_LED_MODE11, /* for Edimax / ASUS */
	SW_LED_MODE12, /* for WNC/NEC */
	SW_LED_MODE13, /* for Netgear A6100, 8811Au */
	SW_LED_MODE14, /* for Buffalo, DNI, 8811Au */
	SW_LED_MODE15, /* for DLINK,  8811Au/8812AU	 */
} LED_STRATEGY_USB, *PLED_STRATEGY_USB;


typedef struct _LED_USB {
	PADAPTER			padapter;

	LED_PIN				LedPin;	/* Identify how to implement this SW led. */

	LED_STATE			CurrLedState; /* Current LED state. */
	BOOLEAN				bLedOn; /* TRUE if LED is ON, FALSE if LED is OFF. */

	BOOLEAN				bSWLedCtrl;

	BOOLEAN				bLedBlinkInProgress; /* TRUE if it is blinking, FALSE o.w.. */
	/* ALPHA, added by chiyoko, 20090106 */
	BOOLEAN				bLedNoLinkBlinkInProgress;
	BOOLEAN				bLedLinkBlinkInProgress;
	BOOLEAN				bLedStartToLinkBlinkInProgress;
	BOOLEAN				bLedScanBlinkInProgress;
	BOOLEAN				bLedWPSBlinkInProgress;

	u32					BlinkTimes; /* Number of times to toggle led state for blinking. */
	u8					BlinkCounter; /* Added for turn off overlap led after blinking a while, by page, 20120821 */
	LED_STATE			BlinkingLedState; /* Next state for blinking, either LED_ON or LED_OFF are. */

	_timer				BlinkTimer; /* Timer object for led blinking. */

	_workitem			BlinkWorkItem; /* Workitem used by BlinkTimer to manipulate H/W to blink LED.' */
} LED_USB, *PLED_USB;

typedef struct _LED_USB	LED_DATA, *PLED_DATA;
typedef enum _LED_STRATEGY_USB	LED_STRATEGY, *PLED_STRATEGY;
#ifdef CONFIG_RTW_SW_LED
void
LedControlUSB(
		PADAPTER		Adapter,
		LED_CTL_MODE		LedAction
);
#endif


/* ********************************************************************************
 * SDIO LED Definition.
 * ******************************************************************************** */
#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)

#define IS_LED_WPS_BLINKING(_LED_SDIO)	(((PLED_SDIO)_LED_SDIO)->CurrLedState == LED_BLINK_WPS \
		|| ((PLED_SDIO)_LED_SDIO)->CurrLedState == LED_BLINK_WPS_STOP \
		|| ((PLED_SDIO)_LED_SDIO)->bLedWPSBlinkInProgress)

#define IS_LED_BLINKING(_LED_SDIO)	(((PLED_SDIO)_LED_SDIO)->bLedWPSBlinkInProgress \
		|| ((PLED_SDIO)_LED_SDIO)->bLedScanBlinkInProgress)


typedef	enum _LED_STRATEGY_SDIO {
	/* start from 2 */
	SW_LED_MODE_UC_TRX_ONLY = 2,
	SW_LED_MODE0, /* SW control 1 LED via GPIO0. It is default option. */
	SW_LED_MODE1, /* 2 LEDs, through LED0 and LED1. For ALPHA. */
	SW_LED_MODE2, /* SW control 1 LED via GPIO0, customized for AzWave 8187 minicard. */
	SW_LED_MODE3, /* SW control 1 LED via GPIO0, customized for Sercomm Printer Server case. */
	SW_LED_MODE4, /* for Edimax / Belkin */
	SW_LED_MODE5, /* for Sercomm / Belkin	 */
	SW_LED_MODE6,	/* for 88CU minicard, porting from ce SW_LED_MODE7 */
} LED_STRATEGY_SDIO, *PLED_STRATEGY_SDIO;

typedef struct _LED_SDIO {
	PADAPTER			padapter;

	LED_PIN				LedPin;	/* Identify how to implement this SW led. */

	LED_STATE			CurrLedState; /* Current LED state. */
	BOOLEAN				bLedOn; /* TRUE if LED is ON, FALSE if LED is OFF. */

	BOOLEAN				bSWLedCtrl;

	BOOLEAN				bLedBlinkInProgress; /* TRUE if it is blinking, FALSE o.w.. */
	/* ALPHA, added by chiyoko, 20090106 */
	BOOLEAN				bLedNoLinkBlinkInProgress;
	BOOLEAN				bLedLinkBlinkInProgress;
	BOOLEAN				bLedStartToLinkBlinkInProgress;
	BOOLEAN				bLedScanBlinkInProgress;
	BOOLEAN				bLedWPSBlinkInProgress;

	u32					BlinkTimes; /* Number of times to toggle led state for blinking. */
	LED_STATE			BlinkingLedState; /* Next state for blinking, either LED_ON or LED_OFF are. */

	_timer				BlinkTimer; /* Timer object for led blinking. */

	_workitem			BlinkWorkItem; /* Workitem used by BlinkTimer to manipulate H/W to blink LED. */
} LED_SDIO, *PLED_SDIO;

typedef struct _LED_SDIO	LED_DATA, *PLED_DATA;
typedef enum _LED_STRATEGY_SDIO	LED_STRATEGY, *PLED_STRATEGY;

void
LedControlSDIO(
		PADAPTER		Adapter,
		LED_CTL_MODE		LedAction
);

#endif

struct led_priv {
	LED_STRATEGY		LedStrategy;
#ifdef CONFIG_RTW_SW_LED
	LED_DATA			SwLed0;
	LED_DATA			SwLed1;
	LED_DATA			SwLed2;
	u8					bRegUseLed;
	u8 iface_en_mask;
	u32 ctl_en_mask[CONFIG_IFACE_NUMBER];
	void (*LedControlHandler)(_adapter *padapter, LED_CTL_MODE LedAction);
	void (*SwLedOn)(_adapter *padapter, PLED_DATA pLed);
	void (*SwLedOff)(_adapter *padapter, PLED_DATA pLed);
#endif
};

#define SwLedOn(adapter, pLed) \
	do { \
		if (adapter_to_led(adapter)->SwLedOn) \
			adapter_to_led(adapter)->SwLedOn((adapter), (pLed)); \
	} while (0)

#define SwLedOff(adapter, pLed) \
	do { \
		if (adapter_to_led(adapter)->SwLedOff) \
			adapter_to_led(adapter)->SwLedOff((adapter), (pLed)); \
	} while (0)

void BlinkTimerCallback(void *data);
void BlinkWorkItemCallback(_workitem *work);

void ResetLedStatus(PLED_DATA pLed);

void
InitLed(
	_adapter			*padapter,
	PLED_DATA		pLed,
	LED_PIN			LedPin
);

void
DeInitLed(
	PLED_DATA		pLed
);

/* hal... */
extern void BlinkHandler(PLED_DATA	pLed);
void dump_led_config(void *sel, _adapter *adapter);
void rtw_led_set_strategy(_adapter *adapter, u8 strategy);
#endif /* CONFIG_RTW_LED */

#if defined(CONFIG_RTW_LED)
#define rtw_led_get_strategy(adapter) (adapter_to_led(adapter)->LedStrategy)
#else
#define rtw_led_get_strategy(adapter) NO_LED
#endif

#define IS_NO_LED_STRATEGY(s) ((s) == NO_LED)
#define IS_HW_LED_STRATEGY(s) ((s) == HW_LED)
#define IS_SW_LED_STRATEGY(s) ((s) != NO_LED && (s) != HW_LED)

#if defined(CONFIG_RTW_LED) && defined(CONFIG_RTW_SW_LED)

#ifndef CONFIG_RTW_SW_LED_TRX_DA_CLASSIFY
#define CONFIG_RTW_SW_LED_TRX_DA_CLASSIFY 0
#endif

#if CONFIG_RTW_SW_LED_TRX_DA_CLASSIFY
void rtw_sw_led_blink_uc_trx_only(LED_DATA *led);
void rtw_sw_led_ctl_mode_uc_trx_only(_adapter *adapter, LED_CTL_MODE ctl);
#endif
void rtw_led_control(_adapter *adapter, LED_CTL_MODE ctl);
void rtw_led_tx_control(_adapter *adapter, const u8 *da);
void rtw_led_rx_control(_adapter *adapter, const u8 *da);
void rtw_led_set_iface_en(_adapter *adapter, u8 en);
void rtw_led_set_iface_en_mask(_adapter *adapter, u8 mask);
void rtw_led_set_ctl_en_mask(_adapter *adapter, u32 ctl_mask);
void rtw_led_set_ctl_en_mask_primary(_adapter *adapter);
void rtw_led_set_ctl_en_mask_virtual(_adapter *adapter);
#else
#define rtw_led_control(adapter, ctl) do {} while (0)
#define rtw_led_tx_control(adapter, da) do {} while (0)
#define rtw_led_rx_control(adapter, da) do {} while (0)
#define rtw_led_set_iface_en(adapter, en) do {} while (0)
#define rtw_led_set_iface_en_mask(adapter, mask) do {} while (0)
#define rtw_led_set_ctl_en_mask(adapter, ctl_mask) do {} while (0)
#define rtw_led_set_ctl_en_mask_primary(adapter) do {} while (0)
#define rtw_led_set_ctl_en_mask_virtual(adapter) do {} while (0)
#endif /* defined(CONFIG_RTW_LED) && defined(CONFIG_RTW_SW_LED) */

#endif /*__HAL_COMMON_LED_H_*/

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8822bu_hal.h                                                               0000644 0001750 0001750 00000003451 14214766567 016100  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822BU_HAL_H_
#define _RTL8822BU_HAL_H_

#ifdef CONFIG_USB_HCI
	#include <drv_types.h>		/* PADAPTER */

	#ifdef CONFIG_USB_HCI
		#ifdef USB_PACKET_OFFSET_SZ
			#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
		#else
			#define PACKET_OFFSET_SZ (8)
		#endif
		#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
	#endif

	/* undefine MAX_RECVBUF_SZ from rtl8822b_hal.h  */
	#ifdef MAX_RECVBUF_SZ
		#undef MAX_RECVBUF_SZ
	#endif

	/* recv_buffer must be large than usb agg size */
	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			#ifdef CONFIG_PLATFORM_NOVATEK_NT72668
				#define MAX_RECVBUF_SZ (15360) /* 15k */
				#elif defined(CONFIG_PLATFORM_HISILICON)
				/* use 16k to workaround for HISILICON platform */
				#define MAX_RECVBUF_SZ (16384)
			#else
				#define MAX_RECVBUF_SZ (32768)
			#endif
		#else
			#define MAX_RECVBUF_SZ (4000)
		#endif
	#endif /* !MAX_RECVBUF_SZ */

	/* rtl8822bu_ops.c */
	void rtl8822bu_set_hal_ops(PADAPTER padapter);
	void rtl8822bu_set_hw_type(struct dvobj_priv *pdvobj);

	/* rtl8822bu_io.c */
	void rtl8822bu_set_intf_ops(struct _io_ops *pops);

#endif /* CONFIG_USB_HCI */


#endif /* _RTL8822BU_HAL_H_ */
                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8814a_sreset.h                                                             0000644 0001750 0001750 00000001630 14214766567 016451  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL88814A_SRESET_H_
#define _RTL8814A_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8814_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8814_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                        rtl8822bu/src/include/rtl8192f_xmit.h                                                               0000644 0001750 0001750 00000060160 14214766567 016134  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_XMIT_H__
#define __RTL8192F_XMIT_H__


#define MAX_TID (15)


#ifndef __INC_HAL8192FDESC_H
#define __INC_HAL8192FDESC_H

#define RX_STATUS_DESC_SIZE_8192F		24
#define RX_DRV_INFO_SIZE_UNIT_8192F 	8


/* DWORD 0 */
#define SET_RX_STATUS_DESC_PKT_LEN_8192F(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_8192F(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_8192F(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

#define GET_RX_STATUS_DESC_PKT_LEN_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICV_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_EOR_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_OWN_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_TID_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_AMSDU_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_A1_FIT_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
#define GET_RX_STATUS_DESC_CHKERR_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_IPVER_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_IS_TCPUDP__8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_CHK_VLD_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_MC_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#define GET_RX_STATUS_DESC_RX_IS_QOS_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_RPT_SEL_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)
#define GET_RX_STATUS_DESC_FCS_OK_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 31, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_HTC_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#ifdef CONFIG_USB_RX_AGGREGATION
#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
#endif
#define GET_RX_STATUS_DESC_PATTERN_MATCH_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_MATCH_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_MATCH_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

/* DWORD 6 */
#define GET_RX_STATUS_DESC_MATCH_ID_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 7)

/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_8192F(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

#define GET_RX_STATUS_DESC_BUFF_ADDR64_8192F(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)



/* Dword 0, rsvd: bit26, bit28 */
#define GET_TX_DESC_OWN_8192F(__pTxDesc)\
	LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

#define SET_TX_DESC_PKT_SIZE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define SET_TX_DESC_OFFSET_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define SET_TX_DESC_BMC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_AMSDU_PAD_EN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_NO_ACM_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)

/* Dword 1 */
#define SET_TX_DESC_MACID_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
#define SET_TX_DESC_MORE_DATA_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)

/* Dword 2 ADD HW_DIG*/
#define SET_TX_DESC_PAID_92F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 9, __Value)
#define SET_TX_DESC_CCA_RTS_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_NULL0_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
#define SET_TX_DESC_NULL1_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
#define SET_TX_DESC_BK_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define SET_TX_DESC_RAW_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define SET_TX_DESC_CCX_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_INT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_HW_DIG_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 7, __Value)

/* Dword 3 */
#define SET_TX_DESC_HWSEQ_SEL_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_CHK_EN_92F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 1, __Value)
#define SET_TX_DESC_NAV_USE_HDR_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
#define SET_TX_DESC_USE_MAX_LEN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_NDPA_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_TX_TRY_RATE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
#define SET_TX_DESC_PCTS_EN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
#define SET_TX_DESC_PCTS_MASK_IDX_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)

/* Dword 5 */
#define SET_TX_DESC_DATA_SC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_LDPC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
#define SET_TX_DESC_DATA_STBC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_RTS_STBC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
#define SET_TX_DESC_PORT_ID_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 21, 1, __Value)
#define SET_TX_DESC_DROP_ID_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 22, 2, __Value)
#define SET_TX_DESC_PATH_A_EN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 1, __Value)
#define SET_TX_DESC_PATH_B_EN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 25, 1, __Value)
#define SET_TX_DESC_TXPWR_OF_SET_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)

/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_MBSSID_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
#define SET_TX_DESC_RF_SEL_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)

/* Dword 7 */
#ifdef CONFIG_PCI_HCI
#define SET_TX_DESC_TX_BUFFER_SIZE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#ifdef CONFIG_USB_HCI
#define SET_TX_DESC_TX_DESC_CHECKSUM_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#ifdef CONFIG_SDIO_HCI
#define SET_TX_DESC_TX_TIMESTAMP_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 6, 18, __Value)
#endif

#define SET_TX_DESC_USB_TXAGG_NUM_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)

/* Dword 8 */
#define SET_TX_DESC_RTS_RC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
#define SET_TX_DESC_BAR_RC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
#define SET_TX_DESC_DATA_RC_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
#define SET_TX_DESC_HWSEQ_EN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
#define SET_TX_DESC_NEXTHEADPAGE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
#define SET_TX_DESC_TAILPAGE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)

/* Dword 9 */
#define SET_TX_DESC_PADDING_LEN_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
#define SET_TX_DESC_SEQ_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
#define SET_TX_DESC_FINAL_DATA_RATE_8192F(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 8, __Value)


#define SET_EARLYMODE_PKTNUM_8192F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_8192F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_8192F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_8192F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_8192F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
#define SET_EARLYMODE_LEN3_8192F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)


/*-----------------------------------------------------------------*/
/*	RTL8192F TX BUFFER DESC                                      */
/*-----------------------------------------------------------------*/
#ifdef CONFIG_64BIT_DMA
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+4, 0, 32, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+8, 0, 32, __Valeu)
#else
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu)	/* 64 BIT mode only */
#endif
/* ********************************************************* */

/* 64 bits  -- 32 bits */
/* =======     ======= */
/* Dword 0     0 */
#define SET_TX_BUFF_DESC_LEN_0_8192F(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 14, __Valeu)
#define SET_TX_BUFF_DESC_PSB_8192F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
#define SET_TX_BUFF_DESC_OWN_8192F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

/* Dword 1     1 */
#define SET_TX_BUFF_DESC_ADDR_LOW_0_8192F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
#define GET_TX_BUFF_DESC_ADDR_LOW_0_8192F(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0, 32)
/* Dword 2     NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_0_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 0, __Value)
#ifdef CONFIG_64BIT_DMA
	#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8192F(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+8, 0, 32)
#else
	#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8192F(__pTxDesc) 0
#endif
/* Dword 3     NA */
/* RESERVED 0 */
/* Dword 4     2 */
#define SET_TX_BUFF_DESC_LEN_1_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 1, __Value)
#define SET_TX_BUFF_DESC_AMSDU_1_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 5     3 */
#define SET_TX_BUFF_DESC_ADDR_LOW_1_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 6     NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_1_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 7     NA */
/*RESERVED 0 */
/* Dword 8     4 */
#define SET_TX_BUFF_DESC_LEN_2_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 2, __Value)
#define SET_TX_BUFF_DESC_AMSDU_2_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 9     5 */
#define SET_TX_BUFF_DESC_ADDR_LOW_2_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 10    NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_2_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 11    NA */
/*RESERVED 0 */
/* Dword 12    6 */
#define SET_TX_BUFF_DESC_LEN_3_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 3, __Value)
#define SET_TX_BUFF_DESC_AMSDU_3_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 13    7 */
#define SET_TX_BUFF_DESC_ADDR_LOW_3_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 14    NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_3_8192F(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 15    NA */
/*RESERVED 0 */


#endif
/* -----------------------------------------------------------
 *
 *	Rate
 *
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC8192F_RATE1M				0x00
#define DESC8192F_RATE2M				0x01
#define DESC8192F_RATE5_5M				0x02
#define DESC8192F_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC8192F_RATE6M				0x04
#define DESC8192F_RATE9M				0x05
#define DESC8192F_RATE12M				0x06
#define DESC8192F_RATE18M				0x07
#define DESC8192F_RATE24M				0x08
#define DESC8192F_RATE36M				0x09
#define DESC8192F_RATE48M				0x0a
#define DESC8192F_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC8192F_RATEMCS0				0x0c
#define DESC8192F_RATEMCS1				0x0d
#define DESC8192F_RATEMCS2				0x0e
#define DESC8192F_RATEMCS3				0x0f
#define DESC8192F_RATEMCS4				0x10
#define DESC8192F_RATEMCS5				0x11
#define DESC8192F_RATEMCS6				0x12
#define DESC8192F_RATEMCS7				0x13
#define DESC8192F_RATEMCS8				0x14
#define DESC8192F_RATEMCS9				0x15
#define DESC8192F_RATEMCS10		0x16
#define DESC8192F_RATEMCS11		0x17
#define DESC8192F_RATEMCS12		0x18
#define DESC8192F_RATEMCS13		0x19
#define DESC8192F_RATEMCS14		0x1a
#define DESC8192F_RATEMCS15		0x1b
#define DESC8192F_RATEVHTSS1MCS0		0x2c
#define DESC8192F_RATEVHTSS1MCS1		0x2d
#define DESC8192F_RATEVHTSS1MCS2		0x2e
#define DESC8192F_RATEVHTSS1MCS3		0x2f
#define DESC8192F_RATEVHTSS1MCS4		0x30
#define DESC8192F_RATEVHTSS1MCS5		0x31
#define DESC8192F_RATEVHTSS1MCS6		0x32
#define DESC8192F_RATEVHTSS1MCS7		0x33
#define DESC8192F_RATEVHTSS1MCS8		0x34
#define DESC8192F_RATEVHTSS1MCS9		0x35
#define DESC8192F_RATEVHTSS2MCS0		0x36
#define DESC8192F_RATEVHTSS2MCS1		0x37
#define DESC8192F_RATEVHTSS2MCS2		0x38
#define DESC8192F_RATEVHTSS2MCS3		0x39
#define DESC8192F_RATEVHTSS2MCS4		0x3a
#define DESC8192F_RATEVHTSS2MCS5		0x3b
#define DESC8192F_RATEVHTSS2MCS6		0x3c
#define DESC8192F_RATEVHTSS2MCS7		0x3d
#define DESC8192F_RATEVHTSS2MCS8		0x3e
#define DESC8192F_RATEVHTSS2MCS9		0x3f


#define	RX_HAL_IS_CCK_RATE_8192F(pDesc)\
	(GET_RX_STATUS_DESC_RX_RATE_8192F(pDesc) == DESC8192F_RATE1M || \
	 GET_RX_STATUS_DESC_RX_RATE_8192F(pDesc) == DESC8192F_RATE2M || \
	 GET_RX_STATUS_DESC_RX_RATE_8192F(pDesc) == DESC8192F_RATE5_5M || \
	 GET_RX_STATUS_DESC_RX_RATE_8192F(pDesc) == DESC8192F_RATE11M)

#ifdef CONFIG_TRX_BD_ARCH
	struct tx_desc;
#endif

void rtl8192f_cal_txdesc_chksum(struct tx_desc *ptxdesc);
void rtl8192f_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
void rtl8192f_fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8192f_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8192f_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8192f_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);

#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8192fs_init_xmit_priv(PADAPTER padapter);
	void rtl8192fs_free_xmit_priv(PADAPTER padapter);
	s32 rtl8192fs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192fs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8192fs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192fs_xmit_buf_handler(PADAPTER padapter);
	thread_return rtl8192fs_xmit_thread(thread_context context);
	#define hal_xmit_handler rtl8192fs_xmit_buf_handler
#endif

#ifdef CONFIG_USB_HCI
	s32 rtl8192fu_init_xmit_priv(PADAPTER padapter);
	void rtl8192fu_free_xmit_priv(PADAPTER padapter);
	s32 rtl8192fu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192fu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	 rtl8192fu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192fu_xmit_buf_handler(PADAPTER padapter);
	#define hal_xmit_handler rtl8192fu_xmit_buf_handler
	void rtl8192fu_xmit_tasklet(void *priv);
	s32 rtl8192fu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
	void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8192fe_init_xmit_priv(PADAPTER padapter);
	void rtl8192fe_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8192fe_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	void    rtl8192fe_xmitframe_resume(_adapter *padapter);
	s32 rtl8192fe_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192fe_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32     rtl8192fe_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8192fe_xmit_tasklet(void *priv);
#endif

u8	BWMapping_8192F(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_8192F(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                rtl8822bu/src/include/rtw_br_ext.h                                                                  0000644 0001750 0001750 00000003715 14214766567 015762  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_BR_EXT_H_
#define _RTW_BR_EXT_H_

#if 1	/* rtw_wifi_driver */
#define CL_IPV6_PASS	1
#define MACADDRLEN		6
#define _DEBUG_ERR		RTW_INFO
#define _DEBUG_INFO		/* RTW_INFO */
#define DEBUG_WARN		RTW_INFO
#define DEBUG_INFO		/* RTW_INFO */
#define DEBUG_ERR		RTW_INFO
/* #define GET_MY_HWADDR		((GET_MIB(priv))->dot11OperationEntry.hwaddr) */
#define GET_MY_HWADDR(padapter)		(adapter_mac_addr(padapter))
#endif /* rtw_wifi_driver */

#define NAT25_HASH_BITS		4
#define NAT25_HASH_SIZE		(1 << NAT25_HASH_BITS)
#define NAT25_AGEING_TIME	300

#ifdef CL_IPV6_PASS
	#define MAX_NETWORK_ADDR_LEN	17
#else
	#define MAX_NETWORK_ADDR_LEN	11
#endif

struct nat25_network_db_entry {
	struct nat25_network_db_entry	*next_hash;
	struct nat25_network_db_entry	**pprev_hash;
	atomic_t						use_count;
	unsigned char					macAddr[6];
	unsigned long					ageing_timer;
	unsigned char				networkAddr[MAX_NETWORK_ADDR_LEN];
};

enum NAT25_METHOD {
	NAT25_MIN,
	NAT25_CHECK,
	NAT25_INSERT,
	NAT25_LOOKUP,
	NAT25_PARSE,
	NAT25_MAX
};

struct br_ext_info {
	unsigned int	nat25_disable;
	unsigned int	macclone_enable;
	unsigned int	dhcp_bcst_disable;
	int		addPPPoETag;		/* 1: Add PPPoE relay-SID, 0: disable */
	unsigned char	nat25_dmzMac[MACADDRLEN];
	unsigned int	nat25sc_disable;
};

void nat25_db_cleanup(_adapter *priv);

#endif /* _RTW_BR_EXT_H_ */
                                                   rtl8822bu/src/include/Hal8703BPhyCfg.h                                                              0000644 0001750 0001750 00000005117 14214766567 016032  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8703BPHYCFG_H__
#define __INC_HAL8703BPHYCFG_H__

/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters End-------------------------------*/


/*------------------------------Define structure----------------------------*/

/*------------------------------Define structure End----------------------------*/

/*--------------------------Exported Function prototype---------------------*/
u32
PHY_QueryBBReg_8703B(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask
);

void
PHY_SetBBReg_8703B(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask,
		u32		Data
);

u32
PHY_QueryRFReg_8703B(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask
);

void
PHY_SetRFReg_8703B(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask,
		u32				Data
);

/* MAC/BB/RF HAL config */
int PHY_BBConfig8703B(PADAPTER	Adapter);

int PHY_RFConfig8703B(PADAPTER	Adapter);

s32 PHY_MACConfig8703B(PADAPTER padapter);

int
PHY_ConfigRFWithParaFile_8703B(
		PADAPTER			Adapter,
		u8					*pFileName,
	enum rf_path				eRFPath
);

void
PHY_SetTxPowerIndex_8703B(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

void
PHY_SetTxPowerLevel8703B(
		PADAPTER		Adapter,
		u8			channel
);

void
PHY_SetSwChnlBWMode8703B(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void phy_set_rf_path_switch_8703b(
		struct dm_struct		*phydm,
		bool		bMain
);

/*--------------------------Exported Function prototype End---------------------*/

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/Hal8723DPwrSeq.h                                                              0000644 0001750 0001750 00000044072 14214766567 016102  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8723D
#define REALTEK_POWER_SEQUENCE_8723D

/* #include "PwrSeqCmd.h" */
#include "HalPwrSeqCmd.h"

/*
	Check document WM-20110607-Paul-RTL8192e_Power_Architecture-R02.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transition from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8723D_TRANS_CARDEMU_TO_ACT_STEPS	27
#define	RTL8723D_TRANS_ACT_TO_CARDEMU_STEPS	8
#define	RTL8723D_TRANS_CARDEMU_TO_SUS_STEPS	7
#define	RTL8723D_TRANS_SUS_TO_CARDEMU_STEPS	5
#define	RTL8723D_TRANS_CARDEMU_TO_CARDDIS_STEPS	8
#define	RTL8723D_TRANS_CARDDIS_TO_CARDEMU_STEPS	7
#define	RTL8723D_TRANS_CARDEMU_TO_PDN_STEPS	4
#define	RTL8723D_TRANS_PDN_TO_CARDEMU_STEPS	1
#define	RTL8723D_TRANS_ACT_TO_LPS_STEPS		13
#define	RTL8723D_TRANS_LPS_TO_ACT_STEPS		11
#define	RTL8723D_TRANS_END_STEPS	1


#define RTL8723D_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), BIT(0)}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/	\
	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(5), 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT(4) | BIT(3) | BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[11]=0*/ \
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0) , BIT(0)},/* Disable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(1), BIT(1)},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0) , 0},/* Enable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), BIT(0)},/* release WLON reset  0x04[16]=1*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, (BIT(1) | BIT(0)), 0}, \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT(4) | BIT(3)), 0},/* disable WL suspend*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), BIT(0)},/* polling until return 0*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(0), 0},/**/ \
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(6), BIT(6)},/* Enable WL control XTAL setting*/ \
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)},/*Enable falling edge triggering interrupt*/\
	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)},/*Enable GPIO9 interrupt mode*/\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), 0},/*Enable GPIO9 input mode*/\
	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), BIT(0)},/*Enable HSISR GPIO[C:0] interrupt*/\
	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)},/*Enable HSISR GPIO9 interrupt*/\
	{0x0068, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3), BIT(3)},/*For GPIO9 internal pull high setting by test chip*/\
	{0x0069, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(6), BIT(6)},/*For GPIO9 internal pull high setting*/\
	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*reset RF path S1*/\
	{0x0077, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*reset RF path S0*/\
	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x07},/*enable RF path S1*/\
	{0x0077, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x07},/*enalbe RF path S0*/\


#define RTL8723D_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, */ /*0x1F[7:0] = 0 turn off RF*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0}, /*0x2[0]=0 Reset BB, RF enter Power Down mode*/ \
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), 0},/*Enable rising edge triggering interrupt*/ \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), BIT(0)},/* release WLON reset  0x04[16]=1*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(1), 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/ \
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(6), 0},/* Enable BT control XTAL setting*/\
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(5), BIT(5)}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/\


#define RTL8723D_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4) | BIT(3), (BIT4 | BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), BIT(4)}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), BIT(0)}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), 0}, /*wait power state to suspend*/

#define RTL8723D_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(7), 0}, /*clear suspend enable and power down enable*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), 0}, /*Set SDIO suspend local register*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), BIT(1)}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), 0}, /*0x04[12:11] = 2b'01enable WL suspend*/


#define RTL8723D_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(2), BIT(2)}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend*/	\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), BIT(4)}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), BIT(0)}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), 0}, /*wait power state to suspend*/

#define RTL8723D_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(7), 0}, /*clear suspend enable and power down enable*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), 0}, /*Set SDIO suspend local register*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), BIT(1)}, /*wait power state to suspend*/\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/


#define RTL8723D_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), BIT(4)}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK | PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), BIT(7)},/* 0x04[15] = 1*/

#define RTL8723D_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), 0},/* 0x04[15] = 0*/

#define RTL8723D_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), 0},/*check if removed later*/ \
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(5), BIT(5)},/*Respond TxOK to scheduler*/	\


#define RTL8723D_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), 0}, /*.	0x08[4] = 0  switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(7), 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(6) | BIT(7), 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1) | BIT(0), BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8723D_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, / comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8723D_power_on_flow[RTL8723D_TRANS_CARDEMU_TO_ACT_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_radio_off_flow[RTL8723D_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_card_disable_flow[RTL8723D_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723D_TRANS_CARDEMU_TO_CARDDIS_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_card_enable_flow[RTL8723D_TRANS_CARDDIS_TO_CARDEMU_STEPS + RTL8723D_TRANS_CARDEMU_TO_ACT_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_suspend_flow[RTL8723D_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723D_TRANS_CARDEMU_TO_SUS_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_resume_flow[RTL8723D_TRANS_SUS_TO_CARDEMU_STEPS + RTL8723D_TRANS_CARDEMU_TO_ACT_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_hwpdn_flow[RTL8723D_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723D_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_enter_lps_flow[RTL8723D_TRANS_ACT_TO_LPS_STEPS + RTL8723D_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723D_leave_lps_flow[RTL8723D_TRANS_LPS_TO_ACT_STEPS + RTL8723D_TRANS_END_STEPS];

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/osdep_service_xp.h                                                            0000644 0001750 0001750 00000011360 14214766567 017137  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __OSDEP_LINUX_SERVICE_H_
#define __OSDEP_LINUX_SERVICE_H_

	#include <ndis.h>
	#include <ntddk.h>
	#include <ntddndis.h>
	#include <ntdef.h>

#ifdef CONFIG_USB_HCI
	#include <usb.h>
	#include <usbioctl.h>
	#include <usbdlib.h>
#endif

	typedef KSEMAPHORE 	_sema;
	typedef	LIST_ENTRY	_list;
	typedef NDIS_STATUS _OS_STATUS;
	

	typedef NDIS_SPIN_LOCK	_lock;

	typedef KMUTEX 			_mutex;

	typedef KIRQL	_irqL;

	// USB_PIPE for WINCE , but handle can be use just integer under windows
	typedef NDIS_HANDLE  _nic_hdl;

	struct rtw_timer_list {
		NDIS_MINIPORT_TIMER ndis_timer;
		void (*function)(void *);
		void *arg;
	};

	struct	__queue	{
		LIST_ENTRY	queue;	
		_lock	lock;
	};

	typedef	NDIS_PACKET	_pkt;
	typedef NDIS_BUFFER	_buffer;
	typedef struct	__queue	_queue;
	
	typedef PKTHREAD _thread_hdl_;
	typedef void	thread_return;
	typedef void* thread_context;

	typedef NDIS_WORK_ITEM _workitem;


	#define HZ			10000000
	#define SEMA_UPBND	(0x7FFFFFFF)   //8192
	
__inline static _list *get_next(_list	*list)
{
	return list->Flink;
}	

__inline static _list	*get_list_head(_queue	*queue)
{
	return (&(queue->queue));
}
	

#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
     

__inline static _enter_critical(_lock *plock, _irqL *pirqL)
{
	NdisAcquireSpinLock(plock);	
}

__inline static _exit_critical(_lock *plock, _irqL *pirqL)
{
	NdisReleaseSpinLock(plock);	
}


__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
{
	NdisDprAcquireSpinLock(plock);	
}

__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
{
	NdisDprReleaseSpinLock(plock);	
}

__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
{
	NdisDprAcquireSpinLock(plock);
}

__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
{
	NdisDprReleaseSpinLock(plock);
}

__inline static _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{
	KeWaitForSingleObject(pmutex, Executive, KernelMode, FALSE, NULL);
}


__inline static _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{
	KeReleaseMutex(pmutex, FALSE);
}


__inline static void rtw_list_delete(_list *plist)
{
	RemoveEntryList(plist);
	InitializeListHead(plist);	
}

static inline void timer_hdl(
	IN PVOID SystemSpecific1,
	IN PVOID FunctionContext,
	IN PVOID SystemSpecific2,
	IN PVOID SystemSpecific3)
{
	_timer *timer = (_timer *)FunctionContext;

	timer->function(timer->arg);
}

static inline void _init_timer(_timer *ptimer, _nic_hdl nic_hdl, void *pfunc, void *cntx)
{
	ptimer->function = pfunc;
	ptimer->arg = cntx;
	NdisMInitializeTimer(&ptimer->ndis_timer, nic_hdl, timer_hdl, ptimer);
}

static inline void _set_timer(_timer *ptimer, u32 delay_time)
{
	NdisMSetTimer(ptimer, delay_time);
}

static inline void _cancel_timer(_timer *ptimer, u8 *bcancelled)
{
	NdisMCancelTimer(ptimer, bcancelled);
}

__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
{

	NdisInitializeWorkItem(pwork, pfunc, cntx);
}

__inline static void _set_workitem(_workitem *pwork)
{
	NdisScheduleWorkItem(pwork);
}


#define ATOMIC_INIT(i)  { (i) }

//
// Global Mutex: can only be used at PASSIVE level.
//

#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
{                                                               \
    while (NdisInterlockedIncrement((PULONG)&(_MutexCounter)) != 1)\
    {                                                           \
        NdisInterlockedDecrement((PULONG)&(_MutexCounter));        \
        NdisMSleep(10000);                          \
    }                                                           \
}

#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
{                                                               \
    NdisInterlockedDecrement((PULONG)&(_MutexCounter));              \
}

// limitation of path length
#define PATH_LENGTH_MAX MAX_PATH

//Atomic integer operations
#define ATOMIC_T LONG


#define NDEV_FMT "%s"
#define NDEV_ARG(ndev) ""
#define ADPT_FMT "%s"
#define ADPT_ARG(adapter) ""
#define FUNC_NDEV_FMT "%s"
#define FUNC_NDEV_ARG(ndev) __func__
#define FUNC_ADPT_FMT "%s"
#define FUNC_ADPT_ARG(adapter) __func__

#define STRUCT_PACKED

#endif

                                                                                                                                                                                                                                                                                rtl8822bu/src/include/hal_phy_reg.h                                                                 0000644 0001750 0001750 00000034555 14214766567 016072  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_PHY_REG_H__
#define __HAL_PHY_REG_H__

/* for PutRFRegsetting & GetRFRegSetting BitMask*/
#define		bRFRegOffsetMask	0xfffff

/* alias for phydm coding style */
#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
#define REG_OFDM_0_ECCA_THRESHOLD		rOFDM0_ECCAThreshold
#define REG_FPGA0_XB_LSSI_READ_BACK		rFPGA0_XB_LSSIReadBack
#define REG_FPGA0_TX_GAIN_STAGE			rFPGA0_TxGainStage
#define REG_OFDM_0_XA_AGC_CORE1			rOFDM0_XAAGCCore1
#define REG_OFDM_0_XB_AGC_CORE1			rOFDM0_XBAGCCore1
#define REG_A_TX_SCALE_JAGUAR			rA_TxScale_Jaguar
#define REG_B_TX_SCALE_JAGUAR			rB_TxScale_Jaguar

#define REG_FPGA0_XAB_RF_INTERFACE_SW	rFPGA0_XAB_RFInterfaceSW
#define REG_FPGA0_XAB_RF_PARAMETER	rFPGA0_XAB_RFParameter
#define REG_FPGA0_XA_HSSI_PARAMETER1	rFPGA0_XA_HSSIParameter1
#define REG_FPGA0_XA_LSSI_PARAMETER	rFPGA0_XA_LSSIParameter
#define REG_FPGA0_XA_RF_INTERFACE_OE	rFPGA0_XA_RFInterfaceOE
#define REG_FPGA0_XB_HSSI_PARAMETER1	rFPGA0_XB_HSSIParameter1
#define REG_FPGA0_XB_LSSI_PARAMETER	rFPGA0_XB_LSSIParameter
#define REG_FPGA0_XB_LSSI_READ_BACK	rFPGA0_XB_LSSIReadBack
#define REG_FPGA0_XB_RF_INTERFACE_OE	rFPGA0_XB_RFInterfaceOE
#define REG_FPGA0_XCD_RF_INTERFACE_SW	rFPGA0_XCD_RFInterfaceSW
#define REG_FPGA0_XCD_SWITCH_CONTROL	rFPGA0_XCD_SwitchControl
#define REG_FPGA1_TX_BLOCK	rFPGA1_TxBlock
#define REG_FPGA1_TX_INFO	rFPGA1_TxInfo
#define REG_IQK_AGC_CONT	rIQK_AGC_Cont
#define REG_IQK_AGC_PTS	rIQK_AGC_Pts
#define REG_IQK_AGC_RSP	rIQK_AGC_Rsp
#define REG_OFDM_0_AGC_RSSI_TABLE	rOFDM0_AGCRSSITable
#define REG_OFDM_0_ECCA_THRESHOLD	rOFDM0_ECCAThreshold
#define REG_OFDM_0_RX_IQ_EXT_ANTA	rOFDM0_RxIQExtAnta
#define REG_OFDM_0_TR_MUX_PAR	rOFDM0_TRMuxPar
#define REG_OFDM_0_TRX_PATH_ENABLE	rOFDM0_TRxPathEnable
#define REG_OFDM_0_XA_AGC_CORE1	rOFDM0_XAAGCCore1
#define REG_OFDM_0_XA_RX_IQ_IMBALANCE	rOFDM0_XARxIQImbalance
#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
#define REG_OFDM_0_XB_AGC_CORE1	rOFDM0_XBAGCCore1
#define REG_OFDM_0_XB_RX_IQ_IMBALANCE	rOFDM0_XBRxIQImbalance
#define REG_OFDM_0_XB_TX_IQ_IMBALANCE	rOFDM0_XBTxIQImbalance
#define REG_OFDM_0_XC_TX_AFE	rOFDM0_XCTxAFE
#define REG_OFDM_0_XD_TX_AFE	rOFDM0_XDTxAFE

/*#define REG_A_CFO_LONG_DUMP_92E	rA_CfoLongDump_92E*/
#define REG_A_CFO_LONG_DUMP_JAGUAR	rA_CfoLongDump_Jaguar
/*#define REG_A_CFO_SHORT_DUMP_92E	rA_CfoShortDump_92E*/
#define REG_A_CFO_SHORT_DUMP_JAGUAR	rA_CfoShortDump_Jaguar
#define REG_A_RFE_PINMUX_JAGUAR	rA_RFE_Pinmux_Jaguar
/*#define REG_A_RSSI_DUMP_92E	rA_RSSIDump_92E*/
#define REG_A_RSSI_DUMP_JAGUAR	rA_RSSIDump_Jaguar
/*#define REG_A_RX_SNR_DUMP_92E	rA_RXsnrDump_92E*/
#define REG_A_RX_SNR_DUMP_JAGUAR	rA_RXsnrDump_Jaguar
/*#define REG_A_TX_AGC	rA_TXAGC*/
#define REG_A_TX_SCALE_JAGUAR	rA_TxScale_Jaguar
#define REG_BW_INDICATION_JAGUAR	rBWIndication_Jaguar
/*#define REG_B_BBSWING	rB_BBSWING*/
/*#define REG_B_CFO_LONG_DUMP_92E	rB_CfoLongDump_92E*/
#define REG_B_CFO_LONG_DUMP_JAGUAR	rB_CfoLongDump_Jaguar
/*#define REG_B_CFO_SHORT_DUMP_92E	rB_CfoShortDump_92E*/
#define REG_B_CFO_SHORT_DUMP_JAGUAR	rB_CfoShortDump_Jaguar
/*#define REG_B_RSSI_DUMP_92E	rB_RSSIDump_92E*/
#define REG_B_RSSI_DUMP_JAGUAR	rB_RSSIDump_Jaguar
/*#define REG_B_RX_SNR_DUMP_92E	rB_RXsnrDump_92E*/
#define REG_B_RX_SNR_DUMP_JAGUAR	rB_RXsnrDump_Jaguar
/*#define REG_B_TX_AGC	rB_TXAGC*/
#define REG_B_TX_SCALE_JAGUAR	rB_TxScale_Jaguar
#define REG_BLUE_TOOTH	rBlue_Tooth
#define REG_CCK_0_AFE_SETTING	rCCK0_AFESetting
/*#define REG_C_BBSWING	rC_BBSWING*/
/*#define REG_C_TX_AGC	rC_TXAGC*/
#define REG_C_TX_SCALE_JAGUAR2	rC_TxScale_Jaguar2
#define REG_CONFIG_ANT_A	rConfig_AntA
#define REG_CONFIG_ANT_B	rConfig_AntB
#define REG_CONFIG_PMPD_ANT_A	rConfig_Pmpd_AntA
#define REG_CONFIG_PMPD_ANT_B	rConfig_Pmpd_AntB
#define REG_DPDT_CONTROL	rDPDT_control
/*#define REG_D_BBSWING	rD_BBSWING*/
/*#define REG_D_TX_AGC	rD_TXAGC*/
#define REG_D_TX_SCALE_JAGUAR2	rD_TxScale_Jaguar2
#define REG_FPGA0_ANALOG_PARAMETER4	rFPGA0_AnalogParameter4
#define REG_FPGA0_IQK	rFPGA0_IQK
#define REG_FPGA0_PSD_FUNCTION	rFPGA0_PSDFunction
#define REG_FPGA0_PSD_REPORT	rFPGA0_PSDReport
#define REG_FPGA0_RFMOD	rFPGA0_RFMOD
#define REG_FPGA0_TX_GAIN_STAGE	rFPGA0_TxGainStage
#define REG_FPGA0_XAB_RF_INTERFACE_SW	rFPGA0_XAB_RFInterfaceSW
#define REG_FPGA0_XAB_RF_PARAMETER	rFPGA0_XAB_RFParameter
#define REG_FPGA0_XA_HSSI_PARAMETER1	rFPGA0_XA_HSSIParameter1
#define REG_FPGA0_XA_LSSI_PARAMETER	rFPGA0_XA_LSSIParameter
#define REG_FPGA0_XA_RF_INTERFACE_OE	rFPGA0_XA_RFInterfaceOE
#define REG_FPGA0_XB_HSSI_PARAMETER1	rFPGA0_XB_HSSIParameter1
#define REG_FPGA0_XB_LSSI_PARAMETER	rFPGA0_XB_LSSIParameter
#define REG_FPGA0_XB_LSSI_READ_BACK	rFPGA0_XB_LSSIReadBack
#define REG_FPGA0_XB_RF_INTERFACE_OE	rFPGA0_XB_RFInterfaceOE
#define REG_FPGA0_XCD_RF_INTERFACE_SW	rFPGA0_XCD_RFInterfaceSW
#define REG_FPGA0_XCD_SWITCH_CONTROL	rFPGA0_XCD_SwitchControl
#define REG_FPGA1_TX_BLOCK	rFPGA1_TxBlock
#define REG_FPGA1_TX_INFO	rFPGA1_TxInfo
#define REG_IQK_AGC_CONT	rIQK_AGC_Cont
#define REG_IQK_AGC_PTS	rIQK_AGC_Pts
#define REG_IQK_AGC_RSP	rIQK_AGC_Rsp
#define REG_OFDM_0_AGC_RSSI_TABLE	rOFDM0_AGCRSSITable
#define REG_OFDM_0_ECCA_THRESHOLD	rOFDM0_ECCAThreshold
#define REG_OFDM_0_RX_IQ_EXT_ANTA	rOFDM0_RxIQExtAnta
#define REG_OFDM_0_TR_MUX_PAR	rOFDM0_TRMuxPar
#define REG_OFDM_0_TRX_PATH_ENABLE	rOFDM0_TRxPathEnable
#define REG_OFDM_0_XA_AGC_CORE1	rOFDM0_XAAGCCore1
#define REG_OFDM_0_XA_RX_IQ_IMBALANCE	rOFDM0_XARxIQImbalance
#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
#define REG_OFDM_0_XB_AGC_CORE1	rOFDM0_XBAGCCore1
#define REG_OFDM_0_XB_RX_IQ_IMBALANCE	rOFDM0_XBRxIQImbalance
#define REG_OFDM_0_XB_TX_IQ_IMBALANCE	rOFDM0_XBTxIQImbalance
#define REG_OFDM_0_XC_TX_AFE	rOFDM0_XCTxAFE
#define REG_OFDM_0_XD_TX_AFE	rOFDM0_XDTxAFE
#define REG_PMPD_ANAEN	rPMPD_ANAEN
#define REG_PDP_ANT_A	rPdp_AntA
#define REG_PDP_ANT_A_4	rPdp_AntA_4
#define REG_PDP_ANT_B	rPdp_AntB
#define REG_PDP_ANT_B_4	rPdp_AntB_4
#define REG_PWED_TH_JAGUAR	rPwed_TH_Jaguar
#define REG_RX_CCK	rRx_CCK
#define REG_RX_IQK	rRx_IQK
#define REG_RX_IQK_PI_A	rRx_IQK_PI_A
#define REG_RX_IQK_PI_B	rRx_IQK_PI_B
#define REG_RX_IQK_TONE_A	rRx_IQK_Tone_A
#define REG_RX_IQK_TONE_B	rRx_IQK_Tone_B
#define REG_RX_OFDM	rRx_OFDM
#define REG_RX_POWER_AFTER_IQK_A_2	rRx_Power_After_IQK_A_2
#define REG_RX_POWER_AFTER_IQK_B_2	rRx_Power_After_IQK_B_2
#define REG_RX_POWER_BEFORE_IQK_A_2	rRx_Power_Before_IQK_A_2
#define REG_RX_POWER_BEFORE_IQK_B_2	rRx_Power_Before_IQK_B_2
#define REG_RX_TO_RX	rRx_TO_Rx
#define REG_RX_WAIT_CCA	rRx_Wait_CCA
#define REG_RX_WAIT_RIFS	rRx_Wait_RIFS
#define REG_S0_S1_PATH_SWITCH	rS0S1_PathSwitch
/*#define REG_S1_RXEVM_DUMP_92E	rS1_RXevmDump_92E*/
#define REG_S1_RXEVM_DUMP_JAGUAR	rS1_RXevmDump_Jaguar
/*#define REG_S2_RXEVM_DUMP_92E	rS2_RXevmDump_92E*/
#define REG_S2_RXEVM_DUMP_JAGUAR	rS2_RXevmDump_Jaguar
#define REG_SYM_WLBT_PAPE_SEL	rSYM_WLBT_PAPE_SEL
#define REG_SINGLE_TONE_CONT_TX_JAGUAR	rSingleTone_ContTx_Jaguar
#define REG_SLEEP	rSleep
#define REG_STANDBY	rStandby
#define REG_TX_AGC_A_CCK_11_CCK_1_JAGUAR	rTxAGC_A_CCK11_CCK1_JAguar
#define REG_TX_AGC_A_CCK_1_MCS32	rTxAGC_A_CCK1_Mcs32
#define REG_TX_AGC_A_MCS11_MCS8_JAGUAR	rTxAGC_A_MCS11_MCS8_JAguar
#define REG_TX_AGC_A_MCS15_MCS12_JAGUAR	rTxAGC_A_MCS15_MCS12_JAguar
#define REG_TX_AGC_A_MCS19_MCS16_JAGUAR	rTxAGC_A_MCS19_MCS16_JAguar
#define REG_TX_AGC_A_MCS23_MCS20_JAGUAR	rTxAGC_A_MCS23_MCS20_JAguar
#define REG_TX_AGC_A_MCS3_MCS0_JAGUAR	rTxAGC_A_MCS3_MCS0_JAguar
#define REG_TX_AGC_A_MCS7_MCS4_JAGUAR	rTxAGC_A_MCS7_MCS4_JAguar
#define REG_TX_AGC_A_MCS03_MCS00	rTxAGC_A_Mcs03_Mcs00
#define REG_TX_AGC_A_MCS07_MCS04	rTxAGC_A_Mcs07_Mcs04
#define REG_TX_AGC_A_MCS11_MCS08	rTxAGC_A_Mcs11_Mcs08
#define REG_TX_AGC_A_MCS15_MCS12	rTxAGC_A_Mcs15_Mcs12
#define REG_TX_AGC_A_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_A_Nss1Index3_Nss1Index0_JAguar
#define REG_TX_AGC_A_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_A_Nss1Index7_Nss1Index4_JAguar
#define REG_TX_AGC_A_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_A_Nss2Index1_Nss1Index8_JAguar
#define REG_TX_AGC_A_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_A_Nss2Index5_Nss2Index2_JAguar
#define REG_TX_AGC_A_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_A_Nss2Index9_Nss2Index6_JAguar
#define REG_TX_AGC_A_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_A_Nss3Index3_Nss3Index0_JAguar
#define REG_TX_AGC_A_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_A_Nss3Index7_Nss3Index4_JAguar
#define REG_TX_AGC_A_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_A_Nss3Index9_Nss3Index8_JAguar
#define REG_TX_AGC_A_OFDM18_OFDM6_JAGUAR	rTxAGC_A_Ofdm18_Ofdm6_JAguar
#define REG_TX_AGC_A_OFDM54_OFDM24_JAGUAR	rTxAGC_A_Ofdm54_Ofdm24_JAguar
#define REG_TX_AGC_A_RATE18_06	rTxAGC_A_Rate18_06
#define REG_TX_AGC_A_RATE54_24	rTxAGC_A_Rate54_24
#define REG_TX_AGC_B_CCK_11_A_CCK_2_11	rTxAGC_B_CCK11_A_CCK2_11
#define REG_TX_AGC_B_CCK_11_CCK_1_JAGUAR	rTxAGC_B_CCK11_CCK1_JAguar
#define REG_TX_AGC_B_CCK_1_55_MCS32	rTxAGC_B_CCK1_55_Mcs32
#define REG_TX_AGC_B_MCS11_MCS8_JAGUAR	rTxAGC_B_MCS11_MCS8_JAguar
#define REG_TX_AGC_B_MCS15_MCS12_JAGUAR	rTxAGC_B_MCS15_MCS12_JAguar
#define REG_TX_AGC_B_MCS19_MCS16_JAGUAR	rTxAGC_B_MCS19_MCS16_JAguar
#define REG_TX_AGC_B_MCS23_MCS20_JAGUAR	rTxAGC_B_MCS23_MCS20_JAguar
#define REG_TX_AGC_B_MCS3_MCS0_JAGUAR	rTxAGC_B_MCS3_MCS0_JAguar
#define REG_TX_AGC_B_MCS7_MCS4_JAGUAR	rTxAGC_B_MCS7_MCS4_JAguar
#define REG_TX_AGC_B_MCS03_MCS00	rTxAGC_B_Mcs03_Mcs00
#define REG_TX_AGC_B_MCS07_MCS04	rTxAGC_B_Mcs07_Mcs04
#define REG_TX_AGC_B_MCS11_MCS08	rTxAGC_B_Mcs11_Mcs08
#define REG_TX_AGC_B_MCS15_MCS12	rTxAGC_B_Mcs15_Mcs12
#define REG_TX_AGC_B_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_B_Nss1Index3_Nss1Index0_JAguar
#define REG_TX_AGC_B_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_B_Nss1Index7_Nss1Index4_JAguar
#define REG_TX_AGC_B_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_B_Nss2Index1_Nss1Index8_JAguar
#define REG_TX_AGC_B_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_B_Nss2Index5_Nss2Index2_JAguar
#define REG_TX_AGC_B_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_B_Nss2Index9_Nss2Index6_JAguar
#define REG_TX_AGC_B_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_B_Nss3Index3_Nss3Index0_JAguar
#define REG_TX_AGC_B_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_B_Nss3Index7_Nss3Index4_JAguar
#define REG_TX_AGC_B_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_B_Nss3Index9_Nss3Index8_JAguar
#define REG_TX_AGC_B_OFDM18_OFDM6_JAGUAR	rTxAGC_B_Ofdm18_Ofdm6_JAguar
#define REG_TX_AGC_B_OFDM54_OFDM24_JAGUAR	rTxAGC_B_Ofdm54_Ofdm24_JAguar
#define REG_TX_AGC_B_RATE18_06	rTxAGC_B_Rate18_06
#define REG_TX_AGC_B_RATE54_24	rTxAGC_B_Rate54_24
#define REG_TX_AGC_C_CCK_11_CCK_1_JAGUAR	rTxAGC_C_CCK11_CCK1_JAguar
#define REG_TX_AGC_C_MCS11_MCS8_JAGUAR	rTxAGC_C_MCS11_MCS8_JAguar
#define REG_TX_AGC_C_MCS15_MCS12_JAGUAR	rTxAGC_C_MCS15_MCS12_JAguar
#define REG_TX_AGC_C_MCS19_MCS16_JAGUAR	rTxAGC_C_MCS19_MCS16_JAguar
#define REG_TX_AGC_C_MCS23_MCS20_JAGUAR	rTxAGC_C_MCS23_MCS20_JAguar
#define REG_TX_AGC_C_MCS3_MCS0_JAGUAR	rTxAGC_C_MCS3_MCS0_JAguar
#define REG_TX_AGC_C_MCS7_MCS4_JAGUAR	rTxAGC_C_MCS7_MCS4_JAguar
#define REG_TX_AGC_C_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_C_Nss1Index3_Nss1Index0_JAguar
#define REG_TX_AGC_C_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_C_Nss1Index7_Nss1Index4_JAguar
#define REG_TX_AGC_C_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_C_Nss2Index1_Nss1Index8_JAguar
#define REG_TX_AGC_C_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_C_Nss2Index5_Nss2Index2_JAguar
#define REG_TX_AGC_C_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_C_Nss2Index9_Nss2Index6_JAguar
#define REG_TX_AGC_C_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_C_Nss3Index3_Nss3Index0_JAguar
#define REG_TX_AGC_C_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_C_Nss3Index7_Nss3Index4_JAguar
#define REG_TX_AGC_C_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_C_Nss3Index9_Nss3Index8_JAguar
#define REG_TX_AGC_C_OFDM18_OFDM6_JAGUAR	rTxAGC_C_Ofdm18_Ofdm6_JAguar
#define REG_TX_AGC_C_OFDM54_OFDM24_JAGUAR	rTxAGC_C_Ofdm54_Ofdm24_JAguar
#define REG_TX_AGC_D_CCK_11_CCK_1_JAGUAR	rTxAGC_D_CCK11_CCK1_JAguar
#define REG_TX_AGC_D_MCS11_MCS8_JAGUAR	rTxAGC_D_MCS11_MCS8_JAguar
#define REG_TX_AGC_D_MCS15_MCS12_JAGUAR	rTxAGC_D_MCS15_MCS12_JAguar
#define REG_TX_AGC_D_MCS19_MCS16_JAGUAR	rTxAGC_D_MCS19_MCS16_JAguar
#define REG_TX_AGC_D_MCS23_MCS20_JAGUAR	rTxAGC_D_MCS23_MCS20_JAguar
#define REG_TX_AGC_D_MCS3_MCS0_JAGUAR	rTxAGC_D_MCS3_MCS0_JAguar
#define REG_TX_AGC_D_MCS7_MCS4_JAGUAR	rTxAGC_D_MCS7_MCS4_JAguar
#define REG_TX_AGC_D_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_D_Nss1Index3_Nss1Index0_JAguar
#define REG_TX_AGC_D_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_D_Nss1Index7_Nss1Index4_JAguar
#define REG_TX_AGC_D_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_D_Nss2Index1_Nss1Index8_JAguar
#define REG_TX_AGC_D_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_D_Nss2Index5_Nss2Index2_JAguar
#define REG_TX_AGC_D_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_D_Nss2Index9_Nss2Index6_JAguar
#define REG_TX_AGC_D_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_D_Nss3Index3_Nss3Index0_JAguar
#define REG_TX_AGC_D_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_D_Nss3Index7_Nss3Index4_JAguar
#define REG_TX_AGC_D_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_D_Nss3Index9_Nss3Index8_JAguar
#define REG_TX_AGC_D_OFDM18_OFDM6_JAGUAR	rTxAGC_D_Ofdm18_Ofdm6_JAguar
#define REG_TX_AGC_D_OFDM54_OFDM24_JAGUAR	rTxAGC_D_Ofdm54_Ofdm24_JAguar
#define REG_TX_PATH_JAGUAR	rTxPath_Jaguar
#define REG_TX_CCK_BBON	rTx_CCK_BBON
#define REG_TX_CCK_RFON	rTx_CCK_RFON
#define REG_TX_IQK	rTx_IQK
#define REG_TX_IQK_PI_A	rTx_IQK_PI_A
#define REG_TX_IQK_PI_B	rTx_IQK_PI_B
#define REG_TX_IQK_TONE_A	rTx_IQK_Tone_A
#define REG_TX_IQK_TONE_B	rTx_IQK_Tone_B
#define REG_TX_OFDM_BBON	rTx_OFDM_BBON
#define REG_TX_OFDM_RFON	rTx_OFDM_RFON
#define REG_TX_POWER_AFTER_IQK_A	rTx_Power_After_IQK_A
#define REG_TX_POWER_AFTER_IQK_B	rTx_Power_After_IQK_B
#define REG_TX_POWER_BEFORE_IQK_A	rTx_Power_Before_IQK_A
#define REG_TX_POWER_BEFORE_IQK_B	rTx_Power_Before_IQK_B
#define REG_TX_TO_RX	rTx_To_Rx
#define REG_TX_TO_TX	rTx_To_Tx
#define REG_APK	rAPK
#define REG_ANTSEL_SW_JAGUAR	r_ANTSEL_SW_Jaguar

#define rf_welut_jaguar	RF_WeLut_Jaguar
#define rf_mode_table_addr	RF_ModeTableAddr
#define rf_mode_table_data0	RF_ModeTableData0
#define rf_mode_table_data1	RF_ModeTableData1

#define RX_SMOOTH_FACTOR	Rx_Smooth_Factor

#endif /* __HAL_PHY_REG_H__ */
                                                                                                                                                   rtl8822bu/src/include/hal_data.h                                                                    0000755 0001750 0001750 00000055077 14214766567 015353  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_DATA_H__
#define __HAL_DATA_H__

#if 1/* def  CONFIG_SINGLE_IMG */

#include "../hal/phydm/phydm_precomp.h"
#ifdef CONFIG_BT_COEXIST
	#include <hal_btcoex.h>
#endif
	#include <hal_btcoex_wifionly.h>

#ifdef CONFIG_SDIO_HCI
	#include <hal_sdio.h>
#endif
#ifdef CONFIG_GSPI_HCI
	#include <hal_gspi.h>
#endif

#if defined(CONFIG_RTW_ACS) || defined(CONFIG_BACKGROUND_NOISE_MONITOR)
#include "../hal/hal_dm_acs.h"
#endif

/*
 * <Roger_Notes> For RTL8723 WiFi/BT/GPS multi-function configuration. 2010.10.06.
 *   */
typedef enum _RT_MULTI_FUNC {
	RT_MULTI_FUNC_NONE	= 0x00,
	RT_MULTI_FUNC_WIFI	= 0x01,
	RT_MULTI_FUNC_BT		= 0x02,
	RT_MULTI_FUNC_GPS	= 0x04,
} RT_MULTI_FUNC, *PRT_MULTI_FUNC;
/*
 * <Roger_Notes> For RTL8723 WiFi PDn/GPIO polarity control configuration. 2010.10.08.
 *   */
typedef enum _RT_POLARITY_CTL {
	RT_POLARITY_LOW_ACT	= 0,
	RT_POLARITY_HIGH_ACT	= 1,
} RT_POLARITY_CTL, *PRT_POLARITY_CTL;

/* For RTL8723 regulator mode. by tynli. 2011.01.14. */
typedef enum _RT_REGULATOR_MODE {
	RT_SWITCHING_REGULATOR	= 0,
	RT_LDO_REGULATOR			= 1,
} RT_REGULATOR_MODE, *PRT_REGULATOR_MODE;

/*
 * Interface type.
 *   */
typedef	enum _INTERFACE_SELECT_PCIE {
	INTF_SEL0_SOLO_MINICARD			= 0,		/* WiFi solo-mCard */
	INTF_SEL1_BT_COMBO_MINICARD		= 1,		/* WiFi+BT combo-mCard */
	INTF_SEL2_PCIe						= 2,		/* PCIe Card */
} INTERFACE_SELECT_PCIE, *PINTERFACE_SELECT_PCIE;


typedef	enum _INTERFACE_SELECT_USB {
	INTF_SEL0_USB 				= 0,		/* USB */
	INTF_SEL1_USB_High_Power  	= 1,		/* USB with high power PA */
	INTF_SEL2_MINICARD		  	= 2,		/* Minicard */
	INTF_SEL3_USB_Solo 		= 3,		/* USB solo-Slim module */
	INTF_SEL4_USB_Combo		= 4,		/* USB Combo-Slim module */
	INTF_SEL5_USB_Combo_MF	= 5,		/* USB WiFi+BT Multi-Function Combo, i.e., Proprietary layout(AS-VAU) which is the same as SDIO card */
} INTERFACE_SELECT_USB, *PINTERFACE_SELECT_USB;

typedef enum _RT_AMPDU_BRUST_MODE {
	RT_AMPDU_BRUST_NONE		= 0,
	RT_AMPDU_BRUST_92D		= 1,
	RT_AMPDU_BRUST_88E		= 2,
	RT_AMPDU_BRUST_8812_4	= 3,
	RT_AMPDU_BRUST_8812_8	= 4,
	RT_AMPDU_BRUST_8812_12	= 5,
	RT_AMPDU_BRUST_8812_15	= 6,
	RT_AMPDU_BRUST_8723B		= 7,
} RT_AMPDU_BRUST, *PRT_AMPDU_BRUST_MODE;

/* Tx Power Limit Table Size */
#define MAX_REGULATION_NUM						4
#define MAX_RF_PATH_NUM_IN_POWER_LIMIT_TABLE	4
#define MAX_2_4G_BANDWIDTH_NUM					2
#define MAX_RATE_SECTION_NUM						10
#define MAX_5G_BANDWIDTH_NUM						4

#define NUM_OF_TARGET_TXPWR_2G	10 /* CCK:1, OFDM:1, HT:4, VHT:4 */
#define NUM_OF_TARGET_TXPWR_5G	9 /* OFDM:1, HT:4, VHT:4 */

#ifdef RTW_RX_AGGREGATION
typedef enum _RX_AGG_MODE {
	RX_AGG_DISABLE,
	RX_AGG_DMA,
	RX_AGG_USB,
	RX_AGG_MIX
} RX_AGG_MODE;

/* #define MAX_RX_DMA_BUFFER_SIZE	10240 */		/* 10K for 8192C RX DMA buffer */

#endif /* RTW_RX_AGGREGATION */

/* E-Fuse */
#ifdef CONFIG_RTL8188E
	#define EFUSE_MAP_SIZE	512
#endif
#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8814A)
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8192E
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8723B
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8814A
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8703B
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8723D
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8188F
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8188GTV
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8710B
	#define EFUSE_MAP_SIZE	512
#endif
#ifdef CONFIG_RTL8192F
	#define EFUSE_MAP_SIZE	512
#endif

#if defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8814B)
	#define EFUSE_MAX_SIZE	1024
#elif defined(CONFIG_RTL8188E) || defined(CONFIG_RTL8188F) || defined(CONFIG_RTL8188GTV) || defined(CONFIG_RTL8703B) || defined(CONFIG_RTL8710B)
	#define EFUSE_MAX_SIZE	256
#else
	#define EFUSE_MAX_SIZE	512
#endif
/* end of E-Fuse */

#define Mac_OFDM_OK			0x00000000
#define Mac_OFDM_Fail		0x10000000
#define Mac_OFDM_FasleAlarm	0x20000000
#define Mac_CCK_OK			0x30000000
#define Mac_CCK_Fail		0x40000000
#define Mac_CCK_FasleAlarm	0x50000000
#define Mac_HT_OK			0x60000000
#define Mac_HT_Fail			0x70000000
#define Mac_HT_FasleAlarm	0x90000000
#define Mac_DropPacket		0xA0000000

#ifdef CONFIG_RF_POWER_TRIM
#if defined(CONFIG_RTL8723B)
	#define REG_RF_BB_GAIN_OFFSET	0x7f
	#define RF_GAIN_OFFSET_MASK		0xfffff
#elif defined(CONFIG_RTL8188E)
	#define REG_RF_BB_GAIN_OFFSET	0x55
	#define RF_GAIN_OFFSET_MASK		0xfffff
#else
	#define REG_RF_BB_GAIN_OFFSET	0x55
	#define RF_GAIN_OFFSET_MASK		0xfffff
#endif /* CONFIG_RTL8723B */
#endif /*CONFIG_RF_POWER_TRIM*/

/* For store initial value of BB register */
typedef struct _BB_INIT_REGISTER {
	u16	offset;
	u32	value;

} BB_INIT_REGISTER, *PBB_INIT_REGISTER;

#define PAGE_SIZE_128	128
#define PAGE_SIZE_256	256
#define PAGE_SIZE_512	512

#define HCI_SUS_ENTER		0
#define HCI_SUS_LEAVING		1
#define HCI_SUS_LEAVE		2
#define HCI_SUS_ENTERING	3
#define HCI_SUS_ERR			4

#define EFUSE_FILE_UNUSED 0
#define EFUSE_FILE_FAILED 1
#define EFUSE_FILE_LOADED 2

#define MACADDR_FILE_UNUSED 0
#define MACADDR_FILE_FAILED 1
#define MACADDR_FILE_LOADED 2

#define MAX_IQK_INFO_BACKUP_CHNL_NUM	5
#define MAX_IQK_INFO_BACKUP_REG_NUM		10

struct kfree_data_t {
	u8 flag;
	s8 bb_gain[BB_GAIN_NUM][RF_PATH_MAX];

#if CONFIG_IEEE80211_BAND_5GHZ
	s8 pa_bias_5g[RF_PATH_MAX];
	s8 pad_bias_5g[RF_PATH_MAX];
#endif
	s8 thermal;
};

bool kfree_data_is_bb_gain_empty(struct kfree_data_t *data);

struct hal_spec_t {
	char *ic_name;
	u8 macid_num;

	u8 sec_cam_ent_num;
	u8 sec_cap;

	u8 rfpath_num_2g:4;	/* used for tx power index path */
	u8 rfpath_num_5g:4;	/* used for tx power index path */
	u8 rf_reg_path_num;
	u8 max_tx_cnt;

	u8 tx_nss_num:4;
	u8 rx_nss_num:4;

	u8 band_cap;	/* value of BAND_CAP_XXX */
	u8 bw_cap;		/* value of BW_CAP_XXX */
	u8 port_num;
	u8 proto_cap;	/* value of PROTO_CAP_XXX */

	u8 txgi_max; /* maximum tx power gain index */
	u8 txgi_pdbm; /* tx power gain index per dBm */

	u8 wl_func;		/* value of WL_FUNC_XXX */

#if CONFIG_TX_AC_LIFETIME
	u8 tx_aclt_unit_factor; /* how many 32us */
#endif

	u8 rx_tsf_filter:1;

	u8 pg_txpwr_saddr; /* starting address of PG tx power info */
	u8 pg_txgi_diff_factor; /* PG tx power gain index diff to tx power gain index */

	u8 hci_type;	/* value of HCI Type */
};

#define HAL_SPEC_CHK_RF_PATH_2G(_spec, _path) ((_spec)->rfpath_num_2g > (_path))
#define HAL_SPEC_CHK_RF_PATH_5G(_spec, _path) ((_spec)->rfpath_num_5g > (_path))
#define HAL_SPEC_CHK_RF_PATH(_spec, _band, _path) ( \
	_band == BAND_ON_2_4G ? HAL_SPEC_CHK_RF_PATH_2G(_spec, _path) : \
	_band == BAND_ON_5G ? HAL_SPEC_CHK_RF_PATH_5G(_spec, _path) : 0)

#ifdef CONFIG_PHY_CAPABILITY_QUERY
struct phy_spec_t {
	u32 trx_cap;
	u32 stbc_cap;
	u32 ldpc_cap;
	u32 txbf_param;
	u32 txbf_cap;
};
#endif
struct hal_iqk_reg_backup {
	u8 central_chnl;
	u8 bw_mode;
	u32 reg_backup[MAX_RF_PATH][MAX_IQK_INFO_BACKUP_REG_NUM];
};


typedef struct hal_p2p_ps_para {
	/*DW0*/
	u8  offload_en:1;
	u8  role:1;
	u8  ctwindow_en:1;
	u8  noa_en:1;
	u8  noa_sel:1;
	u8  all_sta_sleep:1;
	u8  discovery:1;
	u8  disable_close_rf:1;
	u8  p2p_port_id;
	u8  p2p_group;
	u8  p2p_macid;

	/*DW1*/
	u8 ctwindow_length;
	u8 rsvd3;
	u8 rsvd4;
	u8 rsvd5;

	/*DW2*/
	u32 noa_duration_para;

	/*DW3*/
	u32 noa_interval_para;

	/*DW4*/
	u32 noa_start_time_para;

	/*DW5*/
	u32 noa_count_para;
} HAL_P2P_PS_PARA, *PHAL_P2P_PS_PARA;

#define TXPWR_LMT_RS_CCK	0
#define TXPWR_LMT_RS_OFDM	1
#define TXPWR_LMT_RS_HT		2
#define TXPWR_LMT_RS_VHT	3
#define TXPWR_LMT_RS_NUM	4

#define TXPWR_LMT_RS_NUM_2G	4 /* CCK, OFDM, HT, VHT */
#define TXPWR_LMT_RS_NUM_5G	3 /* OFDM, HT, VHT */

#if CONFIG_TXPWR_LIMIT
extern const char *const _txpwr_lmt_rs_str[];
#define txpwr_lmt_rs_str(rs) (((rs) >= TXPWR_LMT_RS_NUM) ? _txpwr_lmt_rs_str[TXPWR_LMT_RS_NUM] : _txpwr_lmt_rs_str[(rs)])

struct txpwr_lmt_ent {
	_list list;

	s8 lmt_2g[MAX_2_4G_BANDWIDTH_NUM]
		[TXPWR_LMT_RS_NUM_2G]
		[CENTER_CH_2G_NUM]
		[MAX_TX_COUNT];

#if CONFIG_IEEE80211_BAND_5GHZ
	s8 lmt_5g[MAX_5G_BANDWIDTH_NUM]
		[TXPWR_LMT_RS_NUM_5G]
		[CENTER_CH_5G_ALL_NUM]
		[MAX_TX_COUNT];
#endif

	char regd_name[0];
};
#endif /* CONFIG_TXPWR_LIMIT */

typedef struct hal_com_data {
	HAL_VERSION			version_id;
	RT_MULTI_FUNC		MultiFunc; /* For multi-function consideration. */
	RT_POLARITY_CTL		PolarityCtl; /* For Wifi PDn Polarity control. */
	RT_REGULATOR_MODE	RegulatorMode; /* switching regulator or LDO */
	u8	hw_init_completed;
	/****** FW related ******/
	u32 firmware_size;
	u16 firmware_version;
	u16	FirmwareVersionRev;
	u16 firmware_sub_version;
	u16	FirmwareSignature;
	u8	RegFWOffload;
	u8	bFWReady;
	u8	bBTFWReady;
	u8	fw_ractrl;
	u8	LastHMEBoxNum;	/* H2C - for host message to fw */
#ifdef CONFIG_LPS_1T1R
	u8 lps_1t1r;
#endif

	/****** current WIFI_PHY values ******/
	WIRELESS_MODE	CurrentWirelessMode;
	enum channel_width current_channel_bw;
	BAND_TYPE		current_band_type;	/* 0:2.4G, 1:5G */
	BAND_TYPE		BandSet;
	u8				current_channel;
	u8				cch_20;
	u8				cch_40;
	u8				cch_80;
	u8				CurrentCenterFrequencyIndex1;
	u8				nCur40MhzPrimeSC;	/* Control channel sub-carrier */
	u8				nCur80MhzPrimeSC;   /* used for primary 40MHz of 80MHz mode */
	BOOLEAN		bSwChnlAndSetBWInProgress;
	u8				bDisableSWChannelPlan; /* flag of disable software change channel plan	 */
	u16				BasicRateSet;
	u32				ReceiveConfig;
	u32				rcr_backup; /* used for switching back from monitor mode */
	u8				rx_tsf_addr_filter_config; /* for 8822B/8821C USE */
	BOOLEAN			bSwChnl;
	BOOLEAN			bSetChnlBW;
	BOOLEAN			bSWToBW40M;
	BOOLEAN			bSWToBW80M;
	BOOLEAN			bChnlBWInitialized;

#ifdef CONFIG_RTW_ACS
	struct auto_chan_sel acs;
#endif
#ifdef CONFIG_BCN_RECOVERY
	u8 issue_bcn_fail;
#endif /*CONFIG_BCN_RECOVERY*/

	/****** rf_ctrl *****/
	u8	rf_chip;

	u8 trx_path_bmp; /* [7:4]TX path bmp, [0:3]RX path bmp */
	u8	rf_type;	/*enum rf_type , is RF_PATH - GET_HAL_RFPATH*/
	u8	NumTotalRFPath; /*GET_HAL_RFPATH_NUM*/
	u8 max_tx_cnt;
	u8	tx_nss; /*tx Spatial Streams - GET_HAL_TX_NSS*/
	u8	rx_nss; /*rx Spatial Streams - GET_HAL_RX_NSS*/

	u8	PackageType;
	u8	antenna_test;

	/* runtime TRX path setting */
	enum bb_path txpath; /* TX path bmp */
	enum bb_path rxpath; /* RX path bmp */
	enum bb_path txpath_nss[4]; /* path bmp for NSS TX, [0] for 1SS, [3] for 4SS */
	u8 txpath_num_nss[4]; /* path num for NSS TX, [0] for 1SS, [3] for 4SS */

	/****** Debug ******/
	u16	ForcedDataRate;	/* Force Data Rate. 0: Auto, 0x02: 1M ~ 0x6C: 54M. */
	u8	bDumpRxPkt;
	u8	bDumpTxPkt;
	u8	dis_turboedca; /* 1: disable turboedca, 
						  2: disable turboedca and setting EDCA parameter based on the input parameter*/
	u32 edca_param_mode;

	/****** EEPROM setting.******/
	u8	bautoload_fail_flag;
	u8	efuse_file_status;
	u8	macaddr_file_status;
	u8	EepromOrEfuse;
	u8	efuse_eeprom_data[EEPROM_MAX_SIZE]; /*92C:256bytes, 88E:512bytes, we use union set (512bytes)*/
	u8	InterfaceSel; /* board type kept in eFuse */
	u16	CustomerID;

	u16	EEPROMVID;
	u16	EEPROMSVID;
#ifdef CONFIG_USB_HCI
	u8	EEPROMUsbSwitch;
	u16	EEPROMPID;
	u16	EEPROMSDID;
#endif
#ifdef CONFIG_PCI_HCI
	u16	EEPROMDID;
	u16	EEPROMSMID;
#endif

	u8	EEPROMCustomerID;
	u8	EEPROMSubCustomerID;
	u8	EEPROMVersion;
	u8	EEPROMRegulatory;
	u8	eeprom_thermal_meter;
	u8	EEPROMBluetoothCoexist;
	u8	EEPROMBluetoothType;
	u8	EEPROMBluetoothAntNum;
	u8	EEPROMBluetoothAntIsolation;
	u8	EEPROMBluetoothRadioShared;
	u8	EEPROMMACAddr[ETH_ALEN];

	u8 eeprom_trx_path_bmp; /* [7:4]TX path bmp, [0:3]RX path bmp. 0x00:not specified */
	u8 eeprom_max_tx_cnt; /* 0: not specified */

	u8	tx_bbswing_24G;
	u8	tx_bbswing_5G;
	u8	efuse0x3d7;	/* efuse[0x3D7] */
	u8	efuse0x3d8;	/* efuse[0x3D8] */

#ifdef CONFIG_RF_POWER_TRIM
	u8	EEPROMRFGainOffset;
	u8	EEPROMRFGainVal;
	struct kfree_data_t kfree_data;
#endif /*CONFIG_RF_POWER_TRIM*/

#ifdef CONFIG_RTL8814A
	u32	BackUp_BB_REG_4_2nd_CCA[3];
#endif
#if defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8703B) || \
	defined(CONFIG_RTL8723D) || \
	defined(CONFIG_RTL8192F)

	u8	adjuseVoltageVal;
	u8	need_restore;
#endif
	u8	EfuseUsedPercentage;
	u16	EfuseUsedBytes;
	/*u8		EfuseMap[2][HWSET_MAX_SIZE_JAGUAR];*/
	EFUSE_HAL	EfuseHal;

	u8 txpwr_pg_mode; /* enum txpwr_pg_mode */

	/*---------------------------------------------------------------------------------*/
#ifdef CONFIG_TXPWR_PG_WITH_PWR_IDX
	/* 2.4G TX power info for target TX power*/
	u8	Index24G_CCK_Base[MAX_RF_PATH][CENTER_CH_2G_NUM];
	u8	Index24G_BW40_Base[MAX_RF_PATH][CENTER_CH_2G_NUM];
	s8	CCK_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
	s8	OFDM_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
	s8	BW20_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
	s8	BW40_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];

	/* 5G TX power info for target TX power*/
#if CONFIG_IEEE80211_BAND_5GHZ
	u8	Index5G_BW40_Base[MAX_RF_PATH][CENTER_CH_5G_ALL_NUM];
	u8	Index5G_BW80_Base[MAX_RF_PATH][CENTER_CH_5G_80M_NUM];
	s8	OFDM_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
	s8	BW20_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
	s8	BW40_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
	s8	BW80_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
#endif
#endif /* CONFIG_TXPWR_PG_WITH_PWR_IDX */

	u8 txpwr_by_rate_undefined_band_path[TX_PWR_BY_RATE_NUM_BAND]
		[TX_PWR_BY_RATE_NUM_RF];

	s8	TxPwrByRate[TX_PWR_BY_RATE_NUM_BAND]
		[TX_PWR_BY_RATE_NUM_RF]
		[TX_PWR_BY_RATE_NUM_RATE];

	/* Store the target power for each rate section and rf path */
	u8	target_txpwr_2g[TX_PWR_BY_RATE_NUM_RF]
		[NUM_OF_TARGET_TXPWR_2G];
	u8	target_txpwr_5g[TX_PWR_BY_RATE_NUM_RF]
		[NUM_OF_TARGET_TXPWR_5G];

#if defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8822C) || defined(CONFIG_RTL8814B)
	u32 txagc_set_buf;
#endif

	u8	txpwr_by_rate_loaded:1;
	u8	txpwr_by_rate_from_file:1;
	u8	txpwr_limit_loaded:1;
	u8	txpwr_limit_from_file:1;

	/* Read/write are allow for following hardware information variables	 */
	u8	crystal_cap;

	u8	PAType_2G;
	u8	PAType_5G;
	u8	LNAType_2G;
	u8	LNAType_5G;
	u8	ExternalPA_2G;
	u8	ExternalLNA_2G;
	u8	external_pa_5g;
	u8	external_lna_5g;
	u16	TypeGLNA;
	u16	TypeGPA;
	u16	TypeALNA;
	u16	TypeAPA;
	u16	rfe_type;

	u8	bLedOpenDrain; /* Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16. */
	u32	ac_param_be; /* Original parameter for BE, use for EDCA turbo.	*/
	u8	is_turbo_edca;
	u8	prv_traffic_idx;
	BB_REGISTER_DEFINITION_T	PHYRegDef[MAX_RF_PATH];	/* Radio A/B/C/D */

	u32	RfRegChnlVal[MAX_RF_PATH];

	/* RDG enable */
	BOOLEAN	 bRDGEnable;

	#if defined (CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
	u32 RegRRSR;
	#endif

	/****** antenna diversity ******/
	u8	AntDivCfg;
	u8	with_extenal_ant_switch;
	u8	b_fix_tx_ant;
	u8	AntDetection;
	u8	TRxAntDivType;
	u8	ant_path; /* for 8723B s0/s1 selection	 */
	u32	antenna_tx_path;					/* Antenna path Tx */
	u32	AntennaRxPath;					/* Antenna path Rx */
	u8 sw_antdiv_bl_state;

	/******** PHY DM & DM Section **********/
	_lock		IQKSpinLock;
	u8			INIDATA_RATE[MACID_NUM_SW_LIMIT];

	struct dm_struct	 odmpriv;
	u64			bk_rf_ability;
	u8			bIQKInitialized;
	u8			bNeedIQK;
	u8			neediqk_24g;
	u8			IQK_MP_Switch;
	u8			bScanInProcess;
	/******** PHY DM & DM Section **********/



	/* 2010/08/09 MH Add CU power down mode. */
	BOOLEAN		pwrdown;

#ifdef CONFIG_P2P
#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	u16 p2p_ps_offload;
#else
	u8	p2p_ps_offload;
#endif
#endif
	/* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
	u8	bMacPwrCtrlOn;
	u8 hci_sus_state;

	u8	RegIQKFWOffload;
	struct submit_ctx	iqk_sctx;
	u8 ch_switch_offload;
	struct submit_ctx chsw_sctx;

	RT_AMPDU_BRUST		AMPDUBurstMode; /* 92C maybe not use, but for compile successfully */

	u8	OutEpQueueSel;
	u8	OutEpNumber;

#ifdef RTW_RX_AGGREGATION
	RX_AGG_MODE rxagg_mode;

	/* For RX Aggregation DMA Mode */
	u8 rxagg_dma_size;
	u8 rxagg_dma_timeout;
#endif /* RTW_RX_AGGREGATION */

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	/*  */
	/* For SDIO Interface HAL related */
	/*  */

	/*  */
	/* SDIO ISR Related */
	/*
	*	u32			IntrMask[1];
	*	u32			IntrMaskToSet[1];
	*	LOG_INTERRUPT		InterruptLog; */
	u32			sdio_himr;
	u32			sdio_hisr;
#ifndef RTW_HALMAC
	/*  */
	/* SDIO Tx FIFO related. */
	/*  */
	/* HIQ, MID, LOW, PUB free pages; padapter->xmitpriv.free_txpg */
#ifdef CONFIG_RTL8192F
	u16			SdioTxFIFOFreePage[SDIO_TX_FREE_PG_QUEUE];
#else
	u8			SdioTxFIFOFreePage[SDIO_TX_FREE_PG_QUEUE];
#endif/*CONFIG_RTL8192F*/
#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT
	u8			sdio_avail_int_en_q;
#endif
	_lock		SdioTxFIFOFreePageLock;
	u8			SdioTxOQTMaxFreeSpace;
	u8			SdioTxOQTFreeSpace;
#else /* RTW_HALMAC */
	u16			SdioTxOQTFreeSpace;
#endif /* RTW_HALMAC */

	/*  */
	/* SDIO Rx FIFO related. */
	/*  */
	u8			SdioRxFIFOCnt;
#ifdef CONFIG_RTL8822C
	u32			SdioRxFIFOSize;
#else
	u16			SdioRxFIFOSize;
#endif

#ifndef RTW_HALMAC
	u32			sdio_tx_max_len[SDIO_MAX_TX_QUEUE];/* H, N, L, used for sdio tx aggregation max length per queue */
#else
#ifdef CONFIG_RTL8821C
	u16			tx_high_page;
	u16			tx_low_page;
	u16			tx_normal_page;
	u16			tx_extra_page;
	u16			tx_pub_page;
	u8			max_oqt_size;
	#ifdef XMIT_BUF_SIZE
	u32			max_xmit_size_vovi;
	u32			max_xmit_size_bebk;
	#endif /*XMIT_BUF_SIZE*/
	u16			max_xmit_page;
	u16			max_xmit_page_vo;
	u16			max_xmit_page_vi;
	u16			max_xmit_page_be;
	u16			max_xmit_page_bk;

#endif /*#ifdef CONFIG_RTL8821C*/
#endif /* !RTW_HALMAC */
#endif /* CONFIG_SDIO_HCI */

#ifdef CONFIG_USB_HCI

	/* 2010/12/10 MH Add for USB aggreation mode dynamic shceme. */
	BOOLEAN		UsbRxHighSpeedMode;
	BOOLEAN		UsbTxVeryHighSpeedMode;
	u32			UsbBulkOutSize;
	BOOLEAN		bSupportUSB3;
	u8			usb_intf_start;

	/* Interrupt relatd register information. */
	u32			IntArray[3];/* HISR0,HISR1,HSISR */
	u32			IntrMask[3];
#ifdef CONFIG_USB_TX_AGGREGATION
	u8			UsbTxAggMode;
	u8			UsbTxAggDescNum;
#endif /* CONFIG_USB_TX_AGGREGATION */

#ifdef CONFIG_USB_RX_AGGREGATION
	u16			HwRxPageSize;				/* Hardware setting */

	/* For RX Aggregation USB Mode */
	u8			rxagg_usb_size;
	u8			rxagg_usb_timeout;
#endif/* CONFIG_USB_RX_AGGREGATION */
#endif /* CONFIG_USB_HCI */


#ifdef CONFIG_PCI_HCI
	/*  */
	/* EEPROM setting. */
	/*  */
	u32			TransmitConfig;
	u32			IntrMaskToSet[2];
	u32			IntArray[4];
	u32			IntrMask[4];
	u32			SysIntArray[1];
	u32			SysIntrMask[1];
	u32			IntrMaskReg[2];
	u32			IntrMaskDefault[4];

	u32			pci_backdoor_ctrl;

	u8			bDefaultAntenna;

	u8			bInterruptMigration;
	u8			bDisableTxInt;

	u16			RxTag;
#endif /* CONFIG_PCI_HCI */


#ifdef DBG_CONFIG_ERROR_DETECT
	struct sreset_priv srestpriv;
#endif /* #ifdef DBG_CONFIG_ERROR_DETECT */

#ifdef CONFIG_BT_COEXIST
	/* For bluetooth co-existance */
	BT_COEXIST		bt_coexist;
#endif /* CONFIG_BT_COEXIST */

#if defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8703B) \
	|| defined(CONFIG_RTL8188F) || defined(CONFIG_RTL8188GTV) || defined(CONFIG_RTL8723D)|| defined(CONFIG_RTL8192F)
#ifndef CONFIG_PCI_HCI	/* mutual exclusive with PCI -- so they're SDIO and GSPI */
	/* Interrupt relatd register information. */
	u32			SysIntrStatus;
	u32			SysIntrMask;
#endif
#endif /*endif CONFIG_RTL8723B	*/

#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
	char	para_file_buf[MAX_PARA_FILE_BUF_LEN];
	char *mac_reg;
	u32	mac_reg_len;
	char *bb_phy_reg;
	u32	bb_phy_reg_len;
	char *bb_agc_tab;
	u32	bb_agc_tab_len;
	char *bb_phy_reg_pg;
	u32	bb_phy_reg_pg_len;
	char *bb_phy_reg_mp;
	u32	bb_phy_reg_mp_len;
	char *rf_radio_a;
	u32	rf_radio_a_len;
	char *rf_radio_b;
	u32	rf_radio_b_len;
	char *rf_tx_pwr_track;
	u32	rf_tx_pwr_track_len;
	char *rf_tx_pwr_lmt;
	u32	rf_tx_pwr_lmt_len;
#endif

#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
	struct noise_monitor nm;
#endif

	struct hal_spec_t hal_spec;
#ifdef CONFIG_PHY_CAPABILITY_QUERY
	struct phy_spec_t phy_spec;
#endif
	u8	RfKFreeEnable;
	u8	RfKFree_ch_group;
	BOOLEAN				bCCKinCH14;
	BB_INIT_REGISTER	RegForRecover[5];

#if defined(CONFIG_PCI_HCI) && defined(RTL8814AE_SW_BCN)
	BOOLEAN bCorrectBCN;
#endif
#ifdef CONFIG_RTL8814A
	u32 RxGainOffset[4]; /*{2G, 5G_Low, 5G_Middle, G_High}*/
	u8 BackUp_IG_REG_4_Chnl_Section[4]; /*{A,B,C,D}*/
#endif
	struct hal_iqk_reg_backup iqk_reg_backup[MAX_IQK_INFO_BACKUP_CHNL_NUM];

#ifdef RTW_HALMAC
	u16 drv_rsvd_page_number;
#endif

#ifdef CONFIG_BEAMFORMING
	u8 backup_snd_ptcl_ctrl;
#ifdef RTW_BEAMFORMING_VERSION_2
	struct beamforming_info beamforming_info;
#endif /* RTW_BEAMFORMING_VERSION_2 */
#endif /* CONFIG_BEAMFORMING */

	u8 not_xmitframe_fw_dl; /*not use xmitframe to download fw*/
	u8 phydm_op_mode;

	u8 in_cta_test;

#ifdef CONFIG_RTW_LED
	struct led_priv led;
#endif
	/* for multi channel case (ex: MCC/TDLS) */
	u8 multi_ch_switch_mode;
	
#ifdef CONFIG_RTL8814B
	u8 dma_ch_map[32];	/* TXDESC qsel maximum size */
#endif

} HAL_DATA_COMMON, *PHAL_DATA_COMMON;

typedef struct hal_com_data HAL_DATA_TYPE, *PHAL_DATA_TYPE;
#define GET_HAL_DATA(__pAdapter)		((HAL_DATA_TYPE *)(((struct _ADAPTER*)__pAdapter)->HalData))
#define GET_HAL_SPEC(__pAdapter)			(&(GET_HAL_DATA((__pAdapter))->hal_spec))
#define adapter_to_led(adapter) (&(GET_HAL_DATA(adapter)->led))

#define RT_GetInterfaceSelection(_Adapter)		(GET_HAL_DATA(_Adapter)->InterfaceSel)

#define GET_KFREE_DATA(_adapter) (&(GET_HAL_DATA((_adapter))->kfree_data))

#define	SUPPORT_HW_RADIO_DETECT(Adapter)	(RT_GetInterfaceSelection(Adapter) == INTF_SEL2_MINICARD || \
		RT_GetInterfaceSelection(Adapter) == INTF_SEL3_USB_Solo || \
		RT_GetInterfaceSelection(Adapter) == INTF_SEL4_USB_Combo)

#define get_hal_mac_addr(adapter)				(GET_HAL_DATA(adapter)->EEPROMMACAddr)
#define is_boot_from_eeprom(adapter)			(GET_HAL_DATA(adapter)->EepromOrEfuse)
#define rtw_get_hw_init_completed(adapter)		(GET_HAL_DATA(adapter)->hw_init_completed)
#define rtw_set_hw_init_completed(adapter, cmp)	(GET_HAL_DATA(adapter)->hw_init_completed = cmp)
#define rtw_is_hw_init_completed(adapter)		(GET_HAL_DATA(adapter)->hw_init_completed == _TRUE)

/* refer to (hal_data->version_id.RFType / registrypriv->rf_path / 8814a from efuse or registrypriv)*/
#define GET_HAL_RFPATH(adapter)			(GET_HAL_DATA(adapter)->rf_type)
#define GET_HAL_RFPATH_NUM(adapter)		(GET_HAL_DATA(adapter)->NumTotalRFPath)
#define GET_HAL_TX_PATH_BMP(adapter)	((GET_HAL_DATA(adapter)->trx_path_bmp & 0xF0) >> 4)
#define GET_HAL_RX_PATH_BMP(adapter)	(GET_HAL_DATA(adapter)->trx_path_bmp & 0x0F)

/* refer to (registrypriv-> tx_nss,rx_nss / hal_spec->tx_nss_num,rx_nss_num)*/
#define GET_HAL_TX_NSS(adapter)			(GET_HAL_DATA(adapter)->tx_nss)
#define GET_HAL_RX_NSS(adapter)			(GET_HAL_DATA(adapter)->rx_nss)

#endif

#ifdef RTW_HALMAC
int rtw_halmac_deinit_adapter(struct dvobj_priv *);
#endif /* RTW_HALMAC */

#endif /* __HAL_DATA_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/rtl8723d_spec.h                                                               0000644 0001750 0001750 00000040027 14214766567 016103  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_SPEC_H__
#define __RTL8723D_SPEC_H__

#include <drv_conf.h>


#define HAL_NAV_UPPER_UNIT_8723D		128		/* micro-second */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_SYS_ISO_CTRL_8723D			0x0000	/* 2 Byte */
#define REG_SYS_FUNC_EN_8723D			0x0002	/* 2 Byte */
#define REG_APS_FSMCO_8723D			0x0004	/* 4 Byte */
#define REG_SYS_CLKR_8723D				0x0008	/* 2 Byte */
#define REG_9346CR_8723D				0x000A	/* 2 Byte */
#define REG_EE_VPD_8723D				0x000C	/* 2 Byte */
#define REG_AFE_MISC_8723D				0x0010	/* 1 Byte */
#define REG_SPS0_CTRL_8723D				0x0011	/* 7 Byte */
#define REG_SPS_OCP_CFG_8723D			0x0018	/* 4 Byte */
#define REG_RSV_CTRL_8723D				0x001C	/* 3 Byte */
#define REG_RF_CTRL_8723D				0x001F	/* 1 Byte */
#define REG_LPLDO_CTRL_8723D			0x0023	/* 1 Byte */
#define REG_AFE_XTAL_CTRL_8723D		0x0024	/* 4 Byte */
#define REG_AFE_PLL_CTRL_8723D			0x0028	/* 4 Byte */
#define REG_MAC_PLL_CTRL_EXT_8723D		0x002c	/* 4 Byte */
#define REG_EFUSE_CTRL_8723D			0x0030
#define REG_EFUSE_TEST_8723D			0x0034
#define REG_PWR_DATA_8723D				0x0038
#define REG_CAL_TIMER_8723D				0x003C
#define REG_ACLK_MON_8723D				0x003E
#define REG_GPIO_MUXCFG_8723D			0x0040
#define REG_GPIO_IO_SEL_8723D			0x0042
#define REG_MAC_PINMUX_CFG_8723D		0x0043
#define REG_GPIO_PIN_CTRL_8723D			0x0044
#define REG_GPIO_INTM_8723D				0x0048
#define REG_LEDCFG0_8723D				0x004C
#define REG_LEDCFG1_8723D				0x004D
#define REG_LEDCFG2_8723D				0x004E
#define REG_LEDCFG3_8723D				0x004F
#define REG_FSIMR_8723D					0x0050
#define REG_FSISR_8723D					0x0054
#define REG_HSIMR_8723D					0x0058
#define REG_HSISR_8723D					0x005c
#define REG_GPIO_EXT_CTRL				0x0060
#define REG_PAD_CTRL1_8723D		0x0064
#define REG_MULTI_FUNC_CTRL_8723D		0x0068
#define REG_GPIO_STATUS_8723D			0x006C
#define REG_SDIO_CTRL_8723D				0x0070
#define REG_OPT_CTRL_8723D				0x0074
#define REG_AFE_CTRL_4_8723D		0x0078
#define REG_MCUFWDL_8723D				0x0080
#define REG_8051FW_CTRL_8723D			0x0080
#define REG_HMEBOX_DBG_0_8723D	0x0088
#define REG_HMEBOX_DBG_1_8723D	0x008A
#define REG_HMEBOX_DBG_2_8723D	0x008C
#define REG_HMEBOX_DBG_3_8723D	0x008E
#define REG_WLLPS_CTRL		0x0090
#define REG_HIMR0_8723D					0x00B0
#define REG_HISR0_8723D					0x00B4
#define REG_HIMR1_8723D					0x00B8
#define REG_HISR1_8723D					0x00BC
#define REG_PMC_DBG_CTRL2_8723D			0x00CC
#define	REG_EFUSE_BURN_GNT_8723D		0x00CF
#define REG_HPON_FSM_8723D				0x00EC
#define REG_SYS_CFG1_8723D				0x00F0
#define REG_SYS_CFG_8723D				0x00FC
#define REG_ROM_VERSION					0x00FD

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_C2HEVT_CMD_ID_8723D	0x01A0
#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
#define REG_C2HEVT_CMD_LEN_8723D        0x01AE
#define REG_C2HEVT_CLEAR_8723D			0x01AF
#define REG_MCUTST_1_8723D				0x01C0
#define REG_WOWLAN_WAKE_REASON 0x01C7
#define REG_FMETHR_8723D				0x01C8
#define REG_HMETFR_8723D				0x01CC
#define REG_HMEBOX_0_8723D				0x01D0
#define REG_HMEBOX_1_8723D				0x01D4
#define REG_HMEBOX_2_8723D				0x01D8
#define REG_HMEBOX_3_8723D				0x01DC
#define REG_LLT_INIT_8723D				0x01E0
#define REG_HMEBOX_EXT0_8723D			0x01F0
#define REG_HMEBOX_EXT1_8723D			0x01F4
#define REG_HMEBOX_EXT2_8723D			0x01F8
#define REG_HMEBOX_EXT3_8723D			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RQPN_8723D					0x0200
#define REG_FIFOPAGE_8723D				0x0204
#define REG_DWBCN0_CTRL_8723D			REG_TDECTRL
#define REG_TXDMA_OFFSET_CHK_8723D	0x020C
#define REG_TXDMA_STATUS_8723D		0x0210
#define REG_RQPN_NPQ_8723D			0x0214
#define REG_DWBCN1_CTRL_8723D			0x0228


/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_AGG_PG_TH_8723D		0x0280
#define REG_FW_UPD_RDPTR_8723D		0x0284 /* FW shall update this register before FW write RXPKT_RELEASE_POLL to 1 */
#define REG_RXDMA_CONTROL_8723D		0x0286 /* Control the RX DMA. */
#define REG_RXDMA_STATUS_8723D			0x0288
#define REG_RXDMA_MODE_CTRL_8723D		0x0290
#define REG_EARLY_MODE_CONTROL_8723D	0x02BC
#define REG_RSVD5_8723D					0x02F0
#define REG_RSVD6_8723D					0x02F4

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8723D			0x0300
#define	REG_INT_MIG_8723D				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_TXBD_DESA_8723D		0x0308	/* TX Beacon Descriptor Address */
#define	REG_MGQ_TXBD_DESA_8723D			0x0310	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_TXBD_DESA_8723D			0x0318	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_TXBD_DESA_8723D			0x0320	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_TXBD_DESA_8723D			0x0328	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_TXBD_DESA_8723D			0x0330	/* TX BK Queue Descriptor Address */
#define	REG_RXQ_RXBD_DESA_8723D			0x0338	/* RX Queue	Descriptor Address */
#define REG_HI0Q_TXBD_DESA_8723D		0x0340
#define REG_HI1Q_TXBD_DESA_8723D		0x0348
#define REG_HI2Q_TXBD_DESA_8723D		0x0350
#define REG_HI3Q_TXBD_DESA_8723D		0x0358
#define REG_HI4Q_TXBD_DESA_8723D		0x0360
#define REG_HI5Q_TXBD_DESA_8723D		0x0368
#define REG_HI6Q_TXBD_DESA_8723D		0x0370
#define REG_HI7Q_TXBD_DESA_8723D		0x0378
#define	REG_MGQ_TXBD_NUM_8723D			0x0380
#define	REG_RX_RXBD_NUM_8723D			0x0382
#define	REG_VOQ_TXBD_NUM_8723D			0x0384
#define	REG_VIQ_TXBD_NUM_8723D			0x0386
#define	REG_BEQ_TXBD_NUM_8723D			0x0388
#define	REG_BKQ_TXBD_NUM_8723D			0x038A
#define	REG_HI0Q_TXBD_NUM_8723D			0x038C
#define	REG_HI1Q_TXBD_NUM_8723D			0x038E
#define	REG_HI2Q_TXBD_NUM_8723D			0x0390
#define	REG_HI3Q_TXBD_NUM_8723D			0x0392
#define	REG_HI4Q_TXBD_NUM_8723D			0x0394
#define	REG_HI5Q_TXBD_NUM_8723D			0x0396
#define	REG_HI6Q_TXBD_NUM_8723D			0x0398
#define	REG_HI7Q_TXBD_NUM_8723D			0x039A
#define	REG_TSFTIMER_HCI_8723D			0x039C
#define	REG_BD_RW_PTR_CLR_8723D			0x039C

/* Read Write Point */
#define	REG_VOQ_TXBD_IDX_8723D			0x03A0
#define	REG_VIQ_TXBD_IDX_8723D			0x03A4
#define	REG_BEQ_TXBD_IDX_8723D			0x03A8
#define	REG_BKQ_TXBD_IDX_8723D			0x03AC
#define	REG_MGQ_TXBD_IDX_8723D			0x03B0
#define	REG_RXQ_TXBD_IDX_8723D			0x03B4
#define	REG_HI0Q_TXBD_IDX_8723D			0x03B8
#define	REG_HI1Q_TXBD_IDX_8723D			0x03BC
#define	REG_HI2Q_TXBD_IDX_8723D			0x03C0
#define	REG_HI3Q_TXBD_IDX_8723D			0x03C4
#define	REG_HI4Q_TXBD_IDX_8723D			0x03C8
#define	REG_HI5Q_TXBD_IDX_8723D			0x03CC
#define	REG_HI6Q_TXBD_IDX_8723D			0x03D0
#define	REG_HI7Q_TXBD_IDX_8723D			0x03D4

#define	REG_PCIE_HCPWM_8723DE			0x03D8 /* ?????? */
#define	REG_PCIE_HRPWM_8723DE			0x03DC	/* PCIe RPWM  ?????? */
#define	REG_DBI_WDATA_V1_8723D			0x03E8
#define	REG_DBI_RDATA_V1_8723D			0x03EC
#define	REG_DBI_FLAG_V1_8723D			0x03F0
#define REG_MDIO_V1_8723D				0x03F4
#define REG_PCIE_MIX_CFG_8723D			0x03F8
#define REG_HCI_MIX_CFG_8723D			0x03FC

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_VOQ_INFORMATION_8723D		0x0400
#define REG_VIQ_INFORMATION_8723D		0x0404
#define REG_BEQ_INFORMATION_8723D		0x0408
#define REG_BKQ_INFORMATION_8723D		0x040C
#define REG_MGQ_INFORMATION_8723D		0x0410
#define REG_HGQ_INFORMATION_8723D		0x0414
#define REG_BCNQ_INFORMATION_8723D	0x0418
#define REG_TXPKT_EMPTY_8723D			0x041A

#define REG_FWHW_TXQ_CTRL_8723D		0x0420
#define REG_HWSEQ_CTRL_8723D			0x0423
#define REG_TXPKTBUF_BCNQ_BDNY_8723D	0x0424
#define REG_TXPKTBUF_MGQ_BDNY_8723D	0x0425
#define REG_LIFECTRL_CTRL_8723D			0x0426
#define REG_MULTI_BCNQ_OFFSET_8723D	0x0427
#define REG_SPEC_SIFS_8723D				0x0428
#define REG_RL_8723D						0x042A
#define REG_TXBF_CTRL_8723D				0x042C
#define REG_DARFRC_8723D				0x0430
#define REG_RARFRC_8723D				0x0438
#define REG_RRSR_8723D					0x0440
#define REG_ARFR0_8723D					0x0444
#define REG_ARFR1_8723D					0x044C
#define REG_CCK_CHECK_8723D				0x0454
#define REG_AMPDU_MAX_TIME_8723D		0x0456
#define REG_TXPKTBUF_BCNQ_BDNY1_8723D	0x0457

#define REG_AMPDU_MAX_LENGTH_8723D	0x0458
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8723D	0x045D
#define REG_NDPA_OPT_CTRL_8723D		0x045F
#define REG_FAST_EDCA_CTRL_8723D		0x0460
#define REG_RD_RESP_PKT_TH_8723D		0x0463
#define REG_DATA_SC_8723D				0x0483
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW             0x0484
	#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_TXRPT_START_OFFSET		0x04AC
#define REG_POWER_STAGE1_8723D		0x04B4
#define REG_POWER_STAGE2_8723D		0x04B8
#define REG_AMPDU_BURST_MODE_8723D	0x04BC
#define REG_PKT_VO_VI_LIFE_TIME_8723D	0x04C0
#define REG_PKT_BE_BK_LIFE_TIME_8723D	0x04C2
#define REG_STBC_SETTING_8723D			0x04C4
#define REG_HT_SINGLE_AMPDU_8723D		0x04C7
#define REG_PROT_MODE_CTRL_8723D		0x04C8
#define REG_MAX_AGGR_NUM_8723D		0x04CA
#define REG_RTS_MAX_AGGR_NUM_8723D	0x04CB
#define REG_BAR_MODE_CTRL_8723D		0x04CC
#define REG_RA_TRY_RATE_AGG_LMT_8723D	0x04CF
#define REG_MACID_PKT_DROP0_8723D		0x04D0
#define REG_MACID_PKT_SLEEP_8723D		0x04D4

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_EDCA_VO_PARAM_8723D		0x0500
#define REG_EDCA_VI_PARAM_8723D		0x0504
#define REG_EDCA_BE_PARAM_8723D		0x0508
#define REG_EDCA_BK_PARAM_8723D		0x050C
#define REG_BCNTCFG_8723D				0x0510
#define REG_PIFS_8723D					0x0512
#define REG_RDG_PIFS_8723D				0x0513
#define REG_SIFS_CTX_8723D				0x0514
#define REG_SIFS_TRX_8723D				0x0516
#define REG_AGGR_BREAK_TIME_8723D		0x051A
#define REG_SLOT_8723D					0x051B
#define REG_TX_PTCL_CTRL_8723D			0x0520
#define REG_TXPAUSE_8723D				0x0522
#define REG_DIS_TXREQ_CLR_8723D		0x0523
#define REG_RD_CTRL_8723D				0x0524
/*
 * Format for offset 540h-542h:
 *	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
 *	[7:4]:   Reserved.
 *	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
 *	[23:20]: Reserved
 * Description:
 *	              |
 * |<--Setup--|--Hold------------>|
 *	--------------|----------------------
 * |
 * TBTT
 * Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
 * Described by Designer Tim and Bruce, 2011-01-14.
 *   */
#define REG_TBTT_PROHIBIT_8723D			0x0540
#define REG_RD_NAV_NXT_8723D			0x0544
#define REG_NAV_PROT_LEN_8723D			0x0546
#define REG_BCN_CTRL_8723D				0x0550
#define REG_BCN_CTRL_1_8723D			0x0551
#define REG_MBID_NUM_8723D				0x0552
#define REG_DUAL_TSF_RST_8723D			0x0553
#define REG_BCN_INTERVAL_8723D			0x0554
#define REG_DRVERLYINT_8723D			0x0558
#define REG_BCNDMATIM_8723D			0x0559
#define REG_ATIMWND_8723D				0x055A
#define REG_USTIME_TSF_8723D			0x055C
#define REG_BCN_MAX_ERR_8723D			0x055D
#define REG_RXTSF_OFFSET_CCK_8723D		0x055E
#define REG_RXTSF_OFFSET_OFDM_8723D	0x055F
#define REG_TSFTR_8723D					0x0560
#define REG_CTWND_8723D					0x0572
#define REG_SECONDARY_CCA_CTRL_8723D	0x0577
#define REG_PSTIMER_8723D				0x0580
#define REG_TIMER0_8723D				0x0584
#define REG_TIMER1_8723D				0x0588
#define REG_ACMHWCTRL_8723D			0x05C0
#define REG_SCH_TXCMD_8723D			0x05F8

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#define REG_MAC_CR_8723D				0x0600
#define REG_TCR_8723D					0x0604
#define REG_RCR_8723D					0x0608
#define REG_RX_PKT_LIMIT_8723D			0x060C
#define REG_RX_DLK_TIME_8723D			0x060D
#define REG_RX_DRVINFO_SZ_8723D		0x060F

#define REG_MACID_8723D					0x0610
#define REG_BSSID_8723D					0x0618
#define REG_MAR_8723D					0x0620
#define REG_MBIDCAMCFG_8723D			0x0628
#define REG_WOWLAN_GTK_DBG1	0x630
#define REG_WOWLAN_GTK_DBG2	0x634

#define REG_USTIME_EDCA_8723D			0x0638
#define REG_MAC_SPEC_SIFS_8723D		0x063A
#define REG_RESP_SIFP_CCK_8723D			0x063C
#define REG_RESP_SIFS_OFDM_8723D		0x063E
#define REG_ACKTO_8723D					0x0640
#define REG_CTS2TO_8723D				0x0641
#define REG_EIFS_8723D					0x0642

#define REG_NAV_UPPER_8723D			0x0652	/* unit of 128 */
#define REG_TRXPTCL_CTL_8723D			0x0668

/* Security */
#define REG_CAMCMD_8723D				0x0670
#define REG_CAMWRITE_8723D				0x0674
#define REG_CAMREAD_8723D				0x0678
#define REG_CAMDBG_8723D				0x067C
#define REG_SECCFG_8723D				0x0680

/* Power */
#define REG_WOW_CTRL_8723D				0x0690
#define REG_PS_RX_INFO_8723D			0x0692
#define REG_UAPSD_TID_8723D				0x0693
#define REG_WKFMCAM_CMD_8723D			0x0698
#define REG_WKFMCAM_NUM_8723D			0x0698
#define REG_WKFMCAM_RWD_8723D			0x069C
#define REG_RXFLTMAP0_8723D				0x06A0
#define REG_RXFLTMAP1_8723D				0x06A2
#define REG_RXFLTMAP2_8723D				0x06A4
#define REG_BCN_PSR_RPT_8723D			0x06A8
#define REG_BT_COEX_TABLE_8723D		0x06C0
#define REG_BFMER0_INFO_8723D			0x06E4
#define REG_BFMER1_INFO_8723D			0x06EC
#define REG_CSI_RPT_PARAM_BW20_8723D	0x06F4
#define REG_CSI_RPT_PARAM_BW40_8723D	0x06F8
#define REG_CSI_RPT_PARAM_BW80_8723D	0x06FC

/* Hardware Port 2 */
#define REG_MACID1_8723D				0x0700
#define REG_BSSID1_8723D				0x0708
#define REG_BFMEE_SEL_8723D				0x0714
#define REG_SND_PTCL_CTRL_8723D		0x0718

/* LTR */
#define REG_LTR_CTRL_BASIC_8723D		0x07A4
#define REG_LTR_IDLE_LATENCY_V1_8723D		0x0798
#define REG_LTR_ACTIVE_LATENCY_V1_8723D		0x079C

/* LTE_COEX */
#define REG_LTECOEX_CTRL			0x07C0
#define REG_LTECOEX_WRITE_DATA		0x07C4
#define REG_LTECOEX_READ_DATA		0x07C8
#define REG_LTECOEX_PATH_CONTROL	0x70

/* ************************************************************
 * SDIO Bus Specification
 * ************************************************************ */

/* -----------------------------------------------------
 * SDIO CMD Address Mapping
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * I/O bus domain (Host)
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * SDIO register
 * ----------------------------------------------------- */
#define SDIO_REG_HCPWM1_8723D	0x025 /* HCI Current Power Mode 1 */


/* ****************************************************************************
 *	8723 Regsiter Bit and Content definition
 * **************************************************************************** */

#define BIT_USB_RXDMA_AGG_EN	BIT(31)
#define RXDMA_AGG_MODE_EN		BIT(1)

#ifdef CONFIG_WOWLAN
	#define RXPKT_RELEASE_POLL		BIT(16)
	#define RXDMA_IDLE				BIT(17)
	#define RW_RELEASE_EN			BIT(18)
#endif

/* 2 HSISR
 * interrupt mask which needs to clear */
#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
		HSISR_SPS_OCP_INT |\
		HSISR_RON_INT |\
		HSISR_PDNINT |\
		HSISR_GPIO9_INT)

#ifdef CONFIG_RF_POWER_TRIM
	#ifdef CONFIG_RTL8723D
		#define EEPROM_RF_GAIN_OFFSET			0xC1
	#endif

	#define EEPROM_RF_GAIN_VAL				0x1F6
#endif /*CONFIG_RF_POWER_TRIM*/

#ifdef CONFIG_PCI_HCI
	/* #define IMR_RX_MASK		(IMR_ROK_8723D|IMR_RDU_8723D|IMR_RXFOVW_8723D) */
	#define IMR_TX_MASK			(IMR_VODOK_8723D | IMR_VIDOK_8723D | IMR_BEDOK_8723D | IMR_BKDOK_8723D | IMR_MGNTDOK_8723D | IMR_HIGHDOK_8723D)

	#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8723D | IMR_TXBCN0OK_8723D | IMR_TXBCN0ERR_8723D | IMR_BCNDERR0_8723D)

	#define RT_AC_INT_MASKS	(IMR_VIDOK_8723D | IMR_VODOK_8723D | IMR_BEDOK_8723D | IMR_BKDOK_8723D)
#endif

#endif /* __RTL8723D_SPEC_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/Hal8188EPhyReg.h                                                              0000644 0001750 0001750 00000104734 14214766567 016067  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8188EPHYREG_H__
#define __INC_HAL8188EPHYREG_H__
/*--------------------------Define Parameters-------------------------------*/
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart				0x104
#define		rPMAC_TxLegacySIG			0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum			0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble		0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK		0x170
#define		rPMAC_OFDMRxCRC32Er		0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus				0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define		rFPGA0_TxInfo					0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1				0x810	/* Useless now */
#define		rFPGA0_RFTiming2				0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter	0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864
#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888
#define		rFPGA0_AdDaClockEn			0x888	/* enable ad/da clock1 for dual-phy */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback		0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback		0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */

#define		rFPGA1_TxBlock				0x904	/* Useless now */
#define		rFPGA1_DebugSelect			0x908	/* Useless now */
#define		rFPGA1_TxInfo					0x90c	/* Useless now */ /* Status report?? */

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System					0xa00

#define		rCCK0_AFESetting				0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1			0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2			0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort				0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport			0xa50
#define		rCCK0_RxReport            			0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower      		0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper      		0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define		rPdp_AntA					0xb00
#define		rPdp_AntA_4				0xb04
#define		rConfig_Pmpd_AntA			0xb28
#define		rConfig_ram64x16				0xb2c
#define		rConfig_AntA					0xb68
#define		rConfig_AntB					0xb6c
#define		rPdp_AntB					0xb70
#define		rPdp_AntB_4					0xb74
#define		rConfig_Pmpd_AntB			0xb98
#define		rAPK							0xbd8



/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF					0xc00

#define		rOFDM0_TRxPathEnable			0xc04
#define		rOFDM0_TRMuxPar				0xc08
#define		rOFDM0_TRSWIsolation			0xc0c

#define		rOFDM0_XARxAFE				0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance    		0xc14  /* RxIQ imblance matrix */
#define		rOFDM0_XBRxAFE			0xc18
#define		rOFDM0_XBRxIQImbalance		0xc1c
#define		rOFDM0_XCRxAFE			0xc20
#define		rOFDM0_XCRxIQImbalance		0xc24
#define		rOFDM0_XDRxAFE			0xc28
#define		rOFDM0_XDRxIQImbalance		0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC			0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold		0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold			0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1		0xc70
#define		rOFDM0_AGCParameter2		0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter		0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync			0xcf0
#define		rOFDM0_DFSReport			0xcf4


/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO					0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD					0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet				0xd3c
#define		rOFDM1_csi_fix_mask1				0xd40
#define		rOFDM1_csi_fix_mask2				0xd44
#define		rOFDM1_PseudoNoiseStateAB	0xd50
#define		rOFDM1_PseudoNoiseStateCD	0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1			0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2			0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3			0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB			0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD			0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR				0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00		0xe10
#define		rTxAGC_A_Mcs07_Mcs04		0xe14
#define		rTxAGC_A_Mcs11_Mcs08		0xe18
#define		rTxAGC_A_Mcs15_Mcs12		0xe1c

#define		rTxAGC_B_Rate18_06			0x830
#define		rTxAGC_B_Rate54_24			0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00		0x83c
#define		rTxAGC_B_Mcs07_Mcs04		0x848
#define		rTxAGC_B_Mcs11_Mcs08		0x84c
#define		rTxAGC_B_Mcs15_Mcs12		0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1			0x1
#define		rZebra1_TRxEnable2			0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain				0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl					0	/* Useless now */
#define		rRTL8256_TxLPF				19
#define		rRTL8256_RxLPF				11

/* RTL8258 */
#define		rRTL8258_TxLPF				0x11	/* Useless now */
#define		rRTL8258_RxLPF				0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/*  */

#define		RF_IQADJ_G1					0x01	/*  */
#define		RF_IQADJ_G2					0x02	/*  */

#define		RF_POW_TRSW				0x05	/*  */

#define		RF_GAIN_RX					0x06	/*  */
#define		RF_GAIN_TX					0x07	/*  */

#define		RF_TXM_IDAC					0x08	/*  */
#define		RF_IPA_G						0x09	/*  */
#define		RF_TXBIAS_G					0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A						0x0C	/*  */
#define		RF_TXBIAS_A					0x0D
#define		RF_BS_PA_APSET_G9_G11		0x0E
#define		RF_BS_IQGEN					0x0F	/*  */

#define		RF_MODE1					0x10	/*  */
#define		RF_MODE2					0x11	/*  */

#define		RF_RX_AGC_HP				0x12	/*  */
#define		RF_TX_AGC					0x13	/*  */
#define		RF_BIAS						0x14	/*  */
#define		RF_IPA						0x15	/*  */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY				0x17	/*  */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/*  */

#define		RF_RX_G1					0x1A	/*  */
#define		RF_RX_G2					0x1B	/*  */

#define		RF_RX_BB2					0x1C	/*  */
#define		RF_RX_BB1					0x1D	/*  */

#define		RF_RCK1						0x1E	/*  */
#define		RF_RCK2						0x1F	/*  */

#define		RF_TX_G1						0x20	/*  */
#define		RF_TX_G2						0x21	/*  */
#define		RF_TX_G3						0x22	/*  */

#define		RF_TX_BB1					0x23	/*  */

#define		RF_T_METER_88E					0x42	/*  */
#define		RF_T_METER					0x24	/*  */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */
#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define		RF_TX_BIAS_A					0x35
#define		RF_TX_BIAS_D					0x36
#define		RF_LOBF_9					0x38
#define		RF_RXRF_A3					0x3C	/*	 */
#define		RF_TRSW						0x3F

#define		RF_TXRF_A2					0x41
#define		RF_TXPA_G4					0x46
#define		RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define		RF_WE_LUT					0xEF


/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB					0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart					0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback				0x10
#define		bTxLSIG						0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength				0x1ffe0
#define		bOFDMTxParity				0x20000
#define		bTxHTSIG1					0xffffff
#define		bTxHTMCSRate				0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2					0xffffff
#define		bTxHTSmoothing				0x1
#define		bTxHTSounding				0x2
#define		bTxHTReserved				0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC					0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8					0x3fc00
#define		bCounterReset				0x10000
#define		bNumOfOFDMTx				0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval				0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader				0xffffffff
#define		bTxDataInit					0xff
#define		bTxHTMode					0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed				0xffffffff
#define		bCCKTxPreamble				0x1
#define		bCCKTxSFD					0xffff0000
#define		bCCKTxSIG					0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus				0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))

/* 2. Page8(0x800) */
#define		bRFMOD						0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode					0x2
#define		bCCKTxSC						0x30
#define		bCCKEn						0x1000000
#define		bOFDMEn					0x2000000

#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC				0x3f

#define		bAntennaSelect			0x0300

#define		bXBTxAGC                  				0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC				0xf000
#define		bXDTxAGC				0xf0000

#define		bPAStart                  				0xf0000000	/* Useless now */
#define		bTRStart				0x00f00000
#define		bRFStart				0x0000f000
#define		bBBStart				0x000000f0
#define		bBBCCKStart			0x0000000f
#define		bPAEnd                    				0xf          /* Reg0x814 */
#define		bTREnd				0x0f000000
#define		bRFEnd				0x000f0000
#define		bCCAMask                  				0x000000f0   /* T2R */
#define		bR2RCCAMask			0x00000f00
#define		bHSSI_R2TDelay			0xf8000000
#define		bHSSI_T2RDelay			0xf80000
#define		bContTxHSSI               			0x400     /* chane gain at continue Tx */
#define		bIGFromCCK			0x200
#define		bAGCAddress			0x3f
#define		bRxHPTx				0x7000
#define		bRxHPT2R				0x38000
#define		bRxHPCCKIni			0xc0000
#define		bAGCTxCode			0xc00000
#define		bAGCRxCode			0x300000

#define		b3WireDataLength          			0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         		0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity			0x40000000
#define		b2GPAPEPolarity			0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData			0x1
#define		bRFSI_3WireClock			0x2
#define		bRFSI_3WireLoad			0x4
#define		bRFSI_3WireRW			0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW                		0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         		0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby	0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP	0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              		0x18000000	/* Useless */
#define		bAFEWatchDogEnable	0x20000000

#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x				0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          		0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode	0x40000
#define		bAD7InputCMMode	0x380000
#define		bAD7Current		0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx	0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx	0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint	0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport		0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 		0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                		0xff   /* reset debug page and LWord */
#define		bAntL				0x10
#define		bAntNonHT			0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode                		0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble              		0x8	/* Useless */
#define		bCCKAntDiversity			0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate			0x3000
#define		bCCKDCCancel		0x0800
#define		bCCKISICancel		0x0400
#define		bCCKMatchFilter		0x0200
#define		bCCKEqualizer		0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart		0x300000
#define		bCCKCCACount		0x080000
#define		bCCKcs_lim			0x070000
#define		bCCKBistMode		0x80000000
#define		bCCKCCAMask		0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset		0xf0
#define		bCCKRxDCOffset		0xf
#define		bCCKCCAMode		0xc000
#define		bCCKFalseCS_lim		0x3f00
#define		bCCKCS_ratio		0xc00000
#define		bCCKCorgBit_sel		0x300000
#define		bCCKPD_lim		0x0f0000
#define		bCCKNewCCA		0x80000000
#define		bCCKRxHPofIG		0x8000
#define		bCCKRxIG			0x7f00
#define		bCCKLNAPolarity		0x800000
#define		bCCKRx1stGain		0x7f0000
#define		bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC		0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType		0x0300
#define		bCCKRxDAGCEn		0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0			0x3f0000
#define		bCCKTxC1			0x3f000000
#define		bCCKTxC2			0x3f
#define		bCCKTxC3			0x3f00
#define		bCCKTxC4			0x3f0000
#define		bCCKTxC5			0x3f000000
#define		bCCKTxC6			0x3f
#define		bCCKTxC7			0x3f00
#define		bCCKDebugPort		0xff0000
#define		bCCKDACDebug		0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead	0x4000
#define		bCCKTRSSI			0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff	0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel		0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF                			0x3	/* Useless */
#define		bShift_L			0xc0
#define		bGI_TH			0xc
#define		bRxPathA			0x1
#define		bRxPathB			0x2
#define		bRxPathC			0x4
#define		bRxPathD			0x8
#define		bTxPathA			0x1
#define		bTxPathB			0x2
#define		bTxPathC			0x4
#define		bTxPathD			0x8
#define		bTRSSIFreq			0x200
#define		bADCBackoff			0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset		0xff00
#define		bRxDFIRMode		0x1800000
#define		bRxDCNFType		0xe000000
#define		bRXIQImb_A		0x3ff
#define		bRXIQImb_B			0xfc00
#define		bRXIQImb_C			0x3f0000
#define		bRXIQImb_D		0xffc00000
#define		bDC_dc_Notch		0x60000
#define		bRxNBINotch		0x1f000000
#define		bPD_TH			0xf
#define		bPD_TH_Opt2		0xc000
#define		bPWED_TH			0x700
#define		bIfMF_Win_L		0x800
#define		bPD_Option			0x1000
#define		bMF_Win_L			0xe000
#define		bBW_Search_L		0x30000
#define		bwin_enh_L			0xc0000
#define		bBW_TH			0x700000
#define		bED_TH2			0x3800000
#define		bBW_option			0x4000000
#define		bRatio_TH			0x18000000
#define		bWindow_L			0xe0000000
#define		bSBD_Option		0x1
#define		bFrame_TH			0x1c
#define		bFS_Option			0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune			0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2		0x7
#define		bFrame_GI2_TH		0x38
#define		bGI2_Sync_en		0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum		0x1
#define		bCFOAcc			0x2
#define		bCFOStartOffset		0xc
#define		bCFOLookBack		0x70
#define		bCFOSumWeight		0x80
#define		bDAGCEnable		0x10000
#define		bTXIQImb_A			0x3ff
#define		bTXIQImb_B			0xfc00
#define		bTXIQImb_C			0x3f0000
#define		bTXIQImb_D			0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset		0xff00
#define		bTxDFIRMode		0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption		0x20000
#define		bCCADropThres		0xfff00000
#define		bEDCCA_H			0xf
#define		bEDCCA_L			0xf0
#define		bLambda_ED		0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn		0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En		0x10000000
#define		bRxQuickAGCEn		0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift			0x7f
#define		bTRSW_Tri_Only		0x80
#define		bPowerThres		0x300
#define		bRxAGCEn			0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin		0x4
#define		bRxHP_Ini			0x7
#define		bRxHP_TRLNA		0x70
#define		bRxHP_RSSI			0x700
#define		bRxHP_BBP1		0x7000
#define		bRxHP_BBP2		0x70000
#define		bRxHP_BBP3		0x700000
#define		bRSSI_H                  			0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen                			0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW		0x7
#define		bRxSettle_LNA		0x38
#define		bRxSettle_RSSI		0x1c0
#define		bRxSettle_BBP		0xe00
#define		bRxSettle_RxHP		0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI		0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final			0x7000000
#define		bRxHTSettle_BBP		0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn		0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin		0x80000
#define		bRxHTAGCEn		0x100000
#define		bRxHTDAGCEn		0x200000
#define		bRxHTRxHP_BBP		0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH		0x3
#define		bRxPWRatioEn		0x4
#define		bRxMFHold			0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH		0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L		0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH			0xc0000000
#define		bDFSCnt0			0xff
#define		bDFSCnt1			0xff00
#define		bDFSFlag			0xf0000
#define		bMFWeightSum		0x300000
#define		bMinIdxTH			0x7f000000
#define		bDAFormat			0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain		0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn                  			0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss			0x20
#define		bCFOAntSumD		0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet		0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn			0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re			0x3f
#define		bSigTone_Im			0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail		0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail		0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync		0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength         		12   /* total */
#define		bShortCFOFLength         		11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength		11
#define		bLongCFOFLength		11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW		0x1
#define		bRxSC			0x6
#define		bRx_HT			0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg		0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain			0x3f
#define		bTableSel			0x40
#define		bTRSW			0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st			0xff
#define		bCSI2nd			0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd		0xff000000
#define		bSIGEVM			0xff
#define		bPWDB			0xff00
#define		bSGIEN			0x10000

#define		bSFactorQAM1             		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet          		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode		0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType             			0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO		0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC				0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF			0x20000
#define		bComChCFO		0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz		0x100000
#define		bUChCfg			0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn         		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C		0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable        		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1      	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW	0x18
#define		bRTL8256_RxLPFBW	0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW          	0xc	/* Useless */
#define		bRTL8258_RxLPFBW	0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0                    			0x1	/* Useless */
#define		bByte1			0x2
#define		bByte2			0x4
#define		bByte3			0x8
#define		bWord0			0x3
#define		bWord1			0xc
#define		bDWord			0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0                		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1		0xff00
#define		bMaskByte2		0xff0000
#define		bMaskByte3		0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord		0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes				0xffffff00
#define		bMask12Bits				0xfff
#define		bMaskH4Bits				0xf0000000
#define		bMaskOFDM_D			0xffc00000
#define		bMaskCCK				0x3f3f3f3f



#define		bEnable                   0x1	/* Useless */
#define		bDisable                  0x0

#define		LeftAntenna               			0x0	/* Useless */
#define		RightAntenna		0x1

#define		tCheckTxStatus            		500   /* 500ms */ /* Useless */
#define		tUpdateRxCounter          		100   /* 100ms */

#define		rateCCK     				0	/* Useless */
#define		rateOFDM				1
#define		rateHT					2

/* define Register-End */
#define		bPMAC_End                 		0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl              		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA                     			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

/*--------------------------Define Parameters-------------------------------*/


#endif
                                    rtl8822bu/src/include/hal_intf.h                                                                    0000644 0001750 0001750 00000100061 14214766567 015357  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_INTF_H__
#define __HAL_INTF_H__


enum RTL871X_HCI_TYPE {
	RTW_PCIE	= BIT0,
	RTW_USB	= BIT1,
	RTW_SDIO	= BIT2,
	RTW_GSPI	= BIT3,
};

enum _CHIP_TYPE {

	NULL_CHIP_TYPE,
	RTL8188E,
	RTL8192E,
	RTL8812,
	RTL8821, /* RTL8811 */
	RTL8723B,
	RTL8814A,
	RTL8703B,
	RTL8188F,
	RTL8188GTV,
	RTL8822B,
	RTL8723D,
	RTL8821C,
	RTL8710B,
	RTL8192F,
	RTL8822C,
	RTL8814B,
	MAX_CHIP_TYPE
};

#ifdef RTW_HALMAC
enum fw_mem {
	FW_EMEM,
	FW_IMEM,
	FW_DMEM,
};
#endif

extern const u32 _chip_type_to_odm_ic_type[];
#define chip_type_to_odm_ic_type(chip_type) (((chip_type) >= MAX_CHIP_TYPE) ? _chip_type_to_odm_ic_type[MAX_CHIP_TYPE] : _chip_type_to_odm_ic_type[(chip_type)])

typedef enum _HAL_HW_TIMER_TYPE {
	HAL_TIMER_NONE = 0,
	HAL_TIMER_TXBF = 1,
	HAL_TIMER_EARLYMODE = 2,
} HAL_HW_TIMER_TYPE, *PHAL_HW_TIMER_TYPE;


typedef enum _HW_VARIABLES {
	HW_VAR_MEDIA_STATUS,
	HW_VAR_SET_OPMODE,
	HW_VAR_MAC_ADDR,
	HW_VAR_BSSID,
	HW_VAR_INIT_RTS_RATE,
	HW_VAR_BASIC_RATE,
	HW_VAR_TXPAUSE,
	HW_VAR_BCN_FUNC,
	HW_VAR_BCN_CTRL_ADDR,
	HW_VAR_CORRECT_TSF,
	HW_VAR_RCR,
	HW_VAR_MLME_DISCONNECT,
	HW_VAR_MLME_SITESURVEY,
	HW_VAR_MLME_JOIN,
	HW_VAR_ON_RCR_AM,
	HW_VAR_OFF_RCR_AM,
	HW_VAR_BEACON_INTERVAL,
	HW_VAR_SLOT_TIME,
	HW_VAR_RESP_SIFS,
	HW_VAR_ACK_PREAMBLE,
	HW_VAR_SEC_CFG,
	HW_VAR_SEC_DK_CFG,
	HW_VAR_BCN_VALID,
	HW_VAR_FREECNT,

	/* PHYDM odm->SupportAbility */
	HW_VAR_CAM_EMPTY_ENTRY,
	HW_VAR_CAM_INVALID_ALL,
	HW_VAR_AC_PARAM_VO,
	HW_VAR_AC_PARAM_VI,
	HW_VAR_AC_PARAM_BE,
	HW_VAR_AC_PARAM_BK,
	HW_VAR_ACM_CTRL,
#ifdef CONFIG_WMMPS_STA
	HW_VAR_UAPSD_TID,
#endif /* CONFIG_WMMPS_STA */
	HW_VAR_AMPDU_MIN_SPACE,
#ifdef CONFIG_80211N_HT
	HW_VAR_AMPDU_FACTOR,
#endif /* CONFIG_80211N_HT */
	HW_VAR_RXDMA_AGG_PG_TH,
	HW_VAR_SET_RPWM,
	HW_VAR_CPWM,
	HW_VAR_H2C_FW_PWRMODE,
	HW_VAR_H2C_INACTIVE_IPS,
	HW_VAR_H2C_PS_TUNE_PARAM,
	HW_VAR_H2C_FW_JOINBSSRPT,
	HW_VAR_FWLPS_RF_ON,
	HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
#ifdef CONFIG_LPS_POFF
	HW_VAR_LPS_POFF_INIT,
	HW_VAR_LPS_POFF_DEINIT,
	HW_VAR_LPS_POFF_SET_MODE,
	HW_VAR_LPS_POFF_WOW_EN,
#endif
#ifdef CONFIG_LPS_PG
	HW_VAR_LPS_PG_HANDLE,
#endif
	HW_VAR_TRIGGER_GPIO_0,
	HW_VAR_BT_SET_COEXIST,
	HW_VAR_BT_ISSUE_DELBA,
	HW_VAR_SWITCH_EPHY_WoWLAN,
	HW_VAR_EFUSE_USAGE,
	HW_VAR_EFUSE_BYTES,
	HW_VAR_EFUSE_BT_USAGE,
	HW_VAR_EFUSE_BT_BYTES,
	HW_VAR_FIFO_CLEARN_UP,
	HW_VAR_RESTORE_HW_SEQ,
	HW_VAR_CHECK_TXBUF,
	HW_VAR_PCIE_STOP_TX_DMA,
	HW_VAR_APFM_ON_MAC, /* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
	HW_VAR_HCI_SUS_STATE,
	/* The valid upper nav range for the HW updating, if the true value is larger than the upper range, the HW won't update it. */
	/* Unit in microsecond. 0 means disable this function. */
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	HW_VAR_WOWLAN,
	HW_VAR_WAKEUP_REASON,
#endif
	HW_VAR_RPWM_TOG,
#ifdef CONFIG_GPIO_WAKEUP
	HW_VAR_WOW_OUTPUT_GPIO,
	HW_VAR_WOW_INPUT_GPIO,
	HW_SET_GPIO_WL_CTRL,
#endif
	HW_VAR_SYS_CLKR,
	HW_VAR_NAV_UPPER,
	HW_VAR_RPT_TIMER_SETTING,
	HW_VAR_TX_RPT_MAX_MACID,
	HW_VAR_CHK_HI_QUEUE_EMPTY,
	HW_VAR_CHK_MGQ_CPU_EMPTY,
	HW_VAR_DL_BCN_SEL,
	HW_VAR_AMPDU_MAX_TIME,
	HW_VAR_WIRELESS_MODE,
	HW_VAR_USB_MODE,
	HW_VAR_PORT_SWITCH,
	HW_VAR_PORT_CFG,
	HW_VAR_DO_IQK,
	HW_VAR_DM_IN_LPS_LCLK,/*flag CONFIG_LPS_LCLK_WD_TIMER*/
	HW_VAR_SET_REQ_FW_PS,
	HW_VAR_FW_PS_STATE,
	HW_VAR_SOUNDING_ENTER,
	HW_VAR_SOUNDING_LEAVE,
	HW_VAR_SOUNDING_RATE,
	HW_VAR_SOUNDING_STATUS,
	HW_VAR_SOUNDING_FW_NDPA,
	HW_VAR_SOUNDING_CLK,
	HW_VAR_SOUNDING_SET_GID_TABLE,
	HW_VAR_SOUNDING_CSI_REPORT,
	/*Add by YuChen for TXBF HW timer*/
	HW_VAR_HW_REG_TIMER_INIT,
	HW_VAR_HW_REG_TIMER_RESTART,
	HW_VAR_HW_REG_TIMER_START,
	HW_VAR_HW_REG_TIMER_STOP,
	/*Add by YuChen for TXBF HW timer*/
	HW_VAR_DL_RSVD_PAGE,
	HW_VAR_MACID_LINK,
	HW_VAR_MACID_NOLINK,
	HW_VAR_DUMP_MAC_QUEUE_INFO,
	HW_VAR_ASIX_IOT,
#ifdef CONFIG_MBSSID_CAM
	HW_VAR_MBSSID_CAM_WRITE,
	HW_VAR_MBSSID_CAM_CLEAR,
	HW_VAR_RCR_MBSSID_EN,
#endif
	HW_VAR_EN_HW_UPDATE_TSF,
	HW_VAR_CH_SW_NEED_TO_TAKE_CARE_IQK_INFO,
	HW_VAR_CH_SW_IQK_INFO_BACKUP,
	HW_VAR_CH_SW_IQK_INFO_RESTORE,

	HW_VAR_DBI,
	HW_VAR_MDIO,
	HW_VAR_L1OFF_CAPABILITY,
	HW_VAR_L1OFF_NIC_SUPPORT,
#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
	HW_VAR_TDLS_BCN_EARLY_C2H_RPT,
#endif
#endif
	HW_VAR_DUMP_MAC_TXFIFO,
	HW_VAR_PWR_CMD,
#ifdef CONFIG_FW_HANDLE_TXBCN
	HW_VAR_BCN_HEAD_SEL,
#endif
	HW_VAR_SET_SOML_PARAM,
	HW_VAR_ENABLE_RX_BAR,
	HW_VAR_TSF_AUTO_SYNC,
	HW_VAR_LPS_STATE_CHK,
	#ifdef CONFIG_RTS_FULL_BW
	HW_VAR_SET_RTS_BW,
	#endif
#if defined(CONFIG_PCI_HCI)
	HW_VAR_ENSWBCN,
#endif
} HW_VARIABLES;

typedef enum _HAL_DEF_VARIABLE {
	HAL_DEF_UNDERCORATEDSMOOTHEDPWDB,
	HAL_DEF_IS_SUPPORT_ANT_DIV,
	HAL_DEF_DRVINFO_SZ,
	HAL_DEF_MAX_RECVBUF_SZ,
	HAL_DEF_RX_PACKET_OFFSET,
	HAL_DEF_RX_DMA_SZ_WOW,
	HAL_DEF_RX_DMA_SZ,
	HAL_DEF_RX_PAGE_SIZE,
	HAL_DEF_DBG_DUMP_RXPKT,/* for dbg */
	HAL_DEF_RA_DECISION_RATE,
	HAL_DEF_RA_SGI,
	HAL_DEF_PT_PWR_STATUS,
	HAL_DEF_TX_LDPC,				/* LDPC support */
	HAL_DEF_RX_LDPC,				/* LDPC support */
	HAL_DEF_TX_STBC,				/* TX STBC support */
	HAL_DEF_RX_STBC,				/* RX STBC support */
	HAL_DEF_EXPLICIT_BEAMFORMER,/* Explicit  Compressed Steering Capable */
	HAL_DEF_EXPLICIT_BEAMFORMEE,/* Explicit Compressed Beamforming Feedback Capable */
	HAL_DEF_VHT_MU_BEAMFORMER,	/* VHT MU Beamformer support */
	HAL_DEF_VHT_MU_BEAMFORMEE,	/* VHT MU Beamformee support */
	HAL_DEF_BEAMFORMER_CAP,
	HAL_DEF_BEAMFORMEE_CAP,
	HW_VAR_MAX_RX_AMPDU_FACTOR,
	HW_DEF_RA_INFO_DUMP,
	HAL_DEF_DBG_DUMP_TXPKT,

	HAL_DEF_TX_PAGE_SIZE,
	HAL_DEF_TX_PAGE_BOUNDARY,
	HAL_DEF_TX_PAGE_BOUNDARY_WOWLAN,
	HAL_DEF_TX_BUFFER_LAST_ENTRY,
	HAL_DEF_ANT_DETECT,/* to do for 8723a */
	HAL_DEF_PCI_ASPM_OSC, /* Support for ASPM OSC, added by Roger, 2013.03.27. */
	HAL_DEF_EFUSE_USAGE,	/* Get current EFUSE utilization. 2008.12.19. Added by Roger. */
	HAL_DEF_EFUSE_BYTES,
	HW_VAR_BEST_AMPDU_DENSITY,
} HAL_DEF_VARIABLE;

typedef enum _HAL_ODM_VARIABLE {
	HAL_ODM_STA_INFO,
	HAL_ODM_P2P_STATE,
	HAL_ODM_WIFI_DISPLAY_STATE,
	HAL_ODM_REGULATION,
	HAL_ODM_INITIAL_GAIN,
	HAL_ODM_RX_INFO_DUMP,
	HAL_ODM_RX_Dframe_INFO,
#ifdef CONFIG_ANTENNA_DIVERSITY
	HAL_ODM_ANTDIV_SELECT
#endif
} HAL_ODM_VARIABLE;

typedef enum _HAL_INTF_PS_FUNC {
	HAL_USB_SELECT_SUSPEND,
	HAL_MAX_ID,
} HAL_INTF_PS_FUNC;

typedef s32(*c2h_id_filter)(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);

struct txpwr_idx_comp;

struct hal_ops {
	/*** initialize section ***/
	void	(*read_chip_version)(_adapter *padapter);
	void	(*init_default_value)(_adapter *padapter);
	void	(*intf_chip_configure)(_adapter *padapter);
	u8	(*read_adapter_info)(_adapter *padapter);
	u32(*hal_power_on)(_adapter *padapter);
	void	(*hal_power_off)(_adapter *padapter);
	u32(*hal_init)(_adapter *padapter);
	u32(*hal_deinit)(_adapter *padapter);
	void	(*dm_init)(_adapter *padapter);
	void	(*dm_deinit)(_adapter *padapter);

	/*** xmit section ***/
	s32(*init_xmit_priv)(_adapter *padapter);
	void	(*free_xmit_priv)(_adapter *padapter);
	s32(*hal_xmit)(_adapter *padapter, struct xmit_frame *pxmitframe);
	/*
	 * mgnt_xmit should be implemented to run in interrupt context
	 */
	s32(*mgnt_xmit)(_adapter *padapter, struct xmit_frame *pmgntframe);
	s32(*hal_xmitframe_enqueue)(_adapter *padapter, struct xmit_frame *pxmitframe);
#ifdef CONFIG_XMIT_THREAD_MODE
	s32(*xmit_thread_handler)(_adapter *padapter);
#endif
	void	(*run_thread)(_adapter *padapter);
	void	(*cancel_thread)(_adapter *padapter);

	/*** recv section ***/
	s32(*init_recv_priv)(_adapter *padapter);
	void	(*free_recv_priv)(_adapter *padapter);
#ifdef CONFIG_RECV_THREAD_MODE
	s32 (*recv_hdl)(_adapter *adapter);
#endif
#if defined(CONFIG_USB_HCI) || defined(CONFIG_PCI_HCI)
	u32(*inirp_init)(_adapter *padapter);
	u32(*inirp_deinit)(_adapter *padapter);
#endif
	/*** interrupt hdl section ***/
	void	(*enable_interrupt)(_adapter *padapter);
	void	(*disable_interrupt)(_adapter *padapter);
	u8(*check_ips_status)(_adapter *padapter);
#if defined(CONFIG_PCI_HCI)
	s32(*interrupt_handler)(_adapter *padapter);
	void (*unmap_beacon_icf)(_adapter *padapter);
#endif

#if defined(CONFIG_USB_HCI) && defined(CONFIG_SUPPORT_USB_INT)
	void	(*interrupt_handler)(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif

#if defined(CONFIG_PCI_HCI)
	void	(*irp_reset)(_adapter *padapter);
#endif

	/*** DM section ***/
#ifdef CONFIG_RTW_SW_LED
	void	(*InitSwLeds)(_adapter *padapter);
	void	(*DeInitSwLeds)(_adapter *padapter);
#endif
	void	(*set_chnl_bw_handler)(_adapter *padapter, u8 channel, enum channel_width Bandwidth, u8 Offset40, u8 Offset80);

	void (*set_tx_power_level_handler)(_adapter *adapter, u8 channel);
	void (*set_txpwr_done)(_adapter *adapter);
	void (*set_tx_power_index_handler)(_adapter *adapter, u32 powerindex, enum rf_path rfpath, u8 rate);

	u8 (*get_tx_power_index_handler)(_adapter *adapter, enum rf_path rfpath, RATE_SECTION rs, enum MGN_RATE rate
		, enum channel_width bw, BAND_TYPE band, u8 cch, u8 opch, struct txpwr_idx_comp *tic);
	s8 (*get_txpwr_target_extra_bias)(_adapter *adapter, enum rf_path rfpath, RATE_SECTION rs, enum MGN_RATE rate, enum channel_width bw, BAND_TYPE band, u8 cch);

	void	(*hal_dm_watchdog)(_adapter *padapter);

	u8	(*set_hw_reg_handler)(_adapter *padapter, u8	variable, u8 *val);

	void	(*GetHwRegHandler)(_adapter *padapter, u8	variable, u8 *val);



	u8 (*get_hal_def_var_handler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void *pValue);

	u8(*SetHalDefVarHandler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void *pValue);

	void	(*GetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void *pValue1, void *pValue2);
	void	(*SetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void *pValue1, BOOLEAN bSet);

	void	(*SetBeaconRelatedRegistersHandler)(_adapter *padapter);

	u8(*interface_ps_func)(_adapter *padapter, HAL_INTF_PS_FUNC efunc_id, u8 *val);

	u32(*read_bbreg)(_adapter *padapter, u32 RegAddr, u32 BitMask);
	void	(*write_bbreg)(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
	u32 (*read_rfreg)(_adapter *padapter, enum rf_path eRFPath, u32 RegAddr, u32 BitMask);
	void	(*write_rfreg)(_adapter *padapter, enum rf_path eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
#ifdef CONFIG_SYSON_INDIRECT_ACCESS
	u32 (*read_syson_reg)(_adapter *padapter, u32 RegAddr, u32 BitMask);
	void (*write_syson_reg)(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
#endif
	void (*read_wmmedca_reg)(_adapter *padapter, u16 *vo_params, u16 *vi_params, u16 *be_params, u16 *bk_params);
	
#ifdef CONFIG_HOSTAPD_MLME
	s32(*hostap_mgnt_xmit_entry)(_adapter *padapter, _pkt *pkt);
#endif

	void (*EfusePowerSwitch)(_adapter *padapter, u8 bWrite, u8 PwrState);
	void (*BTEfusePowerSwitch)(_adapter *padapter, u8 bWrite, u8 PwrState);
	void (*ReadEFuse)(_adapter *padapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf, BOOLEAN bPseudoTest);
	void (*EFUSEGetEfuseDefinition)(_adapter *padapter, u8 efuseType, u8 type, void *pOut, BOOLEAN bPseudoTest);
	u16(*EfuseGetCurrentSize)(_adapter *padapter, u8 efuseType, BOOLEAN bPseudoTest);
	int	(*Efuse_PgPacketRead)(_adapter *padapter, u8 offset, u8 *data, BOOLEAN bPseudoTest);
	int	(*Efuse_PgPacketWrite)(_adapter *padapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
	u8(*Efuse_WordEnableDataWrite)(_adapter *padapter, u16 efuse_addr, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
	BOOLEAN(*Efuse_PgPacketWrite_BT)(_adapter *padapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
#if defined(CONFIG_RTL8710B)
	BOOLEAN(*efuse_indirect_read4)(_adapter *padapter, u16 regaddr, u8 *value);
#endif

#ifdef DBG_CONFIG_ERROR_DETECT
	void (*sreset_init_value)(_adapter *padapter);
	void (*sreset_reset_value)(_adapter *padapter);
	void (*silentreset)(_adapter *padapter);
	void (*sreset_xmit_status_check)(_adapter *padapter);
	void (*sreset_linked_status_check)(_adapter *padapter);
	u8(*sreset_get_wifi_status)(_adapter *padapter);
	bool (*sreset_inprogress)(_adapter *padapter);
#endif

#ifdef CONFIG_IOL
	int (*IOL_exec_cmds_sync)(_adapter *padapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
#endif

	void (*hal_notch_filter)(_adapter *adapter, bool enable);
#ifdef RTW_HALMAC
	void (*hal_mac_c2h_handler)(_adapter *adapter, u8 *pbuf, u16 length);
#else
	s32(*c2h_handler)(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
#endif
	void (*reqtxrpt)(_adapter *padapter, u8 macid);
	s32(*fill_h2c_cmd)(PADAPTER, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
	void (*fill_fake_txdesc)(PADAPTER, u8 *pDesc, u32 BufferLen,
				 u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
	s32(*fw_dl)(_adapter *adapter, u8 wowlan);
#ifdef RTW_HALMAC
	s32 (*fw_mem_dl)(_adapter *adapter, enum fw_mem mem);
#endif

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_PCI_HCI)
	void (*clear_interrupt)(_adapter *padapter);
#endif
	u8(*hal_get_tx_buff_rsvd_page_num)(_adapter *adapter, bool wowlan);
#ifdef CONFIG_GPIO_API
	void (*update_hisr_hsisr_ind)(PADAPTER padapter, u32 flag);
	int (*hal_gpio_func_check)(_adapter *padapter, u8 gpio_num);
	void (*hal_gpio_multi_func_reset)(_adapter *padapter, u8 gpio_num);
#endif
#ifdef CONFIG_FW_CORRECT_BCN
	void (*fw_correct_bcn)(PADAPTER padapter);
#endif

#ifdef RTW_HALMAC
	u8(*init_mac_register)(PADAPTER);
	u8(*init_phy)(PADAPTER);
#endif /* RTW_HALMAC */

#ifdef CONFIG_PCI_HCI
	void (*hal_set_l1ssbackdoor_handler)(_adapter *padapter, u8 enable);
#endif

#ifdef CONFIG_RFKILL_POLL
	bool (*hal_radio_onoff_check)(_adapter *adapter, u8 *valid);
#endif
#ifdef CONFIG_PCI_TX_POLLING
	void (*tx_poll_handler)(_adapter *adapter);
#endif
};

typedef	enum _RT_EEPROM_TYPE {
	EEPROM_93C46,
	EEPROM_93C56,
	EEPROM_BOOT_EFUSE,
} RT_EEPROM_TYPE, *PRT_EEPROM_TYPE;



#define RF_CHANGE_BY_INIT	0
#define RF_CHANGE_BY_IPS	BIT28
#define RF_CHANGE_BY_PS	BIT29
#define RF_CHANGE_BY_HW	BIT30
#define RF_CHANGE_BY_SW	BIT31

typedef enum _HARDWARE_TYPE {
	HARDWARE_TYPE_RTL8188EE,
	HARDWARE_TYPE_RTL8188EU,
	HARDWARE_TYPE_RTL8188ES,
	/*	NEW_GENERATION_IC */
	HARDWARE_TYPE_RTL8192EE,
	HARDWARE_TYPE_RTL8192EU,
	HARDWARE_TYPE_RTL8192ES,
	HARDWARE_TYPE_RTL8812E,
	HARDWARE_TYPE_RTL8812AU,
	HARDWARE_TYPE_RTL8811AU,
	HARDWARE_TYPE_RTL8821E,
	HARDWARE_TYPE_RTL8821U,
	HARDWARE_TYPE_RTL8821S,
	HARDWARE_TYPE_RTL8723BE,
	HARDWARE_TYPE_RTL8723BU,
	HARDWARE_TYPE_RTL8723BS,
	HARDWARE_TYPE_RTL8814AE,
	HARDWARE_TYPE_RTL8814AU,
	HARDWARE_TYPE_RTL8814AS,
	HARDWARE_TYPE_RTL8821BE,
	HARDWARE_TYPE_RTL8821BU,
	HARDWARE_TYPE_RTL8821BS,
	HARDWARE_TYPE_RTL8822BE,
	HARDWARE_TYPE_RTL8822BU,
	HARDWARE_TYPE_RTL8822BS,
	HARDWARE_TYPE_RTL8703BE,
	HARDWARE_TYPE_RTL8703BU,
	HARDWARE_TYPE_RTL8703BS,
	HARDWARE_TYPE_RTL8188FE,
	HARDWARE_TYPE_RTL8188FU,
	HARDWARE_TYPE_RTL8188FS,
	HARDWARE_TYPE_RTL8188GTVU,
	HARDWARE_TYPE_RTL8188GTVS,
	HARDWARE_TYPE_RTL8723DE,
	HARDWARE_TYPE_RTL8723DU,
	HARDWARE_TYPE_RTL8723DS,
	HARDWARE_TYPE_RTL8821CE,
	HARDWARE_TYPE_RTL8821CU,
	HARDWARE_TYPE_RTL8821CS,
	HARDWARE_TYPE_RTL8710BU,
	HARDWARE_TYPE_RTL8192FS,
	HARDWARE_TYPE_RTL8192FU,
	HARDWARE_TYPE_RTL8192FE,
	HARDWARE_TYPE_RTL8822CE,
	HARDWARE_TYPE_RTL8822CU,
	HARDWARE_TYPE_RTL8822CS,
	HARDWARE_TYPE_RTL8814BE,
	HARDWARE_TYPE_RTL8814BU,
	HARDWARE_TYPE_RTL8814BS,
	HARDWARE_TYPE_MAX,
} HARDWARE_TYPE;

#define IS_NEW_GENERATION_IC(_Adapter)	(rtw_get_hw_type(_Adapter) >= HARDWARE_TYPE_RTL8192EE)
/*
 * RTL8188E Series
 *   */
#define IS_HARDWARE_TYPE_8188EE(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188EE)
#define IS_HARDWARE_TYPE_8188EU(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188EU)
#define IS_HARDWARE_TYPE_8188ES(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188ES)
#define	IS_HARDWARE_TYPE_8188E(_Adapter)	\
	(IS_HARDWARE_TYPE_8188EE(_Adapter) || IS_HARDWARE_TYPE_8188EU(_Adapter) || IS_HARDWARE_TYPE_8188ES(_Adapter))

/* RTL8812 Series */
#define IS_HARDWARE_TYPE_8812E(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8812E)
#define IS_HARDWARE_TYPE_8812AU(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8812AU)
#define IS_HARDWARE_TYPE_8812(_Adapter)			\
	(IS_HARDWARE_TYPE_8812E(_Adapter) || IS_HARDWARE_TYPE_8812AU(_Adapter))

/* RTL8821 Series */
#define IS_HARDWARE_TYPE_8821E(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821E)
#define IS_HARDWARE_TYPE_8811AU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8811AU)
#define IS_HARDWARE_TYPE_8821U(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821U || \
		rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8811AU)
#define IS_HARDWARE_TYPE_8821S(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821S)
#define IS_HARDWARE_TYPE_8821(_Adapter)			\
	(IS_HARDWARE_TYPE_8821E(_Adapter) || IS_HARDWARE_TYPE_8821U(_Adapter) || IS_HARDWARE_TYPE_8821S(_Adapter))

#define IS_HARDWARE_TYPE_JAGUAR(_Adapter)		\
	(IS_HARDWARE_TYPE_8812(_Adapter) || IS_HARDWARE_TYPE_8821(_Adapter))

/* RTL8192E Series */
#define IS_HARDWARE_TYPE_8192EE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192EE)
#define IS_HARDWARE_TYPE_8192EU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192EU)
#define IS_HARDWARE_TYPE_8192ES(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192ES)

#define IS_HARDWARE_TYPE_8192E(_Adapter)		\
	(IS_HARDWARE_TYPE_8192EE(_Adapter) || IS_HARDWARE_TYPE_8192EU(_Adapter) || IS_HARDWARE_TYPE_8192ES(_Adapter))

#define IS_HARDWARE_TYPE_8723BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723BE)
#define IS_HARDWARE_TYPE_8723BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723BU)
#define IS_HARDWARE_TYPE_8723BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723BS)

#define IS_HARDWARE_TYPE_8723B(_Adapter) \
	(IS_HARDWARE_TYPE_8723BE(_Adapter) || IS_HARDWARE_TYPE_8723BU(_Adapter) || IS_HARDWARE_TYPE_8723BS(_Adapter))

/* RTL8814A Series */
#define IS_HARDWARE_TYPE_8814AE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814AE)
#define IS_HARDWARE_TYPE_8814AU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814AU)
#define IS_HARDWARE_TYPE_8814AS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814AS)

#define IS_HARDWARE_TYPE_8814A(_Adapter)		\
	(IS_HARDWARE_TYPE_8814AE(_Adapter) || IS_HARDWARE_TYPE_8814AU(_Adapter) || IS_HARDWARE_TYPE_8814AS(_Adapter))

/* RTL8703B Series */
#define IS_HARDWARE_TYPE_8703BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8703BE)
#define IS_HARDWARE_TYPE_8703BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8703BS)
#define IS_HARDWARE_TYPE_8703BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8703BU)
#define	IS_HARDWARE_TYPE_8703B(_Adapter)			\
	(IS_HARDWARE_TYPE_8703BE(_Adapter) || IS_HARDWARE_TYPE_8703BU(_Adapter) || IS_HARDWARE_TYPE_8703BS(_Adapter))

/* RTL8723D Series */
#define IS_HARDWARE_TYPE_8723DE(_Adapter)\
	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723DE)
#define IS_HARDWARE_TYPE_8723DS(_Adapter)\
	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723DS)
#define IS_HARDWARE_TYPE_8723DU(_Adapter)\
	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723DU)
#define	IS_HARDWARE_TYPE_8723D(_Adapter)\
	(IS_HARDWARE_TYPE_8723DE(_Adapter) || \
	 IS_HARDWARE_TYPE_8723DU(_Adapter) || \
	 IS_HARDWARE_TYPE_8723DS(_Adapter))

/* RTL8192F Series */
#define IS_HARDWARE_TYPE_8192FS(_Adapter)\
	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192FS)
#define IS_HARDWARE_TYPE_8192FU(_Adapter)\
	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192FU)	
#define IS_HARDWARE_TYPE_8192FE(_Adapter)\
	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192FE)	
#define	IS_HARDWARE_TYPE_8192F(_Adapter)\
	(IS_HARDWARE_TYPE_8192FS(_Adapter) ||\
	 IS_HARDWARE_TYPE_8192FU(_Adapter) ||\
	 IS_HARDWARE_TYPE_8192FE(_Adapter))

/* RTL8188F Series */
#define IS_HARDWARE_TYPE_8188FE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188FE)
#define IS_HARDWARE_TYPE_8188FS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188FS)
#define IS_HARDWARE_TYPE_8188FU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188FU)
#define	IS_HARDWARE_TYPE_8188F(_Adapter)			\
	(IS_HARDWARE_TYPE_8188FE(_Adapter) || IS_HARDWARE_TYPE_8188FU(_Adapter) || IS_HARDWARE_TYPE_8188FS(_Adapter))

#define IS_HARDWARE_TYPE_8188GTVU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188GTVU)
#define IS_HARDWARE_TYPE_8188GTVS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188GTVS)
#define	IS_HARDWARE_TYPE_8188GTV(_Adapter)			\
	(IS_HARDWARE_TYPE_8188GTVU(_Adapter) || IS_HARDWARE_TYPE_8188GTVS(_Adapter))

/* RTL8710B Series */
#define IS_HARDWARE_TYPE_8710BU(_Adapter) (rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8710BU)
#define IS_HARDWARE_TYPE_8710B(_Adapter) (IS_HARDWARE_TYPE_8710BU(_Adapter))

#define IS_HARDWARE_TYPE_8821BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821BE)
#define IS_HARDWARE_TYPE_8821BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821BU)
#define IS_HARDWARE_TYPE_8821BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821BS)

#define IS_HARDWARE_TYPE_8821B(_Adapter)		\
	(IS_HARDWARE_TYPE_8821BE(_Adapter) || IS_HARDWARE_TYPE_8821BU(_Adapter) || IS_HARDWARE_TYPE_8821BS(_Adapter))

#define IS_HARDWARE_TYPE_8822BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822BE)
#define IS_HARDWARE_TYPE_8822BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822BU)
#define IS_HARDWARE_TYPE_8822BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822BS)
#define IS_HARDWARE_TYPE_8822B(_Adapter)		\
	(IS_HARDWARE_TYPE_8822BE(_Adapter) || IS_HARDWARE_TYPE_8822BU(_Adapter) || IS_HARDWARE_TYPE_8822BS(_Adapter))

#define IS_HARDWARE_TYPE_8821CE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821CE)
#define IS_HARDWARE_TYPE_8821CU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821CU)
#define IS_HARDWARE_TYPE_8821CS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821CS)
#define IS_HARDWARE_TYPE_8821C(_Adapter)		\
	(IS_HARDWARE_TYPE_8821CE(_Adapter) || IS_HARDWARE_TYPE_8821CU(_Adapter) || IS_HARDWARE_TYPE_8821CS(_Adapter))

#define IS_HARDWARE_TYPE_8822CE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822CE)
#define IS_HARDWARE_TYPE_8822CU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822CU)
#define IS_HARDWARE_TYPE_8822CS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822CS)
#define IS_HARDWARE_TYPE_8822C(_Adapter)		\
	(IS_HARDWARE_TYPE_8822CE(_Adapter) || IS_HARDWARE_TYPE_8822CU(_Adapter) || IS_HARDWARE_TYPE_8822CS(_Adapter))

#define IS_HARDWARE_TYPE_8814BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814BE)
#define IS_HARDWARE_TYPE_8814BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814BU)
#define IS_HARDWARE_TYPE_8814BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814BS)
#define IS_HARDWARE_TYPE_8814B(_Adapter)		\
		(IS_HARDWARE_TYPE_8814BE(_Adapter) || IS_HARDWARE_TYPE_8814BU(_Adapter) || IS_HARDWARE_TYPE_8814BS(_Adapter))

#define IS_HARDWARE_TYPE_JAGUAR2(_Adapter)		\
	(IS_HARDWARE_TYPE_8814A(_Adapter) || IS_HARDWARE_TYPE_8821B(_Adapter) || IS_HARDWARE_TYPE_8822B(_Adapter) || IS_HARDWARE_TYPE_8821C(_Adapter))

#define IS_HARDWARE_TYPE_JAGUAR_AND_JAGUAR2(_Adapter)		\
	(IS_HARDWARE_TYPE_JAGUAR(_Adapter) || IS_HARDWARE_TYPE_JAGUAR2(_Adapter))

#define IS_HARDWARE_TYPE_JAGUAR3(_Adapter)		\
	(IS_HARDWARE_TYPE_8814B(_Adapter) || IS_HARDWARE_TYPE_8822C(_Adapter))

#define IS_HARDWARE_TYPE_JAGUAR_ALL(_Adapter)		\
	(IS_HARDWARE_TYPE_JAGUAR_AND_JAGUAR2(_Adapter) || IS_HARDWARE_TYPE_JAGUAR3(_Adapter))


typedef enum _wowlan_subcode {
	WOWLAN_ENABLE			= 0,
	WOWLAN_DISABLE			= 1,
	WOWLAN_AP_ENABLE		= 2,
	WOWLAN_AP_DISABLE		= 3,
	WOWLAN_PATTERN_CLEAN		= 4
} wowlan_subcode;

struct wowlan_ioctl_param {
	unsigned int subcode;
	unsigned int subcode_value;
	unsigned int wakeup_reason;
};

u8 rtw_hal_data_init(_adapter *padapter);
void rtw_hal_data_deinit(_adapter *padapter);

void rtw_hal_def_value_init(_adapter *padapter);

void	rtw_hal_free_data(_adapter *padapter);

void rtw_hal_dm_init(_adapter *padapter);
void rtw_hal_dm_deinit(_adapter *padapter);
#ifdef CONFIG_RTW_SW_LED
void rtw_hal_sw_led_init(_adapter *padapter);
void rtw_hal_sw_led_deinit(_adapter *padapter);
#endif
u32 rtw_hal_power_on(_adapter *padapter);
void rtw_hal_power_off(_adapter *padapter);

uint rtw_hal_init(_adapter *padapter);
#ifdef CONFIG_NEW_NETDEV_HDL
uint rtw_hal_iface_init(_adapter *adapter);
#endif

enum rf_type rtw_chip_rftype_to_hal_rftype(_adapter *adapter, u8 limit);
void dump_hal_runtime_trx_mode(void *sel, _adapter *adapter);
void dump_hal_trx_mode(void *sel, _adapter *adapter);
u8 rtw_hal_rfpath_init(_adapter *adapter);
u8 rtw_hal_trxnss_init(_adapter *adapter);

uint rtw_hal_deinit(_adapter *padapter);
void rtw_hal_stop(_adapter *padapter);
u8 rtw_hal_set_hwreg(PADAPTER padapter, u8 variable, u8 *val);
void rtw_hal_get_hwreg(PADAPTER padapter, u8 variable, u8 *val);

void rtw_hal_chip_configure(_adapter *padapter);
u8 rtw_hal_read_chip_info(_adapter *padapter);
void rtw_hal_read_chip_version(_adapter *padapter);

u8 rtw_hal_set_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void *pValue);
u8 rtw_hal_get_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void *pValue);

void rtw_hal_set_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void *pValue1, BOOLEAN bSet);
void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void *pValue1, void *pValue2);

void rtw_hal_enable_interrupt(_adapter *padapter);
void rtw_hal_disable_interrupt(_adapter *padapter);

u8 rtw_hal_check_ips_status(_adapter *padapter);

#if defined(CONFIG_USB_HCI) || defined(CONFIG_PCI_HCI)
	u32	rtw_hal_inirp_init(_adapter *padapter);
	u32	rtw_hal_inirp_deinit(_adapter *padapter);
#endif

#if defined(CONFIG_PCI_HCI)
	void	rtw_hal_irp_reset(_adapter *padapter);
void	rtw_hal_pci_dbi_write(_adapter *padapter, u16 addr, u8 data);
u8	rtw_hal_pci_dbi_read(_adapter *padapter, u16 addr);
void	rtw_hal_pci_mdio_write(_adapter *padapter, u8 addr, u16 data);
u16	rtw_hal_pci_mdio_read(_adapter *padapter, u8 addr);
u8	rtw_hal_pci_l1off_nic_support(_adapter *padapter);
u8	rtw_hal_pci_l1off_capability(_adapter *padapter);
#endif

u8	rtw_hal_intf_ps_func(_adapter *padapter, HAL_INTF_PS_FUNC efunc_id, u8 *val);

s32	rtw_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
s32	rtw_hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe);
s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe);

s32	rtw_hal_init_xmit_priv(_adapter *padapter);
void	rtw_hal_free_xmit_priv(_adapter *padapter);

s32	rtw_hal_init_recv_priv(_adapter *padapter);
void	rtw_hal_free_recv_priv(_adapter *padapter);

void rtw_hal_update_ra_mask(struct sta_info *psta);

void	rtw_hal_start_thread(_adapter *padapter);
void	rtw_hal_stop_thread(_adapter *padapter);

void rtw_hal_bcn_related_reg_setting(_adapter *padapter);

u32	rtw_hal_read_bbreg(_adapter *padapter, u32 RegAddr, u32 BitMask);
void	rtw_hal_write_bbreg(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
u32	rtw_hal_read_rfreg(_adapter *padapter, enum rf_path eRFPath, u32 RegAddr, u32 BitMask);
void	rtw_hal_write_rfreg(_adapter *padapter, enum rf_path eRFPath, u32 RegAddr, u32 BitMask, u32 Data);


#define phy_query_bb_reg(Adapter, RegAddr, BitMask) rtw_hal_read_bbreg((Adapter), (RegAddr), (BitMask))
#define phy_set_bb_reg(Adapter, RegAddr, BitMask, Data) rtw_hal_write_bbreg((Adapter), (RegAddr), (BitMask), (Data))
#define phy_query_rf_reg(Adapter, eRFPath, RegAddr, BitMask) rtw_hal_read_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask))
#define phy_set_rf_reg(Adapter, eRFPath, RegAddr, BitMask, Data) rtw_hal_write_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask), (Data))

#ifdef CONFIG_SYSON_INDIRECT_ACCESS
u32 rtw_hal_read_syson_reg(PADAPTER padapter, u32 RegAddr, u32 BitMask);
void rtw_hal_write_syson_reg(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
#define hal_query_syson_reg(Adapter, RegAddr, BitMask) rtw_hal_read_syson_reg((Adapter), (RegAddr), (BitMask))
#define hal_set_syson_reg(Adapter, RegAddr, BitMask, Data) rtw_hal_write_syson_reg((Adapter), (RegAddr), (BitMask), (Data))
#endif

#define phy_set_mac_reg	phy_set_bb_reg
#define phy_query_mac_reg phy_query_bb_reg

#if defined(CONFIG_PCI_HCI)
	s32	rtw_hal_interrupt_handler(_adapter *padapter);
	void	rtw_hal_unmap_beacon_icf(_adapter *padapter);
#endif
#if  defined(CONFIG_USB_HCI) && defined(CONFIG_SUPPORT_USB_INT)
	void	rtw_hal_interrupt_handler(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif

void	rtw_hal_set_chnl_bw(_adapter *padapter, u8 channel, enum channel_width Bandwidth, u8 Offset40, u8 Offset80);
void	rtw_hal_dm_watchdog(_adapter *padapter);
void	rtw_hal_dm_watchdog_in_lps(_adapter *padapter);

#ifdef CONFIG_HOSTAPD_MLME
	s32	rtw_hal_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt);
#endif

#ifdef DBG_CONFIG_ERROR_DETECT
void rtw_hal_sreset_init(_adapter *padapter);
void rtw_hal_sreset_reset(_adapter *padapter);
void rtw_hal_sreset_reset_value(_adapter *padapter);
void rtw_hal_sreset_xmit_status_check(_adapter *padapter);
void rtw_hal_sreset_linked_status_check(_adapter *padapter);
u8   rtw_hal_sreset_get_wifi_status(_adapter *padapter);
bool rtw_hal_sreset_inprogress(_adapter *padapter);
#endif

#ifdef CONFIG_IOL
int rtw_hal_iol_cmd(ADAPTER *adapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
#endif

#ifdef CONFIG_XMIT_THREAD_MODE
s32 rtw_hal_xmit_thread_handler(_adapter *padapter);
#endif

#ifdef CONFIG_RECV_THREAD_MODE
s32 rtw_hal_recv_hdl(_adapter *adapter);
#endif

void rtw_hal_notch_filter(_adapter *adapter, bool enable);

#ifdef CONFIG_FW_C2H_REG
bool rtw_hal_c2h_reg_hdr_parse(_adapter *adapter, u8 *buf, u8 *id, u8 *seq, u8 *plen, u8 **payload);
bool rtw_hal_c2h_valid(_adapter *adapter, u8 *buf);
s32 rtw_hal_c2h_evt_read(_adapter *adapter, u8 *buf);
#endif

#ifdef CONFIG_FW_C2H_PKT
bool rtw_hal_c2h_pkt_hdr_parse(_adapter *adapter, u8 *buf, u16 len, u8 *id, u8 *seq, u8 *plen, u8 **payload);
#endif

s32 c2h_handler(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
#ifndef RTW_HALMAC
s32 rtw_hal_c2h_handler(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
s32 rtw_hal_c2h_id_handle_directly(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
#endif

s32 rtw_hal_is_disable_sw_channel_plan(PADAPTER padapter);

s32 rtw_hal_macid_sleep(_adapter *adapter, u8 macid);
s32 rtw_hal_macid_wakeup(_adapter *adapter, u8 macid);
s32 rtw_hal_macid_sleep_all_used(_adapter *adapter);
s32 rtw_hal_macid_wakeup_all_used(_adapter *adapter);

s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
void rtw_hal_fill_fake_txdesc(_adapter *padapter, u8 *pDesc, u32 BufferLen,
			      u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
u8 rtw_hal_get_txbuff_rsvd_page_num(_adapter *adapter, bool wowlan);

#ifdef CONFIG_GPIO_API
void rtw_hal_update_hisr_hsisr_ind(_adapter *padapter, u32 flag);
int rtw_hal_gpio_func_check(_adapter *padapter, u8 gpio_num);
void rtw_hal_gpio_multi_func_reset(_adapter *padapter, u8 gpio_num);
#endif
#ifdef CONFIG_FW_CORRECT_BCN
void rtw_hal_fw_correct_bcn(_adapter *padapter);
#endif
s32 rtw_hal_fw_dl(_adapter *padapter, u8 wowlan);

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	void rtw_hal_clear_interrupt(_adapter *padapter);
#endif

void rtw_hal_set_tx_power_level(_adapter *adapter, u8 channel);
void rtw_hal_update_txpwr_level(_adapter *adapter);
void rtw_hal_set_txpwr_done(_adapter *adapter);
void rtw_hal_set_tx_power_index(_adapter *adapter, u32 powerindex
	, enum rf_path rfpath, u8 rate);

u8 rtw_hal_get_tx_power_index(_adapter *adapter, enum rf_path rfpath
	, RATE_SECTION rs, enum MGN_RATE rate, enum channel_width bw, BAND_TYPE band, u8 cch, u8 opch
	, struct txpwr_idx_comp *tic);
s8 rtw_hal_get_txpwr_target_extra_bias(_adapter *adapter, enum rf_path rfpath
	, RATE_SECTION rs, enum MGN_RATE rate, enum channel_width bw, BAND_TYPE band, u8 cch);

u8 rtw_hal_ops_check(_adapter *padapter);

#ifdef RTW_HALMAC
	u8 rtw_hal_init_mac_register(PADAPTER);
	u8 rtw_hal_init_phy(PADAPTER);
s32 rtw_hal_fw_mem_dl(_adapter *padapter, enum fw_mem mem);
#endif /* RTW_HALMAC */

#ifdef CONFIG_RFKILL_POLL
bool rtw_hal_rfkill_poll(_adapter *adapter, u8 *valid);
#endif

#endif /* __HAL_INTF_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/ip.h                                                                          0000644 0001750 0001750 00000007710 14214766567 014212  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _LINUX_IP_H
#define _LINUX_IP_H

/* SOL_IP socket options */

#define IPTOS_TOS_MASK		0x1E
#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
#define	IPTOS_LOWDELAY		0x10
#define	IPTOS_THROUGHPUT	0x08
#define	IPTOS_RELIABILITY	0x04
#define	IPTOS_MINCOST		0x02

#define IPTOS_PREC_MASK		0xE0
#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
#define IPTOS_PREC_NETCONTROL           0xe0
#define IPTOS_PREC_INTERNETCONTROL      0xc0
#define IPTOS_PREC_CRITIC_ECP           0xa0
#define IPTOS_PREC_FLASHOVERRIDE        0x80
#define IPTOS_PREC_FLASH                0x60
#define IPTOS_PREC_IMMEDIATE            0x40
#define IPTOS_PREC_PRIORITY             0x20
#define IPTOS_PREC_ROUTINE              0x00


/* IP options */
#define IPOPT_COPY		0x80
#define IPOPT_CLASS_MASK	0x60
#define IPOPT_NUMBER_MASK	0x1f

#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)

#define	IPOPT_CONTROL		0x00
#define	IPOPT_RESERVED1		0x20
#define	IPOPT_MEASUREMENT	0x40
#define	IPOPT_RESERVED2		0x60

#define IPOPT_END	(0 | IPOPT_CONTROL)
#define IPOPT_NOOP	(1 | IPOPT_CONTROL)
#define IPOPT_SEC	(2 | IPOPT_CONTROL | IPOPT_COPY)
#define IPOPT_LSRR	(3 | IPOPT_CONTROL | IPOPT_COPY)
#define IPOPT_TIMESTAMP	(4 | IPOPT_MEASUREMENT)
#define IPOPT_RR	(7 | IPOPT_CONTROL)
#define IPOPT_SID	(8 | IPOPT_CONTROL | IPOPT_COPY)
#define IPOPT_SSRR	(9 | IPOPT_CONTROL | IPOPT_COPY)
#define IPOPT_RA	(20 | IPOPT_CONTROL | IPOPT_COPY)

#define IPVERSION	4
#define MAXTTL		255
#define IPDEFTTL	64

/* struct timestamp, struct route and MAX_ROUTES are removed.

   REASONS: it is clear that nobody used them because:
   - MAX_ROUTES value was wrong.
   - "struct route" was wrong.
   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
 */

#define IPOPT_OPTVAL 0
#define IPOPT_OLEN   1
#define IPOPT_OFFSET 2
#define IPOPT_MINOFF 4
#define MAX_IPOPTLEN 40
#define IPOPT_NOP IPOPT_NOOP
#define IPOPT_EOL IPOPT_END
#define IPOPT_TS  IPOPT_TIMESTAMP

#define	IPOPT_TS_TSONLY		0		/* timestamps only */
#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
#define	IPOPT_TS_PRESPEC	3		/* specified modules only */

#ifdef PLATFORM_LINUX

struct ip_options {
	__u32		faddr;				/* Saved first hop address */
	unsigned char	optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_setbyuser:1,			/* Set by setsockopt?			*/
		 is_data:1,			/* Options in __data, rather than skb	*/
		 is_strictroute:1,		/* Strict source route			*/
		 srr_is_hit:1,			/* Packet destination addr was our one	*/
		 is_changed:1,			/* IP checksum more not valid		*/
		 rr_needaddr:1,			/* Need to record addr of outgoing dev	*/
		 ts_needtime:1,			/* Need to record timestamp		*/
		 ts_needaddr:1;			/* Need to record addr of outgoing dev */
	unsigned char router_alert;
	unsigned char __pad1;
	unsigned char __pad2;
	unsigned char __data[0];
};

#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
#endif

struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	ihl:4,
		version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
	__u8	version:4,
		ihl:4;
#else
#error	"Please fix <asm/byteorder.h>"
#endif
	__u8	tos;
	__u16	tot_len;
	__u16	id;
	__u16	frag_off;
	__u8	ttl;
	__u8	protocol;
	__u16	check;
	__u32	saddr;
	__u32	daddr;
	/*The options start here. */
};

#endif	/* _LINUX_IP_H */
                                                        rtl8822bu/src/include/rtl8723b_recv.h                                                               0000755 0001750 0001750 00000004760 14214766567 016115  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_RECV_H__
#define __RTL8723B_RECV_H__

#define RECV_BLK_SZ 512
#define RECV_BLK_CNT 16
#define RECV_BLK_TH RECV_BLK_CNT

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
			#else
				#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
			#endif
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)

	#define MAX_RECVBUF_SZ  (RX_DMA_SIZE_8723B - RX_DMA_RESERVED_SIZE_8723B)

#endif

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

#ifdef CONFIG_SDIO_HCI
	#ifndef CONFIG_SDIO_RX_COPY
		#undef MAX_RECVBUF_SZ
		#define MAX_RECVBUF_SZ	(RX_DMA_SIZE_8723B - RX_DMA_RESERVED_SIZE_8723B)
	#endif /* !CONFIG_SDIO_RX_COPY */
#endif /* CONFIG_SDIO_HCI */

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8723bs_init_recv_priv(PADAPTER padapter);
	void rtl8723bs_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_USB_HCI
	int rtl8723bu_init_recv_priv(_adapter *padapter);
	void rtl8723bu_free_recv_priv(_adapter *padapter);
	void rtl8723bu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8723be_init_recv_priv(PADAPTER padapter);
	void rtl8723be_free_recv_priv(PADAPTER padapter);
#endif

void rtl8723b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8723B_RECV_H__ */
                rtl8822bu/src/include/rtw_rm_fsm.h                                                                  0000644 0001750 0001750 00000022502 14214766567 015755  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 
/******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __RTW_RM_FSM_H_
#define __RTW_RM_FSM_H_

#ifdef CONFIG_RTW_80211K

#define RM_SUPPORT_IWPRIV_DBG	1
#define RM_MORE_DBG_MSG		0

#define DBG_BCN_REQ_DETAIL	0
#define DBG_BCN_REQ_WILDCARD	0
#define DBG_BCN_REQ_SSID	0
#define DBG_BCN_REQ_SSID_NAME	"RealKungFu"

#define RM_REQ_TIMEOUT		10000	/* 10 seconds */
#define RM_MEAS_TIMEOUT		10000	/* 10 seconds */
#define RM_REPT_SCAN_INTVL	5000	/*  5 seconds */
#define RM_REPT_POLL_INTVL	2000	/*  2 seconds */
#define RM_COND_INTVL		2000	/*  2 seconds */
#define RM_SCAN_DENY_TIMES	10
#define RM_BUSY_TRAFFIC_TIMES	10
#define RM_WAIT_BUSY_TIMEOUT	1000	/*  1 seconds */

#define MEAS_REQ_MOD_PARALLEL	BIT(0)
#define MEAS_REQ_MOD_ENABLE	BIT(1)
#define MEAS_REQ_MOD_REQUEST	BIT(2)
#define MEAS_REQ_MOD_REPORT	BIT(3)
#define MEAS_REQ_MOD_DUR_MAND	BIT(4)

#define MEAS_REP_MOD_LATE	BIT(0)
#define MEAS_REP_MOD_INCAP	BIT(1)
#define MEAS_REP_MOD_REFUSE	BIT(2)

#define RM_MASTER		BIT(0)	/* STA who issue meas_req */
#define RM_SLAVE		0	/* STA who do measurement */

#define CLOCK_UNIT		10	/* ms */
#define RTW_MAX_NB_RPT_IE_NUM	16

#define RM_GET_AID(rmid)	((rmid&0xffff0000)>>16)
#define RM_IS_ID_FOR_ALL(rmid)	(rmid&RM_ALL_MEAS)

#define	MAX_OP_CHANNEL_SET_NUM	11
typedef struct _RT_OPERATING_CLASS {
	int	global_op_class;
	int	Len;
	u16	Channel[MAX_OP_CHANNEL_SET_NUM];
} RT_OPERATING_CLASS, *PRT_OPERATING_CLASS;

/* IEEE 802.11-2012 Table 8-59 Measurement Type definitions
*  for measurement request
*  modify rm_meas_type_req_name() when adding new type
*/
enum meas_type_of_req {
	basic_req,	/* spectrum measurement */
	cca_req,
	rpi_histo_req,
	ch_load_req,
	noise_histo_req,
	bcn_req,
	frame_req,
	sta_statis_req,
	lci_req,
	meas_type_req_max,
};

/* IEEE 802.11-2012 Table 8-81 Measurement Type definitions
*  for measurement report
*  modify rm_type_rep_name() when adding new type
*/
enum meas_type_of_rep {
	basic_rep,	/* spectrum measurement */
	cca_rep,
	rpi_histo_rep,
	ch_load_rep,	/* radio measurement */
	noise_histo_rep,
	bcn_rep,
	frame_rep,
	sta_statis_rep,	/* Radio measurement and WNM */
	lci_rep,
	meas_type_rep_max
};

/*
* Beacon request
*/
/* IEEE 802.11-2012 Table 8-64 Measurement mode for Beacon Request element */
enum bcn_req_meas_mode {
	bcn_req_passive,
	bcn_req_active,
	bcn_req_bcn_table
};

/* IEEE 802.11-2012 Table 8-65 optional subelement IDs for Beacon Request */
enum bcn_req_opt_sub_id{
	bcn_req_ssid = 0,		/* len 0-32 */
	bcn_req_rep_info = 1,		/* len 2 */
	bcn_req_rep_detail = 2,		/* len 1 */
	bcn_req_req = 10,		/* len 0-237 */
	bcn_req_ac_ch_rep = 51		/* len 1-237 */
};

/* IEEE 802.11-2012 Table 8-66 Reporting condition of Beacon Report */
enum bcn_rep_cound_id{
	bcn_rep_cond_immediately,	/* default */
	bcn_req_cond_rcpi_greater,
	bcn_req_cond_rcpi_less,
	bcn_req_cond_rsni_greater,
	bcn_req_cond_rsni_less,
	bcn_req_cond_max
};

struct opt_rep_info {
	u8 cond;
	u8 threshold;
};

#define BCN_REQ_OPT_MAX_NUM		16
struct bcn_req_opt {
	/* all req cmd id */
	u8 opt_id[BCN_REQ_OPT_MAX_NUM];
	u8 opt_id_num;
	u8 rep_detail;
	NDIS_802_11_SSID ssid;

	/* bcn report condition */
	struct opt_rep_info rep_cond;

	/* 0:default(Report to be issued after each measurement) */
	u8 *req_start;	/*id : 10 request;start  */
	u8 req_len;	/*id : 10 request;length */
};

/*
* channel load
*/
/* IEEE 802.11-2012 Table 8-60 optional subelement IDs for channel load request */
enum ch_load_opt_sub_id{
	ch_load_rsvd,
	ch_load_rep_info
};

/* IEEE 802.11-2012 Table 8-61 Reporting condition for channel load Report */
enum ch_load_cound_id{
	ch_load_cond_immediately,	/* default */
	ch_load_cond_anpi_equal_greater,
	ch_load_cond_anpi_equal_less,
	ch_load_cond_max
};

/*
* Noise histogram
*/
/* IEEE 802.11-2012 Table 8-62 optional subelement IDs for noise histogram */
enum noise_histo_opt_sub_id{
	noise_histo_rsvd,
	noise_histo_rep_info
};

/* IEEE 802.11-2012 Table 8-63 Reporting condition for noise historgarm Report */
enum noise_histo_cound_id{
	noise_histo_cond_immediately,	/* default */
	noise_histo_cond_anpi_equal_greater,
	noise_histo_cond_anpi_equal_less,
	noise_histo_cond_max
};

struct meas_req_opt {
	/* report condition */
	struct opt_rep_info rep_cond;
};

/*
* State machine
*/

enum RM_STATE {
	RM_ST_IDLE,
	RM_ST_DO_MEAS,
	RM_ST_WAIT_MEAS,
	RM_ST_SEND_REPORT,
	RM_ST_RECV_REPORT,
	RM_ST_END,
	RM_ST_MAX
};

struct rm_meas_req {
	u8 category;
	u8 action_code;		/* T8-206  */
	u8 diag_token;
	u16 rpt;

	u8 e_id;
	u8 len;
	u8 m_token;
	u8 m_mode;		/* req:F8-105, rep:F8-141 */
	u8 m_type;		/* T8-59 */
	u8 op_class;
	u8 ch_num;
	u16 rand_intvl;		/* units of TU */
	u16 meas_dur;		/* units of TU */

	u8 bssid[6];		/* for bcn_req */

	u8 *pssid;
	u8 *opt_s_elem_start;
	int opt_s_elem_len;

	s8 tx_pwr_used;		/* for link measurement */
	s8 tx_pwr_max;		/* for link measurement */

	union {
		struct bcn_req_opt bcn;
		struct meas_req_opt clm;
		struct meas_req_opt nhm;
	}opt;

	struct rtw_ieee80211_channel ch_set[MAX_OP_CHANNEL_SET_NUM];
	u8 ch_set_ch_amount;
	s8 rx_pwr;		/* in dBm */
	u8 rx_bw;
	u8 rx_rate;
	u8 rx_rsni;
};

struct rm_meas_rep {
	u8 category;
	u8 action_code;		/* T8-206  */
	u8 diag_token;

	u8 e_id;		/* T8-54, 38 request; 39 report */
	u8 len;
	u8 m_token;
	u8 m_mode;		/* req:F8-105, rep:F8-141 */
	u8 m_type;		/* T8-59 */
	u8 op_class;
	u8 ch_num;

	u8 ch_load;
	u8 anpi;
	u8 ipi[11];

	u16 rpt;
	u8 bssid[6];		/* for bcn_req */
};

#define MAX_BUF_NUM	128
struct data_buf {
	u8 *pbuf;
	u16 len;
};

struct rm_obj {

	/* aid << 16 
		|diag_token << 8
		|B(1) 1/0:All_AID/UNIC
		|B(0) 1/0:RM_MASTER/RM_SLAVE */
	u32 rmid;

	enum RM_STATE state;
	struct rm_meas_req q;
	struct rm_meas_rep p;
	struct sta_info *psta;
	struct rm_clock *pclock;

	/* meas report */
	u64 meas_start_time;
	u64 meas_end_time;
	int wait_busy;
	u8 poll_mode;

	struct data_buf buf[MAX_BUF_NUM];

	_list list;
};

/*
* Measurement
*/
struct opt_subelement {
	u8 id;
	u8 length;
	u8 *data;
};

/* 802.11-2012 Table 8-206 Radio Measurment Action field */
enum rm_action_code {
	RM_ACT_RADIO_MEAS_REQ,
	RM_ACT_RADIO_MEAS_REP,
	RM_ACT_LINK_MEAS_REQ,
	RM_ACT_LINK_MEAS_REP,
	RM_ACT_NB_REP_REQ,	/* 4 */
	RM_ACT_NB_REP_RESP,
	RM_ACT_RESV,
	RM_ACT_MAX
};

/* 802.11-2012 Table 8-119 RM Enabled Capabilities definition */
enum rm_cap_en {
	RM_LINK_MEAS_CAP_EN,
	RM_NB_REP_CAP_EN,		/* neighbor report */
	RM_PARAL_MEAS_CAP_EN,		/* parallel report */
	RM_REPEAT_MEAS_CAP_EN,
	RM_BCN_PASSIVE_MEAS_CAP_EN,
	RM_BCN_ACTIVE_MEAS_CAP_EN,
	RM_BCN_TABLE_MEAS_CAP_EN,
	RM_BCN_MEAS_REP_COND_CAP_EN,	/* conditions */

	RM_FRAME_MEAS_CAP_EN,
	RM_CH_LOAD_CAP_EN,
	RM_NOISE_HISTO_CAP_EN,		/* noise historgram */
	RM_STATIS_MEAS_CAP_EN,		/* statistics */
	RM_LCI_MEAS_CAP_EN,		/* 12 */
	RM_LCI_AMIMUTH_CAP_EN,
	RM_TRANS_STREAM_CAT_MEAS_CAP_EN,
	RM_TRIG_TRANS_STREAM_CAT_MEAS_CAP_EN,

	RM_AP_CH_REP_CAP_EN,
	RM_RM_MIB_CAP_EN,
	RM_OP_CH_MAX_MEAS_DUR0,		/* 18-20 */
	RM_OP_CH_MAX_MEAS_DUR1,
	RM_OP_CH_MAX_MEAS_DUR2,
	RM_NONOP_CH_MAX_MEAS_DUR0,	/* 21-23 */
	RM_NONOP_CH_MAX_MEAS_DUR1,
	RM_NONOP_CH_MAX_MEAS_DUR2,

	RM_MEAS_PILOT_CAP0,		/* 24-26 */
	RM_MEAS_PILOT_CAP1,
	RM_MEAS_PILOT_CAP2,
	RM_MEAS_PILOT_TRANS_INFO_CAP_EN,
	RM_NB_REP_TSF_OFFSET_CAP_EN,
	RM_RCPI_MEAS_CAP_EN,		/* 29 */
	RM_RSNI_MEAS_CAP_EN,
	RM_BSS_AVG_ACCESS_DELAY_CAP_EN,

	RM_AVALB_ADMIS_CAPACITY_CAP_EN,
	RM_ANT_CAP_EN,
	RM_RSVD,			/* 34-39 */
	RM_MAX
};

char *rm_state_name(enum RM_STATE state);
char *rm_event_name(enum RM_EV_ID evid);
char *rm_type_req_name(u8 meas_type);
int _rm_post_event(_adapter *padapter, u32 rmid, enum RM_EV_ID evid);
int rm_enqueue_rmobj(_adapter *padapter, struct rm_obj *obj, bool to_head);

void rm_free_rmobj(struct rm_obj *prm);
struct rm_obj *rm_alloc_rmobj(_adapter *padapter);
struct rm_obj *rm_get_rmobj(_adapter *padapter, u32 rmid);
struct sta_info *rm_get_psta(_adapter *padapter, u32 rmid);

int retrieve_radio_meas_result(struct rm_obj *prm);
int rm_radio_meas_report_cond(struct rm_obj *prm);
int rm_recv_radio_mens_req(_adapter *padapter,
	union recv_frame *precv_frame,struct sta_info *psta);
int rm_recv_radio_mens_rep(_adapter *padapter,
	union recv_frame *precv_frame, struct sta_info *psta);
int rm_recv_link_mens_req(_adapter *padapter,
	union recv_frame *precv_frame,struct sta_info *psta);
int rm_recv_link_mens_rep(_adapter *padapter,
	union recv_frame *precv_frame, struct sta_info *psta);
int rm_radio_mens_nb_rep(_adapter *padapter,
	union recv_frame *precv_frame, struct sta_info *psta);
int issue_null_reply(struct rm_obj *prm);
int issue_beacon_rep(struct rm_obj *prm);
int issue_nb_req(struct rm_obj *prm);
int issue_radio_meas_req(struct rm_obj *prm);
int issue_radio_meas_rep(struct rm_obj *prm);
int issue_link_meas_req(struct rm_obj *prm);
int issue_link_meas_rep(struct rm_obj *prm);

void rm_set_rep_mode(struct rm_obj *prm, u8 mode);

int ready_for_scan(struct rm_obj *prm);
int rm_sitesurvey(struct rm_obj *prm);

#endif /*CONFIG_RTW_80211K*/
#endif /*__RTW_RM_FSM_H_*/
                                                                                                                                                                                              rtl8822bu/src/include/rtl8814a_spec.h                                                               0000755 0001750 0001750 00000062653 14214766567 016115  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_SPEC_H__
#define __RTL8814A_SPEC_H__

#include <drv_conf.h>


/* ************************************************************
 *
 * ************************************************************ */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_SYS_ISO_CTRL_8814A			0x0000	/* 2 Byte */
#define REG_SYS_FUNC_EN_8814A			0x0002	/* 2 Byte */
#define REG_SYS_PW_CTRL_8814A			0x0004	/* 4 Byte        */
#define REG_SYS_CLKR_8814A				0x0008	/* 2 Byte */
#define REG_SYS_EEPROM_CTRL_8814A		0x000A	/* 2 Byte        */
#define REG_EE_VPD_8814A				0x000C	/* 2 Byte */
#define REG_SYS_SWR_CTRL1_8814A			0x0010	/* 1 Byte */
#define REG_SPS0_CTRL_8814A				0x0011	/* 7 Byte */
#define REG_SYS_SWR_CTRL3_8814A			0x0018	/* 4 Byte */
#define REG_RSV_CTRL_8814A				0x001C	/* 3 Byte */
#define REG_RF_CTRL0_8814A				0x001F	/* 1 Byte */
#define REG_RF_CTRL1_8814A				0x0020	/* 1 Byte */
#define REG_RF_CTRL2_8814A				0x0021	/* 1 Byte */
#define REG_LPLDO_CTRL_8814A			0x0023	/* 1 Byte */
#define REG_AFE_CTRL1_8814A				0x0024	/* 4 Byte        */
#define REG_AFE_CTRL2_8814A				0x0028	/* 4 Byte        */
#define REG_AFE_CTRL3_8814A				0x002c	/* 4 Byte  */
#define REG_EFUSE_CTRL_8814A			0x0030
#define REG_LDO_EFUSE_CTRL_8814A		0x0034
#define REG_PWR_DATA_8814A				0x0038
#define REG_CAL_TIMER_8814A				0x003C
#define REG_ACLK_MON_8814A				0x003E
#define REG_GPIO_MUXCFG_8814A			0x0040
#define REG_GPIO_IO_SEL_8814A			0x0042
#define REG_MAC_PINMUX_CFG_8814A		0x0043
#define REG_GPIO_PIN_CTRL_8814A			0x0044
#define REG_GPIO_INTM_8814A				0x0048
#define REG_LEDCFG0_8814A				0x004C
#define REG_LEDCFG1_8814A				0x004D
#define REG_LEDCFG2_8814A				0x004E
#define REG_LEDCFG3_8814A				0x004F
#define REG_FSIMR_8814A					0x0050
#define REG_FSISR_8814A					0x0054
#define REG_HSIMR_8814A					0x0058
#define REG_HSISR_8814A					0x005c
#define REG_GPIO_EXT_CTRL_8814A			0x0060
#define REG_GPIO_STATUS_8814A			0x006C
#define REG_SDIO_CTRL_8814A				0x0070
#define REG_HCI_OPT_CTRL_8814A			0x0074
#define REG_RF_CTRL3_8814A				0x0076	/* 1 Byte */
#define REG_AFE_CTRL4_8814A				0x0078
#define REG_8051FW_CTRL_8814A			0x0080
#define REG_HIMR0_8814A					0x00B0
#define REG_HISR0_8814A					0x00B4
#define REG_HIMR1_8814A					0x00B8
#define REG_HISR1_8814A					0x00BC
#define REG_SYS_CFG1_8814A				0x00F0
#define REG_SYS_CFG2_8814A				0x00FC
#define REG_SYS_CFG3_8814A				0x1000

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_CR_8814A						0x0100
#define REG_PBP_8814A					0x0104
#define REG_PKT_BUFF_ACCESS_CTRL_8814A	0x0106
#define REG_TRXDMA_CTRL_8814A			0x010C
#define REG_TRXFF_BNDY_8814A			0x0114
#define REG_TRXFF_STATUS_8814A			0x0118
#define REG_RXFF_PTR_8814A				0x011C
#define REG_CPWM_8814A					0x012F
#define REG_FWIMR_8814A					0x0130
#define REG_FWISR_8814A					0x0134
#define REG_FTIMR_8814A					0x0138
#define REG_PKTBUF_DBG_CTRL_8814A		0x0140
#define REG_RXPKTBUF_CTRL_8814A		0x0142
#define REG_PKTBUF_DBG_DATA_L_8814A	0x0144
#define REG_PKTBUF_DBG_DATA_H_8814A	0x0148

#define REG_WOWLAN_WAKE_REASON			REG_MCUTST_WOWLAN

#define REG_TC0_CTRL_8814A				0x0150
#define REG_TC1_CTRL_8814A				0x0154
#define REG_TC2_CTRL_8814A				0x0158
#define REG_TC3_CTRL_8814A				0x015C
#define REG_TC4_CTRL_8814A				0x0160
#define REG_TCUNIT_BASE_8814A			0x0164
#define REG_RSVD3_8814A					0x0168
#define REG_C2HEVT_MSG_NORMAL_8814A	0x01A0
#define REG_C2HEVT_CLEAR_8814A			0x01AF
#define REG_MCUTST_1_8814A				0x01C0
#define REG_MCUTST_WOWLAN_8814A		0x01C7
#define REG_FMETHR_8814A				0x01C8
#define REG_HMETFR_8814A				0x01CC
#define REG_HMEBOX_0_8814A				0x01D0
#define REG_HMEBOX_1_8814A				0x01D4
#define REG_HMEBOX_2_8814A				0x01D8
#define REG_HMEBOX_3_8814A				0x01DC
#define REG_LLT_INIT_8814A				0x01E0
#define REG_LLT_ADDR_8814A				0x01E4 /* 20130415 KaiYuan add for 8814 */
#define REG_HMEBOX_EXT0_8814A			0x01F0
#define REG_HMEBOX_EXT1_8814A			0x01F4
#define REG_HMEBOX_EXT2_8814A			0x01F8
#define REG_HMEBOX_EXT3_8814A			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_FIFOPAGE_CTRL_1_8814A			0x0200
#define REG_FIFOPAGE_CTRL_2_8814A		0x0204
#define REG_AUTO_LLT_8814A					0x0208
#define REG_TXDMA_OFFSET_CHK_8814A	0x020C
#define REG_TXDMA_STATUS_8814A			0x0210
#define REG_RQPN_NPQ_8814A				0x0214
#define REG_TQPNT1_8814A					0x0218
#define REG_TQPNT2_8814A					0x021C
#define REG_TQPNT3_8814A					0x0220
#define REG_TQPNT4_8814A					0x0224
#define REG_RQPN_CTRL_1_8814A				0x0228
#define REG_RQPN_CTRL_2_8814A				0x022C
#define REG_FIFOPAGE_INFO_1_8814A			0x0230
#define REG_FIFOPAGE_INFO_2_8814A			0x0234
#define REG_FIFOPAGE_INFO_3_8814A			0x0238
#define REG_FIFOPAGE_INFO_4_8814A			0x023C
#define REG_FIFOPAGE_INFO_5_8814A			0x0240


/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_AGG_PG_TH_8814A		0x0280
#define REG_RXPKT_NUM_8814A				0x0284 /* The number of packets in RXPKTBUF. */
#define REG_RXDMA_CONTROL_8814A			0x0286 /* ?????? Control the RX DMA. */
#define REG_RXDMA_STATUS_8814A			0x0288
#define REG_RXDMA_MODE_8814A				0x0290 /* ?????? */
#define REG_EARLY_MODE_CONTROL_8814A	0x02BC /* ?????? */
#define REG_RSVD5_8814A					0x02F0 /* ?????? */


/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8814A			0x0300
#define	REG_INT_MIG_8814A				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_TXBD_DESA_8814A		0x0308	/* TX Beacon Descriptor Address */
#define	REG_MGQ_TXBD_DESA_8814A			0x0310	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_TXBD_DESA_8814A			0x0318	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_TXBD_DESA_8814A			0x0320	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_TXBD_DESA_8814A			0x0328	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_TXBD_DESA_8814A			0x0330	/* TX BK Queue Descriptor Address */
#define	REG_RXQ_RXBD_DESA_8814A			0x0338	/* RX Queue	Descriptor Address */
#define REG_HI0Q_TXBD_DESA_8814A		0x0340
#define REG_HI1Q_TXBD_DESA_8814A		0x0348
#define REG_HI2Q_TXBD_DESA_8814A		0x0350
#define REG_HI3Q_TXBD_DESA_8814A		0x0358
#define REG_HI4Q_TXBD_DESA_8814A		0x0360
#define REG_HI5Q_TXBD_DESA_8814A		0x0368
#define REG_HI6Q_TXBD_DESA_8814A		0x0370
#define REG_HI7Q_TXBD_DESA_8814A		0x0378
#define	REG_MGQ_TXBD_NUM_8814A			0x0380
#define	REG_RX_RXBD_NUM_8814A			0x0382
#define	REG_VOQ_TXBD_NUM_8814A			0x0384
#define	REG_VIQ_TXBD_NUM_8814A			0x0386
#define	REG_BEQ_TXBD_NUM_8814A			0x0388
#define	REG_BKQ_TXBD_NUM_8814A			0x038A
#define	REG_HI0Q_TXBD_NUM_8814A			0x038C
#define	REG_HI1Q_TXBD_NUM_8814A			0x038E
#define	REG_HI2Q_TXBD_NUM_8814A			0x0390
#define	REG_HI3Q_TXBD_NUM_8814A			0x0392
#define	REG_HI4Q_TXBD_NUM_8814A			0x0394
#define	REG_HI5Q_TXBD_NUM_8814A			0x0396
#define	REG_HI6Q_TXBD_NUM_8814A			0x0398
#define	REG_HI7Q_TXBD_NUM_8814A			0x039A
#define	REG_TSFTIMER_HCI_8814A			0x039C

/* Read Write Point */
#define	REG_VOQ_TXBD_IDX_8814A			0x03A0
#define	REG_VIQ_TXBD_IDX_8814A			0x03A4
#define	REG_BEQ_TXBD_IDX_8814A			0x03A8
#define	REG_BKQ_TXBD_IDX_8814A			0x03AC
#define	REG_MGQ_TXBD_IDX_8814A			0x03B0
#define	REG_RXQ_TXBD_IDX_8814A			0x03B4
#define	REG_HI0Q_TXBD_IDX_8814A			0x03B8
#define	REG_HI1Q_TXBD_IDX_8814A			0x03BC
#define	REG_HI2Q_TXBD_IDX_8814A			0x03C0
#define	REG_HI3Q_TXBD_IDX_8814A			0x03C4
#define	REG_HI4Q_TXBD_IDX_8814A			0x03C8
#define	REG_HI5Q_TXBD_IDX_8814A			0x03CC
#define	REG_HI6Q_TXBD_IDX_8814A			0x03D0
#define	REG_HI7Q_TXBD_IDX_8814A			0x03D4
#define REG_DBG_SEL_V1_8814A				0x03D8
#define REG_PCIE_HRPWM1_V1_8814A			0x03D9
#define REG_PCIE_HCPWM1_V1_8814A			0x03DA
#define REG_PCIE_CTRL2_8814A				0x03DB
#define REG_PCIE_HRPWM2_V1_8814A			0x03DC
#define REG_PCIE_HCPWM2_V1_8814A			0x03DE
#define REG_PCIE_H2C_MSG_V1_8814A		0x03E0
#define REG_PCIE_C2H_MSG_V1_8814A		0x03E4
#define REG_DBI_WDATA_V1_8814A			0x03E8
#define REG_DBI_RDATA_V1_8814A			0x03EC
#define REG_DBI_FLAG_V1_8814A				0x03F0
#define REG_MDIO_V1_8814A					0x03F4
#define REG_PCIE_MIX_CFG_8814A			0x03F8
#define REG_DBG_8814A						0x03FC
/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_VOQ_INFORMATION_8814A		0x0400
#define REG_VIQ_INFORMATION_8814A		0x0404
#define REG_BEQ_INFORMATION_8814A		0x0408
#define REG_BKQ_INFORMATION_8814A		0x040C
#define REG_MGQ_INFORMATION_8814A		0x0410
#define REG_HGQ_INFORMATION_8814A		0x0414
#define REG_BCNQ_INFORMATION_8814A	0x0418
#define REG_TXPKT_EMPTY_8814A			0x041A
#define REG_CPU_MGQ_INFORMATION_8814A	0x041C
#define REG_FWHW_TXQ_CTRL_8814A		0x0420
#define REG_HWSEQ_CTRL_8814A			0x0423
#define REG_TXPKTBUF_BCNQ_BDNY_8814A	0x0424
/* #define REG_MGQ_BDNY_8814A				0x0425 */
#define REG_LIFETIME_EN_8814A				0x0426
/* #define REG_FW_FREE_TAIL_8814A			0x0427 */
#define REG_SPEC_SIFS_8814A				0x0428
#define REG_RETRY_LIMIT_8814A				0x042A
#define REG_TXBF_CTRL_8814A				0x042C
#define REG_DARFRC_8814A				0x0430
#define REG_RARFRC_8814A				0x0438
#define REG_RRSR_8814A					0x0440
#define REG_ARFR0_8814A					0x0444
#define REG_ARFR1_8814A					0x044C
#define REG_CCK_CHECK_8814A				0x0454
#define REG_AMPDU_MAX_TIME_8814A			0x0455
#define REG_TXPKTBUF_BCNQ1_BDNY_8814A	0x0456
#define REG_AMPDU_MAX_LENGTH_8814A	0x0458
#define REG_ACQ_STOP_8814A				0x045C
#define REG_NDPA_RATE_8814A				0x045D
#define REG_TX_HANG_CTRL_8814A			0x045E
#define REG_NDPA_OPT_CTRL_8814A		0x045F
#define REG_FAST_EDCA_CTRL_8814A		0x0460
#define REG_RD_RESP_PKT_TH_8814A		0x0463
#define REG_CMDQ_INFO_8814A				0x0464
#define REG_Q4_INFO_8814A					0x0468
#define REG_Q5_INFO_8814A					0x046C
#define REG_Q6_INFO_8814A					0x0470
#define REG_Q7_INFO_8814A					0x0474
#define REG_WMAC_LBK_BUF_HD_8814A		0x0478
#define REG_MGQ_PGBNDY_8814A				0x047A
#define REG_INIRTS_RATE_SEL_8814A			0x0480
#define REG_BASIC_CFEND_RATE_8814A		0x0481
#define REG_STBC_CFEND_RATE_8814A		0x0482
#define REG_DATA_SC_8814A					0x0483
#define REG_MACID_SLEEP3_8814A			0x0484
#define REG_MACID_SLEEP1_8814A			0x0488
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW				0x0484
	#define REG_TXPKTBUF_IV_HIGH			0x0488
#endif /* CONFIG_WOWLAN */
#define REG_ARFR2_8814A					0x048C
#define REG_ARFR3_8814A					0x0494
#define REG_ARFR4_8814A					0x049C
#define REG_ARFR5_8814A					0x04A4
#define REG_TXRPT_START_OFFSET_8814A		0x04AC
#define REG_TRYING_CNT_TH_8814A			0x04B0
#define REG_POWER_STAGE1_8814A		0x04B4
#define REG_POWER_STAGE2_8814A		0x04B8
#define REG_SW_AMPDU_BURST_MODE_CTRL_8814A	0x04BC
#define REG_PKT_LIFE_TIME_8814A			0x04C0
#define REG_PKT_BE_BK_LIFE_TIME_8814A		0x04C2 /* ?????? */
#define REG_STBC_SETTING_8814A			0x04C4
#define REG_STBC_8814A						0x04C5
#define REG_QUEUE_CTRL_8814A				0x04C6
#define REG_SINGLE_AMPDU_CTRL_8814A		0x04C7
#define REG_PROT_MODE_CTRL_8814A		0x04C8
#define REG_MAX_AGGR_NUM_8814A		0x04CA
#define REG_RTS_MAX_AGGR_NUM_8814A	0x04CB
#define REG_BAR_MODE_CTRL_8814A		0x04CC
#define REG_RA_TRY_RATE_AGG_LMT_8814A	0x04CF
#define REG_MACID_SLEEP2_8814A			0x04D0
#define REG_MACID_SLEEP0_8814A			0x04D4
#define REG_HW_SEQ0_8814A				0x04D8
#define REG_HW_SEQ1_8814A				0x04DA
#define REG_HW_SEQ2_8814A				0x04DC
#define REG_HW_SEQ3_8814A				0x04DE
#define REG_NULL_PKT_STATUS_8814A			0x04E0
#define REG_PTCL_ERR_STATUS_8814A			0x04E2
#define REG_DROP_PKT_NUM_8814A			0x04EC
#define REG_PTCL_TX_RPT_8814A				0x04F0
#define REG_Dummy_8814A					0x04FC


/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_EDCA_VO_PARAM_8814A			0x0500
#define REG_EDCA_VI_PARAM_8814A			0x0504
#define REG_EDCA_BE_PARAM_8814A			0x0508
#define REG_EDCA_BK_PARAM_8814A			0x050C
#define REG_BCNTCFG_8814A					0x0510
#define REG_PIFS_8814A						0x0512
#define REG_RDG_PIFS_8814A					0x0513
#define REG_SIFS_CTX_8814A					0x0514
#define REG_SIFS_TRX_8814A					0x0516
#define REG_AGGR_BREAK_TIME_8814A			0x051A
#define REG_SLOT_8814A						0x051B
#define REG_TX_PTCL_CTRL_8814A				0x0520
#define REG_TXPAUSE_8814A					0x0522
#define REG_DIS_TXREQ_CLR_8814A			0x0523
#define REG_RD_CTRL_8814A					0x0524
/*
 * Format for offset 540h-542h:
 *	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
 *	[7:4]:   Reserved.
 *	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
 *	[23:20]: Reserved
 * Description:
 *	              |
 * |<--Setup--|--Hold------------>|
 *	--------------|----------------------
 * |
 * TBTT
 * Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
 * Described by Designer Tim and Bruce, 2011-01-14.
 *   */
#define REG_TBTT_PROHIBIT_8814A			0x0540
#define REG_RD_NAV_NXT_8814A				0x0544
#define REG_NAV_PROT_LEN_8814A			0x0546
#define REG_BCN_CTRL_8814A					0x0550
#define REG_BCN_CTRL_1_8814A				0x0551
#define REG_MBID_NUM_8814A				0x0552
#define REG_DUAL_TSF_RST_8814A				0x0553
#define REG_MBSSID_BCN_SPACE_8814A		0x0554
#define REG_DRVERLYINT_8814A				0x0558
#define REG_BCNDMATIM_8814A				0x0559
#define REG_ATIMWND_8814A					0x055A
#define REG_USTIME_TSF_8814A				0x055C
#define REG_BCN_MAX_ERR_8814A				0x055D
#define REG_RXTSF_OFFSET_CCK_8814A		0x055E
#define REG_RXTSF_OFFSET_OFDM_8814A		0x055F
#define REG_TSFTR_8814A						0x0560
#define REG_CTWND_8814A					0x0572
#define REG_SECONDARY_CCA_CTRL_8814A		0x0577 /* ?????? */
#define REG_PSTIMER_8814A					0x0580
#define REG_TIMER0_8814A					0x0584
#define REG_TIMER1_8814A					0x0588
#define REG_BCN_PREDL_ITV_8814A			0x058F	/* Pre download beacon interval */
#define REG_ACMHWCTRL_8814A				0x05C0
#define REG_P2P_RST_8814A				0x05F0

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#define REG_MAC_CR_8814A					0x0600
#define REG_TCR_8814A						0x0604
#define REG_RCR_8814A						0x0608
#define REG_RX_PKT_LIMIT_8814A				0x060C
#define REG_RX_DLK_TIME_8814A				0x060D
#define REG_RX_DRVINFO_SZ_8814A			0x060F

#define REG_MACID_8814A					0x0610
#define REG_BSSID_8814A						0x0618
#define REG_MAR_8814A						0x0620
#define REG_MBIDCAMCFG_8814A				0x0628

#define REG_USTIME_EDCA_8814A				0x0638
#define REG_MAC_SPEC_SIFS_8814A			0x063A
#define REG_RESP_SIFP_CCK_8814A			0x063C
#define REG_RESP_SIFS_OFDM_8814A			0x063E
#define REG_ACKTO_8814A					0x0640
#define REG_CTS2TO_8814A					0x0641
#define REG_EIFS_8814A						0x0642

#define	REG_NAV_UPPER_8814A				0x0652	/* unit of 128 */
#define REG_TRXPTCL_CTL_8814A				0x0668

/* Security */
#define REG_CAMCMD_8814A					0x0670
#define REG_CAMWRITE_8814A				0x0674
#define REG_CAMREAD_8814A					0x0678
#define REG_CAMDBG_8814A					0x067C
#define REG_SECCFG_8814A					0x0680

/* Power */
#define REG_WOW_CTRL_8814A				0x0690
#define REG_PS_RX_INFO_8814A				0x0692
#define REG_UAPSD_TID_8814A				0x0693
#define REG_WKFMCAM_NUM_8814A			0x0698
#define REG_RXFLTMAP0_8814A				0x06A0
#define REG_RXFLTMAP1_8814A				0x06A2
#define REG_RXFLTMAP2_8814A				0x06A4
#define REG_BCN_PSR_RPT_8814A				0x06A8
#define REG_BT_COEX_TABLE_8814A			0x06C0
#define REG_TX_DATA_RSP_RATE_8814A		0x06DE
#define REG_ASSOCIATED_BFMER0_INFO_8814A	0x06E4
#define REG_ASSOCIATED_BFMER1_INFO_8814A	0x06EC
#define REG_CSI_RPT_PARAM_BW20_8814A		0x06F4
#define REG_CSI_RPT_PARAM_BW40_8814A		0x06F8
#define REG_CSI_RPT_PARAM_BW80_8814A		0x06FC

/* Hardware Port 2 */
#define REG_MACID1_8814A					0x0700
#define REG_BSSID1_8814A					0x0708
/* Hardware Port 3 */
#define REG_MACID2_8814A					0x1620
#define REG_BSSID2_8814A					0x1628
/* Hardware Port 4 */
#define REG_MACID3_8814A					0x1630
#define REG_BSSID3_8814A					0x1638
/* Hardware Port 5 */
#define REG_MACID4_8814A					0x1640
#define REG_BSSID4_8814A					0x1648

#define REG_ASSOCIATED_BFMEE_SEL_8814A	0x0714
#define REG_SND_PTCL_CTRL_8814A			0x0718
#define REG_IQ_DUMP_8814A					0x07C0

#define REG_CPU_DMEM_CON_8814A			0x1080

/**** page 19 ****/
/* TX BeamForming */
#define	REG_BB_TXBF_ANT_SET_BF1				0x19ac
#define	REG_BB_TXBF_ANT_SET_BF0				0x19b4

/*	0x1200h ~ 0x12FFh	DDMA CTRL
 *
 * ----------------------------------------------------- */
#define REG_DDMA_CH0SA                   0x1200
#define REG_DDMA_CH0DA                   0x1204
#define REG_DDMA_CH0CTRL                0x1208
#define REG_DDMA_CH1SA                   0x1210
#define REG_DDMA_CH1DA	0x1214
#define REG_DDMA_CH1CTRL                0x1218
#define REG_DDMA_CH2SA                   0x1220
#define REG_DDMA_CH2DA                   0x1224
#define REG_DDMA_CH2CTRL                0x1228
#define REG_DDMA_CH3SA                   0x1230
#define REG_DDMA_CH3DA                   0x1234
#define REG_DDMA_CH3CTRL                0x1238
#define REG_DDMA_CH4SA                   0x1240
#define REG_DDMA_CH4DA                   0x1244
#define REG_DDMA_CH4CTRL                0x1248
#define REG_DDMA_CH5SA                   0x1250
#define REG_DDMA_CH5DA                   0x1254
#define REG_DDMA_CH5CTRL                0x1258
#define REG_DDMA_INT_MSK                0x12E0
#define REG_DDMA_CHSTATUS              0x12E8
#define REG_DDMA_CHKSUM                 0x12F0
#define REG_DDMA_MONITER                0x12FC

#define REG_Q0_Q1_INFO_8814A		0x1400
#define REG_Q2_Q3_INFO_8814A		0x1404
#define REG_Q4_Q5_INFO_8814A		0x1408
#define REG_Q6_Q7_INFO_8814A		0x140C
#define REG_MGQ_HIQ_INFO_8814A	0x1410
#define REG_CMDQ_BCNQ_INFO_8814A	0x1414

#define DDMA_LEN_MASK		0x0001FFFF
#define FW_CHKSUM_DUMMY_SZ		8
#define DDMA_CH_CHKSUM_CNT		BIT(24)
#define DDMA_RST_CHKSUM_STS		BIT(25)
#define DDMA_MODE_BLOCK_CPU		BIT(26)
#define DDMA_CHKSUM_FAIL			BIT(27)
#define DDMA_DA_W_DISABLE			BIT(28)
#define DDMA_CHKSUM_EN			BIT(29)
#define DDMA_CH_OWN	BIT(31)


/* 3081 FWDL */
#define FWDL_EN                 BIT0
#define IMEM_BOOT_DL_RDY        BIT1
#define IMEM_BOOT_CHKSUM_FAIL   BIT2
#define IMEM_DL_RDY             BIT3
#define IMEM_CHKSUM_OK        BIT4
#define DMEM_DL_RDY             BIT5
#define DMEM_CHKSUM_OK        BIT6
#define EMEM_DL_RDY             BIT7
#define EMEM_CHKSUM_FAIL        BIT8
#define EMEM_TXBUF_DL_RDY       BIT9
#define EMEM_TXBUF_CHKSUM_FAIL  BIT10
#define CPU_CLK_SWITCH_BUSY     BIT11
#define CPU_CLK_SEL             (BIT12 | BIT13)
#define FWDL_OK                 BIT14
#define FW_INIT_RDY             BIT15
#define R_EN_BOOT_FLASH         BIT20

#define OCPBASE_IMEM_3081        0x00000000
#define OCPBASE_DMEM_3081        0x00200000
#define OCPBASE_RPTBUF_3081      0x18660000
#define OCPBASE_RXBUF2_3081      0x18680000
#define OCPBASE_RXBUF_3081       0x18700000
#define OCPBASE_TXBUF_3081       0x18780000


#define REG_FAST_EDCA_VOVI_SETTING_8814A 0x1448
#define REG_FAST_EDCA_BEBK_SETTING_8814A 0x144C


/* -----------------------------------------------------
 *   */


/* -----------------------------------------------------
 *
 *	Redifine 8192C register definition for compatibility
 *
 * ----------------------------------------------------- */

/* TODO: use these definition when using REG_xxx naming rule.
 * NOTE: DO NOT Remove these definition. Use later. */
#define	EFUSE_CTRL_8814A					REG_EFUSE_CTRL_8814A		/* E-Fuse Control. */
#define	EFUSE_TEST_8814A					REG_LDO_EFUSE_CTRL_8814A		/* E-Fuse Test. */
#define	MSR_8814A							(REG_CR_8814A + 2)		/* Media Status register */
#define	ISR_8814A							REG_HISR0_8814A
#define	TSFR_8814A							REG_TSFTR_8814A			/* Timing Sync Function Timer Register. */

#define PBP_8814A							REG_PBP_8814A

/* Redifine MACID register, to compatible prior ICs. */
#define	IDR0_8814A							REG_MACID_8814A			/* MAC ID Register, Offset 0x0050-0x0053 */
#define	IDR4_8814A							(REG_MACID_8814A + 4)	/* MAC ID Register, Offset 0x0054-0x0055 */


/*
 * 9. Security Control Registers	(Offset: )
 *   */
#define	RWCAM_8814A						REG_CAMCMD_8814A		/*  8190 Data Sheet is called CAMcmd */
#define	WCAMI_8814A						REG_CAMWRITE_8814A		/* Software write CAM input content */
#define	RCAMO_8814A						REG_CAMREAD_8814A		/* Software read/write CAM config */
#define	CAMDBG_8814A						REG_CAMDBG_8814A
#define	SECR_8814A							REG_SECCFG_8814A		/* Security Configuration Register */


/* ----------------------------------------------------------------------------
 * 8195 IMR/ISR bits						(offset 0xB0,  8bits)
 * ---------------------------------------------------------------------------- */
#define	IMR_DISABLED_8814A					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define	IMR_TIMER2_8814A					BIT31		/* Timeout interrupt 2 */
#define	IMR_TIMER1_8814A					BIT30		/* Timeout interrupt 1	 */
#define	IMR_PSTIMEOUT_8814A				BIT29		/* Power Save Time Out Interrupt */
#define	IMR_GTINT4_8814A					BIT28		/* When GTIMER4 expires, this bit is set to 1	 */
#define	IMR_GTINT3_8814A					BIT27		/* When GTIMER3 expires, this bit is set to 1	 */
#define	IMR_TXBCN0ERR_8814A				BIT26		/* Transmit Beacon0 Error			 */
#define	IMR_TXBCN0OK_8814A					BIT25		/* Transmit Beacon0 OK			 */
#define	IMR_TSF_BIT32_TOGGLE_8814A		BIT24		/* TSF Timer BIT32 toggle indication interrupt			 */
#define	IMR_BCNDMAINT0_8814A				BIT20		/* Beacon DMA Interrupt 0			 */
#define	IMR_BCNDERR0_8814A					BIT16		/* Beacon Queue DMA OK0			 */
#define	IMR_HSISR_IND_ON_INT_8814A		BIT15		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define	IMR_BCNDMAINT_E_8814A				BIT14		/* Beacon DMA Interrupt Extension for Win7			 */
#define	IMR_ATIMEND_8814A					BIT12		/* CTWidnow End or ATIM Window End */
#define	IMR_C2HCMD_8814A					BIT10		/* CPU to Host Command INT Status, Write 1 clear	 */
#define	IMR_CPWM2_8814A					BIT9			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_CPWM_8814A						BIT8			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_HIGHDOK_8814A					BIT7			/* High Queue DMA OK	 */
#define	IMR_MGNTDOK_8814A					BIT6			/* Management Queue DMA OK	 */
#define	IMR_BKDOK_8814A					BIT5			/* AC_BK DMA OK		 */
#define	IMR_BEDOK_8814A					BIT4			/* AC_BE DMA OK	 */
#define	IMR_VIDOK_8814A					BIT3			/* AC_VI DMA OK		 */
#define	IMR_VODOK_8814A					BIT2			/* AC_VO DMA OK	 */
#define	IMR_RDU_8814A						BIT1			/* Rx Descriptor Unavailable	 */
#define	IMR_ROK_8814A						BIT0			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define	IMR_MCUERR_8814A						BIT28		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT7_8814A				BIT27		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT6_8814A				BIT26		/* Beacon DMA Interrupt 6 */
#define	IMR_BCNDMAINT5_8814A				BIT25		/* Beacon DMA Interrupt 5 */
#define	IMR_BCNDMAINT4_8814A				BIT24		/* Beacon DMA Interrupt 4 */
#define	IMR_BCNDMAINT3_8814A				BIT23		/* Beacon DMA Interrupt 3 */
#define	IMR_BCNDMAINT2_8814A				BIT22		/* Beacon DMA Interrupt 2 */
#define	IMR_BCNDMAINT1_8814A				BIT21		/* Beacon DMA Interrupt 1 */
#define	IMR_BCNDOK7_8814A					BIT20		/* Beacon Queue DMA OK Interrup 7 */
#define	IMR_BCNDOK6_8814A					BIT19		/* Beacon Queue DMA OK Interrup 6 */
#define	IMR_BCNDOK5_8814A					BIT18		/* Beacon Queue DMA OK Interrup 5 */
#define	IMR_BCNDOK4_8814A					BIT17		/* Beacon Queue DMA OK Interrup 4 */
#define	IMR_BCNDOK3_8814A					BIT16		/* Beacon Queue DMA OK Interrup 3 */
#define	IMR_BCNDOK2_8814A					BIT15		/* Beacon Queue DMA OK Interrup 2 */
#define	IMR_BCNDOK1_8814A					BIT14		/* Beacon Queue DMA OK Interrup 1 */
#define	IMR_ATIMEND_E_8814A				BIT13		/* ATIM Window End Extension for Win7 */
#define	IMR_TXERR_8814A					BIT11		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define	IMR_RXERR_8814A					BIT10		/* Rx Error Flag INT Status, Write 1 clear */
#define	IMR_TXFOVW_8814A					BIT9			/* Transmit FIFO Overflow */
#define	IMR_RXFOVW_8814A					BIT8			/* Receive FIFO Overflow */


#ifdef CONFIG_PCI_HCI
	#define IMR_TX_MASK			(IMR_VODOK_8814A | IMR_VIDOK_8814A | IMR_BEDOK_8814A | IMR_BKDOK_8814A | IMR_MGNTDOK_8814A | IMR_HIGHDOK_8814A)

	#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8814A | IMR_TXBCN0OK_8814A | IMR_TXBCN0ERR_8814A | IMR_BCNDERR0_8814A)

	#define RT_AC_INT_MASKS	(IMR_VIDOK_8814A | IMR_VODOK_8814A | IMR_BEDOK_8814A | IMR_BKDOK_8814A)
#endif


/*===================================================================
=====================================================================
Here the register defines are for 92C. When the define is as same with 92C,
we will use the 92C's define for the consistency
So the following defines for 92C is not entire!!!!!!
=====================================================================
=====================================================================*/


/* -----------------------------------------------------
 *
 *	0xFE00h ~ 0xFE55h	USB Configuration
 *
 * ----------------------------------------------------- */

/* 2 Special Option */
#define USB_AGG_EN_8814A			BIT(7)
#define REG_USB_HRPWM_U3			0xF052

#define LAST_ENTRY_OF_TX_PKT_BUFFER_8814A       (2048-1)	/* 20130415 KaiYuan add for 8814 */

#endif /* __RTL8814A_SPEC_H__ */
                                                                                     rtl8822bu/src/include/cmd_osdep.h                                                                   0000644 0001750 0001750 00000002074 14214766567 015535  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __CMD_OSDEP_H_
#define __CMD_OSDEP_H_


extern sint _rtw_init_cmd_priv(struct	cmd_priv *pcmdpriv);
extern sint _rtw_init_evt_priv(struct evt_priv *pevtpriv);
extern void _rtw_free_evt_priv(struct	evt_priv *pevtpriv);
extern void _rtw_free_cmd_priv(struct	cmd_priv *pcmdpriv);
extern sint _rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj, bool to_head);
extern struct cmd_obj *_rtw_dequeue_cmd(_queue *queue);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtl8188e_recv.h                                                               0000644 0001750 0001750 00000006567 14214766567 016131  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_RECV_H__
#define __RTL8188E_RECV_H__

#define RECV_BLK_SZ 512
#define RECV_BLK_CNT 16
#define RECV_BLK_TH RECV_BLK_CNT

#if defined(CONFIG_USB_HCI)
	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)

	#define MAX_RECVBUF_SZ (10240)

#endif

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

#define TX_RPT1_PKT_LEN 8

typedef struct rxreport_8188e {
	/* Offset 0 */
	u32 pktlen:14;
	u32 crc32:1;
	u32 icverr:1;
	u32 drvinfosize:4;
	u32 security:3;
	u32 qos:1;
	u32 shift:2;
	u32 physt:1;
	u32 swdec:1;
	u32 ls:1;
	u32 fs:1;
	u32 eor:1;
	u32 own:1;

	/* Offset 4 */
	u32 macid:5;
	u32 tid:4;
	u32 hwrsvd:4;
	u32 amsdu:1;
	u32 paggr:1;
	u32 faggr:1;
	u32 a1fit:4;
	u32 a2fit:4;
	u32 pam:1;
	u32 pwr:1;
	u32 md:1;
	u32 mf:1;
	u32 type:2;
	u32 mc:1;
	u32 bc:1;

	/* Offset 8 */
	u32 seq:12;
	u32 frag:4;
	u32 nextpktlen:14;
	u32 nextind:1;
	u32 rsvd0831:1;

	/* Offset 12 */
	u32 rxmcs:6;
	u32 rxht:1;
	u32 gf:1;
	u32 splcp:1;
	u32 bw:1;
	u32 htc:1;
	u32 eosp:1;
	u32 bssidfit:2;
	u32 rpt_sel:2;
	u32 rsvd1216:13;
	u32 pattern_match:1;
	u32 unicastwake:1;
	u32 magicwake:1;

	/* Offset 16 */
	/*
	u32 pattern0match:1;
	u32 pattern1match:1;
	u32 pattern2match:1;
	u32 pattern3match:1;
	u32 pattern4match:1;
	u32 pattern5match:1;
	u32 pattern6match:1;
	u32 pattern7match:1;
	u32 pattern8match:1;
	u32 pattern9match:1;
	u32 patternamatch:1;
	u32 patternbmatch:1;
	u32 patterncmatch:1;
	u32 rsvd1613:19;
	*/
	u32 rsvd16;

	/* Offset 20 */
	u32 tsfl;

	/* Offset 24 */
	u32 bassn:12;
	u32 bavld:1;
	u32 rsvd2413:19;
} RXREPORT, *PRXREPORT;


#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8188es_init_recv_priv(PADAPTER padapter);
	void rtl8188es_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_USB_HCI
	void rtl8188eu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
	s32 rtl8188eu_init_recv_priv(PADAPTER padapter);
	void rtl8188eu_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8188ee_init_recv_priv(PADAPTER padapter);
	void rtl8188ee_free_recv_priv(PADAPTER padapter);
#endif

void rtl8188e_query_rx_desc_status(union recv_frame *precvframe, struct recv_stat *prxstat);

#endif /* __RTL8188E_RECV_H__ */
                                                                                                                                         rtl8822bu/src/include/rtl8192e_rf.h                                                                 0000644 0001750 0001750 00000001563 14214766567 015563  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_RF_H__
#define __RTL8192E_RF_H__

void
PHY_RF6052SetBandwidth8192E(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);


int
PHY_RF6052_Config_8192E(
		PADAPTER	Adapter);

#endif/* __RTL8192E_RF_H__ */
                                                                                                                                             rtl8822bu/src/include/rtl8703b_rf.h                                                                 0000644 0001750 0001750 00000001530 14214766567 015550  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_RF_H__
#define __RTL8703B_RF_H__

int	PHY_RF6052_Config8703B(PADAPTER		Adapter);

void
PHY_RF6052SetBandwidth8703B(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);

#endif
                                                                                                                                                                        rtl8822bu/src/include/rtl8822bs_hal.h                                                               0000644 0001750 0001750 00000002107 14214766567 016073  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822BS_HAL_H_
#define _RTL8822BS_HAL_H_

#include <drv_types.h>		/* PADAPTER */

/* rtl8822bs_ops.c */
void rtl8822bs_set_hal_ops(PADAPTER);

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
void rtl8822bs_disable_interrupt_but_cpwm2(PADAPTER adapter);
#endif

/* rtl8822bs_xmit.c */
s32 rtl8822bs_dequeue_writeport(PADAPTER);
#define _dequeue_writeport(a)	rtl8822bs_dequeue_writeport(a)

#endif /* _RTL8822BS_HAL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/rtw_iol.h                                                                     0000644 0001750 0001750 00000012545 14214766567 015263  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_IOL_H_
#define __RTW_IOL_H_


struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter);
int rtw_IOL_append_cmds(struct xmit_frame *xmit_frame, u8 *IOL_cmds, u32 cmd_len);
int rtw_IOL_append_LLT_cmd(struct xmit_frame *xmit_frame, u8 page_boundary);
int rtw_IOL_exec_cmds_sync(ADAPTER *adapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
bool rtw_IOL_applied(ADAPTER *adapter);
int rtw_IOL_append_DELAY_US_cmd(struct xmit_frame *xmit_frame, u16 us);
int rtw_IOL_append_DELAY_MS_cmd(struct xmit_frame *xmit_frame, u16 ms);
int rtw_IOL_append_END_cmd(struct xmit_frame *xmit_frame);


#ifdef CONFIG_IOL_NEW_GENERATION
#define IOREG_CMD_END_LEN	4

struct ioreg_cfg {
	u8	length;
	u8	cmd_id;
	u16	address;
	u32	data;
	u32  mask;
};
enum ioreg_cmd {
	IOREG_CMD_LLT			= 0x01,
	IOREG_CMD_REFUSE		= 0x02,
	IOREG_CMD_EFUSE_PATH = 0x03,
	IOREG_CMD_WB_REG		= 0x04,
	IOREG_CMD_WW_REG	= 0x05,
	IOREG_CMD_WD_REG	= 0x06,
	IOREG_CMD_W_RF		= 0x07,
	IOREG_CMD_DELAY_US	= 0x10,
	IOREG_CMD_DELAY_MS	= 0x11,
	IOREG_CMD_END		= 0xFF,
};
void read_efuse_from_txpktbuf(ADAPTER *adapter, int bcnhead, u8 *content, u16 *size);

int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value, u8 mask);
int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value, u16 mask);
int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value, u32 mask);
int _rtw_IOL_append_WRF_cmd(struct xmit_frame *xmit_frame, u8 rf_path, u16 addr, u32 value, u32 mask);
#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value, mask) _rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value), (mask))
#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value, mask) _rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value), (mask))
#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value, mask) _rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value), (mask))
#define rtw_IOL_append_WRF_cmd(xmit_frame, rf_path, addr, value, mask) _rtw_IOL_append_WRF_cmd((xmit_frame), (rf_path), (addr), (value), (mask))

u8 rtw_IOL_cmd_boundary_handle(struct xmit_frame *pxmit_frame);
void  rtw_IOL_cmd_buf_dump(ADAPTER *Adapter, int buf_len, u8 *pbuf);

#ifdef CONFIG_IOL_IOREG_CFG_DBG
struct cmd_cmp {
	u16 addr;
	u32 value;
};
#endif

#else /* CONFIG_IOL_NEW_GENERATION */

typedef struct _io_offload_cmd {
	u8 rsvd0;
	u8 cmd;
	u16 address;
	u32 value;
} IO_OFFLOAD_CMD, IOL_CMD;

#define IOL_CMD_LLT			0x00
/* #define IOL_CMD_R_EFUSE	0x01 */
#define IOL_CMD_WB_REG		0x02
#define IOL_CMD_WW_REG	0x03
#define IOL_CMD_WD_REG		0x04
/* #define IOL_CMD_W_RF		0x05 */
#define IOL_CMD_DELAY_US	0x80
#define IOL_CMD_DELAY_MS	0x81
/* #define IOL_CMD_DELAY_S	0x82 */
#define IOL_CMD_END			0x83

/*****************************************************
CMD					Address			Value
(B1)					(B2/B3:H/L addr)	(B4:B7 : MSB:LSB)
******************************************************
IOL_CMD_LLT			-				B7: PGBNDY
IOL_CMD_R_EFUSE	-				-
IOL_CMD_WB_REG		0x0~0xFFFF		B7
IOL_CMD_WW_REG	0x0~0xFFFF		B6~B7
IOL_CMD_WD_REG	0x0~0xFFFF		B4~B7
IOL_CMD_W_RF		RF Reg			B5~B7
IOL_CMD_DELAY_US	-				B6~B7
IOL_CMD_DELAY_MS	-				B6~B7
IOL_CMD_DELAY_S	-				B6~B7
IOL_CMD_END		-				-
******************************************************/
int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value);
int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value);
int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value);


int rtw_IOL_exec_cmd_array_sync(PADAPTER adapter, u8 *IOL_cmds, u32 cmd_num, u32 max_wating_ms);
int rtw_IOL_exec_empty_cmds_sync(ADAPTER *adapter, u32 max_wating_ms);

#ifdef DBG_IO
int dbg_rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value, const char *caller, const int line);
int dbg_rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value, const char *caller, const int line);
int dbg_rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value, const char *caller, const int line);
#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value), __FUNCTION__, __LINE__)
#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value), __FUNCTION__, __LINE__)
#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value), __FUNCTION__, __LINE__)
#else
#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value) _rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value))
#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value) _rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value))
#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value) _rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value))
#endif /* DBG_IO */
#endif /* CONFIG_IOL_NEW_GENERATION */



#endif /* __RTW_IOL_H_ */
                                                                                                                                                           rtl8822bu/src/include/rtl8821c_dm.h                                                                 0000644 0001750 0001750 00000001567 14214766567 015555  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812C_DM_H__
#define __RTL8812C_DM_H__

void rtl8821c_phy_init_dm_priv(PADAPTER);
void rtl8821c_phy_deinit_dm_priv(PADAPTER);
void rtl8821c_phy_init_haldm(PADAPTER);
void rtl8821c_phy_haldm_watchdog(PADAPTER);

#endif
                                                                                                                                         rtl8822bu/src/include/rtl8188e_spec.h                                                               0000644 0001750 0001750 00000013230 14214766567 016105  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_SPEC_H__
#define __RTL8188E_SPEC_H__


/* ************************************************************
 * 8188E Regsiter offset definition
 * ************************************************************ */


/* ************************************************************
 *
 * ************************************************************ */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_BB_PAD_CTRL				0x0064
#define REG_HMEBOX_E0					0x0088
#define REG_HMEBOX_E1					0x008A
#define REG_HMEBOX_E2					0x008C
#define REG_HMEBOX_E3					0x008E
#define REG_HMEBOX_EXT_0				0x01F0
#define REG_HMEBOX_EXT_1				0x01F4
#define REG_HMEBOX_EXT_2				0x01F8
#define REG_HMEBOX_EXT_3				0x01FC
#define REG_HIMR_88E					0x00B0 /* RTL8188E */
#define REG_HISR_88E					0x00B4 /* RTL8188E */
#define REG_HIMRE_88E					0x00B8 /* RTL8188E */
#define REG_HISRE_88E					0x00BC /* RTL8188E */

#define	REG_DBI_WDATA_8188E				0x0348	/* DBI Write data */
#define	REG_DBI_RDATA_8188E				0x034C	/* DBI Read data */
#define	REG_DBI_ADDR_8188E				0x0350	/* DBI Address */
#define	REG_DBI_FLAG_8188E				0x0352	/* DBI Read/Write Flag */
#define	REG_MDIO_WDATA_8188E				0x0354	/* MDIO for Write PCIE PHY */
#define	REG_MDIO_RDATA_8188E				0x0356	/* MDIO for Reads PCIE PHY */
#define	REG_MDIO_CTL_8188E				0x0358	/* MDIO for Control */

#define REG_MACID_NO_LINK_0			0x0484
#define REG_MACID_NO_LINK_1			0x0488
#define REG_MACID_PAUSE_0			0x048c
#define REG_MACID_PAUSE_1			0x0490

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_PKTBUF_DBG_ADDR			(REG_PKTBUF_DBG_CTRL)
#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
#define REG_WOWLAN_WAKE_REASON		REG_MCUTST_WOWLAN

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define REG_PCIE_HRPWM_8188E		0x0361	/* PCIe RPWM */
#define REG_PCIE_HCPWM_8188E		0x0363	/* PCIe CPWM */

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW             0x01a4
	#define REG_TXPKTBUF_IV_HIGH            0x01a8
#endif

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#ifdef CONFIG_RF_POWER_TRIM
	#define EEPROM_RF_GAIN_OFFSET			0xC1
	#define EEPROM_RF_GAIN_VAL				0xF6
	#define EEPROM_THERMAL_OFFSET			0xF5
#endif /*CONFIG_RF_POWER_TRIM*/
/* ----------------------------------------------------------------------------
 * 88E Driver Initialization Offload REG_FDHM0(Offset 0x88, 8 bits)
 * ----------------------------------------------------------------------------
 * IOL config for REG_FDHM0(Reg0x88) */
#define CMD_INIT_LLT					BIT0
#define CMD_READ_EFUSE_MAP		BIT1
#define CMD_EFUSE_PATCH			BIT2
#define CMD_IOCONFIG				BIT3
#define CMD_INIT_LLT_ERR			BIT4
#define CMD_READ_EFUSE_MAP_ERR	BIT5
#define CMD_EFUSE_PATCH_ERR		BIT6
#define CMD_IOCONFIG_ERR			BIT7

/* -----------------------------------------------------
 *
 *	Redifine register definition for compatibility
 *
 * ----------------------------------------------------- */

/* TODO: use these definition when using REG_xxx naming rule.
 * NOTE: DO NOT Remove these definition. Use later. */
#define ISR_88E				REG_HISR_88E

#ifdef CONFIG_PCI_HCI
	/* #define IMR_RX_MASK		(IMR_ROK_88E|IMR_RDU_88E|IMR_RXFOVW_88E) */
	#define IMR_TX_MASK			(IMR_VODOK_88E | IMR_VIDOK_88E | IMR_BEDOK_88E | IMR_BKDOK_88E | IMR_MGNTDOK_88E | IMR_HIGHDOK_88E | IMR_BCNDERR0_88E)

	#ifdef CONFIG_CONCURRENT_MODE
		#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_88E | IMR_TBDOK_88E | IMR_TBDER_88E | IMR_BCNDMAINT_E_88E)
	#else
		#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_88E | IMR_TBDOK_88E | IMR_TBDER_88E)
	#endif

	#define RT_AC_INT_MASKS	(IMR_VIDOK_88E | IMR_VODOK_88E | IMR_BEDOK_88E | IMR_BKDOK_88E)
#endif

/* ----------------------------------------------------------------------------
 * 8192C EEPROM/EFUSE share register definition.
 * ---------------------------------------------------------------------------- */

#define EFUSE_ACCESS_ON			0x69	/* For RTL8723 only. */
#define EFUSE_ACCESS_OFF			0x00	/* For RTL8723 only. */

#endif /* __RTL8188E_SPEC_H__ */
                                                                                                                                                                                                                                                                                                                                                                        rtl8822bu/src/include/rtw_cmd.h                                                                     0000644 0001750 0001750 00000075134 14214766567 015246  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_CMD_H_
#define __RTW_CMD_H_


#define C2H_MEM_SZ (16*1024)

#define FREE_CMDOBJ_SZ	128

#define MAX_CMDSZ	1536
#define MAX_RSPSZ	512
#define MAX_EVTSZ	1024

#define CMDBUFF_ALIGN_SZ 512

struct cmd_obj {
	_adapter *padapter;
	u16	cmdcode;
	u8	res;
	u8	*parmbuf;
	u32	cmdsz;
	u8	*rsp;
	u32	rspsz;
	struct submit_ctx *sctx;
	u8 no_io;
	/* _sema 	cmd_sem; */
	_list	list;
};

/* cmd flags */
enum {
	RTW_CMDF_DIRECTLY = BIT0,
	RTW_CMDF_WAIT_ACK = BIT1,
};

struct cmd_priv {
	_sema	cmd_queue_sema;
	/* _sema	cmd_done_sema; */
	_sema	start_cmdthread_sema;

	_queue	cmd_queue;
	u8	cmd_seq;
	u8	*cmd_buf;	/* shall be non-paged, and 4 bytes aligned */
	u8	*cmd_allocated_buf;
	u8	*rsp_buf;	/* shall be non-paged, and 4 bytes aligned		 */
	u8	*rsp_allocated_buf;
	u32	cmd_issued_cnt;
	u32	cmd_done_cnt;
	u32	rsp_cnt;
	ATOMIC_T cmdthd_running;
	/* u8 cmdthd_running; */

	_adapter *padapter;
	_mutex sctx_mutex;
};

#ifdef CONFIG_EVENT_THREAD_MODE
struct evt_obj {
	u16	evtcode;
	u8	res;
	u8	*parmbuf;
	u32	evtsz;
	_list	list;
};
#endif

struct	evt_priv {
#ifdef CONFIG_EVENT_THREAD_MODE
	_sema	evt_notify;

	_queue	evt_queue;
#endif

#ifdef CONFIG_FW_C2H_REG
	#define CONFIG_C2H_WK
#endif

#ifdef CONFIG_C2H_WK
	_workitem c2h_wk;
	bool c2h_wk_alive;
	struct rtw_cbuf *c2h_queue;
	#define C2H_QUEUE_MAX_LEN 10
#endif

#ifdef CONFIG_H2CLBK
	_sema	lbkevt_done;
	u8	lbkevt_limit;
	u8	lbkevt_num;
	u8	*cmdevt_parm;
#endif
	ATOMIC_T event_seq;
	u8	*evt_buf;	/* shall be non-paged, and 4 bytes aligned		 */
	u8	*evt_allocated_buf;
	u32	evt_done_cnt;
#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	u8	*c2h_mem;
	u8	*allocated_c2h_mem;
#endif

};

#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
	do {\
		_rtw_init_listhead(&pcmd->list);\
		pcmd->cmdcode = code;\
		pcmd->parmbuf = (u8 *)(pparm);\
		pcmd->cmdsz = sizeof (*pparm);\
		pcmd->rsp = NULL;\
		pcmd->rspsz = 0;\
	} while (0)

#define init_h2fwcmd_w_parm_no_parm_rsp(pcmd, code) \
	do {\
		_rtw_init_listhead(&pcmd->list);\
		pcmd->cmdcode = code;\
		pcmd->parmbuf = NULL;\
		pcmd->cmdsz = 0;\
		pcmd->rsp = NULL;\
		pcmd->rspsz = 0;\
	} while (0)

struct P2P_PS_Offload_t {
	u8 Offload_En:1;
	u8 role:1; /* 1: Owner, 0: Client */
	u8 CTWindow_En:1;
	u8 NoA0_En:1;
	u8 NoA1_En:1;
	u8 AllStaSleep:1; /* Only valid in Owner */
	u8 discovery:1;
	u8 rsvd:1;
#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	u8 p2p_macid:7;
	u8 disable_close_rf:1; /*1: not close RF but just pause p2p_macid when NoA duration*/
#endif /* CONFIG_P2P_PS_NOA_USE_MACID_SLEEP */
};

struct P2P_PS_CTWPeriod_t {
	u8 CTWPeriod;	/* TU */
};

#ifdef CONFIG_P2P_WOWLAN

struct P2P_WoWlan_Offload_t {
	u8 Disconnect_Wkup_Drv:1;
	u8 role:2;
	u8 Wps_Config[2];
};

#endif /* CONFIG_P2P_WOWLAN */

extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);

#ifdef CONFIG_EVENT_THREAD_MODE
extern u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj);
extern struct evt_obj *rtw_dequeue_evt(_queue *queue);
extern void rtw_free_evt_obj(struct evt_obj *pcmd);
#endif

void rtw_stop_cmd_thread(_adapter *adapter);
thread_return rtw_cmd_thread(thread_context context);

extern u32 rtw_init_cmd_priv(struct cmd_priv *pcmdpriv);
extern void rtw_free_cmd_priv(struct cmd_priv *pcmdpriv);

extern u32 rtw_init_evt_priv(struct evt_priv *pevtpriv);
extern void rtw_free_evt_priv(struct evt_priv *pevtpriv);
extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
#ifdef CONFIG_P2P
u8 p2p_protocol_wk_cmd(_adapter *padapter, int intCmdType);

#ifdef CONFIG_IOCTL_CFG80211
struct p2p_roch_parm {
	u64 cookie;
	struct wireless_dev *wdev;
	struct ieee80211_channel ch;
	enum nl80211_channel_type ch_type;
	unsigned int duration;
};

u8 p2p_roch_cmd(_adapter *adapter
	, u64 cookie, struct wireless_dev *wdev
	, struct ieee80211_channel *ch, enum nl80211_channel_type ch_type
	, unsigned int duration
	, u8 flags
);
u8 p2p_cancel_roch_cmd(_adapter *adapter, u64 cookie, struct wireless_dev *wdev, u8 flags);

#endif /* CONFIG_IOCTL_CFG80211 */
#endif /* CONFIG_P2P */

#ifdef CONFIG_IOCTL_CFG80211 
u8 rtw_mgnt_tx_cmd(_adapter *adapter, u8 tx_ch, u8 no_cck, const u8 *buf, size_t len, int wait_ack, u8 flags);
struct mgnt_tx_parm {
	u8 tx_ch;
	u8 no_cck;
	const u8 *buf;
	size_t len;
	int wait_ack;
};
#endif

enum rtw_drvextra_cmd_id {
	NONE_WK_CID,
	STA_MSTATUS_RPT_WK_CID,
	DYNAMIC_CHK_WK_CID,
	DM_CTRL_WK_CID,
	PBC_POLLING_WK_CID,
	POWER_SAVING_CTRL_WK_CID,/* IPS,AUTOSuspend */
	LPS_CTRL_WK_CID,
	ANT_SELECT_WK_CID,
	P2P_PS_WK_CID,
	P2P_PROTO_WK_CID,
	CHECK_HIQ_WK_CID,/* for softap mode, check hi queue if empty */
	C2H_WK_CID,
	RTP_TIMER_CFG_WK_CID,
	RESET_SECURITYPRIV, /* add for CONFIG_IEEE80211W, none 11w also can use */
	FREE_ASSOC_RESOURCES, /* add for CONFIG_IEEE80211W, none 11w also can use */
	DM_IN_LPS_WK_CID,
	DM_RA_MSK_WK_CID, /* add for STA update RAMask when bandwith change. */
	BEAMFORMING_WK_CID,
	LPS_CHANGE_DTIM_CID,
	BTINFO_WK_CID,
	BTC_REDUCE_WL_TXPWR_CID,
	DFS_RADAR_DETECT_WK_CID,
	DFS_RADAR_DETECT_EN_DEC_WK_CID,
	SESSION_TRACKER_WK_CID,
	EN_HW_UPDATE_TSF_WK_CID,
	PERIOD_TSF_UPDATE_END_WK_CID,
	TEST_H2C_CID,
	MP_CMD_WK_CID,
	CUSTOMER_STR_WK_CID,
#ifdef CONFIG_RTW_REPEATER_SON
	RSON_SCAN_WK_CID,
#endif
	MGNT_TX_WK_CID,
	REQ_PER_CMD_WK_CID,
	SSMPS_WK_CID,
#ifdef CONFIG_CTRL_TXSS_BY_TP
	TXSS_WK_CID,
#endif
	AC_PARM_CMD_WK_CID,
#ifdef CONFIG_AP_MODE
	STOP_AP_WK_CID,
#endif
	MAX_WK_CID
};

enum LPS_CTRL_TYPE {
	LPS_CTRL_SCAN = 0,
	LPS_CTRL_JOINBSS = 1,
	LPS_CTRL_CONNECT = 2,
	LPS_CTRL_DISCONNECT = 3,
	LPS_CTRL_SPECIAL_PACKET = 4,
	LPS_CTRL_LEAVE = 5,
	LPS_CTRL_TRAFFIC_BUSY = 6,
	LPS_CTRL_TX_TRAFFIC_LEAVE = 7,
	LPS_CTRL_RX_TRAFFIC_LEAVE = 8,
	LPS_CTRL_ENTER = 9,
	LPS_CTRL_LEAVE_CFG80211_PWRMGMT = 10,
	LPS_CTRL_LEAVE_SET_OPTION = 11,
};

enum STAKEY_TYPE {
	GROUP_KEY		= 0,
	UNICAST_KEY		= 1,
	TDLS_KEY		= 2,
};

enum RFINTFS {
	SWSI,
	HWSI,
	HWPI,
};

/*
Caller Mode: Infra, Ad-HoC(C)

Notes: To enter USB suspend mode

Command Mode

*/
struct usb_suspend_parm {
	u32 action;/* 1: sleep, 0:resume */
};

/*
Caller Mode: Infra, Ad-HoC

Notes: To join a known BSS.

Command-Event Mode

*/

/*
Caller Mode: Infra, Ad-Hoc

Notes: To join the specified bss

Command Event Mode

*/
struct joinbss_parm {
	WLAN_BSSID_EX network;
};

/*
Caller Mode: Infra, Ad-HoC(C)

Notes: To disconnect the current associated BSS

Command Mode

*/
struct disconnect_parm {
	u32 deauth_timeout_ms;
};

/*
Caller Mode: AP, Ad-HoC(M)

Notes: To create a BSS

Command Mode
*/
struct createbss_parm {
	bool adhoc;

	/* used by AP/Mesh mode now */
	u8 ifbmp;
	u8 excl_ifbmp;
	s16 req_ch;
	s8 req_bw;
	s8 req_offset;
};

#if 0
/* Caller Mode: AP, Ad-HoC, Infra */
/* Notes: To set the NIC mode of RTL8711 */
/* Command Mode */
/* The definition of mode: */

#define IW_MODE_AUTO	0	/*  Let the driver decides which AP to join */
#define IW_MODE_ADHOC	1	/*  Single cell network (Ad-Hoc Clients) */
#define IW_MODE_INFRA	2	/*  Multi cell network, roaming, .. */
#define IW_MODE_MASTER	3	/*  Synchronisation master or Access Point */
#define IW_MODE_REPEAT	4	/*  Wireless Repeater (forwarder) */
#define IW_MODE_SECOND	5	/*  Secondary master/repeater (backup) */
#define IW_MODE_MONITOR	6	/*  Passive monitor (listen only) */
#endif

struct	setopmode_parm {
	u8	mode;
	u8	rsvd[3];
};

/*
Caller Mode: AP, Ad-HoC, Infra

Notes: To ask RTL8711 performing site-survey

Command-Event Mode

*/

#define RTW_SSID_SCAN_AMOUNT 9 /* for WEXT_CSCAN_AMOUNT 9 */
#define RTW_CHANNEL_SCAN_AMOUNT (14+37)
struct sitesurvey_parm {
	sint scan_mode;	/* active: 1, passive: 0 */
	/* sint bsslimit;	// 1 ~ 48 */
	u8 ssid_num;
	u8 ch_num;
	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];

	u32 token; 	/* 80211k use it to identify caller */
	u16 duration;	/* 0: use default, otherwise: channel scan time */
	u8 igi;		/* 0: use defalut */
	u8 bw;		/* 0: use default */

	bool acs; /* aim to trigger channel selection when scan done */
};

/*
Caller Mode: Any

Notes: To set the auth type of RTL8711. open/shared/802.1x

Command Mode

*/
struct setauth_parm {
	u8 mode;  /* 0: legacy open, 1: legacy shared 2: 802.1x */
	u8 _1x;   /* 0: PSK, 1: TLS */
	u8 rsvd[2];
};

/*
Caller Mode: Infra

a. algorithm: wep40, wep104, tkip & aes
b. keytype: grp key/unicast key
c. key contents

when shared key ==> keyid is the camid
when 802.1x ==> keyid [0:1] ==> grp key
when 802.1x ==> keyid > 2 ==> unicast key

*/
struct setkey_parm {
	u8	algorithm;	/* encryption algorithm, could be none, wep40, TKIP, CCMP, wep104 */
	u8	keyid;
	u8	set_tx;		/* 1: main tx key for wep. 0: other key. */
	u8	key[16];	/* this could be 40 or 104 */
};

/*
When in AP or Ad-Hoc mode, this is used to
allocate an sw/hw entry for a newly associated sta.

Command

when shared key ==> algorithm/keyid

*/
struct set_stakey_parm {
	u8 addr[ETH_ALEN];
	u8 algorithm;
	u8 keyid;
	u8 key[16];
	u8 gk;
};

struct set_stakey_rsp {
	u8	addr[ETH_ALEN];
	u8	keyid;
	u8	rsvd;
};

/*
Caller Ad-Hoc/AP

Command -Rsp(AID == CAMID) mode

This is to force fw to add an sta_data entry per driver's request.

FW will write an cam entry associated with it.

*/
struct set_assocsta_parm {
	u8	addr[ETH_ALEN];
};

struct set_assocsta_rsp {
	u8	cam_id;
	u8	rsvd[3];
};

/*
	Caller Ad-Hoc/AP
	Command mode
	This is to force fw to del an sta_data entry per driver's request
	FW will invalidate the cam entry associated with it.
*/
struct del_assocsta_parm {
	u8	addr[ETH_ALEN];
};

/*
Caller Mode: AP/Ad-HoC(M)

Notes: To notify fw that given staid has changed its power state

Command Mode

*/
struct setstapwrstate_parm {
	u8	staid;
	u8	status;
	u8	hwaddr[6];
};

/*
Caller Mode: Any

Notes: To setup the basic rate of RTL8711

Command Mode

*/
struct	setbasicrate_parm {
	u8	basicrates[NumRates];
};

/*
Caller Mode: Any

Notes: To read the current basic rate

Command-Rsp Mode

*/
struct getbasicrate_parm {
	u32 rsvd;
};

struct getbasicrate_rsp {
	u8 basicrates[NumRates];
};

/*
Caller Mode: Any

Notes: To setup the data rate of RTL8711

Command Mode

*/
struct setdatarate_parm {
#ifdef MP_FIRMWARE_OFFLOAD
	u32	curr_rateidx;
#else
	u8	mac_id;
	u8	datarates[NumRates];
#endif
};

/*
Caller Mode: Any

Notes: To read the current data rate

Command-Rsp Mode

*/
struct getdatarate_parm {
	u32 rsvd;

};
struct getdatarate_rsp {
	u8 datarates[NumRates];
};

/*
Caller Mode: Any

Notes: To set the channel/modem/band
This command will be used when channel/modem/band is changed.

Command Mode

*/
struct	setphy_parm {
	u8	rfchannel;
	u8	modem;
};

/*
Caller Mode: Any

Notes: To get the current setting of channel/modem/band

Command-Rsp Mode

*/
struct	getphy_parm {
	u32 rsvd;

};
struct	getphy_rsp {
	u8	rfchannel;
	u8	modem;
};

struct readBB_parm {
	u8	offset;
};
struct readBB_rsp {
	u8	value;
};

struct readTSSI_parm {
	u8	offset;
};
struct readTSSI_rsp {
	u8	value;
};

struct readMAC_parm {
	u8 len;
	u32	addr;
};

struct writeBB_parm {
	u8	offset;
	u8	value;
};

struct readRF_parm {
	u8	offset;
};
struct readRF_rsp {
	u32	value;
};

struct writeRF_parm {
	u32	offset;
	u32	value;
};

struct getrfintfs_parm {
	u8	rfintfs;
};


struct Tx_Beacon_param {
	WLAN_BSSID_EX network;
};

/*
	Notes: This command is used for H2C/C2H loopback testing

	mac[0] == 0
	==> CMD mode, return H2C_SUCCESS.
	The following condition must be ture under CMD mode
		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
		s2 == (b1 << 8 | b0);

	mac[0] == 1
	==> CMD_RSP mode, return H2C_SUCCESS_RSP

	The rsp layout shall be:
	rsp:			parm:
		mac[0]  =   mac[5];
		mac[1]  =   mac[4];
		mac[2]  =   mac[3];
		mac[3]  =   mac[2];
		mac[4]  =   mac[1];
		mac[5]  =   mac[0];
		s0		=   s1;
		s1		=   swap16(s0);
		w0		=	swap32(w1);
		b0		=	b1
		s2		=	s0 + s1
		b1		=	b0
		w1		=	w0

	mac[0] ==	2
	==> CMD_EVENT mode, return	H2C_SUCCESS
	The event layout shall be:
	event:			parm:
		mac[0]  =   mac[5];
		mac[1]  =   mac[4];
		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
		mac[3]  =   mac[2];
		mac[4]  =   mac[1];
		mac[5]  =   mac[0];
		s0		=   swap16(s0) - event.mac[2];
		s1		=   s1 + event.mac[2];
		w0		=	swap32(w0);
		b0		=	b1
		s2		=	s0 + event.mac[2]
		b1		=	b0
		w1		=	swap32(w1) - event.mac[2];

		parm->mac[3] is the total event counts that host requested.


	event will be the same with the cmd's param.

*/

#ifdef CONFIG_H2CLBK

struct seth2clbk_parm {
	u8 mac[6];
	u16	s0;
	u16	s1;
	u32	w0;
	u8	b0;
	u16  s2;
	u8	b1;
	u32	w1;
};

struct geth2clbk_parm {
	u32 rsv;
};

struct geth2clbk_rsp {
	u8	mac[6];
	u16	s0;
	u16	s1;
	u32	w0;
	u8	b0;
	u16	s2;
	u8	b1;
	u32	w1;
};

#endif	/* CONFIG_H2CLBK */

/* CMD param Formart for driver extra cmd handler */
struct drvextra_cmd_parm {
	int ec_id; /* extra cmd id */
	int type; /* Can use this field as the type id or command size */
	int size; /* buffer size */
	unsigned char *pbuf;
};

/*------------------- Below are used for RF/BB tunning ---------------------*/

struct	setantenna_parm {
	u8	tx_antset;
	u8	rx_antset;
	u8	tx_antenna;
	u8	rx_antenna;
};

struct	enrateadaptive_parm {
	u32	en;
};

struct settxagctbl_parm {
	u32	txagc[MAX_RATES_LENGTH];
};

struct gettxagctbl_parm {
	u32 rsvd;
};
struct gettxagctbl_rsp {
	u32	txagc[MAX_RATES_LENGTH];
};

struct setagcctrl_parm {
	u32	agcctrl;		/* 0: pure hw, 1: fw */
};


struct setssup_parm	{
	u32	ss_ForceUp[MAX_RATES_LENGTH];
};

struct getssup_parm	{
	u32 rsvd;
};
struct getssup_rsp	{
	u8	ss_ForceUp[MAX_RATES_LENGTH];
};


struct setssdlevel_parm	{
	u8	ss_DLevel[MAX_RATES_LENGTH];
};

struct getssdlevel_parm	{
	u32 rsvd;
};
struct getssdlevel_rsp	{
	u8	ss_DLevel[MAX_RATES_LENGTH];
};

struct setssulevel_parm	{
	u8	ss_ULevel[MAX_RATES_LENGTH];
};

struct getssulevel_parm	{
	u32 rsvd;
};
struct getssulevel_rsp	{
	u8	ss_ULevel[MAX_RATES_LENGTH];
};


struct	setcountjudge_parm {
	u8	count_judge[MAX_RATES_LENGTH];
};

struct	getcountjudge_parm {
	u32 rsvd;
};
struct	getcountjudge_rsp {
	u8	count_judge[MAX_RATES_LENGTH];
};


struct setratable_parm {
	u8 ss_ForceUp[NumRates];
	u8 ss_ULevel[NumRates];
	u8 ss_DLevel[NumRates];
	u8 count_judge[NumRates];
};

struct getratable_parm {
	uint rsvd;
};
struct getratable_rsp {
	u8 ss_ForceUp[NumRates];
	u8 ss_ULevel[NumRates];
	u8 ss_DLevel[NumRates];
	u8 count_judge[NumRates];
};


/* to get TX,RX retry count */
struct gettxretrycnt_parm {
	unsigned int rsvd;
};
struct gettxretrycnt_rsp {
	unsigned long tx_retrycnt;
};

struct getrxretrycnt_parm {
	unsigned int rsvd;
};
struct getrxretrycnt_rsp {
	unsigned long rx_retrycnt;
};

/* to get BCNOK,BCNERR count */
struct getbcnokcnt_parm {
	unsigned int rsvd;
};
struct getbcnokcnt_rsp {
	unsigned long  bcnokcnt;
};

struct getbcnerrcnt_parm {
	unsigned int rsvd;
};
struct getbcnerrcnt_rsp {
	unsigned long bcnerrcnt;
};

/* to get current TX power level */
struct getcurtxpwrlevel_parm {
	unsigned int rsvd;
};
struct getcurtxpwrlevel_rsp {
	unsigned short tx_power;
};

struct setprobereqextraie_parm {
	unsigned char e_id;
	unsigned char ie_len;
	unsigned char ie[0];
};

struct setassocreqextraie_parm {
	unsigned char e_id;
	unsigned char ie_len;
	unsigned char ie[0];
};

struct setproberspextraie_parm {
	unsigned char e_id;
	unsigned char ie_len;
	unsigned char ie[0];
};

struct setassocrspextraie_parm {
	unsigned char e_id;
	unsigned char ie_len;
	unsigned char ie[0];
};


struct addBaReq_parm {
	unsigned int tid;
	u8	addr[ETH_ALEN];
};

struct addBaRsp_parm {
	unsigned int tid;
	unsigned int start_seq;
	u8 addr[ETH_ALEN];
	u8 status;
	u8 size;
};

/*H2C Handler index: 46 */
struct set_ch_parm {
	u8 ch;
	u8 bw;
	u8 ch_offset;
};

#ifdef MP_FIRMWARE_OFFLOAD
/*H2C Handler index: 47 */
struct SetTxPower_parm {
	u8 TxPower;
};

/*H2C Handler index: 48 */
struct SwitchAntenna_parm {
	u16 antenna_tx;
	u16 antenna_rx;
	/*	R_ANTENNA_SELECT_CCK cck_txrx; */
	u8 cck_txrx;
};

/*H2C Handler index: 49 */
struct SetCrystalCap_parm {
	u32 curr_crystalcap;
};

/*H2C Handler index: 50 */
struct SetSingleCarrierTx_parm {
	u8 bStart;
};

/*H2C Handler index: 51 */
struct SetSingleToneTx_parm {
	u8 bStart;
	u8 curr_rfpath;
};

/*H2C Handler index: 52 */
struct SetCarrierSuppressionTx_parm {
	u8 bStart;
	u32 curr_rateidx;
};

/*H2C Handler index: 53 */
struct SetContinuousTx_parm {
	u8 bStart;
	u8 CCK_flag; /*1:CCK 2:OFDM*/
	u32 curr_rateidx;
};

/*H2C Handler index: 54 */
struct SwitchBandwidth_parm {
	u8 curr_bandwidth;
};

#endif	/* MP_FIRMWARE_OFFLOAD */

/*H2C Handler index: 59 */
struct SetChannelPlan_param {
	const struct country_chplan *country_ent;
	u8 channel_plan;
};

/*H2C Handler index: 60 */
struct LedBlink_param {
	void *pLed;
};

/*H2C Handler index: 62 */
struct TDLSoption_param {
	u8 addr[ETH_ALEN];
	u8 option;
};

/*H2C Handler index: 64 */
struct RunInThread_param {
	void (*func)(void *);
	void *context;
};


#define GEN_CMD_CODE(cmd)	cmd ## _CMD_


/*

Result:
0x00: success
0x01: sucess, and check Response.
0x02: cmd ignored due to duplicated sequcne number
0x03: cmd dropped due to invalid cmd code
0x04: reserved.

*/

#define H2C_RSP_OFFSET			512

#define H2C_SUCCESS			0x00
#define H2C_SUCCESS_RSP			0x01
#define H2C_DUPLICATED			0x02
#define H2C_DROPPED			0x03
#define H2C_PARAMETERS_ERROR		0x04
#define H2C_REJECTED			0x05
#define H2C_CMD_OVERFLOW		0x06
#define H2C_RESERVED			0x07
#define H2C_ENQ_HEAD			0x08
#define H2C_ENQ_HEAD_FAIL		0x09
#define H2C_CMD_FAIL			0x0A

extern u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
extern u8 rtw_setstandby_cmd(_adapter *padapter, uint action);
void rtw_init_sitesurvey_parm(_adapter *padapter, struct sitesurvey_parm *pparm);
u8 rtw_sitesurvey_cmd(_adapter *padapter, struct sitesurvey_parm *pparm);
u8 rtw_create_ibss_cmd(_adapter *adapter, int flags);
u8 rtw_startbss_cmd(_adapter *adapter, int flags);

#define REQ_CH_NONE		-1
#define REQ_CH_INT_INFO	-2
#define REQ_BW_NONE		-1
#define REQ_BW_ORI		-2
#define REQ_OFFSET_NONE	-1

u8 rtw_change_bss_chbw_cmd(_adapter *adapter, int flags
	, u8 ifbmp, u8 excl_ifbmp, s16 req_ch, s8 req_bw, s8 req_offset);

extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);

struct sta_info;
extern u8 rtw_setstakey_cmd(_adapter  *padapter, struct sta_info *sta, u8 key_type, bool enqueue);
extern u8 rtw_clearstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 enqueue);

extern u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network *pnetwork);
u8 rtw_disassoc_cmd(_adapter *padapter, u32 deauth_timeout_ms, int flags);
#ifdef CONFIG_AP_MODE
u8 rtw_stop_ap_cmd(_adapter *adapter, u8 flags);
#endif
extern u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype, u8 flags);
extern u8 rtw_setdatarate_cmd(_adapter  *padapter, u8 *rateset);
extern u8 rtw_setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
extern u8 rtw_getmacreg_cmd(_adapter *padapter, u8 len, u32 addr);
extern void rtw_usb_catc_trigger_cmd(_adapter *padapter, const char *caller);
extern u8 rtw_setbbreg_cmd(_adapter *padapter, u8 offset, u8 val);
extern u8 rtw_setrfreg_cmd(_adapter *padapter, u8 offset, u32 val);
extern u8 rtw_getbbreg_cmd(_adapter *padapter, u8 offset, u8 *pval);
extern u8 rtw_getrfreg_cmd(_adapter *padapter, u8 offset, u8 *pval);
extern u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode);
extern u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
extern u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);

extern u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset, u8 *pval);
extern u8 rtw_setfwdig_cmd(_adapter *padapter, u8 type);
extern u8 rtw_setfwra_cmd(_adapter *padapter, u8 type);

extern u8 rtw_addbareq_cmd(_adapter *padapter, u8 tid, u8 *addr);
extern u8 rtw_addbarsp_cmd(_adapter *padapter, u8 *addr, u16 tid, u8 status, u8 size, u16 start_seq);
/* add for CONFIG_IEEE80211W, none 11w also can use */
extern u8 rtw_reset_securitypriv_cmd(_adapter *padapter);
extern u8 rtw_free_assoc_resources_cmd(_adapter *padapter, u8 lock_scanned_queue, int flags);
extern u8 rtw_dynamic_chk_wk_cmd(_adapter *adapter);

u8 rtw_lps_ctrl_wk_cmd(_adapter *padapter, u8 lps_ctrl_type, u8 flags);
u8 rtw_lps_ctrl_leave_set_level_cmd(_adapter *adapter, u8 lps_level, u8 flags);
#ifdef CONFIG_LPS_1T1R
u8 rtw_lps_ctrl_leave_set_1t1r_cmd(_adapter *adapter, u8 lps_1t1r, u8 flags);
#endif
u8 rtw_dm_in_lps_wk_cmd(_adapter *padapter);
u8 rtw_lps_change_dtim_cmd(_adapter *padapter, u8 dtim);

#if (RATE_ADAPTIVE_SUPPORT == 1)
u8 rtw_rpt_timer_cfg_cmd(_adapter *padapter, u16 minRptTime);
#endif

#ifdef CONFIG_ANTENNA_DIVERSITY
extern  u8 rtw_antenna_select_cmd(_adapter *padapter, u8 antenna, u8 enqueue);
#endif

u8 rtw_dm_ra_mask_wk_cmd(_adapter *padapter, u8 *psta);

extern u8 rtw_ps_cmd(_adapter *padapter);

#if CONFIG_DFS
void rtw_dfs_ch_switch_hdl(struct dvobj_priv *dvobj);
#endif

#ifdef CONFIG_AP_MODE
u8 rtw_chk_hi_queue_cmd(_adapter *padapter);
#ifdef CONFIG_DFS_MASTER
u8 rtw_dfs_rd_cmd(_adapter *adapter, bool enqueue);
void rtw_dfs_rd_timer_hdl(void *ctx);
void rtw_dfs_rd_en_decision(_adapter *adapter, u8 mlme_act, u8 excl_ifbmp);
u8 rtw_dfs_rd_en_decision_cmd(_adapter *adapter);
#endif /* CONFIG_DFS_MASTER */
#endif /* CONFIG_AP_MODE */

#ifdef CONFIG_BT_COEXIST
u8 rtw_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
u8 rtw_btc_reduce_wl_txpwr_cmd(_adapter *adapter, u32 val);
#endif

u8 rtw_test_h2c_cmd(_adapter *adapter, u8 *buf, u8 len);

u8 rtw_enable_hw_update_tsf_cmd(_adapter *padapter);
u8 rtw_periodic_tsf_update_end_cmd(_adapter *adapter);

u8 rtw_set_chbw_cmd(_adapter *padapter, u8 ch, u8 bw, u8 ch_offset, u8 flags);

u8 rtw_set_chplan_cmd(_adapter *adapter, int flags, u8 chplan, u8 swconfig);
u8 rtw_set_country_cmd(_adapter *adapter, int flags, const char *country_code, u8 swconfig);

extern u8 rtw_led_blink_cmd(_adapter *padapter, void *pLed);
extern u8 rtw_set_csa_cmd(_adapter *adapter);
extern u8 rtw_tdls_cmd(_adapter *padapter, u8 *addr, u8 option);

u8 rtw_mp_cmd(_adapter *adapter, u8 mp_cmd_id, u8 flags);

#ifdef CONFIG_RTW_CUSTOMER_STR
u8 rtw_customer_str_req_cmd(_adapter *adapter);
u8 rtw_customer_str_write_cmd(_adapter *adapter, const u8 *cstr);
#endif

#ifdef CONFIG_FW_C2H_REG
u8 rtw_c2h_reg_wk_cmd(_adapter *adapter, u8 *c2h_evt);
#endif
#ifdef CONFIG_FW_C2H_PKT
u8 rtw_c2h_packet_wk_cmd(_adapter *adapter, u8 *c2h_evt, u16 length);
#endif

#ifdef CONFIG_RTW_REPEATER_SON
#define RSON_SCAN_PROCESS		10
#define RSON_SCAN_DISABLE		11
u8 rtw_rson_scan_wk_cmd(_adapter *adapter, int op);
#endif

u8 rtw_run_in_thread_cmd(_adapter *adapter, void (*func)(void *), void *context);
u8 rtw_run_in_thread_cmd_wait(_adapter *adapter, void (*func)(void *), void *context, s32 timeout_ms);

struct ssmps_cmd_parm {
	struct sta_info *sta;
	u8 smps;
};
u8 rtw_ssmps_wk_cmd(_adapter *adapter, struct sta_info *sta, u8 smps, u8 enqueue);

u8 session_tracker_chk_cmd(_adapter *adapter, struct sta_info *sta);
u8 session_tracker_add_cmd(_adapter *adapter, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
u8 session_tracker_del_cmd(_adapter *adapter, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);

u8 set_txq_params_cmd(_adapter *adapter, u32 ac_parm, u8 ac_type);

#if defined(CONFIG_RTW_MESH) && defined(RTW_PER_CMD_SUPPORT_FW)
u8 rtw_req_per_cmd(_adapter * adapter);
#endif

#ifdef CONFIG_CTRL_TXSS_BY_TP
struct txss_cmd_parm {
	struct sta_info *sta;
	bool tx_1ss;
};

void rtw_ctrl_txss_update_mimo_type(_adapter *adapter, struct sta_info *sta);
u8 rtw_ctrl_txss(_adapter *adapter, struct sta_info *sta, bool tx_1ss);
void rtw_ctrl_tx_ss_by_tp(_adapter *adapter, u8 from_timer);

#ifdef DBG_CTRL_TXSS
void dbg_ctrl_txss(_adapter *adapter, bool tx_1ss);
#endif
#endif

u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf);

extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
extern void rtw_disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
void rtw_create_ibss_post_hdl(_adapter *padapter, int status);
extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
extern void rtw_readtssi_cmdrsp_callback(_adapter	*padapter,  struct cmd_obj *pcmd);

extern void rtw_setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
extern void rtw_setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
extern void rtw_getrttbl_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
extern void rtw_getmacreg_cmdrsp_callback(_adapter *padapter,  struct cmd_obj *pcmd);


struct _cmd_callback {
	u32	cmd_code;
	void (*callback)(_adapter  *padapter, struct cmd_obj *cmd);
};

enum rtw_h2c_cmd {
	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
	GEN_CMD_CODE(_Write_MACREG) ,
	GEN_CMD_CODE(_Read_BBREG) ,
	GEN_CMD_CODE(_Write_BBREG) ,
	GEN_CMD_CODE(_Read_RFREG) ,
	GEN_CMD_CODE(_Write_RFREG) , /*5*/
	GEN_CMD_CODE(_Read_EEPROM) ,
	GEN_CMD_CODE(_Write_EEPROM) ,
	GEN_CMD_CODE(_Read_EFUSE) ,
	GEN_CMD_CODE(_Write_EFUSE) ,

	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
	GEN_CMD_CODE(_Write_CAM) ,
	GEN_CMD_CODE(_setBCNITV),
	GEN_CMD_CODE(_setMBIDCFG),
	GEN_CMD_CODE(_JoinBss),   /*14*/
	GEN_CMD_CODE(_DisConnect) , /*15*/
	GEN_CMD_CODE(_CreateBss) ,
	GEN_CMD_CODE(_SetOpMode) ,
	GEN_CMD_CODE(_SiteSurvey),  /*18*/
	GEN_CMD_CODE(_SetAuth) ,

	GEN_CMD_CODE(_SetKey) ,	/*20*/
	GEN_CMD_CODE(_SetStaKey) ,
	GEN_CMD_CODE(_SetAssocSta) ,
	GEN_CMD_CODE(_DelAssocSta) ,
	GEN_CMD_CODE(_SetStaPwrState) ,
	GEN_CMD_CODE(_SetBasicRate) , /*25*/
	GEN_CMD_CODE(_GetBasicRate) ,
	GEN_CMD_CODE(_SetDataRate) ,
	GEN_CMD_CODE(_GetDataRate) ,
	GEN_CMD_CODE(_SetPhyInfo) ,

	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
	GEN_CMD_CODE(_SetPhy) ,
	GEN_CMD_CODE(_GetPhy) ,
	GEN_CMD_CODE(_readRssi) ,
	GEN_CMD_CODE(_readGain) ,
	GEN_CMD_CODE(_SetAtim) , /*35*/
	GEN_CMD_CODE(_SetPwrMode) ,
	GEN_CMD_CODE(_JoinbssRpt),
	GEN_CMD_CODE(_SetRaTable) ,
	GEN_CMD_CODE(_GetRaTable) ,

	GEN_CMD_CODE(_GetCCXReport), /*40*/
	GEN_CMD_CODE(_GetDTMReport),
	GEN_CMD_CODE(_GetTXRateStatistics),
	GEN_CMD_CODE(_SetUsbSuspend),
	GEN_CMD_CODE(_SetH2cLbk),
	GEN_CMD_CODE(_AddBAReq) , /*45*/
	GEN_CMD_CODE(_SetChannel), /*46*/
	GEN_CMD_CODE(_SetTxPower),
	GEN_CMD_CODE(_SwitchAntenna),
	GEN_CMD_CODE(_SetCrystalCap),
	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/

	GEN_CMD_CODE(_SetSingleToneTx),/*51*/
	GEN_CMD_CODE(_SetCarrierSuppressionTx),
	GEN_CMD_CODE(_SetContinuousTx),
	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
	GEN_CMD_CODE(_TX_Beacon), /*55*/

	GEN_CMD_CODE(_Set_MLME_EVT), /*56*/
	GEN_CMD_CODE(_Set_Drv_Extra), /*57*/
	GEN_CMD_CODE(_Set_H2C_MSG), /*58*/

	GEN_CMD_CODE(_SetChannelPlan), /*59*/
	GEN_CMD_CODE(_LedBlink), /*60*/

	GEN_CMD_CODE(_SetChannelSwitch), /*61*/
	GEN_CMD_CODE(_TDLS), /*62*/
	GEN_CMD_CODE(_ChkBMCSleepq), /*63*/

	GEN_CMD_CODE(_RunInThreadCMD), /*64*/
	GEN_CMD_CODE(_AddBARsp) , /*65*/
	GEN_CMD_CODE(_RM_POST_EVENT), /*66*/

	MAX_H2CCMD
};

#define _GetMACReg_CMD_ _Read_MACREG_CMD_
#define _SetMACReg_CMD_ _Write_MACREG_CMD_
#define _GetBBReg_CMD_		_Read_BBREG_CMD_
#define _SetBBReg_CMD_		_Write_BBREG_CMD_
#define _GetRFReg_CMD_		_Read_RFREG_CMD_
#define _SetRFReg_CMD_		_Write_RFREG_CMD_

#ifdef _RTW_CMD_C_
struct _cmd_callback	rtw_cmd_callback[] = {
	{GEN_CMD_CODE(_Read_MACREG), &rtw_getmacreg_cmdrsp_callback}, /*0*/
	{GEN_CMD_CODE(_Write_MACREG), NULL},
	{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
	{GEN_CMD_CODE(_Write_BBREG), NULL},
	{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
	{GEN_CMD_CODE(_Read_EEPROM), NULL},
	{GEN_CMD_CODE(_Write_EEPROM), NULL},
	{GEN_CMD_CODE(_Read_EFUSE), NULL},
	{GEN_CMD_CODE(_Write_EFUSE), NULL},

	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
	{GEN_CMD_CODE(_Write_CAM),	 NULL},
	{GEN_CMD_CODE(_setBCNITV), NULL},
	{GEN_CMD_CODE(_setMBIDCFG), NULL},
	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
	{GEN_CMD_CODE(_CreateBss), NULL},
	{GEN_CMD_CODE(_SetOpMode), NULL},
	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback}, /*18*/
	{GEN_CMD_CODE(_SetAuth), NULL},

	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},
	{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},
	{GEN_CMD_CODE(_DelAssocSta), NULL},
	{GEN_CMD_CODE(_SetStaPwrState), NULL},
	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
	{GEN_CMD_CODE(_GetBasicRate), NULL},
	{GEN_CMD_CODE(_SetDataRate), NULL},
	{GEN_CMD_CODE(_GetDataRate), NULL},
	{GEN_CMD_CODE(_SetPhyInfo), NULL},

	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
	{GEN_CMD_CODE(_SetPhy), NULL},
	{GEN_CMD_CODE(_GetPhy), NULL},
	{GEN_CMD_CODE(_readRssi), NULL},
	{GEN_CMD_CODE(_readGain), NULL},
	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
	{GEN_CMD_CODE(_SetPwrMode), NULL},
	{GEN_CMD_CODE(_JoinbssRpt), NULL},
	{GEN_CMD_CODE(_SetRaTable), NULL},
	{GEN_CMD_CODE(_GetRaTable) , NULL},

	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
	{GEN_CMD_CODE(_GetDTMReport),	NULL},
	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
	{GEN_CMD_CODE(_SetH2cLbk), NULL},
	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
	{GEN_CMD_CODE(_SetTxPower), NULL},
	{GEN_CMD_CODE(_SwitchAntenna), NULL},
	{GEN_CMD_CODE(_SetCrystalCap), NULL},
	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/

	{GEN_CMD_CODE(_SetSingleToneTx), NULL}, /*51*/
	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
	{GEN_CMD_CODE(_SetContinuousTx), NULL},
	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
	{GEN_CMD_CODE(_TX_Beacon), NULL},/*55*/

	{GEN_CMD_CODE(_Set_MLME_EVT), NULL},/*56*/
	{GEN_CMD_CODE(_Set_Drv_Extra), NULL},/*57*/
	{GEN_CMD_CODE(_Set_H2C_MSG), NULL},/*58*/
	{GEN_CMD_CODE(_SetChannelPlan), NULL},/*59*/
	{GEN_CMD_CODE(_LedBlink), NULL},/*60*/

	{GEN_CMD_CODE(_SetChannelSwitch), NULL},/*61*/
	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
	{GEN_CMD_CODE(_ChkBMCSleepq), NULL}, /*63*/

	{GEN_CMD_CODE(_RunInThreadCMD), NULL},/*64*/
	{GEN_CMD_CODE(_AddBARsp), NULL}, /*65*/
	{GEN_CMD_CODE(_RM_POST_EVENT), NULL}, /*66*/
};
#endif

#define CMD_FMT "cmd=%d,%d,%d"
#define CMD_ARG(cmd) \
	(cmd)->cmdcode, \
	(cmd)->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ? ((struct drvextra_cmd_parm *)(cmd)->parmbuf)->ec_id : ((cmd)->cmdcode == GEN_CMD_CODE(_Set_MLME_EVT) ? ((struct C2HEvent_Header *)(cmd)->parmbuf)->ID : 0), \
	(cmd)->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ? ((struct drvextra_cmd_parm *)(cmd)->parmbuf)->type : 0

#endif /* _CMD_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/Hal8710BPwrSeq.h                                                              0000644 0001750 0001750 00000027612 14214766567 016075  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8710B
#define REALTEK_POWER_SEQUENCE_8710B

/* #include "PwrSeqCmd.h" */
#include "HalPwrSeqCmd.h"

/*
	Check document WM-20110607-Paul-RTL8192e_Power_Architecture-R02.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transition from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define RTL8710B_TRANS_CARDEMU_TO_ACT_STEPS 5
#define RTL8710B_TRANS_ACT_TO_CARDEMU_STEPS 4
#define RTL8710B_TRANS_CARDEMU_TO_SUS_STEPS 7
#define RTL8710B_TRANS_SUS_TO_CARDEMU_STEPS 15
#define RTL8710B_TRANS_CARDEMU_TO_PDN_STEPS 15
#define RTL8710B_TRANS_PDN_TO_CARDEMU_STEPS 15
#define RTL8710B_TRANS_ACT_TO_LPS_STEPS 	15
#define RTL8710B_TRANS_LPS_TO_ACT_STEPS 	15	
#define RTL8710B_TRANS_ACT_TO_SWLPS_STEPS		22
#define RTL8710B_TRANS_SWLPS_TO_ACT_STEPS		15
#define RTL8710B_TRANS_END_STEPS		1


#define RTL8710B_TRANS_CARDEMU_TO_ACT 														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x005D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*AFE power mode selection:1:  LDO mode ,0:  Power-cut mode*/\
	{0x0004, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1},\
	{0x0056, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x0E},\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1},\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/ 

	
#define RTL8710B_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, */ /*0x1F[7:0] = 0 turn off RF*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT0|BIT1|BIT2), 0},/*0x04[24:26] = 0 turn off RF*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT0|BIT1), 0},/*0x04[16:17] = 0 BB reset*/	\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x20[1] = 1 turn off MAC by HW state machine*/	\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x20[1] = 0 polling until return 0 to disable*/ \


#define RTL8710B_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8710B_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
	

#define RTL8710B_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\

#define RTL8710B_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\


#define RTL8710B_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8710B_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8710B_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/ \
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	


#define RTL8710B_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0 	 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
 
#define RTL8710B_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //


extern WLAN_PWR_CFG rtl8710B_power_on_flow[RTL8710B_TRANS_CARDEMU_TO_ACT_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_radio_off_flow[RTL8710B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_card_disable_flow[RTL8710B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8710B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_card_enable_flow[RTL8710B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8710B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_suspend_flow[RTL8710B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8710B_TRANS_CARDEMU_TO_SUS_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_resume_flow[RTL8710B_TRANS_SUS_TO_CARDEMU_STEPS+RTL8710B_TRANS_CARDEMU_TO_ACT_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_hwpdn_flow[RTL8710B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8710B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_enter_lps_flow[RTL8710B_TRANS_ACT_TO_LPS_STEPS+RTL8710B_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8710B_leave_lps_flow[RTL8710B_TRANS_LPS_TO_ACT_STEPS+RTL8710B_TRANS_END_STEPS];

#endif
                                                                                                                      rtl8822bu/src/include/Hal8723PwrSeq.h                                                               0000644 0001750 0001750 00000036670 14214766567 016003  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL8723PWRSEQ_H__
#define __HAL8723PWRSEQ_H__
/*
	Check document WM-20110607-Paul-RTL8723A_Power_Architecture-R02.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#include "HalPwrSeqCmd.h"

#define	RTL8723A_TRANS_CARDEMU_TO_ACT_STEPS	15
#define	RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS	15
#define	RTL8723A_TRANS_CARDEMU_TO_SUS_STEPS	15
#define	RTL8723A_TRANS_SUS_TO_CARDEMU_STEPS	15
#define	RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS	15
#define	RTL8723A_TRANS_PDN_TO_CARDEMU_STEPS	15
#define	RTL8723A_TRANS_ACT_TO_LPS_STEPS	15
#define	RTL8723A_TRANS_LPS_TO_ACT_STEPS	15
#define	RTL8723A_TRANS_END_STEPS	1


#define RTL8723A_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3), 0},/* disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	\
	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 1},/*0x4C[23] = 0x4E[7] = 1, switch DPDT_SEL_P output from WL BB */\

#define RTL8723A_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/   \


#define RTL8723A_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, (BIT4 | BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8723A_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8723A_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8723A_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/


#define RTL8723A_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK | PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8723A_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8723A_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8723A_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8723A_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8723A_power_on_flow[RTL8723A_TRANS_CARDEMU_TO_ACT_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_radio_off_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_card_disable_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_card_enable_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_suspend_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723A_TRANS_CARDEMU_TO_SUS_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_resume_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723A_TRANS_CARDEMU_TO_SUS_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_hwpdn_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_enter_lps_flow[RTL8723A_TRANS_ACT_TO_LPS_STEPS + RTL8723A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723A_leave_lps_flow[RTL8723A_TRANS_LPS_TO_ACT_STEPS + RTL8723A_TRANS_END_STEPS];

#endif
                                                                        rtl8822bu/src/include/Hal8814PhyReg.h                                                               0000644 0001750 0001750 00000073502 14214766567 015754  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8814PHYREG_H__
#define __INC_HAL8814PHYREG_H__
/*--------------------------Define Parameters-------------------------------*/
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/* BB Register Definition */

#define rCCAonSec_Jaguar		0x838
#define rPwed_TH_Jaguar			0x830
#define rL1_Weight_Jaguar		0x840
#define	r_L1_SBD_start_time		0x844

/* BW and sideband setting */
#define rBWIndication_Jaguar		0x834
#define rL1PeakTH_Jaguar		0x848
#define rRFMOD_Jaguar			0x8ac	/* RF mode */
#define rADC_Buf_Clk_Jaguar		0x8c4
#define	rADC_Buf_40_Clk_Jaguar2		0x8c8
#define rRFECTRL_Jaguar			0x900
#define bRFMOD_Jaguar			0xc3
#define rCCK_System_Jaguar		0xa00   /* for cck sideband */
#define bCCK_System_Jaguar		0x10

/* Block & Path enable */
#define rOFDMCCKEN_Jaguar 		0x808 /* OFDM/CCK block enable */
#define bOFDMEN_Jaguar			0x20000000
#define bCCKEN_Jaguar			0x10000000
#define rRxPath_Jaguar			0x808	/* Rx antenna */
#define bRxPath_Jaguar			0xff
#define rTxPath_Jaguar			0x80c	/* Tx antenna */
#define bTxPath_Jaguar			0x0fffffff
#define rCCK_RX_Jaguar			0xa04	/* for cck rx path selection */
#define bCCK_RX_Jaguar			0x0c000000
#define rVhtlen_Use_Lsig_Jaguar	0x8c3	/* Use LSIG for VHT length */

#define	rRxPath_Jaguar2				0xa04	/* Rx antenna */
#define	rTxAnt_1Nsts_Jaguar2		0x93c	/* Tx antenna for 1Nsts */
#define	rTxAnt_23Nsts_Jaguar2		0x940	/* Tx antenna for 2Nsts and 3Nsts */


/* RF read/write-related */
#define rHSSIRead_Jaguar			0x8b0  /* RF read addr */
#define bHSSIRead_addr_Jaguar		0xff
#define bHSSIRead_trigger_Jaguar	0x100
#define rA_PIRead_Jaguar			0xd04 /* RF readback with PI */
#define rB_PIRead_Jaguar			0xd44 /* RF readback with PI */
#define rA_SIRead_Jaguar			0xd08 /* RF readback with SI */
#define rB_SIRead_Jaguar			0xd48 /* RF readback with SI */
#define rRead_data_Jaguar			0xfffff
#define rA_LSSIWrite_Jaguar			0xc90 /* RF write addr */
#define rB_LSSIWrite_Jaguar			0xe90 /* RF write addr */
#define bLSSIWrite_data_Jaguar		0x000fffff
#define bLSSIWrite_addr_Jaguar		0x0ff00000

#define	rC_PIRead_Jaguar2			0xd84 /* RF readback with PI */
#define	rD_PIRead_Jaguar2			0xdC4 /* RF readback with PI */
#define	rC_SIRead_Jaguar2			0xd88 /* RF readback with SI */
#define	rD_SIRead_Jaguar2			0xdC8 /* RF readback with SI */
#define	rC_LSSIWrite_Jaguar2		0x1890 /* RF write addr */
#define	rD_LSSIWrite_Jaguar2		0x1A90 /* RF write addr */


/* YN: mask the following register definition temporarily */
#define rFPGA0_XA_RFInterfaceOE			0x860	/* RF Channel switch */
#define rFPGA0_XB_RFInterfaceOE			0x864

#define rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define rFPGA0_XCD_RFInterfaceSW		0x874

/* #define rFPGA0_XAB_RFParameter		0x878 */	/* RF Parameter
 * #define rFPGA0_XCD_RFParameter		0x87c */

/* #define rFPGA0_AnalogParameter1		0x880 */	/* Crystal cap setting RF-R/W protection for parameter4??
 * #define rFPGA0_AnalogParameter2		0x884
 * #define rFPGA0_AnalogParameter3		0x888
 * #define rFPGA0_AdDaClockEn			0x888 */	/* enable ad/da clock1 for dual-phy
 * #define rFPGA0_AnalogParameter4		0x88c */


/* CCK TX scaling */
#define rCCK_TxFilter1_Jaguar		0xa20
#define bCCK_TxFilter1_C0_Jaguar	0x00ff0000
#define bCCK_TxFilter1_C1_Jaguar		0xff000000
#define rCCK_TxFilter2_Jaguar		0xa24
#define bCCK_TxFilter2_C2_Jaguar		0x000000ff
#define bCCK_TxFilter2_C3_Jaguar		0x0000ff00
#define bCCK_TxFilter2_C4_Jaguar		0x00ff0000
#define bCCK_TxFilter2_C5_Jaguar		0xff000000
#define rCCK_TxFilter3_Jaguar		0xa28
#define bCCK_TxFilter3_C6_Jaguar		0x000000ff
#define bCCK_TxFilter3_C7_Jaguar		0x0000ff00
/* NBI & CSI Mask setting */
#define	rCSI_Mask_Setting1_Jaguar	0x874
#define	rCSI_Fix_Mask0_Jaguar		0x880
#define	rCSI_Fix_Mask1_Jaguar		0x884
#define	rCSI_Fix_Mask2_Jaguar		0x888
#define	rCSI_Fix_Mask3_Jaguar		0x88c
#define	rCSI_Fix_Mask4_Jaguar		0x890
#define	rCSI_Fix_Mask5_Jaguar		0x894
#define	rCSI_Fix_Mask6_Jaguar		0x898
#define	rCSI_Fix_Mask7_Jaguar		0x89c
#define	rNBI_Setting_Jaguar			0x87c


/* YN: mask the following register definition temporarily
 * #define rPdp_AntA					0xb00
 * #define rPdp_AntA_4				0xb04
 * #define rConfig_Pmpd_AntA			0xb28
 * #define rConfig_AntA					0xb68
 * #define rConfig_AntB					0xb6c
 * #define rPdp_AntB					0xb70
 * #define rPdp_AntB_4					0xb74
 * #define rConfig_Pmpd_AntB			0xb98
 * #define rAPK							0xbd8 */

/* RXIQC */
#define rA_RxIQC_AB_Jaguar    	0xc10  /* RxIQ imblance matrix coeff. A & B */
#define rA_RxIQC_CD_Jaguar    	0xc14  /* RxIQ imblance matrix coeff. C & D */
#define rA_TxScale_Jaguar 		0xc1c  /* Pah_A TX scaling factor */
#define rB_TxScale_Jaguar 		0xe1c  /* Path_B TX scaling factor */
#define rB_RxIQC_AB_Jaguar    	0xe10  /* RxIQ imblance matrix coeff. A & B */
#define rB_RxIQC_CD_Jaguar    	0xe14  /* RxIQ imblance matrix coeff. C & D */
#define b_RxIQC_AC_Jaguar		0x02ff  /* bit mask for IQC matrix element A & C */
#define b_RxIQC_BD_Jaguar		0x02ff0000 /* bit mask for IQC matrix element A & C */

#define	rC_TxScale_Jaguar2 		0x181c  /* Pah_C TX scaling factor */
#define	rD_TxScale_Jaguar2 		0x1A1c  /* Path_D TX scaling factor */
#define	rRF_TxGainOffset		0x55

/* DIG-related */
#define rA_IGI_Jaguar				0xc50	/* Initial Gain for path-A */
#define rB_IGI_Jaguar				0xe50	/* Initial Gain for path-B */
#define	rC_IGI_Jaguar2				0x1850	/* Initial Gain for path-C */
#define	rD_IGI_Jaguar2				0x1A50	/* Initial Gain for path-D */

#define rOFDM_FalseAlarm1_Jaguar	0xf48  /* counter for break */
#define rOFDM_FalseAlarm2_Jaguar	0xf4c  /* counter for spoofing */
#define rCCK_FalseAlarm_Jaguar        	0xa5c /* counter for cck false alarm */
#define b_FalseAlarm_Jaguar			0xffff
#define rCCK_CCA_Jaguar				0xa08	/* cca threshold */
#define bCCK_CCA_Jaguar				0x00ff0000

/* Tx Power Ttraining-related */
#define rA_TxPwrTraing_Jaguar		0xc54
#define rB_TxPwrTraing_Jaguar		0xe54

/* Report-related */
#define rOFDM_ShortCFOAB_Jaguar	0xf60
#define rOFDM_LongCFOAB_Jaguar		0xf64
#define rOFDM_EndCFOAB_Jaguar		0xf70
#define rOFDM_AGCReport_Jaguar		0xf84
#define rOFDM_RxSNR_Jaguar			0xf88
#define rOFDM_RxEVMCSI_Jaguar		0xf8c
#define rOFDM_SIGReport_Jaguar		0xf90

/* Misc functions */
#define rEDCCA_Jaguar				0x8a4 /* EDCCA */
#define bEDCCA_Jaguar				0xffff
#define rAGC_table_Jaguar			0x82c   /* AGC tabel select */
#define bAGC_table_Jaguar			0x3
#define b_sel5g_Jaguar    				0x1000 /* sel5g */
#define b_LNA_sw_Jaguar				0x8000 /* HW/WS control for LNA */
#define rFc_area_Jaguar				0x860   /* fc_area */
#define bFc_area_Jaguar				0x1ffe000
#define rSingleTone_ContTx_Jaguar	0x914

#define	rAGC_table_Jaguar2			0x958	/* AGC tabel select */
#define	rDMA_trigger_Jaguar2		0x95C	/* ADC sample mode */


/* RFE */
#define rA_RFE_Pinmux_Jaguar	0xcb0  /* Path_A RFE cotrol pinmux */
#define rB_RFE_Pinmux_Jaguar	0xeb0 /* Path_B RFE control pinmux */
#define rA_RFE_Inv_Jaguar		0xcb4  /* Path_A RFE cotrol   */
#define rB_RFE_Inv_Jaguar		0xeb4 /* Path_B RFE control */
#define rA_RFE_Jaguar			0xcb8  /* Path_A RFE cotrol   */
#define rB_RFE_Jaguar			0xeb8 /* Path_B RFE control */
#define	rA_RFE_Inverse_Jaguar	0xCBC	/* Path_A RFE control inverse */
#define	rB_RFE_Inverse_Jaguar	0xEBC	/* Path_B RFE control inverse */
#define r_ANTSEL_SW_Jaguar		0x900 /* ANTSEL SW Control */
#define bMask_RFEInv_Jaguar		0x3ff00000
#define bMask_AntselPathFollow_Jaguar 0x00030000

#define	rC_RFE_Pinmux_Jaguar	0x18B4	/* Path_C RFE cotrol pinmux */
#define	rD_RFE_Pinmux_Jaguar	0x1AB4	/* Path_D RFE cotrol pinmux */
#define	rA_RFE_Sel_Jaguar2		0x1990



/* TX AGC */
#define rTxAGC_A_CCK11_CCK1_JAguar				0xc20
#define rTxAGC_A_Ofdm18_Ofdm6_JAguar				0xc24
#define rTxAGC_A_Ofdm54_Ofdm24_JAguar			0xc28
#define rTxAGC_A_MCS3_MCS0_JAguar					0xc2c
#define rTxAGC_A_MCS7_MCS4_JAguar					0xc30
#define rTxAGC_A_MCS11_MCS8_JAguar				0xc34
#define rTxAGC_A_MCS15_MCS12_JAguar				0xc38
#define rTxAGC_A_Nss1Index3_Nss1Index0_JAguar	0xc3c
#define rTxAGC_A_Nss1Index7_Nss1Index4_JAguar	0xc40
#define rTxAGC_A_Nss2Index1_Nss1Index8_JAguar	0xc44
#define rTxAGC_A_Nss2Index5_Nss2Index2_JAguar	0xc48
#define rTxAGC_A_Nss2Index9_Nss2Index6_JAguar	0xc4c
#define rTxAGC_B_CCK11_CCK1_JAguar				0xe20
#define rTxAGC_B_Ofdm18_Ofdm6_JAguar				0xe24
#define rTxAGC_B_Ofdm54_Ofdm24_JAguar			0xe28
#define rTxAGC_B_MCS3_MCS0_JAguar					0xe2c
#define rTxAGC_B_MCS7_MCS4_JAguar					0xe30
#define rTxAGC_B_MCS11_MCS8_JAguar				0xe34
#define rTxAGC_B_MCS15_MCS12_JAguar				0xe38
#define rTxAGC_B_Nss1Index3_Nss1Index0_JAguar		0xe3c
#define rTxAGC_B_Nss1Index7_Nss1Index4_JAguar		0xe40
#define rTxAGC_B_Nss2Index1_Nss1Index8_JAguar		0xe44
#define rTxAGC_B_Nss2Index5_Nss2Index2_JAguar		0xe48
#define rTxAGC_B_Nss2Index9_Nss2Index6_JAguar		0xe4c
#define bTxAGC_byte0_Jaguar							0xff
#define bTxAGC_byte1_Jaguar							0xff00
#define bTxAGC_byte2_Jaguar							0xff0000
#define bTxAGC_byte3_Jaguar							0xff000000


/* TX AGC */
#define		rTxAGC_A_CCK11_CCK1_Jaguar2	0xc20
#define		rTxAGC_A_Ofdm18_Ofdm6_Jaguar2	0xc24
#define		rTxAGC_A_Ofdm54_Ofdm24_Jaguar2	0xc28
#define		rTxAGC_A_MCS3_MCS0_Jaguar2	0xc2c
#define		rTxAGC_A_MCS7_MCS4_Jaguar2	0xc30
#define		rTxAGC_A_MCS11_MCS8_Jaguar2	0xc34
#define		rTxAGC_A_MCS15_MCS12_Jaguar2	0xc38
#define		rTxAGC_A_MCS19_MCS16_Jaguar2	0xcd8
#define		rTxAGC_A_MCS23_MCS20_Jaguar2	0xcdc
#define		rTxAGC_A_Nss1Index3_Nss1Index0_Jaguar2	0xc3c
#define		rTxAGC_A_Nss1Index7_Nss1Index4_Jaguar2	0xc40
#define		rTxAGC_A_Nss2Index1_Nss1Index8_Jaguar2	0xc44
#define		rTxAGC_A_Nss2Index5_Nss2Index2_Jaguar2	0xc48
#define		rTxAGC_A_Nss2Index9_Nss2Index6_Jaguar2	0xc4c
#define		rTxAGC_A_Nss3Index3_Nss3Index0_Jaguar2	0xce0
#define		rTxAGC_A_Nss3Index7_Nss3Index4_Jaguar2	0xce4
#define		rTxAGC_A_Nss3Index9_Nss3Index8_Jaguar2	0xce8
#define		rTxAGC_B_CCK11_CCK1_Jaguar2	0xe20
#define		rTxAGC_B_Ofdm18_Ofdm6_Jaguar2	0xe24
#define		rTxAGC_B_Ofdm54_Ofdm24_Jaguar2	0xe28
#define		rTxAGC_B_MCS3_MCS0_Jaguar2	0xe2c
#define		rTxAGC_B_MCS7_MCS4_Jaguar2	0xe30
#define		rTxAGC_B_MCS11_MCS8_Jaguar2	0xe34
#define		rTxAGC_B_MCS15_MCS12_Jaguar2	0xe38
#define		rTxAGC_B_MCS19_MCS16_Jaguar2	0xed8
#define		rTxAGC_B_MCS23_MCS20_Jaguar2	0xedc
#define		rTxAGC_B_Nss1Index3_Nss1Index0_Jaguar2	0xe3c
#define		rTxAGC_B_Nss1Index7_Nss1Index4_Jaguar2	0xe40
#define		rTxAGC_B_Nss2Index1_Nss1Index8_Jaguar2	0xe44
#define		rTxAGC_B_Nss2Index5_Nss2Index2_Jaguar2	0xe48
#define		rTxAGC_B_Nss2Index9_Nss2Index6_Jaguar2	0xe4c
#define		rTxAGC_B_Nss3Index3_Nss3Index0_Jaguar2	0xee0
#define		rTxAGC_B_Nss3Index7_Nss3Index4_Jaguar2	0xee4
#define		rTxAGC_B_Nss3Index9_Nss3Index8_Jaguar2	0xee8
#define		rTxAGC_C_CCK11_CCK1_Jaguar2	0x1820
#define		rTxAGC_C_Ofdm18_Ofdm6_Jaguar2	0x1824
#define		rTxAGC_C_Ofdm54_Ofdm24_Jaguar2	0x1828
#define		rTxAGC_C_MCS3_MCS0_Jaguar2	0x182c
#define		rTxAGC_C_MCS7_MCS4_Jaguar2	0x1830
#define		rTxAGC_C_MCS11_MCS8_Jaguar2	0x1834
#define		rTxAGC_C_MCS15_MCS12_Jaguar2	0x1838
#define		rTxAGC_C_MCS19_MCS16_Jaguar2	0x18d8
#define		rTxAGC_C_MCS23_MCS20_Jaguar2	0x18dc
#define		rTxAGC_C_Nss1Index3_Nss1Index0_Jaguar2	0x183c
#define		rTxAGC_C_Nss1Index7_Nss1Index4_Jaguar2	0x1840
#define		rTxAGC_C_Nss2Index1_Nss1Index8_Jaguar2	0x1844
#define		rTxAGC_C_Nss2Index5_Nss2Index2_Jaguar2	0x1848
#define		rTxAGC_C_Nss2Index9_Nss2Index6_Jaguar2	0x184c
#define		rTxAGC_C_Nss3Index3_Nss3Index0_Jaguar2	0x18e0
#define		rTxAGC_C_Nss3Index7_Nss3Index4_Jaguar2	0x18e4
#define		rTxAGC_C_Nss3Index9_Nss3Index8_Jaguar2	0x18e8
#define		rTxAGC_D_CCK11_CCK1_Jaguar2	0x1a20
#define		rTxAGC_D_Ofdm18_Ofdm6_Jaguar2	0x1a24
#define		rTxAGC_D_Ofdm54_Ofdm24_Jaguar2	0x1a28
#define		rTxAGC_D_MCS3_MCS0_Jaguar2	0x1a2c
#define		rTxAGC_D_MCS7_MCS4_Jaguar2	0x1a30
#define		rTxAGC_D_MCS11_MCS8_Jaguar2	0x1a34
#define		rTxAGC_D_MCS15_MCS12_Jaguar2	0x1a38
#define		rTxAGC_D_MCS19_MCS16_Jaguar2	0x1ad8
#define		rTxAGC_D_MCS23_MCS20_Jaguar2	0x1adc
#define		rTxAGC_D_Nss1Index3_Nss1Index0_Jaguar2	0x1a3c
#define		rTxAGC_D_Nss1Index7_Nss1Index4_Jaguar2	0x1a40
#define		rTxAGC_D_Nss2Index1_Nss1Index8_Jaguar2	0x1a44
#define		rTxAGC_D_Nss2Index5_Nss2Index2_Jaguar2	0x1a48
#define		rTxAGC_D_Nss2Index9_Nss2Index6_Jaguar2	0x1a4c
#define		rTxAGC_D_Nss3Index3_Nss3Index0_Jaguar2	0x1ae0
#define		rTxAGC_D_Nss3Index7_Nss3Index4_Jaguar2	0x1ae4
#define		rTxAGC_D_Nss3Index9_Nss3Index8_Jaguar2	0x1ae8
/* IQK YN: temporaily mask this part
 * #define rFPGA0_IQK					0xe28
 * #define rTx_IQK_Tone_A				0xe30
 * #define rRx_IQK_Tone_A				0xe34
 * #define rTx_IQK_PI_A					0xe38
 * #define rRx_IQK_PI_A					0xe3c */

/* #define rTx_IQK						0xe40 */
/* #define rRx_IQK						0xe44 */
/* #define rIQK_AGC_Pts					0xe48 */
/* #define rIQK_AGC_Rsp					0xe4c */
/* #define rTx_IQK_Tone_B				0xe50 */
/* #define rRx_IQK_Tone_B				0xe54 */
/* #define rTx_IQK_PI_B					0xe58 */
/* #define rRx_IQK_PI_B					0xe5c */
/* #define rIQK_AGC_Cont				0xe60 */


/* AFE-related */
#define rA_AFEPwr1_Jaguar					0xc60 /* dynamic AFE power control */
#define rA_AFEPwr2_Jaguar					0xc64 /* dynamic AFE power control */
#define rA_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xc68
#define rA_Tx_CCKBBON_OFDMRFON_Jaguar	0xc6c
#define rA_Tx_OFDMBBON_Tx2Rx_Jaguar		0xc70
#define rA_Tx2Tx_RXCCK_Jaguar				0xc74
#define rA_Rx_OFDM_WaitRIFS_Jaguar			0xc78
#define rA_Rx2Rx_BT_Jaguar					0xc7c
#define rA_sleep_nav_Jaguar					0xc80
#define rA_pmpd_Jaguar						0xc84
#define rB_AFEPwr1_Jaguar					0xe60 /* dynamic AFE power control */
#define rB_AFEPwr2_Jaguar					0xe64 /* dynamic AFE power control */
#define rB_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xe68
#define rB_Tx_CCKBBON_OFDMRFON_Jaguar	0xe6c
#define rB_Tx_OFDMBBON_Tx2Rx_Jaguar		0xe70
#define rB_Tx2Tx_RXCCK_Jaguar				0xe74
#define rB_Rx_OFDM_WaitRIFS_Jaguar			0xe78
#define rB_Rx2Rx_BT_Jaguar					0xe7c
#define rB_sleep_nav_Jaguar					0xe80
#define rB_pmpd_Jaguar						0xe84


/* YN: mask these registers temporaily
 * #define rTx_Power_Before_IQK_A		0xe94
 * #define rTx_Power_After_IQK_A			0xe9c */

/* #define rRx_Power_Before_IQK_A		0xea0 */
/* #define rRx_Power_Before_IQK_A_2		0xea4 */
/* #define rRx_Power_After_IQK_A			0xea8 */
/* #define rRx_Power_After_IQK_A_2		0xeac */

/* #define rTx_Power_Before_IQK_B		0xeb4 */
/* #define rTx_Power_After_IQK_B			0xebc */

/* #define rRx_Power_Before_IQK_B		0xec0 */
/* #define rRx_Power_Before_IQK_B_2		0xec4 */
/* #define rRx_Power_After_IQK_B			0xec8 */
/* #define rRx_Power_After_IQK_B_2		0xecc */


/* RSSI Dump */
#define rA_RSSIDump_Jaguar			0xBF0
#define rB_RSSIDump_Jaguar			0xBF1
#define rS1_RXevmDump_Jaguar		0xBF4
#define rS2_RXevmDump_Jaguar		0xBF5
#define rA_RXsnrDump_Jaguar		0xBF6
#define rB_RXsnrDump_Jaguar		0xBF7
#define rA_CfoShortDump_Jaguar		0xBF8
#define rB_CfoShortDump_Jaguar		0xBFA
#define rA_CfoLongDump_Jaguar		0xBEC
#define rB_CfoLongDump_Jaguar		0xBEE


/* RF Register
 *   */
#define RF_AC_Jaguar				0x00	/*  */
#define RF_RF_Top_Jaguar			0x07	/*  */
#define RF_TXLOK_Jaguar				0x08	/*  */
#define RF_TXAPK_Jaguar				0x0B
#define RF_CHNLBW_Jaguar 			0x18	/* RF channel and BW switch */
#define RF_RCK1_Jaguar				0x1c	/*  */
#define RF_RCK2_Jaguar				0x1d
#define RF_RCK3_Jaguar			0x1e
#define RF_ModeTableAddr			0x30
#define RF_ModeTableData0			0x31
#define RF_ModeTableData1			0x32
#define RF_TxLCTank_Jaguar	0x54
#define RF_APK_Jaguar				0x63
#define RF_LCK						0xB4
#define RF_WeLut_Jaguar				0xEF

#define bRF_CHNLBW_MOD_AG_Jaguar	0x70300
#define bRF_CHNLBW_BW				0xc00


/*
 * RL6052 Register definition
 *   */
#define RF_AC						0x00	/*  */
#define RF_IPA_A					0x0C	/*  */
#define RF_TXBIAS_A					0x0D
#define RF_BS_PA_APSET_G9_G11		0x0E
#define RF_MODE1					0x10	/*  */
#define RF_MODE2					0x11	/*  */
#define RF_CHNLBW					0x18	/* RF channel and BW switch */
#define RF_RCK_OS					0x30	/* RF TX PA control */
#define RF_TXPA_G1					0x31	/* RF TX PA control */
#define RF_TXPA_G2					0x32	/* RF TX PA control */
#define RF_TXPA_G3					0x33	/* RF TX PA control */
#define RF_0x52						0x52
#define RF_WE_LUT					0xEF

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define bBBResetB					0x100	/* Useless now? */
#define bGlobalResetB				0x200
#define bOFDMTxStart				0x4
#define bCCKTxStart					0x8
#define bCRC32Debug					0x100
#define bPMACLoopback				0x10
#define bTxLSIG						0xffffff
#define bOFDMTxRate					0xf
#define bOFDMTxReserved			0x10
#define bOFDMTxLength				0x1ffe0
#define bOFDMTxParity				0x20000
#define bTxHTSIG1					0xffffff
#define bTxHTMCSRate				0x7f
#define bTxHTBW						0x80
#define bTxHTLength					0xffff00
#define bTxHTSIG2					0xffffff
#define bTxHTSmoothing				0x1
#define bTxHTSounding				0x2
#define bTxHTReserved				0x4
#define bTxHTAggreation				0x8
#define bTxHTSTBC					0x30
#define bTxHTAdvanceCoding			0x40
#define bTxHTShortGI					0x80
#define bTxHTNumberHT_LTF			0x300
#define bTxHTCRC8					0x3fc00
#define bCounterReset				0x10000
#define bNumOfOFDMTx				0xffff
#define bNumOfCCKTx					0xffff0000
#define bTxIdleInterval				0xffff
#define bOFDMService				0xffff0000
#define bTxMACHeader				0xffffffff
#define bTxDataInit					0xff
#define bTxHTMode					0x100
#define bTxDataType					0x30000
#define bTxRandomSeed				0xffffffff
#define bCCKTxPreamble				0x1
#define bCCKTxSFD					0xffff0000
#define bCCKTxSIG					0xff
#define bCCKTxService				0xff00
#define bCCKLengthExt				0x8000
#define bCCKTxLength				0xffff0000
#define bCCKTxCRC16					0xffff
#define bCCKTxStatus					0x1
#define bOFDMTxStatus				0x2


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define rPMAC_Reset					0x100
#define rPMAC_TxStart				0x104
#define rPMAC_TxLegacySIG			0x108
#define rPMAC_TxHTSIG1				0x10c
#define rPMAC_TxHTSIG2				0x110
#define rPMAC_PHYDebug				0x114
#define rPMAC_TxPacketNum			0x118
#define rPMAC_TxIdle					0x11c
#define rPMAC_TxMACHeader0			0x120
#define rPMAC_TxMACHeader1			0x124
#define rPMAC_TxMACHeader2			0x128
#define rPMAC_TxMACHeader3			0x12c
#define rPMAC_TxMACHeader4			0x130
#define rPMAC_TxMACHeader5			0x134
#define rPMAC_TxDataType			0x138
#define rPMAC_TxRandomSeed		0x13c
#define rPMAC_CCKPLCPPreamble		0x140
#define rPMAC_CCKPLCPHeader		0x144
#define rPMAC_CCKCRC16				0x148
#define rPMAC_OFDMRxCRC32OK		0x170
#define rPMAC_OFDMRxCRC32Er		0x174
#define rPMAC_OFDMRxParityEr		0x178
#define rPMAC_OFDMRxCRC8Er			0x17c
#define rPMAC_CCKCRxRC16Er			0x180
#define rPMAC_CCKCRxRC32Er			0x184
#define rPMAC_CCKCRxRC32OK			0x188
#define rPMAC_TxStatus				0x18c

/*
 * 3. Page8(0x800)
 *   */
#define rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define rFPGA0_TxInfo				0x804	/* Status report?? */
#define rFPGA0_PSDFunction			0x808
#define rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define rFPGA0_XA_HSSIParameter1	0x820	/* RF 3 wire register */
#define rFPGA0_XA_HSSIParameter2	0x824
#define rFPGA0_XB_HSSIParameter1	0x828
#define rFPGA0_XB_HSSIParameter2	0x82c

#define	rFPGA0_XA_LSSIParameter		0x840
#define	rFPGA0_XB_LSSIParameter		0x844

#define rFPGA0_XAB_SwitchControl	0x858	/* RF Channel switch */
#define rFPGA0_XCD_SwitchControl	0x85c

#define rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define rFPGA0_XCD_RFParameter		0x87c

#define rFPGA0_AnalogParameter1	0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define rFPGA0_AnalogParameter2	0x884
#define rFPGA0_AnalogParameter3	0x888
#define rFPGA0_AdDaClockEn			0x888	/* enable ad/da clock1 for dual-phy */
#define rFPGA0_AnalogParameter4	0x88c

#define	rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define	rFPGA0_XB_LSSIReadBack		0x8a4
#define	rFPGA0_XC_LSSIReadBack		0x8a8
#define	rFPGA0_XD_LSSIReadBack		0x8ac

#define rFPGA0_XCD_RFPara	0x8b4
#define	rFPGA0_PSDReport				0x8b4	/* Useless now */
#define	TransceiverA_HSPI_Readback		0x8b8	/* Transceiver A HSPI Readback */
#define	TransceiverB_HSPI_Readback		0x8bc	/* Transceiver B HSPI Readback */
#define	rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define	rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */
#define	REG_BB_TX_PATH_SEL_1_8814A		0x93c
#define	REG_BB_TX_PATH_SEL_2_8814A		0x940
#define rFPGA1_TxBlock				0x904	/* Useless now */
#define rFPGA1_DebugSelect			0x908	/* Useless now */
#define rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
/*Page 19 for TxBF*/
#define	REG_BB_TXBF_ANT_SET_BF1_8814A	0x19ac
#define	REG_BB_TXBF_ANT_SET_BF0_8814A	0x19b4
/*
 * PageA(0xA00)
 *   */
#define rCCK0_System				0xa00
#define rCCK0_AFESetting				0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define	rCCK0_DSPParameter2			0xa1c	/* SQ threshold */
#define rCCK0_TxFilter1				0xa20
#define rCCK0_TxFilter2				0xa24
#define rCCK0_DebugPort				0xa28	/* debug port and Tx filter3 */
#define	rCCK0_FalseAlarmReport			0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA				0xb00
#define rPdp_AntA_4				0xb04
#define rConfig_Pmpd_AntA			0xb28
#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c
#define rPdp_AntB					0xb70
#define rPdp_AntB_4					0xb74
#define rConfig_Pmpd_AntB			0xb98
#define rAPK							0xbd8

/*
 * 6. PageC(0xC00)
 *   */
#define rOFDM0_LSTF					0xc00

#define rOFDM0_TRxPathEnable		0xc04
#define rOFDM0_TRMuxPar			0xc08
#define rOFDM0_TRSWIsolation		0xc0c

#define rOFDM0_XARxAFE				0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
#define rOFDM0_XBRxAFE		0xc18
#define rOFDM0_XBRxIQImbalance	0xc1c
#define rOFDM0_XCRxAFE		0xc20
#define rOFDM0_XCRxIQImbalance	0xc24
#define rOFDM0_XDRxAFE		0xc28
#define rOFDM0_XDRxIQImbalance	0xc2c

#define rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define rOFDM0_CFOandDAGC			0xc44  /* CFO & DAGC */
#define rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define rOFDM0_XAAGCCore2			0xc54
#define rOFDM0_XBAGCCore1			0xc58
#define rOFDM0_XBAGCCore2			0xc5c
#define rOFDM0_XCAGCCore1			0xc60
#define rOFDM0_XCAGCCore2			0xc64
#define rOFDM0_XDAGCCore1			0xc68
#define rOFDM0_XDAGCCore2			0xc6c

#define rOFDM0_AGCParameter1		0xc70
#define rOFDM0_AGCParameter2		0xc74
#define rOFDM0_AGCRSSITable		0xc78
#define rOFDM0_HTSTFAGC			0xc7c

#define rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define rOFDM0_XATxAFE				0xc84
#define rOFDM0_XBTxIQImbalance		0xc88
#define rOFDM0_XBTxAFE				0xc8c
#define rOFDM0_XCTxIQImbalance		0xc90
#define rOFDM0_XCTxAFE		0xc94
#define rOFDM0_XDTxIQImbalance		0xc98
#define rOFDM0_XDTxAFE				0xc9c

#define rOFDM0_RxIQExtAnta			0xca0
#define rOFDM0_TxCoeff1				0xca4
#define rOFDM0_TxCoeff2				0xca8
#define rOFDM0_TxCoeff3				0xcac
#define rOFDM0_TxCoeff4				0xcb0
#define rOFDM0_TxCoeff5				0xcb4
#define rOFDM0_TxCoeff6				0xcb8
#define rOFDM0_RxHPParameter		0xce0
#define rOFDM0_TxPseudoNoiseWgt	0xce4
#define rOFDM0_FrameSync			0xcf0
#define rOFDM0_DFSReport			0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define rOFDM1_LSTF					0xd00
#define rOFDM1_TRxPathEnable		0xd04

/*
 * 8. PageE(0xE00)
 *   */
#define rTxAGC_A_Rate18_06			0xe00
#define rTxAGC_A_Rate54_24			0xe04
#define rTxAGC_A_CCK1_Mcs32		0xe08
#define rTxAGC_A_Mcs03_Mcs00		0xe10
#define rTxAGC_A_Mcs07_Mcs04		0xe14
#define rTxAGC_A_Mcs11_Mcs08		0xe18
#define rTxAGC_A_Mcs15_Mcs12		0xe1c

#define rTxAGC_B_Rate18_06			0x830
#define rTxAGC_B_Rate54_24			0x834
#define rTxAGC_B_CCK1_55_Mcs32	0x838
#define rTxAGC_B_Mcs03_Mcs00		0x83c
#define rTxAGC_B_Mcs07_Mcs04		0x848
#define rTxAGC_B_Mcs11_Mcs08		0x84c
#define rTxAGC_B_Mcs15_Mcs12		0x868
#define rTxAGC_B_CCK11_A_CCK2_11	0x86c

#define rFPGA0_IQK					0xe28
#define rTx_IQK_Tone_A				0xe30
#define rRx_IQK_Tone_A				0xe34
#define rTx_IQK_PI_A				0xe38
#define rRx_IQK_PI_A				0xe3c

#define rTx_IQK						0xe40
#define rRx_IQK						0xe44
#define rIQK_AGC_Pts					0xe48
#define rIQK_AGC_Rsp				0xe4c
#define rTx_IQK_Tone_B				0xe50
#define rRx_IQK_Tone_B				0xe54
#define rTx_IQK_PI_B					0xe58
#define rRx_IQK_PI_B					0xe5c
#define rIQK_AGC_Cont				0xe60

#define rBlue_Tooth					0xe6c
#define rRx_Wait_CCA				0xe70
#define rTx_CCK_RFON				0xe74
#define rTx_CCK_BBON				0xe78
#define rTx_OFDM_RFON				0xe7c
#define rTx_OFDM_BBON				0xe80
#define rTx_To_Rx					0xe84
#define rTx_To_Tx					0xe88
#define rRx_CCK						0xe8c

#define rTx_Power_Before_IQK_A		0xe94
#define rTx_Power_After_IQK_A		0xe9c

#define rRx_Power_Before_IQK_A		0xea0
#define rRx_Power_Before_IQK_A_2	0xea4
#define rRx_Power_After_IQK_A		0xea8
#define rRx_Power_After_IQK_A_2		0xeac

#define rTx_Power_Before_IQK_B		0xeb4
#define rTx_Power_After_IQK_B		0xebc

#define rRx_Power_Before_IQK_B		0xec0
#define rRx_Power_Before_IQK_B_2	0xec4
#define rRx_Power_After_IQK_B		0xec8
#define rRx_Power_After_IQK_B_2		0xecc

#define rRx_OFDM					0xed0
#define rRx_Wait_RIFS				0xed4
#define rRx_TO_Rx					0xed8
#define rStandby						0xedc
#define rSleep						0xee0
#define rPMPD_ANAEN				0xeec


/* 2. Page8(0x800) */
#define bRFMOD						0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define bJapanMode					0x2
#define bCCKTxSC					0x30
#define bCCKEn						0x1000000
#define bOFDMEn						0x2000000
#define bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define bXCTxAGC			0xf000
#define bXDTxAGC			0xf0000

/* 4. PageA(0xA00) */
#define bCCKBBMode                			0x3	/* Useless */
#define bCCKTxPowerSaving		0x80
#define bCCKRxPowerSaving		0x40

#define bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define bCCKScramble              		0x8	/* Useless */
#define bCCKAntDiversity			0x8000
#define bCCKCarrierRecovery		0x4000
#define bCCKTxRate			0x3000
#define bCCKDCCancel			0x0800
#define bCCKISICancel			0x0400
#define bCCKMatchFilter		0x0200
#define bCCKEqualizer			0x0100
#define bCCKPreambleDetect		0x800000
#define bCCKFastFalseCCA		0x400000
#define bCCKChEstStart		0x300000
#define bCCKCCACount		0x080000
#define bCCKcs_lim			0x070000
#define bCCKBistMode			0x80000000
#define bCCKCCAMask			0x40000000
#define bCCKTxDACPhase		0x4
#define bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
#define bCCKr_cp_mode0		0x0100
#define bCCKTxDCOffset		0xf0
#define bCCKRxDCOffset		0xf
#define bCCKCCAMode			0xc000
#define bCCKFalseCS_lim		0x3f00
#define bCCKCS_ratio			0xc00000
#define bCCKCorgBit_sel		0x300000
#define bCCKPD_lim			0x0f0000
#define bCCKNewCCA		0x80000000
#define bCCKRxHPofIG		0x8000
#define bCCKRxIG			0x7f00
#define bCCKLNAPolarity		0x800000
#define bCCKRx1stGain		0x7f0000
#define bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
#define bCCKRxAGCSatLevel		0x1f000000
#define bCCKRxAGCSatCount		0xe0
#define bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
#define bCCKFixedRxAGC		0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define bCCKAntennaPolarity		0x2000
#define bCCKTxFilterType		0x0c00
#define bCCKRxAGCReportType		0x0300
#define bCCKRxDAGCEn		0x80000000
#define bCCKRxDAGCPeriod		0x20000000
#define bCCKRxDAGCSatLevel		0x1f000000
#define bCCKTimingRecovery		0x800000
#define bCCKTxC0			0x3f0000
#define bCCKTxC1			0x3f000000
#define bCCKTxC2			0x3f
#define bCCKTxC3			0x3f00
#define bCCKTxC4			0x3f0000
#define bCCKTxC5			0x3f000000
#define bCCKTxC6			0x3f
#define bCCKTxC7			0x3f00
#define bCCKDebugPort		0xff0000
#define bCCKDACDebug		0x0f000000
#define bCCKFalseAlarmEnable		0x8000
#define bCCKFalseAlarmRead		0x4000
#define bCCKTRSSI			0x7f
#define bCCKRxAGCReport		0xfe
#define bCCKRxReport_AntSel		0x80000000
#define bCCKRxReport_MFOff		0x40000000
#define bCCKRxRxReport_SQLoss	0x20000000
#define bCCKRxReport_Pktloss		0x10000000
#define bCCKRxReport_Lockedbit	0x08000000
#define bCCKRxReport_RateError	0x04000000
#define bCCKRxReport_RxRate		0x03000000
#define bCCKRxFACounterLower	0xff
#define bCCKRxFACounterUpper	0xff000000
#define bCCKRxHPAGCStart		0xe000
#define bCCKRxHPAGCFinal		0x1c00
#define bCCKRxFalseAlarmEnable	0x8000
#define bCCKFACounterFreeze		0x4000
#define bCCKTxPathSel		0x10000000
#define bCCKDefaultRxPath		0xc000000
#define bCCKOptionRxPath		0x3000000

#define		RF_T_METER_88E				0x42

/* 6. PageE(0xE00) */
#define bSTBCEn                  			0x4	/* Useless */
#define bAntennaMapping		0x10
#define bNss				0x20
#define bCFOAntSumD		0x200
#define bPHYCounterReset		0x8000000
#define bCFOReportGet			0x4000000
#define bOFDMContinueTx		0x10000000
#define bOFDMSingleCarrier		0x20000000
#define bOFDMSingleTone		0x40000000


/*
 * Other Definition
 *   */

#define bEnable                   0x1	/* Useless */
#define bDisable                  0x0

/* byte endable for srwrite */
#define bByte0                    		0x1	/* Useless */
#define bByte1		0x2
#define bByte2		0x4
#define bByte3		0x8
#define bWord0		0x3
#define bWord1		0xc
#define bDWord		0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define bMaskByte0                		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define bMaskByte1		0xff00
#define bMaskByte2		0xff0000
#define bMaskByte3		0xff000000
#define bMaskHWord	0xffff0000
#define bMaskLWord		0x0000ffff
#define bMaskDWord	0xffffffff
#define bMaskH3Bytes				0xffffff00
#define bMask12Bits				0xfff
#define bMaskH4Bits				0xf0000000
#define bMaskOFDM_D			0xffc00000
#define bMaskCCK				0x3f3f3f3f
#define bMask7bits				0x7f
#define bMaskByte2HighNibble			0x00f00000
#define bMaskByte3LowNibble				0x0f000000
#define bMaskL3Bytes			0x00ffffff

/*--------------------------Define Parameters-------------------------------*/


#endif
                                                                                                                                                                                              rtl8822bu/src/include/drv_types_gspi.h                                                              0000644 0001750 0001750 00000002527 14214766567 016644  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_TYPES_GSPI_H__
#define __DRV_TYPES_GSPI_H__

/* SPI Header Files */
#ifdef PLATFORM_LINUX
	#include <linux/platform_device.h>
	#include <linux/spi/spi.h>
	#include <linux/gpio.h>
	/* #include <mach/ldo.h> */
	#include <asm/mach-types.h>
	#include <asm/gpio.h>
	#include <asm/io.h>
	#include <mach/board.h>
	#include <mach/hardware.h>
	#include <mach/irqs.h>
	#include <custom_gpio.h>
#endif


typedef struct gspi_data {
	u8  func_number;

	u8  tx_block_mode;
	u8  rx_block_mode;
	u32 block_transfer_len;

#ifdef PLATFORM_LINUX
	struct spi_device *func;

	struct workqueue_struct *priv_wq;
	struct delayed_work irq_work;
#endif
} GSPI_DATA, *PGSPI_DATA;

#endif /*  #ifndef __DRV_TYPES_GSPI_H__ */
                                                                                                                                                                         rtl8822bu/src/include/rtl8814a_recv.h                                                               0000755 0001750 0001750 00000023530 14214766567 016111  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_RECV_H__
#define __RTL8814A_RECV_H__

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
			#else
				#define MAX_RECVBUF_SZ (32768) /* 32k */
			#endif
			/* #define MAX_RECVBUF_SZ (24576) */ /* 24k */
			/* #define MAX_RECVBUF_SZ (20480) */ /* 20K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			/* #define MAX_RECVBUF_SZ (15360) */ /* 15k < 16k */
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI)
	#if 0
		/* temp solution */
		#ifdef CONFIG_SDIO_RX_COPY
			#define MAX_RECVBUF_SZ (10240)
		#else /*  !CONFIG_SDIO_RX_COPY */
			#define MAX_RECVBUF_SZ	MAX_RX_DMA_BUFFER_SIZE_8821
		#endif /*  !CONFIG_SDIO_RX_COPY */
	#endif
#endif


/* RX buffer descriptor */
/* DWORD 0 */
#define SET_RX_BUFFER_DESC_DATA_LENGTH_8814A(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_BUFFER_DESC_LS_8814A(__pRxStatusDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 14, 1, __Value)
#define SET_RX_BUFFER_DESC_FS_8814A(__pRxStatusDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 15, 1, __Value)
#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_8814A(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 16, __Value)

#define GET_RX_BUFFER_DESC_OWN_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)
#define GET_RX_BUFFER_DESC_LS_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_BUFFER_DESC_FS_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 15)

/* DWORD 1 */
#define SET_RX_BUFFER_PHYSICAL_LOW_8814A(__pRxStatusDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+4, 0, 32, __Value)
#define GET_RX_BUFFER_PHYSICAL_LOW_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 0, 32)

/* DWORD 2 */
#define SET_RX_BUFFER_PHYSICAL_HIGH_8814A(__pRxStatusDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+8, 0, 32, __Value)

/* DWORD 3*/ /* RESERVED */


#if 0
	/* =============
	* RX Info
	* ============== */
#endif
/* DWORD 0 */
#define SET_RX_STATUS_DESC_PKT_LEN_8814A(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_8814A(__pRxStatusDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_8814AE(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

#define GET_RX_STATUS_DESC_PKT_LEN_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICV_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_LAST_SEG_8814AE(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 28, 1)
#define GET_RX_STATUS_DESC_EOR_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_EXT_SECTYPE_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 7, 1)/* 20130415 KaiYuan add for 8814 */
#define GET_RX_STATUS_DESC_TID_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_MACID_VLD_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 12, 1)
#define GET_RX_STATUS_DESC_AMSDU_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHKERR_8814A(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_IPVER_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_IS_TCPUDP_8814A(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHK_VLD_8814A(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_FIRST_SEG_8814AE(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 29, 1)
#define GET_RX_STATUS_DESC_EOR_8814AE(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_MC_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#ifdef CONFIG_USB_RX_AGGREGATION
	#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 8)
#else
	#define GET_RX_STATUS_DESC_RX_IS_QOS_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
#endif
#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_HWRSVD_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 24, 4)
#define GET_RX_STATUS_C2H_8814A(__pRxStatusDesc)								LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)
#define GET_RX_STATUS_DESC_FCS_OK_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 31, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_BSSID_FIT_H_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 7, 3)/* 20130415 KaiYuan add for 8814 */
#define GET_RX_STATUS_DESC_HTC_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_L_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#define GET_RX_STATUS_DESC_DMA_AGG_NUM_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)/* 20130415 KaiYuan Check if it exist anymore */
#define GET_RX_STATUS_DESC_PATTERN_MATCH_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_WAKE_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 31, 1)

/* DWORD 4 */
#define GET_RX_STATUS_DESC_PATTERN_IDX_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+16, 0, 8)
#define GET_RX_STATUS_DESC_RX_EOF_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+16, 8, 1)
#define GET_RX_STATUS_DESC_RX_SCRAMBLER_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+16, 9, 7)
#define GET_RX_STATUS_DESC_RX_PRE_NDP_VLD_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+16, 16, 1)
#define GET_RX_STATUS_DESC_A1_FIT_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+16, 24, 5)


/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)


/* Rx smooth factor */
#define Rx_Smooth_Factor (20)

#ifdef CONFIG_USB_HCI
	s32 rtl8814au_init_recv_priv(PADAPTER padapter);
	void rtl8814au_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8814ae_init_recv_priv(PADAPTER padapter);
	void rtl8814ae_free_recv_priv(PADAPTER padapter);
#endif

#if 0
	/* temp solution */
	#ifdef CONFIG_SDIO_HCI
		s32 InitRecvPriv8821AS(PADAPTER padapter);
		void FreeRecvPriv8821AS(PADAPTER padapter);
	#endif /*  CONFIG_SDIO_HCI */
#endif

void rtl8814_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8814A_RECV_H__ */
                                                                                                                                                                        rtl8822bu/src/include/rtl8703b_spec.h                                                               0000644 0001750 0001750 00000044735 14214766567 016111  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_SPEC_H__
#define __RTL8703B_SPEC_H__

#include <drv_conf.h>


#define HAL_NAV_UPPER_UNIT_8703B		128		/* micro-second */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_SYS_ISO_CTRL_8703B			0x0000	/* 2 Byte */
#define REG_SYS_FUNC_EN_8703B			0x0002	/* 2 Byte */
#define REG_APS_FSMCO_8703B			0x0004	/* 4 Byte */
#define REG_SYS_CLKR_8703B				0x0008	/* 2 Byte */
#define REG_9346CR_8703B				0x000A	/* 2 Byte */
#define REG_EE_VPD_8703B				0x000C	/* 2 Byte */
#define REG_AFE_MISC_8703B				0x0010	/* 1 Byte */
#define REG_SPS0_CTRL_8703B				0x0011	/* 7 Byte */
#define REG_SPS_OCP_CFG_8703B			0x0018	/* 4 Byte */
#define REG_RSV_CTRL_8703B				0x001C	/* 3 Byte */
#define REG_RF_CTRL_8703B				0x001F	/* 1 Byte */
#define REG_LPLDO_CTRL_8703B			0x0023	/* 1 Byte */
#define REG_AFE_XTAL_CTRL_8703B		0x0024	/* 4 Byte */
#define REG_AFE_PLL_CTRL_8703B			0x0028	/* 4 Byte */
#define REG_MAC_PLL_CTRL_EXT_8703B		0x002c	/* 4 Byte */
#define REG_EFUSE_CTRL_8703B			0x0030
#define REG_EFUSE_TEST_8703B			0x0034
#define REG_PWR_DATA_8703B				0x0038
#define REG_CAL_TIMER_8703B				0x003C
#define REG_ACLK_MON_8703B				0x003E
#define REG_GPIO_MUXCFG_8703B			0x0040
#define REG_GPIO_IO_SEL_8703B			0x0042
#define REG_MAC_PINMUX_CFG_8703B		0x0043
#define REG_GPIO_PIN_CTRL_8703B			0x0044
#define REG_GPIO_INTM_8703B				0x0048
#define REG_LEDCFG0_8703B				0x004C
#define REG_LEDCFG1_8703B				0x004D
#define REG_LEDCFG2_8703B				0x004E
#define REG_LEDCFG3_8703B				0x004F
#define REG_FSIMR_8703B					0x0050
#define REG_FSISR_8703B					0x0054
#define REG_HSIMR_8703B					0x0058
#define REG_HSISR_8703B					0x005c
#define REG_GPIO_EXT_CTRL				0x0060
#define REG_PAD_CTRL1_8703B		0x0064
#define REG_MULTI_FUNC_CTRL_8703B		0x0068
#define REG_GPIO_STATUS_8703B			0x006C
#define REG_SDIO_CTRL_8703B				0x0070
#define REG_OPT_CTRL_8703B				0x0074
#define REG_AFE_CTRL_4_8703B		0x0078
#define REG_MCUFWDL_8703B				0x0080
#define REG_HMEBOX_DBG_0_8703B	0x0088
#define REG_HMEBOX_DBG_1_8703B	0x008A
#define REG_HMEBOX_DBG_2_8703B	0x008C
#define REG_HMEBOX_DBG_3_8703B	0x008E
#define REG_HIMR0_8703B					0x00B0
#define REG_HISR0_8703B					0x00B4
#define REG_HIMR1_8703B					0x00B8
#define REG_HISR1_8703B					0x00BC
#define REG_PMC_DBG_CTRL2_8703B			0x00CC
#define	REG_EFUSE_BURN_GNT_8703B		0x00CF
#define REG_HPON_FSM_8703B				0x00EC
#define REG_SYS_CFG_8703B				0x00F0
#define REG_SYS_CFG1_8703B				0x00FC
#define REG_ROM_VERSION					0x00FD

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_C2HEVT_CMD_ID_8703B	0x01A0
#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
#define REG_C2HEVT_CMD_LEN_8703B        0x01AE
#define REG_C2HEVT_CMD_LEN_88XX		REG_C2HEVT_CMD_LEN_8703B
#define REG_C2HEVT_CLEAR_8703B			0x01AF
#define REG_MCUTST_1_8703B				0x01C0
#define REG_WOWLAN_WAKE_REASON 0x01C7
#define REG_FMETHR_8703B				0x01C8
#define REG_HMETFR_8703B				0x01CC
#define REG_HMEBOX_0_8703B				0x01D0
#define REG_HMEBOX_1_8703B				0x01D4
#define REG_HMEBOX_2_8703B				0x01D8
#define REG_HMEBOX_3_8703B				0x01DC
#define REG_LLT_INIT_8703B				0x01E0
#define REG_HMEBOX_EXT0_8703B			0x01F0
#define REG_HMEBOX_EXT1_8703B			0x01F4
#define REG_HMEBOX_EXT2_8703B			0x01F8
#define REG_HMEBOX_EXT3_8703B			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RQPN_8703B					0x0200
#define REG_FIFOPAGE_8703B				0x0204
#define REG_DWBCN0_CTRL_8703B			REG_TDECTRL
#define REG_TXDMA_OFFSET_CHK_8703B	0x020C
#define REG_TXDMA_STATUS_8703B		0x0210
#define REG_RQPN_NPQ_8703B			0x0214
#define REG_DWBCN1_CTRL_8703B			0x0228


/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_AGG_PG_TH_8703B		0x0280
#define REG_FW_UPD_RDPTR_8703B		0x0284 /* FW shall update this register before FW write RXPKT_RELEASE_POLL to 1 */
#define REG_RXDMA_CONTROL_8703B		0x0286 /* Control the RX DMA. */
#define REG_RXPKT_NUM_8703B			0x0287 /* The number of packets in RXPKTBUF.	 */
#define REG_RXDMA_STATUS_8703B			0x0288
#define REG_RXDMA_MODE_CTRL_8703B		0x0290
#define REG_EARLY_MODE_CONTROL_8703B	0x02BC
#define REG_RSVD5_8703B					0x02F0
#define REG_RSVD6_8703B					0x02F4

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8703B		0x0300
#define	REG_INT_MIG_8703B				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_DESA_8703B			0x0308	/* TX Beacon Descriptor Address */
#define	REG_HQ_DESA_8703B				0x0310	/* TX High Queue Descriptor Address */
#define	REG_MGQ_DESA_8703B			0x0318	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_DESA_8703B			0x0320	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_DESA_8703B				0x0328	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_DESA_8703B			0x0330	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_DESA_8703B			0x0338	/* TX BK Queue Descriptor Address */
#define	REG_RX_DESA_8703B				0x0340	/* RX Queue	Descriptor Address */
#define	REG_DBI_WDATA_8703B			0x0348	/* DBI Write Data */
#define	REG_DBI_RDATA_8703B			0x034C	/* DBI Read Data */
#define	REG_DBI_ADDR_8703B				0x0350	/* DBI Address */
#define	REG_DBI_FLAG_8703B				0x0352	/* DBI Read/Write Flag */
#define	REG_MDIO_WDATA_8703B		0x0354	/* MDIO for Write PCIE PHY */
#define	REG_MDIO_RDATA_8703B			0x0356	/* MDIO for Reads PCIE PHY */
#define	REG_MDIO_CTL_8703B			0x0358	/* MDIO for Control */
#define	REG_DBG_SEL_8703B				0x0360	/* Debug Selection Register */
#define	REG_PCIE_HRPWM_8703B			0x0361	/* PCIe RPWM */
#define	REG_PCIE_HCPWM_8703B			0x0363	/* PCIe CPWM */
#define	REG_PCIE_MULTIFET_CTRL_8703B	0x036A	/* PCIE Multi-Fethc Control */

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_VOQ_INFORMATION_8703B		0x0400
#define REG_VIQ_INFORMATION_8703B		0x0404
#define REG_BEQ_INFORMATION_8703B		0x0408
#define REG_BKQ_INFORMATION_8703B		0x040C
#define REG_MGQ_INFORMATION_8703B		0x0410
#define REG_HGQ_INFORMATION_8703B		0x0414
#define REG_BCNQ_INFORMATION_8703B	0x0418
#define REG_TXPKT_EMPTY_8703B			0x041A

#define REG_FWHW_TXQ_CTRL_8703B		0x0420
#define REG_HWSEQ_CTRL_8703B			0x0423
#define REG_TXPKTBUF_BCNQ_BDNY_8703B	0x0424
#define REG_TXPKTBUF_MGQ_BDNY_8703B	0x0425
#define REG_LIFECTRL_CTRL_8703B			0x0426
#define REG_MULTI_BCNQ_OFFSET_8703B	0x0427
#define REG_SPEC_SIFS_8703B				0x0428
#define REG_RL_8703B						0x042A
#define REG_TXBF_CTRL_8703B				0x042C
#define REG_DARFRC_8703B				0x0430
#define REG_RARFRC_8703B				0x0438
#define REG_RRSR_8703B					0x0440
#define REG_ARFR0_8703B					0x0444
#define REG_ARFR1_8703B					0x044C
#define REG_CCK_CHECK_8703B				0x0454
#define REG_AMPDU_MAX_TIME_8703B		0x0456
#define REG_TXPKTBUF_BCNQ_BDNY1_8703B	0x0457

#define REG_AMPDU_MAX_LENGTH_8703B	0x0458
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8703B	0x045D
#define REG_NDPA_OPT_CTRL_8703B		0x045F
#define REG_FAST_EDCA_CTRL_8703B		0x0460
#define REG_RD_RESP_PKT_TH_8703B		0x0463
#define REG_DATA_SC_8703B				0x0483
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW             0x0484
	#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_TXRPT_START_OFFSET		0x04AC
#define REG_POWER_STAGE1_8703B		0x04B4
#define REG_POWER_STAGE2_8703B		0x04B8
#define REG_AMPDU_BURST_MODE_8703B	0x04BC
#define REG_PKT_VO_VI_LIFE_TIME_8703B	0x04C0
#define REG_PKT_BE_BK_LIFE_TIME_8703B	0x04C2
#define REG_STBC_SETTING_8703B			0x04C4
#define REG_HT_SINGLE_AMPDU_8703B		0x04C7
#define REG_PROT_MODE_CTRL_8703B		0x04C8
#define REG_MAX_AGGR_NUM_8703B		0x04CA
#define REG_RTS_MAX_AGGR_NUM_8703B	0x04CB
#define REG_BAR_MODE_CTRL_8703B		0x04CC
#define REG_RA_TRY_RATE_AGG_LMT_8703B	0x04CF
#define REG_MACID_PKT_DROP0_8703B		0x04D0
#define REG_MACID_PKT_SLEEP_8703B		0x04D4

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_EDCA_VO_PARAM_8703B		0x0500
#define REG_EDCA_VI_PARAM_8703B		0x0504
#define REG_EDCA_BE_PARAM_8703B		0x0508
#define REG_EDCA_BK_PARAM_8703B		0x050C
#define REG_BCNTCFG_8703B				0x0510
#define REG_PIFS_8703B					0x0512
#define REG_RDG_PIFS_8703B				0x0513
#define REG_SIFS_CTX_8703B				0x0514
#define REG_SIFS_TRX_8703B				0x0516
#define REG_AGGR_BREAK_TIME_8703B		0x051A
#define REG_SLOT_8703B					0x051B
#define REG_TX_PTCL_CTRL_8703B			0x0520
#define REG_TXPAUSE_8703B				0x0522
#define REG_DIS_TXREQ_CLR_8703B		0x0523
#define REG_RD_CTRL_8703B				0x0524
/*
 * Format for offset 540h-542h:
 *	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
 *	[7:4]:   Reserved.
 *	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
 *	[23:20]: Reserved
 * Description:
 *	              |
 * |<--Setup--|--Hold------------>|
 *	--------------|----------------------
 * |
 * TBTT
 * Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
 * Described by Designer Tim and Bruce, 2011-01-14.
 *   */
#define REG_TBTT_PROHIBIT_8703B			0x0540
#define REG_RD_NAV_NXT_8703B			0x0544
#define REG_NAV_PROT_LEN_8703B			0x0546
#define REG_BCN_CTRL_8703B				0x0550
#define REG_BCN_CTRL_1_8703B			0x0551
#define REG_MBID_NUM_8703B				0x0552
#define REG_DUAL_TSF_RST_8703B			0x0553
#define REG_BCN_INTERVAL_8703B			0x0554
#define REG_DRVERLYINT_8703B			0x0558
#define REG_BCNDMATIM_8703B			0x0559
#define REG_ATIMWND_8703B				0x055A
#define REG_USTIME_TSF_8703B			0x055C
#define REG_BCN_MAX_ERR_8703B			0x055D
#define REG_RXTSF_OFFSET_CCK_8703B		0x055E
#define REG_RXTSF_OFFSET_OFDM_8703B	0x055F
#define REG_TSFTR_8703B					0x0560
#define REG_CTWND_8703B					0x0572
#define REG_SECONDARY_CCA_CTRL_8703B	0x0577
#define REG_PSTIMER_8703B				0x0580
#define REG_TIMER0_8703B				0x0584
#define REG_TIMER1_8703B				0x0588
#define REG_ACMHWCTRL_8703B			0x05C0
#define REG_SCH_TXCMD_8703B			0x05F8

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#define REG_MAC_CR_8703B				0x0600
#define REG_TCR_8703B					0x0604
#define REG_RCR_8703B					0x0608
#define REG_RX_PKT_LIMIT_8703B			0x060C
#define REG_RX_DLK_TIME_8703B			0x060D
#define REG_RX_DRVINFO_SZ_8703B		0x060F

#define REG_MACID_8703B					0x0610
#define REG_BSSID_8703B					0x0618
#define REG_MAR_8703B					0x0620
#define REG_MBIDCAMCFG_8703B			0x0628
#define REG_WOWLAN_GTK_DBG1	0x630
#define REG_WOWLAN_GTK_DBG2	0x634

#define REG_USTIME_EDCA_8703B			0x0638
#define REG_MAC_SPEC_SIFS_8703B		0x063A
#define REG_RESP_SIFP_CCK_8703B			0x063C
#define REG_RESP_SIFS_OFDM_8703B		0x063E
#define REG_ACKTO_8703B					0x0640
#define REG_CTS2TO_8703B				0x0641
#define REG_EIFS_8703B					0x0642

#define REG_NAV_UPPER_8703B			0x0652	/* unit of 128 */
#define REG_TRXPTCL_CTL_8703B			0x0668

/* Security */
#define REG_CAMCMD_8703B				0x0670
#define REG_CAMWRITE_8703B				0x0674
#define REG_CAMREAD_8703B				0x0678
#define REG_CAMDBG_8703B				0x067C
#define REG_SECCFG_8703B				0x0680

/* Power */
#define REG_WOW_CTRL_8703B				0x0690
#define REG_PS_RX_INFO_8703B			0x0692
#define REG_UAPSD_TID_8703B				0x0693
#define REG_WKFMCAM_CMD_8703B			0x0698
#define REG_WKFMCAM_NUM_8703B			0x0698
#define REG_WKFMCAM_RWD_8703B			0x069C
#define REG_RXFLTMAP0_8703B				0x06A0
#define REG_RXFLTMAP1_8703B				0x06A2
#define REG_RXFLTMAP2_8703B				0x06A4
#define REG_BCN_PSR_RPT_8703B			0x06A8
#define REG_BT_COEX_TABLE_8703B		0x06C0
#define REG_BFMER0_INFO_8703B			0x06E4
#define REG_BFMER1_INFO_8703B			0x06EC
#define REG_CSI_RPT_PARAM_BW20_8703B	0x06F4
#define REG_CSI_RPT_PARAM_BW40_8703B	0x06F8
#define REG_CSI_RPT_PARAM_BW80_8703B	0x06FC

/* Hardware Port 2 */
#define REG_MACID1_8703B				0x0700
#define REG_BSSID1_8703B				0x0708
#define REG_BFMEE_SEL_8703B				0x0714
#define REG_SND_PTCL_CTRL_8703B		0x0718

/* LTE_COEX */
#define REG_LTECOEX_CTRL			0x07C0
#define REG_LTECOEX_WRITE_DATA		0x07C4
#define REG_LTECOEX_READ_DATA		0x07C8
#define REG_LTECOEX_PATH_CONTROL	0x70

/* ************************************************************
 * SDIO Bus Specification
 * ************************************************************ */

/* -----------------------------------------------------
 * SDIO CMD Address Mapping
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * I/O bus domain (Host)
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * SDIO register
 * ----------------------------------------------------- */
#define SDIO_REG_HCPWM1_8703B	0x025 /* HCI Current Power Mode 1 */


/* ****************************************************************************
 *	8703 Regsiter Bit and Content definition
 * **************************************************************************** */

#define BIT_USB_RXDMA_AGG_EN	BIT(31)
#define RXDMA_AGG_MODE_EN		BIT(1)

#ifdef CONFIG_WOWLAN
	#define RXPKT_RELEASE_POLL		BIT(16)
	#define RXDMA_IDLE				BIT(17)
	#define RW_RELEASE_EN			BIT(18)
#endif

/* 2 HSISR
 * interrupt mask which needs to clear */
#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
		HSISR_SPS_OCP_INT |\
		HSISR_RON_INT |\
		HSISR_PDNINT |\
		HSISR_GPIO9_INT)


/* ----------------------------------------------------------------------------
 * 8703B REG_CCK_CHECK						(offset 0x454)
 * ---------------------------------------------------------------------------- */
#define BIT_BCN_PORT_SEL		BIT(5)

#ifdef CONFIG_RF_POWER_TRIM

	#ifdef CONFIG_RTL8703B
		#define EEPROM_RF_GAIN_OFFSET			0xC1
	#endif

	#define EEPROM_RF_GAIN_VAL				0x1F6
#endif /*CONFIG_RF_POWER_TRIM*/


/* ----------------------------------------------------------------------------
 * 8195 IMR/ISR bits						(offset 0xB0,  8bits)
 * ---------------------------------------------------------------------------- */
#define	IMR_DISABLED_8703B					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define	IMR_TIMER2_8703B					BIT(31)		/* Timeout interrupt 2 */
#define	IMR_TIMER1_8703B					BIT(30)		/* Timeout interrupt 1	 */
#define	IMR_PSTIMEOUT_8703B				BIT(29)		/* Power Save Time Out Interrupt */
#define	IMR_GTINT4_8703B					BIT(28)		/* When GTIMER4 expires, this bit is set to 1	 */
#define	IMR_GTINT3_8703B					BIT(27)		/* When GTIMER3 expires, this bit is set to 1	 */
#define	IMR_TXBCN0ERR_8703B				BIT(26)		/* Transmit Beacon0 Error			 */
#define	IMR_TXBCN0OK_8703B				BIT(25)		/* Transmit Beacon0 OK			 */
#define	IMR_TSF_BIT32_TOGGLE_8703B		BIT(24)		/* TSF Timer BIT32 toggle indication interrupt			 */
#define	IMR_BCNDMAINT0_8703B				BIT(20)		/* Beacon DMA Interrupt 0			 */
#define	IMR_BCNDERR0_8703B				BIT(16)		/* Beacon Queue DMA OK0			 */
#define	IMR_HSISR_IND_ON_INT_8703B		BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define	IMR_BCNDMAINT_E_8703B			BIT(14)		/* Beacon DMA Interrupt Extension for Win7			 */
#define	IMR_ATIMEND_8703B				BIT(12)		/* CTWidnow End or ATIM Window End */
#define	IMR_C2HCMD_8703B					BIT(10)		/* CPU to Host Command INT Status, Write 1 clear	 */
#define	IMR_CPWM2_8703B					BIT(9)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_CPWM_8703B					BIT(8)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_HIGHDOK_8703B				BIT(7)			/* High Queue DMA OK	 */
#define	IMR_MGNTDOK_8703B				BIT(6)			/* Management Queue DMA OK	 */
#define	IMR_BKDOK_8703B					BIT(5)			/* AC_BK DMA OK		 */
#define	IMR_BEDOK_8703B					BIT(4)			/* AC_BE DMA OK	 */
#define	IMR_VIDOK_8703B					BIT(3)			/* AC_VI DMA OK		 */
#define	IMR_VODOK_8703B					BIT(2)			/* AC_VO DMA OK	 */
#define	IMR_RDU_8703B					BIT(1)			/* Rx Descriptor Unavailable	 */
#define	IMR_ROK_8703B					BIT(0)			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define	IMR_BCNDMAINT7_8703B				BIT(27)		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT6_8703B				BIT(26)		/* Beacon DMA Interrupt 6 */
#define	IMR_BCNDMAINT5_8703B				BIT(25)		/* Beacon DMA Interrupt 5 */
#define	IMR_BCNDMAINT4_8703B				BIT(24)		/* Beacon DMA Interrupt 4 */
#define	IMR_BCNDMAINT3_8703B				BIT(23)		/* Beacon DMA Interrupt 3 */
#define	IMR_BCNDMAINT2_8703B				BIT(22)		/* Beacon DMA Interrupt 2 */
#define	IMR_BCNDMAINT1_8703B				BIT(21)		/* Beacon DMA Interrupt 1 */
#define	IMR_BCNDOK7_8703B					BIT(20)		/* Beacon Queue DMA OK Interrupt 7 */
#define	IMR_BCNDOK6_8703B					BIT(19)		/* Beacon Queue DMA OK Interrupt 6 */
#define	IMR_BCNDOK5_8703B					BIT(18)		/* Beacon Queue DMA OK Interrupt 5 */
#define	IMR_BCNDOK4_8703B					BIT(17)		/* Beacon Queue DMA OK Interrupt 4 */
#define	IMR_BCNDOK3_8703B					BIT(16)		/* Beacon Queue DMA OK Interrupt 3 */
#define	IMR_BCNDOK2_8703B					BIT(15)		/* Beacon Queue DMA OK Interrupt 2 */
#define	IMR_BCNDOK1_8703B					BIT(14)		/* Beacon Queue DMA OK Interrupt 1 */
#define	IMR_ATIMEND_E_8703B				BIT(13)		/* ATIM Window End Extension for Win7 */
#define	IMR_TXERR_8703B					BIT(11)		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define	IMR_RXERR_8703B					BIT(10)		/* Rx Error Flag INT Status, Write 1 clear */
#define	IMR_TXFOVW_8703B					BIT(9)			/* Transmit FIFO Overflow */
#define	IMR_RXFOVW_8703B					BIT(8)			/* Receive FIFO Overflow */

#ifdef CONFIG_PCI_HCI
	/* #define IMR_RX_MASK		(IMR_ROK_8703B|IMR_RDU_8703B|IMR_RXFOVW_8703B) */
	#define IMR_TX_MASK			(IMR_VODOK_8703B | IMR_VIDOK_8703B | IMR_BEDOK_8703B | IMR_BKDOK_8703B | IMR_MGNTDOK_8703B | IMR_HIGHDOK_8703B)

	#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8703B | IMR_TXBCN0OK_8703B | IMR_TXBCN0ERR_8703B | IMR_BCNDERR0_8703B)

	#define RT_AC_INT_MASKS	(IMR_VIDOK_8703B | IMR_VODOK_8703B | IMR_BEDOK_8703B | IMR_BKDOK_8703B)
#endif

#endif /* __RTL8703B_SPEC_H__ */
                                   rtl8822bu/src/include/rtl8821c_spec.h                                                               0000644 0001750 0001750 00000016612 14214766567 016104  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8821C_SPEC_H__
#define __RTL8821C_SPEC_H__

#define EFUSE_MAP_SIZE		HALMAC_EFUSE_SIZE_8821C

/*
 * MAC Register definition
 */
#define REG_AFE_XTAL_CTRL			REG_AFE_CTRL1_8821C	/* hal_com.c & phydm */
#define REG_AFE_PLL_CTRL			REG_AFE_CTRL2_8821C	/* hal_com.c & phydm */
#define REG_MAC_PHY_CTRL			REG_AFE_CTRL3_8821C	/* phydm only */
#define REG_LEDCFG0					REG_LED_CFG_8821C	/* rtw_mp.c */
#define MSR							(REG_CR_8821C + 2)	/* rtw_mp.c */
#define MSR1						REG_CR_EXT_8821C	/* rtw_mp.c & hal_com.c */
#define REG_C2HEVT_MSG_NORMAL		0x1A0			/* hal_com.c */
#define REG_C2HEVT_CLEAR			0x1AF			/* hal_com.c */
#define REG_BCN_CTRL_1				REG_BCN_CTRL_CLINT0_8821C/* hal_com.c */

#define REG_WOWLAN_WAKE_REASON	0x01C7
#define REG_GPIO_PIN_CTRL_2			REG_GPIO_EXT_CTRL_8821C

/* RXERR_RPT, for rtw_mp.c */
#define RXERR_TYPE_OFDM_PPDU		0
#define RXERR_TYPE_OFDM_FALSE_ALARM	2
#define RXERR_TYPE_OFDM_MPDU_OK		0
#define RXERR_TYPE_OFDM_MPDU_FAIL	1
#define RXERR_TYPE_CCK_PPDU		3
#define RXERR_TYPE_CCK_FALSE_ALARM	5
#define RXERR_TYPE_CCK_MPDU_OK		3
#define RXERR_TYPE_CCK_MPDU_FAIL	4
#define RXERR_TYPE_HT_PPDU		8
#define RXERR_TYPE_HT_FALSE_ALARM	9
#define RXERR_TYPE_HT_MPDU_TOTAL	6
#define RXERR_TYPE_HT_MPDU_OK		6
#define RXERR_TYPE_HT_MPDU_FAIL		7
#define RXERR_TYPE_RX_FULL_DROP		10

#define RXERR_COUNTER_MASK		BIT_MASK_RPT_COUNTER_8821C
#define RXERR_RPT_RST			BIT_RXERR_RPT_RST_8821C
#define _RXERR_RPT_SEL(type)		(BIT_RXERR_RPT_SEL_V1_3_0_8821C(type) \
		| ((type & 0x10) ? BIT_RXERR_RPT_SEL_V1_4_8821C : 0))

/*
 * BB Register definition
 */
#define rPMAC_Reset				0x100	/* hal_mp.c */

#define rFPGA0_RFMOD				0x800
#define rFPGA0_TxInfo				0x804
#define rOFDMCCKEN_Jaguar		0x808	/* hal_mp.c */
#define rFPGA0_TxGainStage		0x80C	/* phydm only */
#define rFPGA0_XA_HSSIParameter1	0x820	/* hal_mp.c */
#define rFPGA0_XA_HSSIParameter2	0x824	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter1	0x828	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter2	0x82C	/* hal_mp.c */
#define rTxAGC_B_Rate18_06		0x830
#define rTxAGC_B_Rate54_24		0x834
#define rTxAGC_B_CCK1_55_Mcs32	0x838
#define rCCAonSec_Jaguar			0x838	/* hal_mp.c */
#define rTxAGC_B_Mcs03_Mcs00		0x83C
#define rTxAGC_B_Mcs07_Mcs04		0x848
#define rTxAGC_B_Mcs11_Mcs08		0x84C
#define rFPGA0_XA_RFInterfaceOE		0x860
#define rFPGA0_XB_RFInterfaceOE		0x864
#define rTxAGC_B_Mcs15_Mcs12		0x868
#define rTxAGC_B_CCK11_A_CCK2_11	0x86C
#define rFPGA0_XAB_RFInterfaceSW		0x870
#define rFPGA0_XAB_RFParameter		0x878
#define rFPGA0_AnalogParameter4		0x88C	/* hal_mp.c & phydm */
#define rFPGA0_XB_LSSIReadBack		0x8A4	/* phydm */
#define rHSSIRead_Jaguar				0x8B0	/* RF read addr (rtl8821c_phy.c) */

#define	rC_TxScale_Jaguar2			0x181C  /* Pah_C TX scaling factor (hal_mp.c) */
#define	rC_IGI_Jaguar2				0x1850	/* Initial Gain for path-C (hal_mp.c) */

#define rFPGA1_TxInfo					0x90C	/* hal_mp.c */
#define rSingleTone_ContTx_Jaguar		0x914	/* hal_mp.c */

#define rCCK0_System					0xA00
#define rCCK0_AFESetting				0xA04

#define rCCK0_DSPParameter2			0xA1C
#define rCCK0_TxFilter1				0xA20
#define rCCK0_TxFilter2				0xA24
#define rCCK0_DebugPort				0xA28
#define rCCK0_FalseAlarmReport		0xA2C

#define	rD_TxScale_Jaguar2			0x1A1C  /* Path_D TX scaling factor (hal_mp.c) */
#define	rD_IGI_Jaguar2				0x1A50	/* Initial Gain for path-D (hal_mp.c) */

#define rOFDM0_TRxPathEnable			0xC04
#define rOFDM0_TRMuxPar				0xC08
#define rA_TxScale_Jaguar				0xC1C	/* Pah_A TX scaling factor (hal_mp.c) */
#define rOFDM0_RxDetector1			0xC30	/* rtw_mp.c */
#define rOFDM0_ECCAThreshold			0xC4C	/* phydm only */
#define rOFDM0_XAAGCCore1			0xC50	/* phydm only */
#define rA_IGI_Jaguar					0xC50	/* Initial Gain for path-A (hal_mp.c) */
#define rOFDM0_XBAGCCore1			0xC58	/* phydm only */
#define rOFDM0_XATxIQImbalance		0xC80	/* phydm only */
#define rA_LSSIWrite_Jaguar			0xC90	/* RF write addr, LSSI Parameter (rtl8821c_phy.c) */
/* RFE */
#define rA_RFE_Pinmux_Jaguar	0xCB0	/* hal_mp.c */
#define	rB_RFE_Pinmux_Jaguar	0xEB0	/* Path_B RFE control pinmux */
#define	rA_RFE_Inv_Jaguar		0xCB4	/* Path_A RFE cotrol */  
#define	rB_RFE_Inv_Jaguar		0xEB4	/* Path_B RFE control */
#define	rA_RFE_Jaguar			0xCB8 	/* Path_A RFE cotrol */  
#define	rB_RFE_Jaguar			0xEB8	/* Path_B RFE control */
#define	rA_RFE_Inverse_Jaguar	0xCBC	/* Path_A RFE control inverse */
#define	rB_RFE_Inverse_Jaguar	0xEBC	/* Path_B RFE control inverse */
#define	r_ANTSEL_SW_Jaguar		0x900	/* ANTSEL SW Control */
#define	bMask_RFEInv_Jaguar	0x3FF00000
#define	bMask_AntselPathFollow_Jaguar 0x00030000   

#define rOFDM1_LSTF					0xD00
#define rOFDM1_TRxPathEnable			0xD04	/* hal_mp.c */
#define rA_PIRead_Jaguar				0xD04	/* RF readback with PI (rtl8821c_phy.c) */
#define rA_SIRead_Jaguar				0xD08	/* RF readback with SI (rtl8821c_phy.c) */
#define rB_PIRead_Jaguar				0xD44	/* RF readback with PI (rtl8821c_phy.c) */
#define rB_SIRead_Jaguar				0xD48	/* RF readback with SI (rtl8821c_phy.c) */

#define rTxAGC_A_Rate18_06			0xE00
#define rTxAGC_A_Rate54_24			0xE04
#define rTxAGC_A_CCK1_Mcs32			0xE08
#define rTxAGC_A_Mcs03_Mcs00		0xE10
#define rTxAGC_A_Mcs07_Mcs04		0xE14
#define rTxAGC_A_Mcs11_Mcs08		0xE18
#define rTxAGC_A_Mcs15_Mcs12		0xE1C
#define rB_TxScale_Jaguar				0xE1C	/* Path_B TX scaling factor (hal_mp.c) */
#define rB_IGI_Jaguar					0xE50	/* Initial Gain for path-B (hal_mp.c) */
#define rB_LSSIWrite_Jaguar			0xE90	/* RF write addr, LSSI Parameter (rtl8821c_phy.c) */

/* Page1(0x100) */
#define bBBResetB					0x100

/* Page8(0x800) */
#define bCCKEn						0x1000000
#define bOFDMEn						0x2000000
/* Reg 0x80C rFPGA0_TxGainStage */
#define bXBTxAGC						0xF00
#define bXCTxAGC						0xF000
#define bXDTxAGC						0xF0000

/* PageA(0xA00) */
#define bCCKBBMode					0x3

#define bCCKScramble					0x8
#define bCCKTxRate					0x3000

/* General */
#define bMaskByte0		0xFF		/* mp, rtw_odm.c & phydm */
#define bMaskByte1		0xFF00		/* hal_mp.c & phydm */
#define bMaskByte2		0xFF0000	/* hal_mp.c & phydm */
#define bMaskByte3		0xFF000000	/* hal_mp.c & phydm */
#define bMaskHWord		0xFFFF0000	/* hal_com.c, rtw_mp.c */
#define bMaskLWord		0x0000FFFF	/* mp, hal_com.c & phydm */
#define bMaskDWord		0xFFFFFFFF	/* mp, hal, rtw_odm.c & phydm */

#define bEnable			0x1		/* hal_mp.c, rtw_mp.c */
#define bDisable			0x0		/* rtw_mp.c */

#define MAX_STALL_TIME		50		/* unit: us, hal_com_phycfg.c */

#define Rx_Smooth_Factor		20		/* phydm only */

/*
 * RF Register definition
 */
#define RF_AC			0x00
#define RF_AC_Jaguar		0x00	/* hal_mp.c */
#define RF_CHNLBW		0x18	/* rtl8821c_phy.c */
#define RF_0x52			0x52

struct hw_port_reg {
	u32 net_type;	/*reg_offset*/
	u8 net_type_shift;
	u32 macaddr;		/*reg_offset*/
	u32 bssid;		/*reg_offset*/
	u32 bcn_ctl;			/*reg_offset*/
	u32 tsf_rst;			/*reg_offset*/
	u8 tsf_rst_bit;
	u32 bcn_space;		/*reg_offset*/
	u8 bcn_space_shift;
	u16 bcn_space_mask;
	u32	ps_aid;			/*reg_offset*/
	u32	ta;				/*reg_offset*/
};

#endif /* __RTL8192E_SPEC_H__ */
                                                                                                                      rtl8822bu/src/include/rtw_mem.h                                                                     0000644 0001750 0001750 00000002577 14214766567 015262  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_MEM_H__
#define __RTW_MEM_H__

#include <drv_conf.h>
#include <basic_types.h>
#include <osdep_service.h>

#ifdef CONFIG_SDIO_HCI
#define MAX_RTKM_RECVBUF_SZ		MAX_RECVBUF_SZ
#define MAX_RTKM_NR_PREALLOC_RECV_SKB	NR_RECVBUFF
#else /* !CONFIG_SDIO_HCI */
#ifdef CONFIG_PLATFORM_MSTAR_HIGH
	#define MAX_RTKM_RECVBUF_SZ (31744) /* 31k */
#else
	#define MAX_RTKM_RECVBUF_SZ (15360) /* 15k */
#endif /* CONFIG_PLATFORM_MSTAR_HIGH */
#define MAX_RTKM_NR_PREALLOC_RECV_SKB 16
#endif /* !CONFIG_SDIO_HCI */

u16 rtw_rtkm_get_buff_size(void);
u8 rtw_rtkm_get_nr_recv_skb(void);
struct u8 *rtw_alloc_revcbuf_premem(void);
struct sk_buff *rtw_alloc_skb_premem(u16 in_size);
int rtw_free_skb_premem(struct sk_buff *pskb);


#endif /* __RTW_MEM_H__ */
                                                                                                                                 rtl8822bu/src/include/rtw_rson.h                                                                    0000644 0001750 0001750 00000004714 14214766567 015460  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
 *
 *
 ******************************************************************************/
#ifndef __RTW_RSON_H_
#define __RTW_RSON_H_


#define RTW_RSON_VER						1

#define RTW_RSON_SCORE_NOTSUP			0x0
#define RTW_RSON_SCORE_NOTCNNT			0x1
#define RTW_RSON_SCORE_MAX				0xFF
#define RTW_RSON_HC_NOTREADY			0xFF
#define RTW_RSON_HC_ROOT				0x0
#define RTW_RSON_ALLOWCONNECT			0x1
#define RTW_RSON_DENYCONNECT			0x0



/*	for rtw self-origanization spec 1	*/
struct rtw_rson_struct {
	u8 ver;
	u32 id;
	u8 hopcnt;
	u8 connectible;
	u8 loading;
	u8 res[16];
} __attribute__((__packed__));

void init_rtw_rson_data(struct dvobj_priv *dvobj);
void rtw_rson_get_property_str(_adapter *padapter, char *rson_data_str);
int rtw_rson_set_property(_adapter *padapter, char *field, char *value);
int rtw_rson_choose(struct wlan_network **candidate, struct wlan_network *competitor);
int rtw_get_rson_struct(WLAN_BSSID_EX *bssid, struct  rtw_rson_struct *rson_data);
u8 rtw_cal_rson_score(struct rtw_rson_struct *cand_rson_data, NDIS_802_11_RSSI  Rssi);
void rtw_rson_handle_ie(WLAN_BSSID_EX *bssid, u8 ie_offset);
u32 rtw_rson_append_ie(_adapter *padapter, unsigned char *pframe, u32 *len);
void rtw_rson_do_disconnect(_adapter *padapter);
void rtw_rson_join_done(_adapter *padapter);
int rtw_rson_isupdate_roamcan(struct mlme_priv *mlme, struct wlan_network **candidate, struct wlan_network *competitor);
void rtw_rson_show_survey_info(struct seq_file *m, _list *plist, _list *phead);
u8 rtw_rson_ap_check_sta(_adapter *padapter, u8 *pframe, uint pkt_len, unsigned short ie_offset);
u8 rtw_rson_scan_wk_cmd(_adapter *padapter, int op);
void rtw_rson_scan_cmd_hdl(_adapter *padapter, int op);
#endif /* __RTW_RSON_H_ */
                                                    rtl8822bu/src/include/byteorder/                                                                    0000755 0001750 0001750 00000000000 14214766567 015423  5                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 rtl8822bu/src/include/byteorder/swabb.h                                                             0000644 0001750 0001750 00000007664 14214766567 016707  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _LINUX_BYTEORDER_SWABB_H
#define _LINUX_BYTEORDER_SWABB_H

/*
 * linux/byteorder/swabb.h
 * SWAp Bytes Bizarrely
 *	swaHHXX[ps]?(foo)
 *
 * Support for obNUXIous pdp-endian and other bizarre architectures.
 * Will Linux ever run on such ancient beasts? if not, this file
 * will be but a programming pearl. Still, it's a reminder that we
 * shouldn't be making too many assumptions when trying to be portable.
 *
 */

/*
 * Meaning of the names I chose (vaxlinux people feel free to correct them):
 * swahw32	swap 16-bit half-words in a 32-bit word
 * swahb32	swap 8-bit halves of each 16-bit half-word in a 32-bit word
 *
 * No 64-bit support yet. I don't know NUXI conventions for long longs.
 * I guarantee it will be a mess when it's there, though :->
 * It will be even worse if there are conflicting 64-bit conventions.
 * Hopefully, no one ever used 64-bit objects on NUXI machines.
 *
 */

#define ___swahw32(x) \
	({ \
		__u32 __x = (x); \
		((__u32)(\
			 (((__u32)(__x) & (__u32)0x0000ffffUL) << 16) | \
			 (((__u32)(__x) & (__u32)0xffff0000UL) >> 16))); \
	})
#define ___swahb32(x) \
	({ \
		__u32 __x = (x); \
		((__u32)(\
			 (((__u32)(__x) & (__u32)0x00ff00ffUL) << 8) | \
			 (((__u32)(__x) & (__u32)0xff00ff00UL) >> 8))); \
	})

#define ___constant_swahw32(x) \
	((__u32)(\
		 (((__u32)(x) & (__u32)0x0000ffffUL) << 16) | \
		 (((__u32)(x) & (__u32)0xffff0000UL) >> 16)))
#define ___constant_swahb32(x) \
	((__u32)(\
		 (((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | \
		 (((__u32)(x) & (__u32)0xff00ff00UL) >> 8)))

/*
 * provide defaults when no architecture-specific optimization is detected
 */
#ifndef __arch__swahw32
	#define __arch__swahw32(x) ___swahw32(x)
#endif
#ifndef __arch__swahb32
	#define __arch__swahb32(x) ___swahb32(x)
#endif

#ifndef __arch__swahw32p
	#define __arch__swahw32p(x) __swahw32(*(x))
#endif
#ifndef __arch__swahb32p
	#define __arch__swahb32p(x) __swahb32(*(x))
#endif

#ifndef __arch__swahw32s
	#define __arch__swahw32s(x) do { *(x) = __swahw32p((x)); } while (0)
#endif
#ifndef __arch__swahb32s
	#define __arch__swahb32s(x) do { *(x) = __swahb32p((x)); } while (0)
#endif


/*
 * Allow constant folding
 */
#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
#  define __swahw32(x) \
	(__builtin_constant_p((__u32)(x)) ? \
	 ___swahw32((x)) : \
	 __fswahw32((x)))
#  define __swahb32(x) \
	(__builtin_constant_p((__u32)(x)) ? \
	 ___swahb32((x)) : \
	 __fswahb32((x)))
#else
#  define __swahw32(x) __fswahw32(x)
#  define __swahb32(x) __fswahb32(x)
#endif /* OPTIMIZE */


__inline static__ __const__ __u32 __fswahw32(__u32 x)
{
	return __arch__swahw32(x);
}
__inline static__ __u32 __swahw32p(__u32 *x)
{
	return __arch__swahw32p(x);
}
__inline static__ void __swahw32s(__u32 *addr)
{
	__arch__swahw32s(addr);
}


__inline static__ __const__ __u32 __fswahb32(__u32 x)
{
	return __arch__swahb32(x);
}
__inline static__ __u32 __swahb32p(__u32 *x)
{
	return __arch__swahb32p(x);
}
__inline static__ void __swahb32s(__u32 *addr)
{
	__arch__swahb32s(addr);
}

#ifdef __BYTEORDER_HAS_U64__
	/*
	* Not supported yet
	*/
#endif /* __BYTEORDER_HAS_U64__ */

#if defined(PLATFORM_LINUX)
	#define swahw32 __swahw32
	#define swahb32 __swahb32
	#define swahw32p __swahw32p
	#define swahb32p __swahb32p
	#define swahw32s __swahw32s
	#define swahb32s __swahb32s
#endif

#endif /* _LINUX_BYTEORDER_SWABB_H */
                                                                            rtl8822bu/src/include/byteorder/little_endian.h                                                     0000644 0001750 0001750 00000006472 14214766567 020420  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H

#ifndef __LITTLE_ENDIAN
	#define __LITTLE_ENDIAN 1234
#endif
#ifndef __LITTLE_ENDIAN_BITFIELD
	#define __LITTLE_ENDIAN_BITFIELD
#endif

#include <byteorder/swab.h>

#ifndef __constant_htonl
	#define __constant_htonl(x) ___constant_swab32((x))
	#define __constant_ntohl(x) ___constant_swab32((x))
	#define __constant_htons(x) ___constant_swab16((x))
	#define __constant_ntohs(x) ___constant_swab16((x))
	#define __constant_cpu_to_le64(x) ((__u64)(x))
	#define __constant_le64_to_cpu(x) ((__u64)(x))
	#define __constant_cpu_to_le32(x) ((__u32)(x))
	#define __constant_le32_to_cpu(x) ((__u32)(x))
	#define __constant_cpu_to_le16(x) ((__u16)(x))
	#define __constant_le16_to_cpu(x) ((__u16)(x))
	#define __constant_cpu_to_be64(x) ___constant_swab64((x))
	#define __constant_be64_to_cpu(x) ___constant_swab64((x))
	#define __constant_cpu_to_be32(x) ___constant_swab32((x))
	#define __constant_be32_to_cpu(x) ___constant_swab32((x))
	#define __constant_cpu_to_be16(x) ___constant_swab16((x))
	#define __constant_be16_to_cpu(x) ___constant_swab16((x))
	#define __cpu_to_le64(x) ((__u64)(x))
	#define __le64_to_cpu(x) ((__u64)(x))
	#define __cpu_to_le32(x) ((__u32)(x))
	#define __le32_to_cpu(x) ((__u32)(x))
	#define __cpu_to_le16(x) ((__u16)(x))
	#define __le16_to_cpu(x) ((__u16)(x))
	#define __cpu_to_be64(x) __swab64((x))
	#define __be64_to_cpu(x) __swab64((x))
	#define __cpu_to_be32(x) __swab32((x))
	#define __be32_to_cpu(x) __swab32((x))
	#define __cpu_to_be16(x) __swab16((x))
	#define __be16_to_cpu(x) __swab16((x))
	#define __cpu_to_le64p(x) (*(__u64 *)(x))
	#define __le64_to_cpup(x) (*(__u64 *)(x))
	#define __cpu_to_le32p(x) (*(__u32 *)(x))
	#define __le32_to_cpup(x) (*(__u32 *)(x))
	#define __cpu_to_le16p(x) (*(__u16 *)(x))
	#define __le16_to_cpup(x) (*(__u16 *)(x))
	#define __cpu_to_be64p(x) __swab64p((x))
	#define __be64_to_cpup(x) __swab64p((x))
	#define __cpu_to_be32p(x) __swab32p((x))
	#define __be32_to_cpup(x) __swab32p((x))
	#define __cpu_to_be16p(x) __swab16p((x))
	#define __be16_to_cpup(x) __swab16p((x))
	#define __cpu_to_le64s(x) do {} while (0)
	#define __le64_to_cpus(x) do {} while (0)
	#define __cpu_to_le32s(x) do {} while (0)
	#define __le32_to_cpus(x) do {} while (0)
	#define __cpu_to_le16s(x) do {} while (0)
	#define __le16_to_cpus(x) do {} while (0)
	#define __cpu_to_be64s(x) __swab64s((x))
	#define __be64_to_cpus(x) __swab64s((x))
	#define __cpu_to_be32s(x) __swab32s((x))
	#define __be32_to_cpus(x) __swab32s((x))
	#define __cpu_to_be16s(x) __swab16s((x))
	#define __be16_to_cpus(x) __swab16s((x))
#endif /* __constant_htonl */

#include <byteorder/generic.h>

#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
                                                                                                                                                                                                      rtl8822bu/src/include/byteorder/big_endian.h                                                        0000644 0001750 0001750 00000006216 14214766567 017660  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
#define _LINUX_BYTEORDER_BIG_ENDIAN_H

#ifndef __BIG_ENDIAN
	#define __BIG_ENDIAN 4321
#endif
#ifndef __BIG_ENDIAN_BITFIELD
	#define __BIG_ENDIAN_BITFIELD
#endif

#include <byteorder/swab.h>

#define __constant_htonl(x) ((__u32)(x))
#define __constant_ntohl(x) ((__u32)(x))
#define __constant_htons(x) ((__u16)(x))
#define __constant_ntohs(x) ((__u16)(x))
#define __constant_cpu_to_le64(x) ___constant_swab64((x))
#define __constant_le64_to_cpu(x) ___constant_swab64((x))
#define __constant_cpu_to_le32(x) ___constant_swab32((x))
#define __constant_le32_to_cpu(x) ___constant_swab32((x))
#define __constant_cpu_to_le16(x) ___constant_swab16((x))
#define __constant_le16_to_cpu(x) ___constant_swab16((x))
#define __constant_cpu_to_be64(x) ((__u64)(x))
#define __constant_be64_to_cpu(x) ((__u64)(x))
#define __constant_cpu_to_be32(x) ((__u32)(x))
#define __constant_be32_to_cpu(x) ((__u32)(x))
#define __constant_cpu_to_be16(x) ((__u16)(x))
#define __constant_be16_to_cpu(x) ((__u16)(x))
#define __cpu_to_le64(x) __swab64((x))
#define __le64_to_cpu(x) __swab64((x))
#define __cpu_to_le32(x) __swab32((x))
#define __le32_to_cpu(x) __swab32((x))
#define __cpu_to_le16(x) __swab16((x))
#define __le16_to_cpu(x) __swab16((x))
#define __cpu_to_be64(x) ((__u64)(x))
#define __be64_to_cpu(x) ((__u64)(x))
#define __cpu_to_be32(x) ((__u32)(x))
#define __be32_to_cpu(x) ((__u32)(x))
#define __cpu_to_be16(x) ((__u16)(x))
#define __be16_to_cpu(x) ((__u16)(x))
#define __cpu_to_le64p(x) __swab64p((x))
#define __le64_to_cpup(x) __swab64p((x))
#define __cpu_to_le32p(x) __swab32p((x))
#define __le32_to_cpup(x) __swab32p((x))
#define __cpu_to_le16p(x) __swab16p((x))
#define __le16_to_cpup(x) __swab16p((x))
#define __cpu_to_be64p(x) (*(__u64 *)(x))
#define __be64_to_cpup(x) (*(__u64 *)(x))
#define __cpu_to_be32p(x) (*(__u32 *)(x))
#define __be32_to_cpup(x) (*(__u32 *)(x))
#define __cpu_to_be16p(x) (*(__u16 *)(x))
#define __be16_to_cpup(x) (*(__u16 *)(x))
#define __cpu_to_le64s(x) __swab64s((x))
#define __le64_to_cpus(x) __swab64s((x))
#define __cpu_to_le32s(x) __swab32s((x))
#define __le32_to_cpus(x) __swab32s((x))
#define __cpu_to_le16s(x) __swab16s((x))
#define __le16_to_cpus(x) __swab16s((x))
#define __cpu_to_be64s(x) do {} while (0)
#define __be64_to_cpus(x) do {} while (0)
#define __cpu_to_be32s(x) do {} while (0)
#define __be32_to_cpus(x) do {} while (0)
#define __cpu_to_be16s(x) do {} while (0)
#define __be16_to_cpus(x) do {} while (0)

#include <byteorder/generic.h>

#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/include/byteorder/swab.h                                                              0000644 0001750 0001750 00000006310 14214766567 016530  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _LINUX_BYTEORDER_SWAB_H
#define _LINUX_BYTEORDER_SWAB_H

#if !defined(CONFIG_PLATFORM_MSTAR)
#ifndef __u16
	typedef unsigned short __u16;
#endif

#ifndef __u32
	typedef unsigned int	__u32;
#endif

#ifndef __u8
	typedef unsigned char __u8;
#endif

#ifndef __u64
	typedef unsigned long long	__u64;
#endif


__inline static __u16  ___swab16(__u16 x)
{
	__u16 __x = x;
	return
		 (__u16)(
			 (((__u16)(__x)&(__u16)0x00ffU) << 8) |
			 (((__u16)(__x)&(__u16)0xff00U) >> 8));

}

__inline static __u32  ___swab32(__u32 x)
{
	__u32 __x = (x);
	return  (__u32)(
			(((__u32)(__x)&(__u32)0x000000ffUL) << 24) |
			(((__u32)(__x)&(__u32)0x0000ff00UL) <<  8) |
			(((__u32)(__x)&(__u32)0x00ff0000UL) >>  8) |
			(((__u32)(__x)&(__u32)0xff000000UL) >> 24));
}

__inline static __u64  ___swab64(__u64 x)
{
	__u64 __x = (x);

	return
		 (__u64)(\
		 (__u64)(((__u64)(__x)&(__u64)0x00000000000000ffULL) << 56) | \
		 (__u64)(((__u64)(__x)&(__u64)0x000000000000ff00ULL) << 40) | \
		 (__u64)(((__u64)(__x)&(__u64)0x0000000000ff0000ULL) << 24) | \
		 (__u64)(((__u64)(__x)&(__u64)0x00000000ff000000ULL) <<  8) | \
		 (__u64)(((__u64)(__x)&(__u64)0x000000ff00000000ULL) >>  8) | \
		 (__u64)(((__u64)(__x)&(__u64)0x0000ff0000000000ULL) >> 24) | \
		 (__u64)(((__u64)(__x)&(__u64)0x00ff000000000000ULL) >> 40) | \
		 (__u64)(((__u64)(__x)&(__u64)0xff00000000000000ULL) >> 56));
	\
}
#endif /* CONFIG_PLATFORM_MSTAR */

#ifndef __arch__swab16
__inline static __u16 __arch__swab16(__u16 x)
{
	return ___swab16(x);
}

#endif

#ifndef __arch__swab32
__inline static __u32 __arch__swab32(__u32 x)
{
	__u32 __tmp = (x) ;
	return ___swab32(__tmp);
}
#endif

#ifndef __arch__swab64

__inline static __u64 __arch__swab64(__u64 x)
{
	__u64 __tmp = (x) ;
	return ___swab64(__tmp);
}


#endif

#ifndef __swab16
	#define __swab16(x) __fswab16(x)
	#define __swab32(x) __fswab32(x)
	#define __swab64(x) __fswab64(x)
#endif /* __swab16 */

#ifdef PLATFORM_FREEBSD
	__inline static __u16 __fswab16(__u16 x)
#else
	__inline static const __u16 __fswab16(__u16 x)
#endif /* PLATFORM_FREEBSD */
{
	return __arch__swab16(x);
}
#ifdef PLATFORM_FREEBSD
	__inline static __u32 __fswab32(__u32 x)
#else
	__inline static const __u32 __fswab32(__u32 x)
#endif /* PLATFORM_FREEBSD */
{
	return __arch__swab32(x);
}

#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS)
	#define swab16 __swab16
	#define swab32 __swab32
	#define swab64 __swab64
	#define swab16p __swab16p
	#define swab32p __swab32p
	#define swab64p __swab64p
	#define swab16s __swab16s
	#define swab32s __swab32s
	#define swab64s __swab64s
#endif

#endif /* _LINUX_BYTEORDER_SWAB_H */
                                                                                                                                                                                                                                                                                                                        rtl8822bu/src/include/byteorder/generic.h                                                           0000644 0001750 0001750 00000016011 14214766567 017207  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _LINUX_BYTEORDER_GENERIC_H
#define _LINUX_BYTEORDER_GENERIC_H

/*
 * linux/byteorder_generic.h
 * Generic Byte-reordering support
 *
 * Francois-Rene Rideau <fare@tunes.org> 19970707
 *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
 *    cleaned them up.
 *    I hope it is compliant with non-GCC compilers.
 *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
 *    because I wasn't sure it would be ok to put it in types.h
 *    Upgraded it to 2.1.43
 * Francois-Rene Rideau <fare@tunes.org> 19971012
 *    Upgraded it to 2.1.57
 *    to please Linus T., replaced huge #ifdef's between little/big endian
 *    by nestedly #include'd files.
 * Francois-Rene Rideau <fare@tunes.org> 19971205
 *    Made it to 2.1.71; now a facelift:
 *    Put files under include/linux/byteorder/
 *    Split swab from generic support.
 *
 * TODO:
 *   = Regular kernel maintainers could also replace all these manual
 *    byteswap macros that remain, disseminated among drivers,
 *    after some grep or the sources...
 *   = Linus might want to rename all these macros and files to fit his taste,
 *    to fit his personal naming scheme.
 *   = it seems that a few drivers would also appreciate
 *    nybble swapping support...
 *   = every architecture could add their byteswap macro in asm/byteorder.h
 *    see how some architectures already do (i386, alpha, ppc, etc)
 *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
 *    distinguished throughout the kernel. This is not the case currently,
 *    since little endian, big endian, and pdp endian machines needn't it.
 *    But this might be the case for, say, a port of Linux to 20/21 bit
 *    architectures (and F21 Linux addict around?).
 */

/*
 * The following macros are to be defined by <asm/byteorder.h>:
 *
 * Conversion of long and short int between network and host format
 *	ntohl(__u32 x)
 *	ntohs(__u16 x)
 *	htonl(__u32 x)
 *	htons(__u16 x)
 * It seems that some programs (which? where? or perhaps a standard? POSIX?)
 * might like the above to be functions, not macros (why?).
 * if that's true, then detect them, and take measures.
 * Anyway, the measure is: define only ___ntohl as a macro instead,
 * and in a separate file, have
 * unsigned long inline ntohl(x){return ___ntohl(x);}
 *
 * The same for constant arguments
 *	__constant_ntohl(__u32 x)
 *	__constant_ntohs(__u16 x)
 *	__constant_htonl(__u32 x)
 *	__constant_htons(__u16 x)
 *
 * Conversion of XX-bit integers (16- 32- or 64-)
 * between native CPU format and little/big endian format
 * 64-bit stuff only defined for proper architectures
 *	cpu_to_[bl]eXX(__uXX x)
 *	[bl]eXX_to_cpu(__uXX x)
 *
 * The same, but takes a pointer to the value to convert
 *	cpu_to_[bl]eXXp(__uXX x)
 *	[bl]eXX_to_cpup(__uXX x)
 *
 * The same, but change in situ
 *	cpu_to_[bl]eXXs(__uXX x)
 *	[bl]eXX_to_cpus(__uXX x)
 *
 * See asm-foo/byteorder.h for examples of how to provide
 * architecture-optimized versions
 *
 */


#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL) || defined(PLATFORM_FREEBSD)
	/*
	* inside the kernel, we can use nicknames;
	* outside of it, we must avoid POSIX namespace pollution...
	*/
	#define cpu_to_le64 __cpu_to_le64
	#define le64_to_cpu __le64_to_cpu
	#define cpu_to_le32 __cpu_to_le32
	#define le32_to_cpu __le32_to_cpu
	#define cpu_to_le16 __cpu_to_le16
	#define le16_to_cpu __le16_to_cpu
	#define cpu_to_be64 __cpu_to_be64
	#define be64_to_cpu __be64_to_cpu
	#define cpu_to_be32 __cpu_to_be32
	#define be32_to_cpu __be32_to_cpu
	#define cpu_to_be16 __cpu_to_be16
	#define be16_to_cpu __be16_to_cpu
	#define cpu_to_le64p __cpu_to_le64p
	#define le64_to_cpup __le64_to_cpup
	#define cpu_to_le32p __cpu_to_le32p
	#define le32_to_cpup __le32_to_cpup
	#define cpu_to_le16p __cpu_to_le16p
	#define le16_to_cpup __le16_to_cpup
	#define cpu_to_be64p __cpu_to_be64p
	#define be64_to_cpup __be64_to_cpup
	#define cpu_to_be32p __cpu_to_be32p
	#define be32_to_cpup __be32_to_cpup
	#define cpu_to_be16p __cpu_to_be16p
	#define be16_to_cpup __be16_to_cpup
	#define cpu_to_le64s __cpu_to_le64s
	#define le64_to_cpus __le64_to_cpus
	#define cpu_to_le32s __cpu_to_le32s
	#define le32_to_cpus __le32_to_cpus
	#define cpu_to_le16s __cpu_to_le16s
	#define le16_to_cpus __le16_to_cpus
	#define cpu_to_be64s __cpu_to_be64s
	#define be64_to_cpus __be64_to_cpus
	#define cpu_to_be32s __cpu_to_be32s
	#define be32_to_cpus __be32_to_cpus
	#define cpu_to_be16s __cpu_to_be16s
	#define be16_to_cpus __be16_to_cpus
#endif


/*
 * Handle ntohl and suches. These have various compatibility
 * issues - like we want to give the prototype even though we
 * also have a macro for them in case some strange program
 * wants to take the address of the thing or something..
 *
 * Note that these used to return a "long" in libc5, even though
 * long is often 64-bit these days.. Thus the casts.
 *
 * They have to be macros in order to do the constant folding
 * correctly - if the argument passed into a inline function
 * it is no longer constant according to gcc..
 */

#undef ntohl
#undef ntohs
#undef htonl
#undef htons

/*
 * Do the prototypes. Somebody might want to take the
 * address or some such sick thing..
 */
#if defined(PLATFORM_LINUX) || (defined(__GLIBC__) && __GLIBC__ >= 2)
	extern __u32			ntohl(__u32);
	extern __u32			htonl(__u32);
#else /* defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2) */
	#ifndef PLATFORM_FREEBSD
		extern unsigned long int	ntohl(unsigned long int);
		extern unsigned long int	htonl(unsigned long int);
	#endif
#endif
#ifndef PLATFORM_FREEBSD
	extern unsigned short int	ntohs(unsigned short int);
	extern unsigned short int	htons(unsigned short int);
#endif

#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) || defined(PLATFORM_MPIXEL)

	#define ___htonl(x) __cpu_to_be32(x)
	#define ___htons(x) __cpu_to_be16(x)
	#define ___ntohl(x) __be32_to_cpu(x)
	#define ___ntohs(x) __be16_to_cpu(x)

	#if defined(PLATFORM_LINUX) || (defined(__GLIBC__) && __GLIBC__ >= 2)
		#define htonl(x) ___htonl(x)
		#define ntohl(x) ___ntohl(x)
	#else
		#define htonl(x) ((unsigned long)___htonl(x))
		#define ntohl(x) ((unsigned long)___ntohl(x))
	#endif
	#define htons(x) ___htons(x)
	#define ntohs(x) ___ntohs(x)

#endif /* OPTIMIZE */


#if defined(PLATFORM_WINDOWS)

	#define htonl(x) __cpu_to_be32(x)
	#define ntohl(x) __be32_to_cpu(x)
	#define htons(x) __cpu_to_be16(x)
	#define ntohs(x) __be16_to_cpu(x)


#endif

#endif /* _LINUX_BYTEORDER_GENERIC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/wlan_bssdef.h                                                                 0000644 0001750 0001750 00000023671 14214766567 016075  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __WLAN_BSSDEF_H__
#define __WLAN_BSSDEF_H__


#define MAX_IE_SZ	768


#ifdef PLATFORM_LINUX

#define NDIS_802_11_LENGTH_SSID         32
#define NDIS_802_11_LENGTH_RATES        8
#define NDIS_802_11_LENGTH_RATES_EX     16

typedef unsigned char   NDIS_802_11_MAC_ADDRESS[ETH_ALEN];
typedef long    		NDIS_802_11_RSSI;           /* in dBm */
typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        /* Set of 8 data rates */
typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  /* Set of 16 data rates */

typedef struct _NDIS_802_11_SSID {
	u32  SsidLength;
	u8  Ssid[32];
} NDIS_802_11_SSID, *PNDIS_802_11_SSID;

/*
	FW will only save the channel number in DSConfig.
	ODI Handler will convert the channel number to freq. number.
*/
typedef struct _NDIS_802_11_CONFIGURATION {
	u32           Length;             /* Length of structure */
	u32           BeaconPeriod;       /* units are Kusec */
	u32           ATIMWindow;         /* units are Kusec */
	u32           DSConfig;           /* channel number */
} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;

typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
	Ndis802_11IBSS,
	Ndis802_11Infrastructure,
	Ndis802_11AutoUnknown,
	Ndis802_11InfrastructureMax,     /* Not a real value, defined as upper bound */
	Ndis802_11APMode,
	Ndis802_11Monitor,
	Ndis802_11_mesh,
} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;

typedef struct _NDIS_802_11_FIXED_IEs {
	u8  Timestamp[8];
	u16  BeaconInterval;
	u16  Capabilities;
} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;

typedef struct _NDIS_802_11_VARIABLE_IEs {
	u8  ElementID;
	u8  Length;
	u8  data[1];
} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;

typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
	Ndis802_11AuthModeOpen,
	Ndis802_11AuthModeShared,
	Ndis802_11AuthModeAutoSwitch,
	Ndis802_11AuthModeWPA,
	Ndis802_11AuthModeWPAPSK,
	Ndis802_11AuthModeWPANone,
	Ndis802_11AuthModeWAPI,
	Ndis802_11AuthModeMax               /* Not a real mode, defined as upper bound */
} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;

typedef enum _NDIS_802_11_WEP_STATUS {
	Ndis802_11WEPEnabled,
	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
	Ndis802_11WEPDisabled,
	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
	Ndis802_11WEPKeyAbsent,
	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
	Ndis802_11WEPNotSupported,
	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
	Ndis802_11Encryption2Enabled,
	Ndis802_11Encryption2KeyAbsent,
	Ndis802_11Encryption3Enabled,
	Ndis802_11Encryption3KeyAbsent,
	Ndis802_11_EncrypteionWAPI
} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;

typedef struct _NDIS_802_11_WEP {
	u32     Length;        /* Length of this structure */
	u32     KeyIndex;      /* 0 is the per-client key, 1-N are the global keys */
	u32     KeyLength;     /* length of key in bytes */
	u8     KeyMaterial[16];/* variable length depending on above field */
} NDIS_802_11_WEP, *PNDIS_802_11_WEP;

#endif /* end of #ifdef PLATFORM_LINUX */

#ifdef PLATFORM_FREEBSD

#define NDIS_802_11_LENGTH_SSID         32
#define NDIS_802_11_LENGTH_RATES        8
#define NDIS_802_11_LENGTH_RATES_EX     16

typedef unsigned char   NDIS_802_11_MAC_ADDRESS[ETH_ALEN];
typedef long    		NDIS_802_11_RSSI;           /* in dBm */
typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        /* Set of 8 data rates */
typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  /* Set of 16 data rates */


typedef struct _NDIS_802_11_SSID {
	u32  SsidLength;
	u8  Ssid[32];
} NDIS_802_11_SSID, *PNDIS_802_11_SSID;

/*
	FW will only save the channel number in DSConfig.
	ODI Handler will convert the channel number to freq. number.
*/
typedef struct _NDIS_802_11_CONFIGURATION {
	u32           Length;             /* Length of structure */
	u32           BeaconPeriod;       /* units are Kusec */
	u32           ATIMWindow;         /* units are Kusec */
	u32           DSConfig;           /* channel number */
} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;

typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
	Ndis802_11IBSS,
	Ndis802_11Infrastructure,
	Ndis802_11AutoUnknown,
	Ndis802_11InfrastructureMax,     /* Not a real value, defined as upper bound */
	Ndis802_11APMode
} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;

typedef struct _NDIS_802_11_FIXED_IEs {
	u8  Timestamp[8];
	u16  BeaconInterval;
	u16  Capabilities;
} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;

typedef struct _NDIS_802_11_VARIABLE_IEs {
	u8  ElementID;
	u8  Length;
	u8  data[1];
} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;

typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
	Ndis802_11AuthModeOpen,
	Ndis802_11AuthModeShared,
	Ndis802_11AuthModeAutoSwitch,
	Ndis802_11AuthModeWPA,
	Ndis802_11AuthModeWPAPSK,
	Ndis802_11AuthModeWPANone,
	Ndis802_11AuthModeMax               /* Not a real mode, defined as upper bound */
} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;

typedef enum _NDIS_802_11_WEP_STATUS {
	Ndis802_11WEPEnabled,
	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
	Ndis802_11WEPDisabled,
	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
	Ndis802_11WEPKeyAbsent,
	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
	Ndis802_11WEPNotSupported,
	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
	Ndis802_11Encryption2Enabled,
	Ndis802_11Encryption2KeyAbsent,
	Ndis802_11Encryption3Enabled,
	Ndis802_11Encryption3KeyAbsent
} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;


typedef struct _NDIS_802_11_WEP {
	u32     Length;        /* Length of this structure */
	u32     KeyIndex;      /* 0 is the per-client key, 1-N are the global keys */
	u32     KeyLength;     /* length of key in bytes */
	u8     KeyMaterial[16];/* variable length depending on above field */
} NDIS_802_11_WEP, *PNDIS_802_11_WEP;

#endif /* PLATFORM_FREEBSD */

#ifndef Ndis802_11APMode
#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
#endif

typedef struct _WLAN_PHY_INFO {
	u8	SignalStrength;/* (in percentage) */
	u8	SignalQuality;/* (in percentage) */
	u8	Optimum_antenna;  /* for Antenna diversity */
	u8	is_cck_rate;	/* 1:cck_rate */
	s8	rx_snr[4];
#ifdef CONFIG_RTW_80211K
	u32	free_cnt; 	/* freerun counter */
	u8	rm_en_cap[5];
#endif
} WLAN_PHY_INFO, *PWLAN_PHY_INFO;

typedef struct _WLAN_BCN_INFO {
	/* these infor get from rtw_get_encrypt_info when
	 *	 * translate scan to UI */
	u8 encryp_protocol;/* ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI */
	int group_cipher; /* WPA/WPA2 group cipher */
	int pairwise_cipher;/* //WPA/WPA2/WEP pairwise cipher */
	int is_8021x;

	/* bwmode 20/40 and ch_offset UP/LOW */
	unsigned short	ht_cap_info;
	unsigned char	ht_info_infos_0;
} WLAN_BCN_INFO, *PWLAN_BCN_INFO;

enum bss_type {
	BSS_TYPE_UNDEF,
	BSS_TYPE_PROB_REQ = 1,
	BSS_TYPE_BCN = 2,
	BSS_TYPE_PROB_RSP = 3,
};

/* temporally add #pragma pack for structure alignment issue of
*   WLAN_BSSID_EX and get_WLAN_BSSID_EX_sz()
*/
typedef struct _WLAN_BSSID_EX {
	u32  Length;
	NDIS_802_11_MAC_ADDRESS  MacAddress;
	u8  Reserved[2];/* [0]: IS beacon frame , bss_type*/
	NDIS_802_11_SSID  Ssid;
	NDIS_802_11_SSID  mesh_id;
	u32  Privacy;
	NDIS_802_11_RSSI  Rssi;/* (in dBM,raw data ,get from PHY) */
	NDIS_802_11_CONFIGURATION  Configuration;
	NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
	NDIS_802_11_RATES_EX  SupportedRates;
	WLAN_PHY_INFO	PhyInfo;
	u32  IELength;
	u8  IEs[MAX_IE_SZ];	/* (timestamp, beacon interval, and capability information) */
}
__attribute__((packed)) WLAN_BSSID_EX, *PWLAN_BSSID_EX;

#define BSS_EX_IES(bss_ex) ((bss_ex)->IEs)
#define BSS_EX_IES_LEN(bss_ex) ((bss_ex)->IELength)
#define BSS_EX_FIXED_IE_OFFSET(bss_ex) ((bss_ex)->Reserved[0] == BSS_TYPE_PROB_REQ ? 0 : 12)
#define BSS_EX_TLV_IES(bss_ex) (BSS_EX_IES((bss_ex)) + BSS_EX_FIXED_IE_OFFSET((bss_ex)))
#define BSS_EX_TLV_IES_LEN(bss_ex) (BSS_EX_IES_LEN((bss_ex)) - BSS_EX_FIXED_IE_OFFSET((bss_ex)))

__inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
{
	return sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + bss->IELength;
}

struct beacon_keys {
	u8 ssid[IW_ESSID_MAX_SIZE];
	u32 ssid_len;
	u8 ch;
	u8 bw;
	u8 offset;
	u8 proto_cap; /* PROTO_CAP_XXX */
	u8 rate_set[12];
	u8 rate_num;
	int encryp_protocol;
	int pairwise_cipher;
	int group_cipher;
	u32 akm;
};

struct	wlan_network {
	_list	list;
	int	network_type;	/* refer to ieee80211.h for WIRELESS_11A/B/G */
	int	fixed;			/* set to fixed when not to be removed as site-surveying */
	systime last_scanned; /* timestamp for the network */
	systime last_non_hidden_ssid_ap;
#ifdef CONFIG_RTW_MESH
#if CONFIG_RTW_MESH_ACNODE_PREVENT
	systime acnode_stime;
	systime acnode_notify_etime;
#endif
#endif
	int	aid;			/* will only be valid when a BSS is joinned. */
	int	join_res;
	struct beacon_keys bcn_keys;
	bool bcn_keys_valid;
	WLAN_BSSID_EX	network; /* must be the last item */
};

enum VRTL_CARRIER_SENSE {
	DISABLE_VCS,
	ENABLE_VCS,
	AUTO_VCS
};

enum VCS_TYPE {
	NONE_VCS,
	RTS_CTS,
	CTS_TO_SELF
};




#define PWR_CAM 0
#define PWR_MINPS 1
#define PWR_MAXPS 2
#define PWR_UAPSD 3
#define PWR_VOIP 4


enum UAPSD_MAX_SP {
	NO_LIMIT,
	TWO_MSDU,
	FOUR_MSDU,
	SIX_MSDU
};


/* john */
#define NUM_PRE_AUTH_KEY 16
#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY

#endif /* #ifndef WLAN_BSSDEF_H_ */
                                                                       rtl8822bu/src/include/rtl8188e_dm.h                                                                 0000644 0001750 0001750 00000002016 14214766567 015553  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_DM_H__
#define __RTL8188E_DM_H__

void rtl8188e_init_dm_priv(PADAPTER Adapter);
void rtl8188e_deinit_dm_priv(PADAPTER Adapter);
void rtl8188e_InitHalDm(PADAPTER Adapter);
void rtl8188e_HalDmWatchDog(PADAPTER Adapter);

/* void rtl8192c_dm_CheckTXPowerTracking(PADAPTER Adapter); */

/* void rtl8192c_dm_RF_Saving(PADAPTER pAdapter, u8 bForceInNormal); */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/include/rtl8822b_hal.h                                                                0000644 0001750 0001750 00000021142 14214766567 015710  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822B_HAL_H_
#define _RTL8822B_HAL_H_

#include <osdep_service.h>		/* BIT(x) */
#include <drv_types.h>			/* PADAPTER */
#include "../hal/halmac/halmac_api.h"	/* MAC REG definition */


#ifdef CONFIG_SUPPORT_TRX_SHARED
#define MAX_RECVBUF_SZ		46080	/* 45KB, TX: (256-64)KB */
#else /* !CONFIG_SUPPORT_TRX_SHARED */
#ifdef CONFIG_PCI_HCI
#define MAX_RECVBUF_SZ		12288	/* 12KB */
#else
#define MAX_RECVBUF_SZ		24576	/* 24KB, TX: 256KB */
#endif /* !CONFIG_PCI_HCI */
#endif /* !CONFIG_SUPPORT_TRX_SHARED */

/*
 * MAC Register definition
 */
#define REG_AFE_XTAL_CTRL	REG_AFE_CTRL1_8822B	/* hal_com.c & phydm */
#define REG_AFE_PLL_CTRL	REG_AFE_CTRL2_8822B	/* hal_com.c & phydm */
#define REG_MAC_PHY_CTRL	REG_AFE_CTRL3_8822B	/* phydm only */
#define REG_LEDCFG0		REG_LED_CFG_8822B	/* rtw_mp.c */
#define MSR			(REG_CR_8822B + 2)	/* rtw_mp.c & hal_com.c */
#define MSR1			REG_CR_EXT_8822B	/* rtw_mp.c & hal_com.c */
#define REG_C2HEVT_MSG_NORMAL	0x1A0			/* hal_com.c */
#define REG_C2HEVT_CLEAR	0x1AF			/* hal_com.c */
#define REG_BCN_CTRL_1		REG_BCN_CTRL_CLINT0_8822B	/* hal_com.c */

#define REG_WOWLAN_WAKE_REASON	0x01C7 /* hal_com.c */
#define REG_GPIO_PIN_CTRL_2		REG_GPIO_EXT_CTRL_8822B		/* hal_com.c */

/* RXERR_RPT, for rtw_mp.c */
#define RXERR_TYPE_OFDM_PPDU		0
#define RXERR_TYPE_OFDM_FALSE_ALARM	2
#define RXERR_TYPE_OFDM_MPDU_OK		0
#define RXERR_TYPE_OFDM_MPDU_FAIL	1
#define RXERR_TYPE_CCK_PPDU		3
#define RXERR_TYPE_CCK_FALSE_ALARM	5
#define RXERR_TYPE_CCK_MPDU_OK		3
#define RXERR_TYPE_CCK_MPDU_FAIL	4
#define RXERR_TYPE_HT_PPDU		8
#define RXERR_TYPE_HT_FALSE_ALARM	9
#define RXERR_TYPE_HT_MPDU_TOTAL	6
#define RXERR_TYPE_HT_MPDU_OK		6
#define RXERR_TYPE_HT_MPDU_FAIL		7
#define RXERR_TYPE_RX_FULL_DROP		10

#define RXERR_COUNTER_MASK		BIT_MASK_RPT_COUNTER_8822B
#define RXERR_RPT_RST			BIT_RXERR_RPT_RST_8822B
#define _RXERR_RPT_SEL(type)		(BIT_RXERR_RPT_SEL_V1_3_0_8822B(type) \
					| ((type & 0x10) ? BIT_RXERR_RPT_SEL_V1_4_8822B : 0))

/*
 * BB Register definition
 */
#define rPMAC_Reset			0x100	/* hal_mp.c */

#define	rFPGA0_RFMOD			0x800
#define rFPGA0_TxInfo			0x804
#define rOFDMCCKEN_Jaguar		0x808	/* hal_mp.c */
#define rFPGA0_TxGainStage		0x80C	/* phydm only */
#define rFPGA0_XA_HSSIParameter1	0x820	/* hal_mp.c */
#define rFPGA0_XA_HSSIParameter2	0x824	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter1	0x828	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter2	0x82C	/* hal_mp.c */
#define rTxAGC_B_Rate18_06		0x830
#define rTxAGC_B_Rate54_24		0x834
#define rTxAGC_B_CCK1_55_Mcs32		0x838
#define rCCAonSec_Jaguar		0x838	/* hal_mp.c */
#define rTxAGC_B_Mcs03_Mcs00		0x83C
#define rTxAGC_B_Mcs07_Mcs04		0x848
#define rTxAGC_B_Mcs11_Mcs08		0x84C
#define rFPGA0_XA_RFInterfaceOE		0x860
#define rFPGA0_XB_RFInterfaceOE		0x864
#define rTxAGC_B_Mcs15_Mcs12		0x868
#define rTxAGC_B_CCK11_A_CCK2_11	0x86C
#define rFPGA0_XAB_RFInterfaceSW	0x870
#define rFPGA0_XAB_RFParameter		0x878
#define rFPGA0_AnalogParameter4		0x88C	/* hal_mp.c & phydm */
#define rFPGA0_XB_LSSIReadBack		0x8A4	/* phydm */
#define rHSSIRead_Jaguar		0x8B0	/* RF read addr (rtl8822b_phy.c) */

#define	rC_TxScale_Jaguar2		0x181C  /* Pah_C TX scaling factor (hal_mp.c) */
#define	rC_IGI_Jaguar2			0x1850	/* Initial Gain for path-C (hal_mp.c) */

#define rFPGA1_TxInfo			0x90C	/* hal_mp.c */
#define rSingleTone_ContTx_Jaguar	0x914	/* hal_mp.c */
/* TX BeamForming */
#define REG_BB_TX_PATH_SEL_1_8822B	0x93C	/* rtl8822b_phy.c */
#define REG_BB_TX_PATH_SEL_2_8822B	0x940	/* rtl8822b_phy.c */

/* TX BeamForming */
#define REG_BB_TXBF_ANT_SET_BF1_8822B	0x19AC	/* rtl8822b_phy.c */
#define REG_BB_TXBF_ANT_SET_BF0_8822B	0x19B4	/* rtl8822b_phy.c */

#define rCCK0_System			0xA00
#define rCCK0_AFESetting		0xA04

#define rCCK0_DSPParameter2		0xA1C
#define rCCK0_TxFilter1			0xA20
#define rCCK0_TxFilter2			0xA24
#define rCCK0_DebugPort			0xA28
#define rCCK0_FalseAlarmReport		0xA2C

#define	rD_TxScale_Jaguar2		0x1A1C  /* Path_D TX scaling factor (hal_mp.c) */
#define	rD_IGI_Jaguar2			0x1A50	/* Initial Gain for path-D (hal_mp.c) */

#define rOFDM0_TRxPathEnable		0xC04
#define rOFDM0_TRMuxPar			0xC08
#define rA_TxScale_Jaguar		0xC1C	/* Pah_A TX scaling factor (hal_mp.c) */
#define rOFDM0_RxDetector1		0xC30	/* rtw_mp.c */
#define rOFDM0_ECCAThreshold		0xC4C	/* phydm only */
#define rOFDM0_XAAGCCore1		0xC50	/* phydm only */
#define rA_IGI_Jaguar			0xC50	/* Initial Gain for path-A (hal_mp.c) */
#define rOFDM0_XBAGCCore1		0xC58	/* phydm only */
#define rOFDM0_XATxIQImbalance		0xC80	/* phydm only */
#define rA_LSSIWrite_Jaguar		0xC90	/* RF write addr, LSSI Parameter (rtl8822b_phy.c) */

#define rOFDM1_LSTF			0xD00
#define rOFDM1_TRxPathEnable		0xD04	/* hal_mp.c */
#define rA_PIRead_Jaguar		0xD04	/* RF readback with PI (rtl8822b_phy.c) */
#define rA_SIRead_Jaguar		0xD08	/* RF readback with SI (rtl8822b_phy.c) */
#define rB_PIRead_Jaguar		0xD44	/* RF readback with PI (rtl8822b_phy.c) */
#define rB_SIRead_Jaguar		0xD48	/* RF readback with SI (rtl8822b_phy.c) */

#define rTxAGC_A_Rate18_06		0xE00
#define rTxAGC_A_Rate54_24		0xE04
#define rTxAGC_A_CCK1_Mcs32		0xE08
#define rTxAGC_A_Mcs03_Mcs00		0xE10
#define rTxAGC_A_Mcs07_Mcs04		0xE14
#define rTxAGC_A_Mcs11_Mcs08		0xE18
#define rTxAGC_A_Mcs15_Mcs12		0xE1C
#define rB_TxScale_Jaguar		0xE1C	/* Path_B TX scaling factor (hal_mp.c) */
#define rB_IGI_Jaguar			0xE50	/* Initial Gain for path-B (hal_mp.c) */
#define rB_LSSIWrite_Jaguar		0xE90	/* RF write addr, LSSI Parameter (rtl8822b_phy.c) */
/* RFE */
#define rA_RFE_Pinmux_Jaguar	0xCB0	/* hal_mp.c */
#define	rB_RFE_Pinmux_Jaguar	0xEB0	/* Path_B RFE control pinmux */
#define	rA_RFE_Inv_Jaguar		0xCB4	/* Path_A RFE cotrol */  
#define	rB_RFE_Inv_Jaguar		0xEB4	/* Path_B RFE control */
#define	rA_RFE_Jaguar			0xCB8 	/* Path_A RFE cotrol */  
#define	rB_RFE_Jaguar			0xEB8	/* Path_B RFE control */
#define	rA_RFE_Inverse_Jaguar	0xCBC	/* Path_A RFE control inverse */
#define	rB_RFE_Inverse_Jaguar	0xEBC	/* Path_B RFE control inverse */
#define	r_ANTSEL_SW_Jaguar		0x900	/* ANTSEL SW Control */
#define	bMask_RFEInv_Jaguar	0x3FF00000
#define	bMask_AntselPathFollow_Jaguar 0x00030000

#define		rC_RFE_Pinmux_Jaguar	0x18B4	/* Path_C RFE cotrol pinmux*/
#define		rD_RFE_Pinmux_Jaguar	0x1AB4	/* Path_D RFE cotrol pinmux*/
#define		rA_RFE_Sel_Jaguar2		0x1990

/* Page1(0x100) */
#define bBBResetB			0x100

/* Page8(0x800) */
#define bCCKEn				0x1000000
#define bOFDMEn				0x2000000
/* Reg 0x80C rFPGA0_TxGainStage */
#define bXBTxAGC			0xF00
#define bXCTxAGC			0xF000
#define bXDTxAGC			0xF0000

/* PageA(0xA00) */
#define bCCKBBMode			0x3

#define bCCKScramble			0x8
#define bCCKTxRate			0x3000

/* General */
#define bMaskByte0		0xFF		/* mp, rtw_odm.c & phydm */
#define bMaskByte1		0xFF00		/* hal_mp.c & phydm */
#define bMaskByte2		0xFF0000	/* hal_mp.c & phydm */
#define bMaskByte3		0xFF000000	/* hal_mp.c & phydm */
#define bMaskHWord		0xFFFF0000	/* hal_com.c, rtw_mp.c */
#define bMaskLWord		0x0000FFFF	/* mp, hal_com.c & phydm */
#define bMaskDWord		0xFFFFFFFF	/* mp, hal, rtw_odm.c & phydm */

#define bEnable			0x1		/* hal_mp.c, rtw_mp.c */
#define bDisable		0x0		/* rtw_mp.c */

#define MAX_STALL_TIME		50		/* unit: us, hal_com_phycfg.c */

#define Rx_Smooth_Factor	20		/* phydm only */

/*
 * RF Register definition
 */
#define RF_AC			0x00
#define RF_AC_Jaguar		0x00	/* hal_mp.c */
#define RF_CHNLBW		0x18	/* rtl8822b_phy.c */
#define RF_ModeTableAddr	0x30	/* rtl8822b_phy.c */
#define RF_ModeTableData0	0x31	/* rtl8822b_phy.c */
#define RF_ModeTableData1	0x32	/* rtl8822b_phy.c */
#define RF_0x52			0x52
#define RF_WeLut_Jaguar		0xEF	/* rtl8822b_phy.c */

/* General Functions */
void rtl8822b_init_hal_spec(PADAPTER);				/* hal/hal_com.c */

#ifdef CONFIG_MP_INCLUDED
/* MP Functions */
#include <rtw_mp.h>		/* struct mp_priv */
void rtl8822b_prepare_mp_txdesc(PADAPTER, struct mp_priv *);	/* rtw_mp.c */
void rtl8822b_mp_config_rfpath(PADAPTER);			/* hal_mp.c */
#endif
void hw_var_set_dl_rsvd_page(PADAPTER adapter, u8 mstatus);

#ifdef CONFIG_USB_HCI
#include <rtl8822bu_hal.h>
#elif defined(CONFIG_SDIO_HCI)
#include <rtl8822bs_hal.h>
#elif defined(CONFIG_PCI_HCI)
#include <rtl8822be_hal.h>
#endif

#endif /* _RTL8822B_HAL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                              rtl8822bu/src/include/Hal8192FPwrSeq.h                                                              0000644 0001750 0001750 00000047144 14214766567 016107  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8192F
#define REALTEK_POWER_SEQUENCE_8192F
#define POWER_SEQUENCE_8192F_VER 04
/* #include "PwrSeqCmd.h" */
#include "HalPwrSeqCmd.h"

/*
	Check document WM-20110607-Paul-RTL8192e_Power_Architecture-R02.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transition from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8192F_TRANS_CARDEMU_TO_ACT_STEPS	38
#define	RTL8192F_TRANS_ACT_TO_CARDEMU_STEPS	8
#define	RTL8192F_TRANS_CARDEMU_TO_SUS_STEPS	7
#define	RTL8192F_TRANS_SUS_TO_CARDEMU_STEPS	5
#define	RTL8192F_TRANS_CARDEMU_TO_CARDDIS_STEPS	8
#define	RTL8192F_TRANS_CARDDIS_TO_CARDEMU_STEPS	8
#define	RTL8192F_TRANS_CARDEMU_TO_PDN_STEPS	4
#define	RTL8192F_TRANS_PDN_TO_CARDEMU_STEPS	1
#define	RTL8192F_TRANS_ACT_TO_LPS_STEPS		13
#define	RTL8192F_TRANS_LPS_TO_ACT_STEPS		11	
#define	RTL8192F_TRANS_END_STEPS	1


#define RTL8192F_TRANS_CARDEMU_TO_ACT 														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/	\
	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3|BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[11]=0*/ \
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, (BIT1|BIT0), 0}, \
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2},/* SWR OCP enable 0x10[18]=1*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3), 0},/* disable WL suspend*/ \
	{0x007f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x7c[31]=1,LDO has max output capability*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/ \
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/* Enable WL control XTAL setting*/ \
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 data mode*/\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
	{0x0068, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0},/*RF HW ON/OFF Enable*/\
	{0x001C, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/*Register Lock Disable*/\
	{0x0069, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/*For GPIO9 internal pull high setting*/\
	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*reset RF path S1*/\
	{0x007B, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*reset RF path S0*/\
	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},/*enable RF path S1*/\
	{0x007B, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},/*enalbe RF path S0*/\
	{0x0097, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*AFE_Ctrl*/\
	{0x00DC, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xCC},/*AFE_Ctrl*/\
	{0x0024, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x18, 0x00},/*AFE_Ctrl 0x24[4:3]=00 for xtal gmn*/\
	{0x1050, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*GPIO_A[7:0] Pull down software register*/\
	{0x1051, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*GPIO_A[15:8] Pull down software register*/\
	{0x1052, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*GPIO_A[23:16] Pull down software register*/\
	{0x1053, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*GPIO_A[31:24] Pull down software register*/\
	{0x105B, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*GPIO_B[7:0] Pull down software register*/\
	{0x001C, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/*Register Lock Enable*/\
	{0x0077, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT7|BIT6), 0x3},/*set HCI Power sequence state delay time:0*/

	
#define RTL8192F_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, */ /*0x1F[7:0] = 0 turn off RF*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x2[0]=0 Reset BB,RF enter Power Down mode*/ \
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/ \
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0}, /*0x10[18] = 0 to disable ocp*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/ \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/\


#define RTL8192F_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 USB|SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8192F_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
	

#define RTL8192F_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend*/	\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8192F_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/ \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/	\
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x10[18] = 1 to enable ocp*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/


#define RTL8192F_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8192F_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8192F_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/ \
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8192F_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0 	 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
 
#define RTL8192F_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //


extern WLAN_PWR_CFG rtl8192F_power_on_flow[RTL8192F_TRANS_CARDEMU_TO_ACT_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_radio_off_flow[RTL8192F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_card_disable_flow[RTL8192F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192F_TRANS_CARDEMU_TO_CARDDIS_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_card_enable_flow[RTL8192F_TRANS_CARDDIS_TO_CARDEMU_STEPS+RTL8192F_TRANS_CARDEMU_TO_ACT_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_suspend_flow[RTL8192F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192F_TRANS_CARDEMU_TO_SUS_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_resume_flow[RTL8192F_TRANS_SUS_TO_CARDEMU_STEPS+RTL8192F_TRANS_CARDEMU_TO_ACT_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_hwpdn_flow[RTL8192F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192F_TRANS_CARDEMU_TO_PDN_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_enter_lps_flow[RTL8192F_TRANS_ACT_TO_LPS_STEPS+RTL8192F_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8192F_leave_lps_flow[RTL8192F_TRANS_LPS_TO_ACT_STEPS+RTL8192F_TRANS_END_STEPS];

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8188e_hal.h                                                                0000644 0001750 0001750 00000027735 14214766567 015736  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_HAL_H__
#define __RTL8188E_HAL_H__

/* #include "hal_com.h" */
#include "hal_data.h"

/* include HAL Related header after HAL Related compiling flags */
#include "rtl8188e_spec.h"
#include "Hal8188EPhyReg.h"
#include "Hal8188EPhyCfg.h"
#include "rtl8188e_rf.h"
#include "rtl8188e_dm.h"
#include "rtl8188e_recv.h"
#include "rtl8188e_xmit.h"
#include "rtl8188e_cmd.h"
#include "rtl8188e_led.h"
#include "Hal8188EPwrSeq.h"
#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8188e_sreset.h"
#endif

/* --------------------------------------------------------------------- */
/*		RTL8188E Power Configuration CMDs for USB/SDIO/PCIE interfaces */
/* --------------------------------------------------------------------- */
#define Rtl8188E_NIC_PWR_ON_FLOW				rtl8188E_power_on_flow
#define Rtl8188E_NIC_RF_OFF_FLOW				rtl8188E_radio_off_flow
#define Rtl8188E_NIC_DISABLE_FLOW				rtl8188E_card_disable_flow
#define Rtl8188E_NIC_ENABLE_FLOW				rtl8188E_card_enable_flow
#define Rtl8188E_NIC_SUSPEND_FLOW				rtl8188E_suspend_flow
#define Rtl8188E_NIC_RESUME_FLOW				rtl8188E_resume_flow
#define Rtl8188E_NIC_PDN_FLOW					rtl8188E_hwpdn_flow
#define Rtl8188E_NIC_LPS_ENTER_FLOW			rtl8188E_enter_lps_flow
#define Rtl8188E_NIC_LPS_LEAVE_FLOW			rtl8188E_leave_lps_flow


#if 1 /* download firmware related data structure */
#define MAX_FW_8188E_SIZE			0x8000 /* 32768, 32k / 16384, 16k */

#define FW_8188E_SIZE				0x4000 /* 16384, 16k */
#define FW_8188E_SIZE_2			0x8000 /* 32768, 32k */

#define FW_8188E_START_ADDRESS	0x1000
#define FW_8188E_END_ADDRESS		0x1FFF /* 0x5FFF */


#define IS_FW_HEADER_EXIST_88E(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x88E0)

typedef struct _RT_FIRMWARE_8188E {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[MAX_FW_8188E_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8188E, *PRT_FIRMWARE_8188E;

/*
 * This structure must be cared byte-ordering
 *   */

typedef struct _RT_8188E_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u8		Subversion;	/* FW Subversion, default 0x00 */
	u16		Rsvd1;


	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u8		Foundry;
	u8		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8188E_FIRMWARE_HDR, *PRT_8188E_FIRMWARE_HDR;
#endif /* download firmware related data structure */


#define DRIVER_EARLY_INT_TIME_8188E			0x05
#define BCN_DMA_ATIME_INT_TIME_8188E		0x02


/* #define MAX_RX_DMA_BUFFER_SIZE_88E	      0x2400 */ /* 9k for 88E nornal chip , */ /* MaxRxBuff=10k-max(TxReportSize(64*8), WOLPattern(16*24)) */
#ifdef CONFIG_USB_HCI
	#define RX_DMA_SIZE_88E(__Adapter) 0x2800
#else
	#define RX_DMA_SIZE_88E(__Adapter) ((!IS_VENDOR_8188E_I_CUT_SERIES(__Adapter))?0x2800:0x4000)
#endif

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#define RX_DMA_RESERVD_FW_FEATURE	0x200 /* for tx report (64*8) */

#define MAX_RX_DMA_BUFFER_SIZE_88E(__Adapter) (RX_DMA_SIZE_88E(__Adapter)-RX_DMA_RESERVD_FW_FEATURE)

#define MAX_TX_REPORT_BUFFER_SIZE			0x0400 /* 1k */

#define PAGE_SIZE_TX_88E PAGE_SIZE_128
/* Note: We will divide number of page equally for each queue other than public queue!
 * 22k = 22528 bytes = 176 pages (@page =  128 bytes)
 * BCN rsvd_page_num = MAX_BEACON_LEN / PAGE_SIZE_TX_88E
 * 1 ps-poll / 1 null-data /1 prob_rsp /1 QOS null-data = 4 pages */

#define BCNQ_PAGE_NUM_88E		(MAX_BEACON_LEN / PAGE_SIZE_TX_88E + 4) /*0x09*/

/* For WoWLan , more reserved page */
#ifdef CONFIG_WOWLAN
	/* 1 ArpRsp + 2 NbrAdv + 2 NDPInfo + 1 RCI + 1 AOAC = 7 pages */
	#define WOWLAN_PAGE_NUM_88E	0x07
#else
	#define WOWLAN_PAGE_NUM_88E	0x00
#endif

/* Note:
Tx FIFO Size : previous CUT:22K /I_CUT after:32KB
Tx page Size : 128B
Total page numbers : 176(0xB0) / 256(0x100)
*/
#ifdef CONFIG_USB_HCI
	#define TOTAL_PAGE_NUMBER_88E(_Adapter) (0xB0 - 1)
#else
	#define TOTAL_PAGE_NUMBER_88E(_Adapter)	((IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)?0x100:0xB0) - 1)/* must reserved 1 page for dma issue */
#endif
#define TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	(TOTAL_PAGE_NUMBER_88E(_Adapter) - BCNQ_PAGE_NUM_88E - WOWLAN_PAGE_NUM_88E)
#define TX_PAGE_BOUNDARY_88E(_Adapter)		(TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1) /* beacon header start address */

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	TX_TOTAL_PAGE_NUMBER_88E(_Adapter)
#define WMM_NORMAL_TX_PAGE_BOUNDARY_88E(_Adapter)		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723B */
#define NORMAL_PAGE_NUM_HPQ_88E		0x0
#define NORMAL_PAGE_NUM_LPQ_88E		0x09
#define NORMAL_PAGE_NUM_NPQ_88E		0x0

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_88E		0x29
#define WMM_NORMAL_PAGE_NUM_LPQ_88E		0x1C
#define WMM_NORMAL_PAGE_NUM_NPQ_88E		0x1C


/* -------------------------------------------------------------------------
 *	Chip specific
 * ------------------------------------------------------------------------- */
#define CHIP_BONDING_IDENTIFIER(_value)	(((_value)>>22) & 0x3)
#define CHIP_BONDING_92C_1T2R	0x1
#define CHIP_BONDING_88C_USB_MCARD	0x2
#define CHIP_BONDING_88C_USB_HP	0x1

/* -------------------------------------------------------------------------
 *	Channel Plan
 * ------------------------------------------------------------------------- */


#define EFUSE_REAL_CONTENT_LEN		512
#define EFUSE_MAP_LEN				128
#define EFUSE_MAX_SECTION			16
#define EFUSE_IC_ID_OFFSET			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN)
/*
 * <Roger_Notes>
 * To prevent out of boundary programming case,
 * leave 1byte and program full section
 * 9bytes + 1byt + 5bytes and pre 1byte.
 * For worst case:
 * | 1byte|----8bytes----|1byte|--5bytes--|
 * |         |            Reserved(14bytes)	      |
 *   */
#define EFUSE_OOB_PROTECT_BYTES 		15	/* PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte. */

#define		EFUSE_REAL_CONTENT_LEN_88E	256
#define		EFUSE_MAP_LEN_88E		512
#define		EFUSE_MAX_SECTION_88E		64
#define		EFUSE_MAX_WORD_UNIT_88E		4
#define		EFUSE_IC_ID_OFFSET_88E			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define		AVAILABLE_EFUSE_ADDR_88E(addr)	(addr < EFUSE_REAL_CONTENT_LEN_88E)
/* <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
 * 9bytes + 1byt + 5bytes and pre 1byte.
 * For worst case:
 * | 2byte|----8bytes----|1byte|--7bytes--|  */ /* 92D */
#define 		EFUSE_OOB_PROTECT_BYTES_88E	18	/* PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte. */
#define		EFUSE_PROTECT_BYTES_BANK_88E	16


/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define EFUSE_BT_REAL_CONTENT_LEN		1536	/* 512*3 */
#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION			128		/* 1024/8 */

#define EFUSE_PROTECT_BYTES_BANK		16

#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

/* #define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? _TRUE : _FALSE) */

/* #define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) ) */

#ifdef CONFIG_PCI_HCI
	/* according to the define in the rtw_xmit.h, rtw_recv.h */
	#define TX_DESC_NUM_8188EE  TXDESC_NUM   /* 128 */
	#ifdef CONFIG_CONCURRENT_MODE
		/*#define BE_QUEUE_TX_DESC_NUM_8188EE  (TXDESC_NUM<<1)*/		/* 256 */
		#define BE_QUEUE_TX_DESC_NUM_8188EE  ((TXDESC_NUM<<1)+(TXDESC_NUM>>1))    /* 320 */
		/*#define BE_QUEUE_TX_DESC_NUM_8188EE  ((TXDESC_NUM<<1)+TXDESC_NUM)*/    /* 384 */
	#else
		#define BE_QUEUE_TX_DESC_NUM_8188EE  TXDESC_NUM /* 128 */
		/*#define BE_QUEUE_TX_DESC_NUM_8188EE  (TXDESC_NUM+(TXDESC_NUM>>1)) */ /* 192 */
	#endif

	void InterruptRecognized8188EE(PADAPTER Adapter, PRT_ISR_CONTENT pIsrContent);
	void UpdateInterruptMask8188EE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
#endif /* CONFIG_PCI_HCI */

/* rtl8188e_hal_init.c */

s32 rtl8188e_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void _8051Reset88E(PADAPTER padapter);
void rtl8188e_InitializeFirmwareVars(PADAPTER padapter);


s32 InitLLTTable(PADAPTER padapter, u8 txpktbuf_bndy);

/* EFuse */
u8 GetEEPROMSize8188E(PADAPTER padapter);
void Hal_InitPGData88E(PADAPTER padapter);
void Hal_EfuseParseIDCode88E(PADAPTER padapter, u8 *hwinfo);
void Hal_ReadTxPowerInfo88E(PADAPTER padapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);

void Hal_EfuseParseEEPROMVer88E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void rtl8188e_EfuseParseChnlPlan(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID88E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_ReadAntennaDiversity88E(PADAPTER pAdapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
void Hal_ReadThermalMeter_88E(PADAPTER	Adapter, u8 *PROMContent, BOOLEAN	AutoloadFail);
void Hal_EfuseParseXtal_8188E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseBoardType88E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_ReadPowerSavingMode88E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_ReadPAType_8188E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void Hal_ReadAmplifierType_8188E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void Hal_ReadRFEType_8188E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);

BOOLEAN HalDetectPwrDownMode88E(PADAPTER Adapter);

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */


#ifdef CONFIG_RF_POWER_TRIM
	void Hal_ReadRFGainOffset(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
#endif /*CONFIG_RF_POWER_TRIM*/


void InitBeaconParameters_8188e(_adapter *adapter);
void SetBeaconRelatedRegisters8188E(PADAPTER padapter);

void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8188e(_adapter *adapter);

void rtl8188e_start_thread(_adapter *padapter);
void rtl8188e_stop_thread(_adapter *padapter);

void rtw_IOL_cmd_tx_pkt_buf_dump(ADAPTER *Adapter, int data_len);
#ifdef CONFIG_IOL_EFUSE_PATCH
	s32 rtl8188e_iol_efuse_patch(PADAPTER padapter);
#endif/* CONFIG_IOL_EFUSE_PATCH */
void _InitTransferPageSize(PADAPTER padapter);

u8 SetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);

u8
GetHalDefVar8188E(
		PADAPTER				Adapter,
		HAL_DEF_VARIABLE		eVariable,
		void						*pValue
);
#ifdef CONFIG_GPIO_API
int rtl8188e_GpioFuncCheck(PADAPTER adapter, u8 gpio_num);
#endif
#endif /* __RTL8188E_HAL_H__ */
                                   rtl8822bu/src/include/Hal8723BPhyReg.h                                                              0000644 0001750 0001750 00000106032 14214766567 016050  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8723BPHYREG_H__
#define __INC_HAL8723BPHYREG_H__

#define		rSYM_WLBT_PAPE_SEL		0x64
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rTxAGC_B_Rate18_06				0x830
#define		rTxAGC_B_Rate54_24				0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00			0x83c

#define		rTxAGC_B_Mcs07_Mcs04			0x848
#define		rTxAGC_B_Mcs11_Mcs08			0x84c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rTxAGC_B_Mcs15_Mcs12			0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define	rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */
#define	rFPGA1_TxBlock				0x904	/* Useless now */
#define	rFPGA1_DebugSelect			0x908	/* Useless now */
#define	rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
#define	rDPDT_control				0x92c
#define	rfe_ctrl_anta_src				0x930
#define	rS0S1_PathSwitch			0x948

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport            		0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower      	0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper      	0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA						0xb00
#define rPdp_AntA_4						0xb04
#define rPdp_AntA_8						0xb08
#define rPdp_AntA_C						0xb0c
#define rPdp_AntA_10					0xb10
#define rPdp_AntA_14					0xb14
#define rPdp_AntA_18					0xb18
#define rPdp_AntA_1C					0xb1c
#define rPdp_AntA_20					0xb20
#define rPdp_AntA_24					0xb24

#define rConfig_Pmpd_AntA				0xb28
#define rConfig_ram64x16				0xb2c

#define rBndA							0xb30
#define rHssiPar						0xb34

#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c

#define rPdp_AntB						0xb70
#define rPdp_AntB_4						0xb74
#define rPdp_AntB_8						0xb78
#define rPdp_AntB_C						0xb7c
#define rPdp_AntB_10					0xb80
#define rPdp_AntB_14					0xb84
#define rPdp_AntB_18					0xb88
#define rPdp_AntB_1C					0xb8c
#define rPdp_AntB_20					0xb90
#define rPdp_AntB_24					0xb94

#define rConfig_Pmpd_AntB				0xb98

#define rBndB							0xba0

#define rAPK							0xbd8
#define rPm_Rx0_AntA					0xbdc
#define rPm_Rx1_AntA					0xbe0
#define rPm_Rx2_AntA					0xbe4
#define rPm_Rx3_AntA					0xbe8
#define rPm_Rx0_AntB					0xbec
#define rPm_Rx1_AntB					0xbf0
#define rPm_Rx2_AntB					0xbf4
#define rPm_Rx3_AntB					0xbf8
/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00			0xe10
#define		rTxAGC_A_Mcs07_Mcs04			0xe14
#define		rTxAGC_A_Mcs11_Mcs08			0xe18
#define		rTxAGC_A_Mcs15_Mcs12			0xe1c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/*  */

#define		RF_IQADJ_G1				0x01	/*  */
#define		RF_IQADJ_G2				0x02	/*  */
#define		RF_BS_PA_APSET_G1_G4		0x03
#define		RF_BS_PA_APSET_G5_G8		0x04
#define		RF_POW_TRSW				0x05	/*  */

#define		RF_GAIN_RX					0x06	/*  */
#define		RF_GAIN_TX					0x07	/*  */

#define		RF_TXM_IDAC				0x08	/*  */
#define		RF_IPA_G					0x09	/*  */
#define		RF_TXBIAS_G				0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A					0x0C	/*  */
#define		RF_TXBIAS_A				0x0D
#define		RF_BS_PA_APSET_G9_G11	0x0E
#define		RF_BS_IQGEN				0x0F	/*  */

#define		RF_MODE1					0x10	/*  */
#define		RF_MODE2					0x11	/*  */

#define		RF_RX_AGC_HP				0x12	/*  */
#define		RF_TX_AGC					0x13	/*  */
#define		RF_BIAS						0x14	/*  */
#define		RF_IPA						0x15	/*  */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/*  */
#define		RF_MODE_AG				0x18	/*  */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/*  */

#define		RF_RX_G1					0x1A	/*  */
#define		RF_RX_G2					0x1B	/*  */

#define		RF_RX_BB2					0x1C	/*  */
#define		RF_RX_BB1					0x1D	/*  */

#define		RF_RCK1					0x1E	/*  */
#define		RF_RCK2					0x1F	/*  */

#define		RF_TX_G1					0x20	/*  */
#define		RF_TX_G2					0x21	/*  */
#define		RF_TX_G3					0x22	/*  */

#define		RF_TX_BB1					0x23	/*  */

#define		RF_T_METER					0x24	/*  */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define	RF_TX_BIAS_A				0x35
#define	RF_TX_BIAS_D				0x36
#define	RF_LOBF_9					0x38
#define 	RF_RXRF_A3					0x3C	/*	 */
#define	RF_TRSW					0x3F

#define	RF_TXRF_A2					0x41
#define	RF_TXPA_G4					0x46
#define	RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define	RF_WE_LUT					0xEF
#define	RF_S0S1					0xB0

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bAntennaSelect		0x0300

#define		bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                  			0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    			0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  			0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI               		0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength          		0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         		0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW                		0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         		0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              		0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          		0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 		0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                		0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode				0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble			0x8	/* Useless */
#define		bCCKAntDiversity		0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate				0x3000
#define		bCCKDCCancel			0x0800
#define		bCCKISICancel			0x0400
#define		bCCKMatchFilter			0x0200
#define		bCCKEqualizer			0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart			0x300000
#define		bCCKCCACount			0x080000
#define		bCCKcs_lim				0x070000
#define		bCCKBistMode			0x80000000
#define		bCCKCCAMask			0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset			0xf0
#define		bCCKRxDCOffset			0xf
#define		bCCKCCAMode			0xc000
#define		bCCKFalseCS_lim			0x3f00
#define		bCCKCS_ratio			0xc00000
#define		bCCKCorgBit_sel			0x300000
#define		bCCKPD_lim				0x0f0000
#define		bCCKNewCCA			0x80000000
#define		bCCKRxHPofIG			0x8000
#define		bCCKRxIG				0x7f00
#define		bCCKLNAPolarity			0x800000
#define		bCCKRx1stGain			0x7f0000
#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC			0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType	0x0300
#define		bCCKRxDAGCEn			0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0				0x3f0000
#define		bCCKTxC1				0x3f000000
#define		bCCKTxC2				0x3f
#define		bCCKTxC3				0x3f00
#define		bCCKTxC4				0x3f0000
#define		bCCKTxC5				0x3f000000
#define		bCCKTxC6				0x3f
#define		bCCKTxC7				0x3f00
#define		bCCKDebugPort			0xff0000
#define		bCCKDACDebug			0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI				0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel			0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF				0x3	/* Useless */
#define		bShift_L					0xc0
#define		bGI_TH					0xc
#define		bRxPathA				0x1
#define		bRxPathB				0x2
#define		bRxPathC				0x4
#define		bRxPathD				0x8
#define		bTxPathA				0x1
#define		bTxPathB				0x2
#define		bTxPathC				0x4
#define		bTxPathD				0x8
#define		bTRSSIFreq				0x200
#define		bADCBackoff				0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode			0x1800000
#define		bRxDCNFType			0xe000000
#define		bRXIQImb_A				0x3ff
#define		bRXIQImb_B				0xfc00
#define		bRXIQImb_C				0x3f0000
#define		bRXIQImb_D				0xffc00000
#define		bDC_dc_Notch			0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH					0xf
#define		bPD_TH_Opt2			0xc000
#define		bPWED_TH				0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option				0x1000
#define		bMF_Win_L				0xe000
#define		bBW_Search_L			0x30000
#define		bwin_enh_L				0xc0000
#define		bBW_TH					0x700000
#define		bED_TH2				0x3800000
#define		bBW_option				0x4000000
#define		bRatio_TH				0x18000000
#define		bWindow_L				0xe0000000
#define		bSBD_Option				0x1
#define		bFrame_TH				0x1c
#define		bFS_Option				0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune				0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2			0x7
#define		bFrame_GI2_TH			0x38
#define		bGI2_Sync_en			0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum				0x1
#define		bCFOAcc				0x2
#define		bCFOStartOffset			0xc
#define		bCFOLookBack			0x70
#define		bCFOSumWeight			0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A				0x3ff
#define		bTXIQImb_B				0xfc00
#define		bTXIQImb_C				0x3f0000
#define		bTXIQImb_D				0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode			0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption			0x20000
#define		bCCADropThres			0xfff00000
#define		bEDCCA_H				0xf
#define		bEDCCA_L				0xf0
#define		bLambda_ED			0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn				0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En			0x10000000
#define		bRxQuickAGCEn			0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift				0x7f
#define		bTRSW_Tri_Only			0x80
#define		bPowerThres			0x300
#define		bRxAGCEn				0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin				0x4
#define		bRxHP_Ini				0x7
#define		bRxHP_TRLNA			0x70
#define		bRxHP_RSSI				0x700
#define		bRxHP_BBP1				0x7000
#define		bRxHP_BBP2				0x70000
#define		bRxHP_BBP3				0x700000
#define		bRSSI_H					0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW			0x7
#define		bRxSettle_LNA			0x38
#define		bRxSettle_RSSI			0x1c0
#define		bRxSettle_BBP			0xe00
#define		bRxSettle_RxHP			0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI			0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final				0x7000000
#define		bRxHTSettle_BBP			0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn			0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin			0x80000
#define		bRxHTAGCEn				0x100000
#define		bRxHTDAGCEn			0x200000
#define		bRxHTRxHP_BBP			0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH			0x3
#define		bRxPWRatioEn			0x4
#define		bRxMFHold				0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH			0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L			0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH				0xc0000000
#define		bDFSCnt0				0xff
#define		bDFSCnt1				0xff00
#define		bDFSFlag				0xf0000
#define		bMFWeightSum			0x300000
#define		bMinIdxTH				0x7f000000
#define		bDAFormat				0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain				0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn				0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss					0x20
#define		bCFOAntSumD			0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet			0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn				0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re		0x3f
#define		bSigTone_Im		0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail	0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail	0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync	0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength	12   /* total */
#define		bShortCFOFLength	11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength	11
#define		bLongCFOFLength	11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW			0x1
#define		bRxSC				0x6
#define		bRx_HT				0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg	0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain				0x3f
#define		bTableSel			0x40
#define		bTRSW				0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st				0xff
#define		bCSI2nd				0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd			0xff000000
#define		bSIGEVM			0xff
#define		bPWDB				0xff00
#define		bSGIEN				0x10000

#define		bSFactorQAM1		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode			0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType		0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO			0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC					0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF		0x20000
#define		bComChCFO			0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz			0x100000
#define		bUChCfg				0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C	0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW		0x18
#define		bRTL8256_RxLPFBW		0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW		0xc	/* Useless */
#define		bRTL8258_RxLPFBW		0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0				0x1	/* Useless */
#define		bByte1				0x2
#define		bByte2				0x4
#define		bByte3				0x8
#define		bWord0				0x3
#define		bWord1				0xc
#define		bDWord				0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1			0xff00
#define		bMaskByte2			0xff0000
#define		bMaskByte3			0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord			0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes		0xffffff00
#define		bMask12Bits			0xfff
#define		bMaskH4Bits			0xf0000000
#define		bMaskOFDM_D		0xffc00000
#define		bMaskCCK			0x3f3f3f3f


#define		bEnable			0x1	/* Useless */
#define		bDisable		0x0

#define		LeftAntenna		0x0	/* Useless */
#define		RightAntenna	0x1

#define		tCheckTxStatus		500   /* 500ms */ /* Useless */
#define		tUpdateRxCounter	100   /* 100ms */

#define		rateCCK		0	/* Useless */
#define		rateOFDM	1
#define		rateHT		2

/* define Register-End */
#define		bPMAC_End			0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/rtl8710b_dm.h                                                                 0000644 0001750 0001750 00000002615 14214766567 015544  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_DM_H__
#define __RTL8710B_DM_H__
/* ************************************************************
 * Description:
 *
 * This file is for 8710B dynamic mechanism only
 *
 *
 * ************************************************************ */

/* ************************************************************
 * structure and define
 * ************************************************************ */

/* ************************************************************
 * function prototype
 * ************************************************************ */

void rtl8710b_init_dm_priv(PADAPTER padapter);
void rtl8710b_deinit_dm_priv(PADAPTER padapter);

void rtl8710b_InitHalDm(PADAPTER padapter);
void rtl8710b_HalDmWatchDog(PADAPTER padapter);

#endif
                                                                                                                   rtl8822bu/src/include/rtl8723d_hal.h                                                                0000644 0001750 0001750 00000023631 14214766567 015717  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_HAL_H__
#define __RTL8723D_HAL_H__

#include "hal_data.h"

#include "rtl8723d_spec.h"
#include "rtl8723d_rf.h"
#include "rtl8723d_dm.h"
#include "rtl8723d_recv.h"
#include "rtl8723d_xmit.h"
#include "rtl8723d_cmd.h"
#include "rtl8723d_led.h"
#include "Hal8723DPwrSeq.h"
#include "Hal8723DPhyReg.h"
#include "Hal8723DPhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8723d_sreset.h"
#endif
#ifdef CONFIG_LPS_POFF
	#include "rtl8723d_lps_poff.h"
#endif

#define FW_8723D_SIZE		0x8000
#define FW_8723D_START_ADDRESS	0x1000
#define FW_8723D_END_ADDRESS	0x1FFF /* 0x5FFF */

#define IS_FW_HEADER_EXIST_8723D(_pFwHdr)\
	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x23D0)

typedef struct _RT_FIRMWARE {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_8723D_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8723D, *PRT_FIRMWARE_8723D;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
typedef struct _RT_8723D_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u16		Subversion;	/* FW Subversion, default 0x00 */

	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u16		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8723D_FIRMWARE_HDR, *PRT_8723D_FIRMWARE_HDR;

#define DRIVER_EARLY_INT_TIME_8723D		0x05
#define BCN_DMA_ATIME_INT_TIME_8723D		0x02

/* for 8723D
 * TX 32K, RX 16K, Page size 128B for TX, 8B for RX */
#define PAGE_SIZE_TX_8723D			128
#define PAGE_SIZE_RX_8723D			8

#define TX_DMA_SIZE_8723D			0x8000	/* 32K(TX) */
#define RX_DMA_SIZE_8723D			0x4000	/* 16K(RX) */

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8723D	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8723D	0x80	/* 128B, reserved for tx report */
#endif
#define RX_DMA_BOUNDARY_8723D\
	(RX_DMA_SIZE_8723D - RX_DMA_RESERVED_SIZE_8723D - 1)


/* Note: We will divide number of page equally for each queue other than public queue! */

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8723D
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/

#define BCNQ_PAGE_NUM_8723D		(MAX_BEACON_LEN/PAGE_SIZE_TX_8723D + 6) /*0x08*/

/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt 1, PNO: 6
 * NS offload: 2 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8723D	0x0b
#else
	#define WOWLAN_PAGE_NUM_8723D	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
	#undef WOWLAN_PAGE_NUM_8723D
	#define WOWLAN_PAGE_NUM_8723D	0x15
#endif

#ifdef CONFIG_AP_WOWLAN
	#define AP_WOWLAN_PAGE_NUM_8723D	0x02
#endif

#define TX_TOTAL_PAGE_NUMBER_8723D\
	(0xFF - BCNQ_PAGE_NUM_8723D - WOWLAN_PAGE_NUM_8723D)
#define TX_PAGE_BOUNDARY_8723D		(TX_TOTAL_PAGE_NUMBER_8723D + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8723D	TX_TOTAL_PAGE_NUMBER_8723D
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8723D\
	(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8723D + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723D */
#define NORMAL_PAGE_NUM_HPQ_8723D		0x0C
#define NORMAL_PAGE_NUM_LPQ_8723D		0x02
#define NORMAL_PAGE_NUM_NPQ_8723D		0x02
#define NORMAL_PAGE_NUM_EPQ_8723D		0x04

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8723D		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8723D		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8723D		0x20
#define WMM_NORMAL_PAGE_NUM_EPQ_8723D		0x00


#include "HalVerDef.h"
#include "hal_com.h"

#define EFUSE_OOB_PROTECT_BYTES (96 + 1)

#define HAL_EFUSE_MEMORY
#define HWSET_MAX_SIZE_8723D                512
#define EFUSE_REAL_CONTENT_LEN_8723D        512
#define EFUSE_MAP_LEN_8723D                 512
#define EFUSE_MAX_SECTION_8723D             64

/* For some inferiority IC purpose. added by Roger, 2009.09.02.*/
#define EFUSE_IC_ID_OFFSET			506
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8723D)

#define EFUSE_ACCESS_ON		0x69
#define EFUSE_ACCESS_OFF	0x00

/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define BANK_NUM			1
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	128
#define EFUSE_BT_REAL_CONTENT_LEN	\
	(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)
#define EFUSE_BT_MAP_LEN		1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION		(EFUSE_BT_MAP_LEN / 8)
#define EFUSE_PROTECT_BYTES_BANK	16

typedef enum tag_Package_Definition {
	PACKAGE_DEFAULT,
	PACKAGE_QFN68,
	PACKAGE_TFBGA90,
	PACKAGE_TFBGA80,
	PACKAGE_TFBGA79
} PACKAGE_TYPE_E;

#define INCLUDE_MULTI_FUNC_BT(_Adapter) \
	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter) \
	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

#ifdef CONFIG_FILE_FWIMG
	extern char *rtw_fw_file_path;
	extern char *rtw_fw_wow_file_path;
	#ifdef CONFIG_MP_INCLUDED
		extern char *rtw_fw_mp_bt_file_path;
	#endif /* CONFIG_MP_INCLUDED */
#endif /* CONFIG_FILE_FWIMG */

/* rtl8723d_hal_init.c */
s32 rtl8723d_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void rtl8723d_FirmwareSelfReset(PADAPTER padapter);
void rtl8723d_InitializeFirmwareVars(PADAPTER padapter);

void rtl8723d_InitAntenna_Selection(PADAPTER padapter);
void rtl8723d_DeinitAntenna_Selection(PADAPTER padapter);
void rtl8723d_CheckAntenna_Selection(PADAPTER padapter);
void rtl8723d_init_default_value(PADAPTER padapter);

s32 rtl8723d_InitLLTTable(PADAPTER padapter);

s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
s32 CardDisableWithoutHWSM(PADAPTER padapter);

/* EFuse */
u8 GetEEPROMSize8723D(PADAPTER padapter);
void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
void Hal_EfuseParseTxPowerInfo_8723D(PADAPTER padapter,
				     u8 *PROMContent, BOOLEAN AutoLoadFail);
void Hal_EfuseParseBTCoexistInfo_8723D(PADAPTER padapter,
				       u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseEEPROMVer_8723D(PADAPTER padapter,
				   u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseChnlPlan_8723D(PADAPTER padapter,
				  u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID_8723D(PADAPTER padapter,
				    u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseAntennaDiversity_8723D(PADAPTER padapter,
		u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseXtal_8723D(PADAPTER pAdapter,
			      u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseThermalMeter_8723D(PADAPTER padapter,
				      u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseVoltage_8723D(PADAPTER pAdapter,
				 u8 *hwinfo, BOOLEAN	AutoLoadFail);
void Hal_EfuseParseBoardType_8723D(PADAPTER Adapter,
				   u8	*PROMContent, BOOLEAN AutoloadFail);

void rtl8723d_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8723d(_adapter *adapter);
u8 SetHwReg8723D(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8723D(PADAPTER padapter, u8 variable, u8 *val);
u8 SetHalDefVar8723D(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8723D(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);

/* register */
void rtl8723d_InitBeaconParameters(PADAPTER padapter);
void rtl8723d_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
void _InitMacAPLLSetting_8723D(PADAPTER Adapter);
void _8051Reset8723(PADAPTER padapter);
#ifdef CONFIG_WOWLAN
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void rtl8723d_start_thread(_adapter *padapter);
void rtl8723d_stop_thread(_adapter *padapter);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void rtl8723ds_init_checkbthang_workqueue(_adapter *adapter);
	void rtl8723ds_free_checkbthang_workqueue(_adapter *adapter);
	void rtl8723ds_cancle_checkbthang_workqueue(_adapter *adapter);
	void rtl8723ds_hal_check_bt_hang(_adapter *adapter);
#endif

#ifdef CONFIG_GPIO_WAKEUP
	void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
#endif
#ifdef CONFIG_MP_INCLUDED
int FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
#endif
void CCX_FwC2HTxRpt_8723d(PADAPTER padapter, u8 *pdata, u8 len);

u8 MRateToHwRate8723D(u8 rate);
u8 HwRateToMRate8723D(u8 rate);

void Hal_ReadRFGainOffset(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void check_bt_status_work(void *data);
#endif

#ifdef CONFIG_USB_HCI
	void rtl8723d_cal_txdesc_chksum(struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
	BOOLEAN	InterruptRecognized8723DE(PADAPTER Adapter);
	void	UpdateInterruptMask8723DE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
	u16 get_txbd_rw_reg(u16 ff_hwaddr);
#endif

#endif
                                                                                                       rtl8822bu/src/include/rtl8723b_hal.h                                                                0000755 0001750 0001750 00000023146 14214766567 015721  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_HAL_H__
#define __RTL8723B_HAL_H__

#include "hal_data.h"

#include "rtl8723b_spec.h"
#include "rtl8723b_rf.h"
#include "rtl8723b_dm.h"
#include "rtl8723b_recv.h"
#include "rtl8723b_xmit.h"
#include "rtl8723b_cmd.h"
#include "rtl8723b_led.h"
#include "Hal8723BPwrSeq.h"
#include "Hal8723BPhyReg.h"
#include "Hal8723BPhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8723b_sreset.h"
#endif

#define FW_8723B_SIZE			0x8000
#define FW_8723B_START_ADDRESS	0x1000
#define FW_8723B_END_ADDRESS		0x1FFF /* 0x5FFF */

#define IS_FW_HEADER_EXIST_8723B(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x5300)

typedef struct _RT_FIRMWARE {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_8723B_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8723B, *PRT_FIRMWARE_8723B;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
typedef struct _RT_8723B_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u16		Subversion;	/* FW Subversion, default 0x00 */

	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u16		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8723B_FIRMWARE_HDR, *PRT_8723B_FIRMWARE_HDR;

#define DRIVER_EARLY_INT_TIME_8723B		0x05
#define BCN_DMA_ATIME_INT_TIME_8723B		0x02

/* for 8723B
 * TX 32K, RX 16K, Page size 128B for TX, 8B for RX */
#define PAGE_SIZE_TX_8723B			128
#define PAGE_SIZE_RX_8723B			8

#define TX_DMA_SIZE_8723B			0x8000	/* 32K(TX) */
#define RX_DMA_SIZE_8723B			0x4000	/* 16K(RX) */

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8723B	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8723B	0x80	/* 128B, reserved for tx report */
#endif
#define RX_DMA_BOUNDARY_8723B		(RX_DMA_SIZE_8723B - RX_DMA_RESERVED_SIZE_8723B - 1)


/* Note: We will divide number of page equally for each queue other than public queue! */

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8723B
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/
#define BCNQ_PAGE_NUM_8723B		(MAX_BEACON_LEN / PAGE_SIZE_TX_8723B + 6) /*0x08*/


/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt: 1,PNO: 6
 * NS offload: 2 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8723B	0x0b
#else
	#define WOWLAN_PAGE_NUM_8723B	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
	#undef WOWLAN_PAGE_NUM_8723B
	#define WOWLAN_PAGE_NUM_8723B	0x15
#endif

#ifdef CONFIG_AP_WOWLAN
	#define AP_WOWLAN_PAGE_NUM_8723B	0x02
#endif

#define TX_TOTAL_PAGE_NUMBER_8723B	(0xFF - BCNQ_PAGE_NUM_8723B - WOWLAN_PAGE_NUM_8723B)
#define TX_PAGE_BOUNDARY_8723B		(TX_TOTAL_PAGE_NUMBER_8723B + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8723B	TX_TOTAL_PAGE_NUMBER_8723B
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8723B		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8723B + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723B */
#define NORMAL_PAGE_NUM_HPQ_8723B		0x0C
#define NORMAL_PAGE_NUM_LPQ_8723B		0x02
#define NORMAL_PAGE_NUM_NPQ_8723B		0x02
#define NORMAL_PAGE_NUM_EPQ_8723B		0x04

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8723B		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8723B		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8723B		0x20
#define WMM_NORMAL_PAGE_NUM_EPQ_8723B		0x00


#include "HalVerDef.h"
#include "hal_com.h"

#define EFUSE_OOB_PROTECT_BYTES		15

#define HAL_EFUSE_MEMORY

#define HWSET_MAX_SIZE_8723B			512
#define EFUSE_REAL_CONTENT_LEN_8723B		512
#define EFUSE_MAP_LEN_8723B				512
#define EFUSE_MAX_SECTION_8723B			64

#define EFUSE_IC_ID_OFFSET			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8723B)

#define EFUSE_ACCESS_ON			0x69	/* For RTL8723 only. */
#define EFUSE_ACCESS_OFF			0x00	/* For RTL8723 only. */

/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
#define EFUSE_BT_REAL_CONTENT_LEN		1536	/* 512*3 */
#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION			128		/* 1024/8 */

#define EFUSE_PROTECT_BYTES_BANK		16

typedef enum tag_Package_Definition {
	PACKAGE_DEFAULT,
	PACKAGE_QFN68,
	PACKAGE_TFBGA90,
	PACKAGE_TFBGA80,
	PACKAGE_TFBGA79
} PACKAGE_TYPE_E;

#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

/* rtl8723a_hal_init.c */
s32 rtl8723b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void rtl8723b_FirmwareSelfReset(PADAPTER padapter);
void rtl8723b_InitializeFirmwareVars(PADAPTER padapter);

void rtl8723b_InitAntenna_Selection(PADAPTER padapter);
void rtl8723b_DeinitAntenna_Selection(PADAPTER padapter);
void rtl8723b_CheckAntenna_Selection(PADAPTER padapter);
void rtl8723b_init_default_value(PADAPTER padapter);

s32 rtl8723b_InitLLTTable(PADAPTER padapter);

s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
s32 CardDisableWithoutHWSM(PADAPTER padapter);

/* EFuse */
u8 GetEEPROMSize8723B(PADAPTER padapter);
void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
void Hal_EfuseParseTxPowerInfo_8723B(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
void Hal_EfuseParseBTCoexistInfo_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseEEPROMVer_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseChnlPlan_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseAntennaDiversity_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseXtal_8723B(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseThermalMeter_8723B(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParsePackageType_8723B(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseVoltage_8723B(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);
void Hal_EfuseParseBoardType_8723B(PADAPTER Adapter,	u8	*PROMContent, BOOLEAN AutoloadFail);

void rtl8723b_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8723b(_adapter *adapter);
u8 SetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val);
u8 SetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);

/* register */
void rtl8723b_InitBeaconParameters(PADAPTER padapter);
void rtl8723b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
void	_InitBurstPktLen_8723BS(PADAPTER Adapter);
void _8051Reset8723(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void rtl8723b_start_thread(_adapter *padapter);
void rtl8723b_stop_thread(_adapter *padapter);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void rtl8723bs_init_checkbthang_workqueue(_adapter *adapter);
	void rtl8723bs_free_checkbthang_workqueue(_adapter *adapter);
	void rtl8723bs_cancle_checkbthang_workqueue(_adapter *adapter);
	void rtl8723bs_hal_check_bt_hang(_adapter *adapter);
#endif

#ifdef CONFIG_GPIO_WAKEUP
	void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
#endif
#ifdef CONFIG_MP_INCLUDED
int FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
#endif
void CCX_FwC2HTxRpt_8723b(PADAPTER padapter, u8 *pdata, u8 len);

u8 MRateToHwRate8723B(u8  rate);
u8 HwRateToMRate8723B(u8	 rate);

#ifdef CONFIG_RF_POWER_TRIM
	void Hal_ReadRFGainOffset(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
#endif /*CONFIG_RF_POWER_TRIM*/

#ifdef CONFIG_PCI_HCI
	BOOLEAN	InterruptRecognized8723BE(PADAPTER Adapter);
	void	UpdateInterruptMask8723BE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
#endif

#ifdef CONFIG_GPIO_API
int rtl8723b_GpioFuncCheck(PADAPTER adapter, u8 gpio_num);
void rtl8723b_GpioMultiFuncReset(PADAPTER adapter, u8 gpio_num);
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                          rtl8822bu/src/include/rtl8703b_sreset.h                                                             0000644 0001750 0001750 00000001631 14214766567 016450  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8703B_SRESET_H_
#define _RTL8703B_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8703b_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8703b_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                       rtl8822bu/src/include/rtl8814a_cmd.h                                                                0000755 0001750 0001750 00000025162 14214766567 015720  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_CMD_H__
#define __RTL8814A_CMD_H__
#include "hal_com_h2c.h"

/* _RSVDPAGE_LOC_CMD0 */
#define SET_8814A_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8814A_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8814A_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8814A_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8814A_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _SETPWRMODE_PARM */
#define SET_8814A_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8814A_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8814A_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8814A_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8814A_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8814A_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8814A_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8814A_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)


/* _WoWLAN PARAM_CMD5 */
#define SET_8814A_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_ALL_PKT_DROP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_GPIO_ACTIVE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_REKEY_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
#define SET_8814A_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8814A_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)


/* WLANINFO_PARM */
#define SET_8814A_H2CCMD_WLANINFO_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8814A_H2CCMD_WLANINFO_PARM_CHANNEL(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8814A_H2CCMD_WLANINFO_PARM_BW40MHZ(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)

/* _REMOTE_WAKEUP_CMD7 */
#define SET_8814A_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8814A_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8814A_H2CCMD_REMOTE_WAKE_CTRL_NDP_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8814A_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)


/* _AP_OFFLOAD_CMD8 */
#define SET_8814A_H2CCMD_AP_OFFLOAD_ON(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8814A_H2CCMD_AP_OFFLOAD_HIDDEN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8814A_H2CCMD_AP_OFFLOAD_DENYANY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8814A_H2CCMD_AP_OFFLOAD_WAKEUP_EVT_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)

/* _PWR_MOD_CMD20 */
#define SET_88E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_88E_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_88E_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_88E_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_88E_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_88E_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/*	AP_REQ_TXREP_CMD 0x43	*/
#define SET_8814A_H2CCMD_TXREP_PARM_STA1(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8814A_H2CCMD_TXREP_PARM_STA2(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8814A_H2CCMD_TXREP_PARM_RTY(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 2, __Value)

/*		C2H_AP_REQ_TXRPT		*/
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_MACID1(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 8)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_TXOK1(_Header)			LE_BITS_TO_2BYTE((_Header + 1), 0, 16)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_TXFAIL1(_Header)			LE_BITS_TO_2BYTE((_Header + 3), 0, 16)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_INIRATE1(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_MACID2(_Header)			LE_BITS_TO_1BYTE((_Header + 6), 0, 8)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_TXOK2(_Header)			LE_BITS_TO_2BYTE((_Header + 7), 0, 16)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_TXFAIL2(_Header)			LE_BITS_TO_2BYTE((_Header + 9), 0, 16)
#define	GET_8814A_C2H_TC2H_APREQ_TXRPT_INIRATE2(_Header)		LE_BITS_TO_1BYTE((_Header + 11), 0, 8)

/*		C2H_SPC_STAT			*/
#define	GET_8814A_C2H_SPC_STAT_IDX(_Header)						LE_BITS_TO_1BYTE((_Header + 0), 0, 8)
	/*	Tip :TYPE_A data3 is msb and data0 is lsb	*/
#define	GET_8814A_C2H_SPC_STAT_TYPEA_RETRY(_Header)				LE_BITS_TO_4BYTE((_Header + 1), 0, 32)
#define	GET_8814A_C2H_SPC_STAT_TYPEB_PKT1(_Header)				LE_BITS_TO_2BYTE((_Header + 1), 0, 16)
#define	GET_8814A_C2H_SPC_STAT_TYPEB_RETRY1(_Header)			LE_BITS_TO_2BYTE((_Header + 3), 0, 16)
#define	GET_8814A_C2H_SPC_STAT_TYPEB_PKT2(_Header)				LE_BITS_TO_2BYTE((_Header + 5), 0, 16)
#define	GET_8814A_C2H_SPC_STAT_TYPEB_RETRY2(_Header)			LE_BITS_TO_2BYTE((_Header + 7), 0, 16)

/*BCNHWSEQ*/
#define SET_8814A_H2CCMD_BCNHWSEQ_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 1, __Value)
#define SET_8814A_H2CCMD_BCNHWSEQ_BCN_NUMBER(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 1, 3, __Value)
#define SET_8814A_H2CCMD_BCNHWSEQ_HWSEQ(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 6, 1, __Value)
#define SET_8814A_H2CCMD_BCNHWSEQ_EXHWSEQ(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 7, 1, __Value)
#define SET_8814A_H2CCMD_BCNHWSEQ_PAGE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
void rtl8814_fw_update_beacon_cmd(_adapter *padapter);

/* TX Beamforming */
#define GET_8814A_C2H_TXBF_ORIGINATE(_Header)			LE_BITS_TO_1BYTE(_Header, 0, 8)
#define GET_8814A_C2H_TXBF_MACID(_Header)				LE_BITS_TO_1BYTE((_Header + 1), 0, 8)



/* / TX Feedback Content */
#define	USEC_UNIT_FOR_8814A_C2H_TX_RPT_QUEUE_TIME			256

#define	GET_8814A_C2H_TX_RPT_QUEUE_SELECT(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 5)
#define	GET_8814A_C2H_TX_RPT_PKT_BROCAST(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 5, 1)
#define	GET_8814A_C2H_TX_RPT_LIFE_TIME_OVER(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 6, 1)
#define	GET_8814A_C2H_TX_RPT_RETRY_OVER(_Header)				LE_BITS_TO_1BYTE((_Header + 0), 7, 1)
#define	GET_8814A_C2H_TX_RPT_MAC_ID(_Header)					LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
#define	GET_8814A_C2H_TX_RPT_DATA_RETRY_CNT(_Header)		LE_BITS_TO_1BYTE((_Header + 2), 0, 6)
#define	GET_8814A_C2H_TX_RPT_QUEUE_TIME(_Header)				LE_BITS_TO_2BYTE((_Header + 3), 0, 16)	/* In unit of 256 microseconds. */
#define	GET_8814A_C2H_TX_RPT_FINAL_DATA_RATE(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)


/* _P2P_PS_OFFLOAD */
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)

s32 FillH2CCmd_8814(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
void rtl8814_set_wowlan_cmd(_adapter *padapter, u8 enable);
void rtl8814_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
void rtl8814_set_FwPwrMode_cmd(PADAPTER padapter, u8 PSMode);
u8 GetTxBufferRsvdPageNum8814(_adapter *padapter, bool wowlan);
void rtl8814_req_txrpt_cmd(PADAPTER padapter, u8 macid);

#ifdef CONFIG_TDLS
	#ifdef CONFIG_TDLS_CH_SW
		void rtl8814_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
	#endif
#endif

void
Set_RA_LDPC_8814(
	struct sta_info	*psta,
	BOOLEAN			bLDPC
);

s32 c2h_handler_8814a(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);

#ifdef CONFIG_BT_COEXIST
void rtl8814a_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P_PS
	void rtl8814_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#endif/* __RTL8814A_CMD_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                              rtl8822bu/src/include/rtw_btcoex.h                                                                  0000644 0001750 0001750 00000046125 14214766567 015765  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifdef CONFIG_BT_COEXIST

#ifndef __RTW_BTCOEX_H__
#define __RTW_BTCOEX_H__

#include <drv_types.h>

/* For H2C: H2C_BT_MP_OPER. Return status definition to the user layer */
typedef enum _BT_CTRL_STATUS {
	BT_STATUS_SUCCESS								= 0x00, /* Success */
	BT_STATUS_BT_OP_SUCCESS							= 0x01, /* bt fw op execution success */
	BT_STATUS_H2C_SUCCESS							= 0x02, /* H2c success */
	BT_STATUS_H2C_FAIL								= 0x03, /* H2c fail */
	BT_STATUS_H2C_LENGTH_EXCEEDED					= 0x04, /* H2c command length exceeded */
	BT_STATUS_H2C_TIMTOUT							= 0x05, /* H2c timeout */
	BT_STATUS_H2C_BT_NO_RSP							= 0x06, /* H2c sent, bt no rsp */
	BT_STATUS_C2H_SUCCESS							= 0x07, /* C2h success */
	BT_STATUS_C2H_REQNUM_MISMATCH					= 0x08, /* bt fw wrong rsp */
	BT_STATUS_OPCODE_U_VERSION_MISMATCH				= 0x08, /* Upper layer OP code version mismatch. */
	BT_STATUS_OPCODE_L_VERSION_MISMATCH				= 0x0a, /* Lower layer OP code version mismatch. */
	BT_STATUS_UNKNOWN_OPCODE_U						= 0x0b, /* Unknown Upper layer OP code */
	BT_STATUS_UNKNOWN_OPCODE_L						= 0x0c, /* Unknown Lower layer OP code */
	BT_STATUS_PARAMETER_FORMAT_ERROR_U				= 0x0d, /* Wrong parameters sent by upper layer. */
	BT_STATUS_PARAMETER_FORMAT_ERROR_L				= 0x0e, /* bt fw parameter format is not consistency */
	BT_STATUS_PARAMETER_OUT_OF_RANGE_U				= 0x0f, /* uppery layer parameter value is out of range */
	BT_STATUS_PARAMETER_OUT_OF_RANGE_L				= 0x10, /* bt fw parameter value is out of range */
	BT_STATUS_UNKNOWN_STATUS_L						= 0x11, /* bt returned an defined status code */
	BT_STATUS_UNKNOWN_STATUS_H						= 0x12, /* driver need to do error handle or not handle-well. */
	BT_STATUS_WRONG_LEVEL							= 0x13, /* should be under passive level */
	BT_STATUS_NOT_IMPLEMENT						= 0x14, /* op code not implemented yet */
	BT_STATUS_BT_STACK_OP_SUCCESS					= 0x15, /* bt stack op execution success */
	BT_STATUS_BT_STACK_NOT_SUPPORT					= 0x16, /* stack version not support this. */
	BT_STATUS_BT_STACK_SEND_HCI_EVENT_FAIL			= 0x17, /* send hci event fail */
	BT_STATUS_BT_STACK_NOT_BIND						= 0x18, /* stack not bind wifi driver */
	BT_STATUS_BT_STACK_NO_RSP						= 0x19, /* stack doesn't have any rsp. */
	BT_STATUS_MAX
} BT_CTRL_STATUS, *PBT_CTRL_STATUS;

typedef enum _BTCOEX_SUSPEND_STATE {
	BTCOEX_SUSPEND_STATE_RESUME					= 0x0,
	BTCOEX_SUSPEND_STATE_SUSPEND				= 0x1,
	BTCOEX_SUSPEND_STATE_SUSPEND_KEEP_ANT		= 0x2,
	BTCOEX_SUSPEND_STATE_MAX
} BTCOEX_SUSPEND_STATE, *PBTCOEX_SUSPEND_STATE;

#define SET_BT_MP_OPER_RET(OpCode, StatusCode)						((OpCode << 8) | StatusCode)
#define GET_OP_CODE_FROM_BT_MP_OPER_RET(RetCode)					((RetCode & 0xF0) >> 8)
#define GET_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode)				(RetCode & 0x0F)
#define CHECK_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode, StatusCode)	(GET_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode) == StatusCode)

#ifdef CONFIG_BT_COEXIST_SOCKET_TRX

#define NETLINK_USER 31
#define CONNECT_PORT 30000
#define CONNECT_PORT_BT 30001
#define KERNEL_SOCKET_OK 0x01
#define NETLINK_SOCKET_OK 0x02

#define OTHER 0
#define RX_ATTEND_ACK 1
#define RX_LEAVE_ACK 2
#define RX_BT_LEAVE 3
#define RX_INVITE_REQ 4
#define RX_ATTEND_REQ 5
#define RX_INVITE_RSP 6

#define invite_req "INVITE_REQ"
#define invite_rsp "INVITE_RSP"
#define attend_req "ATTEND_REQ"
#define attend_ack "ATTEND_ACK"
#define wifi_leave "WIFI_LEAVE"
#define leave_ack "LEAVE_ACK"
#define bt_leave "BT_LEAVE"

#define BT_INFO_NOTIFY_CMD 0x0106
#define BT_INFO_LEN 8

typedef struct _HCI_LINK_INFO {
	u16					ConnectHandle;
	u8					IncomingTrafficMode;
	u8					OutgoingTrafficMode;
	u8					BTProfile;
	u8					BTCoreSpec;
	s8					BT_RSSI;
	u8					TrafficProfile;
	u8					linkRole;
} HCI_LINK_INFO, *PHCI_LINK_INFO;

#define	MAX_BT_ACL_LINK_NUM				8

typedef struct _HCI_EXT_CONFIG {
	HCI_LINK_INFO				aclLink[MAX_BT_ACL_LINK_NUM];
	u8					btOperationCode;
	u16					CurrentConnectHandle;
	u8					CurrentIncomingTrafficMode;
	u8					CurrentOutgoingTrafficMode;

	u8					NumberOfACL;
	u8					NumberOfSCO;
	u8					CurrentBTStatus;
	u16					HCIExtensionVer;

	BOOLEAN					bEnableWifiScanNotify;
} HCI_EXT_CONFIG, *PHCI_EXT_CONFIG;

typedef struct _HCI_PHY_LINK_BSS_INFO {
	u16						bdCap;			/* capability information */

	/* Qos related. Added by Annie, 2005-11-01. */
	/* BSS_QOS						BssQos;		 */

} HCI_PHY_LINK_BSS_INFO, *PHCI_PHY_LINK_BSS_INFO;

typedef enum _BT_CONNECT_TYPE {
	BT_CONNECT_AUTH_REQ								= 0x00,
	BT_CONNECT_AUTH_RSP								= 0x01,
	BT_CONNECT_ASOC_REQ								= 0x02,
	BT_CONNECT_ASOC_RSP								= 0x03,
	BT_DISCONNECT										= 0x04
} BT_CONNECT_TYPE, *PBT_CONNECT_TYPE;


typedef struct _PACKET_IRP_HCIEVENT_DATA {
	u8		EventCode;
	u8		Length; /* total cmd length = extension event length+1(extension event code length) */
	u8		Data[1]; /* byte1 is extension event code */
} rtw_HCI_event;


struct btinfo_8761ATV {
	u8 cid;
	u8 len;

	u8 bConnection:1;
	u8 bSCOeSCO:1;
	u8 bInQPage:1;
	u8 bACLBusy:1;
	u8 bSCOBusy:1;
	u8 bHID:1;
	u8 bA2DP:1;
	u8 bFTP:1;

	u8 retry_cnt:4;
	u8 rsvd_34:1;
	u8 bPage:1;
	u8 TRxMask:1;
	u8 Sniff_attempt:1;

	u8 rssi;

	u8 A2dp_rate:1;
	u8 ReInit:1;
	u8 MaxPower:1;
	u8 bEnIgnoreWlanAct:1;
	u8 TxPowerLow:1;
	u8 TxPowerHigh:1;
	u8 eSCO_SCO:1;
	u8 Master_Slave:1;

	u8 ACL_TRx_TP_low;
	u8 ACL_TRx_TP_high;
};

#define HCIOPCODE(_OCF, _OGF)     ((_OGF)<<10|(_OCF))
#define HCIOPCODELOW(_OCF, _OGF)	(u8)(HCIOPCODE(_OCF, _OGF) & 0x00ff)
#define HCIOPCODEHIGHT(_OCF, _OGF) (u8)(HCIOPCODE(_OCF, _OGF)>>8)
#define HCI_OGF(opCode)  (unsigned char)((0xFC00 & (opCode)) >> 10)
#define HCI_OCF(opCode)  (0x3FF & (opCode))


typedef enum _HCI_STATUS {
	HCI_STATUS_SUCCESS										= 0x00, /* Success */
	HCI_STATUS_UNKNOW_HCI_CMD								= 0x01, /* Unknown HCI Command */
	HCI_STATUS_UNKNOW_CONNECT_ID							= 0X02, /* Unknown Connection Identifier */
	HCI_STATUS_HW_FAIL										= 0X03, /* Hardware Failure */
	HCI_STATUS_PAGE_TIMEOUT									= 0X04, /* Page Timeout */
	HCI_STATUS_AUTH_FAIL										= 0X05, /* Authentication Failure */
	HCI_STATUS_PIN_OR_KEY_MISSING							= 0X06, /* PIN or Key Missing */
	HCI_STATUS_MEM_CAP_EXCEED								= 0X07, /* Memory Capacity Exceeded */
	HCI_STATUS_CONNECT_TIMEOUT								= 0X08, /* Connection Timeout */
	HCI_STATUS_CONNECT_LIMIT									= 0X09, /* Connection Limit Exceeded */
	HCI_STATUS_SYN_CONNECT_LIMIT								= 0X0a, /* Synchronous Connection Limit To A Device Exceeded */
	HCI_STATUS_ACL_CONNECT_EXISTS							= 0X0b, /* ACL Connection Already Exists */
	HCI_STATUS_CMD_DISALLOW									= 0X0c, /* Command Disallowed */
	HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE					= 0X0d, /* Connection Rejected due to Limited Resources */
	HCI_STATUS_CONNECT_RJT_SEC_REASON						= 0X0e, /* Connection Rejected Due To Security Reasons */
	HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR				= 0X0f, /* Connection Rejected due to Unacceptable BD_ADDR */
	HCI_STATUS_CONNECT_ACCEPT_TIMEOUT						= 0X10, /* Connection Accept Timeout Exceeded */
	HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE				= 0X11, /* Unsupported Feature or Parameter Value */
	HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE					= 0X12, /* Invalid HCI Command Parameters */
	HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT				= 0X13, /* Remote User Terminated Connection */
	HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE			= 0X14, /* Remote Device Terminated Connection due to Low Resources */
	HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF	= 0X15, /* Remote Device Terminated Connection due to Power Off */
	HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST				= 0X16, /* Connection Terminated By Local Host */
	HCI_STATUS_REPEATE_ATTEMPT								= 0X17, /* Repeated Attempts */
	HCI_STATUS_PAIR_NOT_ALLOW								= 0X18, /* Pairing Not Allowed */
	HCI_STATUS_UNKNOW_LMP_PDU								= 0X19, /* Unknown LMP PDU */
	HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE				= 0X1a, /* Unsupported Remote Feature / Unsupported LMP Feature */
	HCI_STATUS_SOC_OFFSET_REJECT								= 0X1b, /* SCO Offset Rejected */
	HCI_STATUS_SOC_INTERVAL_REJECT							= 0X1c, /* SCO Interval Rejected */
	HCI_STATUS_SOC_AIR_MODE_REJECT							= 0X1d, /* SCO Air Mode Rejected */
	HCI_STATUS_INVALID_LMP_PARA								= 0X1e, /* Invalid LMP Parameters */
	HCI_STATUS_UNSPECIFIC_ERROR								= 0X1f, /* Unspecified Error */
	HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE					= 0X20, /* Unsupported LMP Parameter Value */
	HCI_STATUS_ROLE_CHANGE_NOT_ALLOW						= 0X21, /* Role Change Not Allowed */
	HCI_STATUS_LMP_RESPONSE_TIMEOUT							= 0X22, /* LMP Response Timeout */
	HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION				= 0X23, /* LMP Error Transaction Collision */
	HCI_STATUS_LMP_PDU_NOT_ALLOW							= 0X24, /* LMP PDU Not Allowed */
	HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW					= 0X25, /* Encryption Mode Not Acceptable */
	HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE						= 0X26, /* Link Key Can Not be Changed */
	HCI_STATUS_REQUEST_QOS_NOT_SUPPORT						= 0X27, /* Requested QoS Not Supported */
	HCI_STATUS_INSTANT_PASSED								= 0X28, /* Instant Passed */
	HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT					= 0X29, /* Pairing With Unit Key Not Supported */
	HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION				= 0X2a, /* Different Transaction Collision */
	HCI_STATUS_RESERVE_1										= 0X2b, /* Reserved */
	HCI_STATUS_QOS_UNACCEPT_PARA							= 0X2c, /* QoS Unacceptable Parameter */
	HCI_STATUS_QOS_REJECT										= 0X2d, /* QoS Rejected */
	HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT				= 0X2e, /* Channel Classification Not Supported */
	HCI_STATUS_INSUFFICIENT_SECURITY							= 0X2f, /* Insufficient Security */
	HCI_STATUS_PARA_OUT_OF_RANGE							= 0x30, /* Parameter Out Of Mandatory Range */
	HCI_STATUS_RESERVE_2										= 0X31, /* Reserved */
	HCI_STATUS_ROLE_SWITCH_PENDING							= 0X32, /* Role Switch Pending */
	HCI_STATUS_RESERVE_3										= 0X33, /* Reserved */
	HCI_STATUS_RESERVE_SOLT_VIOLATION						= 0X34, /* Reserved Slot Violation */
	HCI_STATUS_ROLE_SWITCH_FAIL								= 0X35, /* Role Switch Failed */
	HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE				= 0X36, /* Extended Inquiry Response Too Large */
	HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT				= 0X37, /* Secure Simple Pairing Not Supported By Host. */
	HCI_STATUS_HOST_BUSY_PAIRING								= 0X38, /* Host Busy - Pairing */
	HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND			= 0X39, /* Connection Rejected due to No Suitable Channel Found */
	HCI_STATUS_CONTROLLER_BUSY								= 0X3a /* CONTROLLER BUSY */
} RTW_HCI_STATUS;

#define HCI_EVENT_COMMAND_COMPLETE					0x0e

#define OGF_EXTENSION									0X3f
typedef enum HCI_EXTENSION_COMMANDS {
	HCI_SET_ACL_LINK_DATA_FLOW_MODE				= 0x0010,
	HCI_SET_ACL_LINK_STATUS							= 0x0020,
	HCI_SET_SCO_LINK_STATUS							= 0x0030,
	HCI_SET_RSSI_VALUE								= 0x0040,
	HCI_SET_CURRENT_BLUETOOTH_STATUS				= 0x0041,

	/* The following is for RTK8723 */
	HCI_EXTENSION_VERSION_NOTIFY					= 0x0100,
	HCI_LINK_STATUS_NOTIFY							= 0x0101,
	HCI_BT_OPERATION_NOTIFY							= 0x0102,
	HCI_ENABLE_WIFI_SCAN_NOTIFY						= 0x0103,
	HCI_QUERY_RF_STATUS								= 0x0104,
	HCI_BT_ABNORMAL_NOTIFY							= 0x0105,
	HCI_BT_INFO_NOTIFY								= 0x0106,
	HCI_BT_COEX_NOTIFY								= 0x0107,
	HCI_BT_PATCH_VERSION_NOTIFY						= 0x0108,
	HCI_BT_AFH_MAP_NOTIFY							= 0x0109,
	HCI_BT_REGISTER_VALUE_NOTIFY					= 0x010a,

	/* The following is for IVT */
	HCI_WIFI_CURRENT_CHANNEL						= 0x0300,
	HCI_WIFI_CURRENT_BANDWIDTH						= 0x0301,
	HCI_WIFI_CONNECTION_STATUS						= 0x0302
} RTW_HCI_EXT_CMD;

#define HCI_EVENT_EXTENSION_RTK						0xfe
typedef enum HCI_EXTENSION_EVENT_RTK {
	HCI_EVENT_EXT_WIFI_SCAN_NOTIFY								= 0x01,
	HCI_EVENT_EXT_WIFI_RF_STATUS_NOTIFY						= 0x02,
	HCI_EVENT_EXT_BT_INFO_CONTROL								= 0x03,
	HCI_EVENT_EXT_BT_COEX_CONTROL								= 0x04
} RTW_HCI_EXT_EVENT;

typedef enum _BT_TRAFFIC_MODE {
	BT_MOTOR_EXT_BE		= 0x00, /* Best Effort. Default. for HCRP, PAN, SDP, RFCOMM-based profiles like FTP,OPP, SPP, DUN, etc. */
	BT_MOTOR_EXT_GUL		= 0x01, /* Guaranteed Latency. This type of traffic is used e.g. for HID and AVRCP. */
	BT_MOTOR_EXT_GUB		= 0X02, /* Guaranteed Bandwidth. */
	BT_MOTOR_EXT_GULB	= 0X03  /* Guaranteed Latency and Bandwidth. for A2DP and VDP. */
} BT_TRAFFIC_MODE;

typedef enum _BT_TRAFFIC_MODE_PROFILE {
	BT_PROFILE_NONE,
	BT_PROFILE_A2DP,
	BT_PROFILE_PAN	,
	BT_PROFILE_HID,
	BT_PROFILE_SCO
} BT_TRAFFIC_MODE_PROFILE;

typedef enum _HCI_EXT_BT_OPERATION {
	HCI_BT_OP_NONE				= 0x0,
	HCI_BT_OP_INQUIRY_START		= 0x1,
	HCI_BT_OP_INQUIRY_FINISH		= 0x2,
	HCI_BT_OP_PAGING_START		= 0x3,
	HCI_BT_OP_PAGING_SUCCESS		= 0x4,
	HCI_BT_OP_PAGING_UNSUCCESS	= 0x5,
	HCI_BT_OP_PAIRING_START		= 0x6,
	HCI_BT_OP_PAIRING_FINISH		= 0x7,
	HCI_BT_OP_BT_DEV_ENABLE		= 0x8,
	HCI_BT_OP_BT_DEV_DISABLE		= 0x9,
	HCI_BT_OP_MAX
} HCI_EXT_BT_OPERATION, *PHCI_EXT_BT_OPERATION;

typedef struct _BT_MGNT {
	BOOLEAN				bBTConnectInProgress;
	BOOLEAN				bLogLinkInProgress;
	BOOLEAN				bPhyLinkInProgress;
	BOOLEAN				bPhyLinkInProgressStartLL;
	u8				BtCurrentPhyLinkhandle;
	u16				BtCurrentLogLinkhandle;
	u8				CurrentConnectEntryNum;
	u8				DisconnectEntryNum;
	u8				CurrentBTConnectionCnt;
	BT_CONNECT_TYPE		BTCurrentConnectType;
	BT_CONNECT_TYPE		BTReceiveConnectPkt;
	u8				BTAuthCount;
	u8				BTAsocCount;
	BOOLEAN				bStartSendSupervisionPkt;
	BOOLEAN				BtOperationOn;
	BOOLEAN				BTNeedAMPStatusChg;
	BOOLEAN				JoinerNeedSendAuth;
	HCI_PHY_LINK_BSS_INFO	bssDesc;
	HCI_EXT_CONFIG		ExtConfig;
	BOOLEAN				bNeedNotifyAMPNoCap;
	BOOLEAN				bCreateSpportQos;
	BOOLEAN				bSupportProfile;
	u8				BTChannel;
	BOOLEAN				CheckChnlIsSuit;
	BOOLEAN				bBtScan;
	BOOLEAN				btLogoTest;
	BOOLEAN				bRfStatusNotified;
	BOOLEAN				bBtRsvedPageDownload;
} BT_MGNT, *PBT_MGNT;

struct bt_coex_info {
	/* For Kernel Socket */
	struct socket *udpsock;
	struct sockaddr_in wifi_sockaddr; /*wifi socket*/
	struct sockaddr_in bt_sockaddr;/* BT socket */
	struct sock *sk_store;/*back up socket for UDP RX int*/

	/* store which socket is OK */
	u8 sock_open;

	u8 BT_attend;
	u8 is_exist; /* socket exist */
	BT_MGNT BtMgnt;
	struct workqueue_struct *btcoex_wq;
	struct delayed_work recvmsg_work;
};
#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */

#define	PACKET_NORMAL			0
#define	PACKET_DHCP				1
#define	PACKET_ARP				2
#define	PACKET_EAPOL			3

void rtw_btcoex_Initialize(PADAPTER);
void rtw_btcoex_PowerOnSetting(PADAPTER padapter);
void rtw_btcoex_AntInfoSetting(PADAPTER padapter);
void rtw_btcoex_PowerOffSetting(PADAPTER padapter);
void rtw_btcoex_PreLoadFirmware(PADAPTER padapter);
void rtw_btcoex_HAL_Initialize(PADAPTER padapter, u8 bWifiOnly);
void rtw_btcoex_IpsNotify(PADAPTER, u8 type);
void rtw_btcoex_LpsNotify(PADAPTER, u8 type);
void rtw_btcoex_ScanNotify(PADAPTER, u8 type);
void rtw_btcoex_MediaStatusNotify(PADAPTER, u8 mediaStatus);
void rtw_btcoex_SpecialPacketNotify(PADAPTER, u8 pktType);
void rtw_btcoex_IQKNotify(PADAPTER padapter, u8 state);
void rtw_btcoex_BtInfoNotify(PADAPTER, u8 length, u8 *tmpBuf);
void rtw_btcoex_BtMpRptNotify(PADAPTER, u8 length, u8 *tmpBuf);
void rtw_btcoex_SuspendNotify(PADAPTER, u8 state);
void rtw_btcoex_HaltNotify(PADAPTER);
void rtw_btcoex_switchband_notify(u8 under_scan, u8 band_type);
void rtw_btcoex_WlFwDbgInfoNotify(PADAPTER padapter, u8* tmpBuf, u8 length);
void rtw_btcoex_rx_rate_change_notify(PADAPTER padapter, u8 is_data_frame, u8 rate_id);
void rtw_btcoex_SwitchBtTRxMask(PADAPTER);
void rtw_btcoex_Switch(PADAPTER, u8 enable);
u8 rtw_btcoex_IsBtDisabled(PADAPTER);
void rtw_btcoex_Handler(PADAPTER);
s32 rtw_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
s32 rtw_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER);
u32 rtw_btcoex_GetAMPDUSize(PADAPTER);
void rtw_btcoex_SetManualControl(PADAPTER, u8 bmanual);
u8 rtw_btcoex_1Ant(PADAPTER);
u8 rtw_btcoex_IsBtControlLps(PADAPTER);
u8 rtw_btcoex_IsLpsOn(PADAPTER);
u8 rtw_btcoex_RpwmVal(PADAPTER);
u8 rtw_btcoex_LpsVal(PADAPTER);
u32 rtw_btcoex_GetRaMask(PADAPTER);
u8 rtw_btcoex_query_reduced_wl_pwr_lvl(PADAPTER padapter);
void rtw_btcoex_set_reduced_wl_pwr_lvl(PADAPTER padapter, u8 val);
void rtw_btcoex_do_reduce_wl_pwr_lvl(PADAPTER padapter);
void rtw_btcoex_RecordPwrMode(PADAPTER, u8 *pCmdBuf, u8 cmdLen);
void rtw_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
void rtw_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
u32 rtw_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
u8 rtw_btcoex_IncreaseScanDeviceNum(PADAPTER);
u8 rtw_btcoex_IsBtLinkExist(PADAPTER);
void rtw_btcoex_pta_off_on_notify(PADAPTER padapter, u8 bBTON);

#ifdef CONFIG_RF4CE_COEXIST
void rtw_btcoex_SetRf4ceLinkState(PADAPTER padapter, u8 state);
u8 rtw_btcoex_GetRf4ceLinkState(PADAPTER padapter);
#endif

#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
void rtw_btcoex_SetBtPatchVersion(PADAPTER padapter, u16 btHciVer, u16 btPatchVer);
void rtw_btcoex_SetHciVersion(PADAPTER  padapter, u16 hciVersion);
void rtw_btcoex_StackUpdateProfileInfo(void);
void rtw_btcoex_init_socket(_adapter *padapter);
void rtw_btcoex_close_socket(_adapter *padapter);
void rtw_btcoex_dump_tx_msg(u8 *tx_msg, u8 len, u8 *msg_name);
u8 rtw_btcoex_sendmsgbysocket(_adapter *padapter, u8 *msg, u8 msg_size, bool force);
u8 rtw_btcoex_create_kernel_socket(_adapter *padapter);
void rtw_btcoex_close_kernel_socket(_adapter *padapter);
void rtw_btcoex_recvmsgbysocket(void *data);
u16 rtw_btcoex_parse_recv_data(u8 *msg, u8 msg_size);
u8 rtw_btcoex_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
void rtw_btcoex_parse_hci_cmd(_adapter *padapter, u8 *cmd, u16 len);
void rtw_btcoex_SendEventExtBtCoexControl(PADAPTER Adapter, u8 bNeedDbgRsp, u8 dataLen, void *pData);
void rtw_btcoex_SendEventExtBtInfoControl(PADAPTER Adapter, u8 dataLen, void *pData);
void rtw_btcoex_SendScanNotify(PADAPTER padapter, u8 scanType);
#define BT_SendEventExtBtCoexControl(Adapter, bNeedDbgRsp, dataLen, pData) rtw_btcoex_SendEventExtBtCoexControl(Adapter, bNeedDbgRsp, dataLen, pData)
#define BT_SendEventExtBtInfoControl(Adapter, dataLen, pData) rtw_btcoex_SendEventExtBtInfoControl(Adapter, dataLen, pData)
#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
u16 rtw_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
u16 rtw_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
u8 rtw_btcoex_get_reduce_wl_txpwr(PADAPTER padapter);
u8 rtw_btcoex_get_bt_coexist(PADAPTER padapter);
u8 rtw_btcoex_get_chip_type(PADAPTER padapter);
u8 rtw_btcoex_get_pg_ant_num(PADAPTER padapter);
u8 rtw_btcoex_get_pg_single_ant_path(PADAPTER padapter);
u8 rtw_btcoex_get_pg_rfe_type(PADAPTER padapter);
u8 rtw_btcoex_is_tfbga_package_type(PADAPTER padapter);
u8 rtw_btcoex_get_ant_div_cfg(PADAPTER padapter);
u16 rtw_btcoex_btset_testmode(PADAPTER padapter, u8 type);

/* ==================================================
 * Below Functions are called by BT-Coex
 * ================================================== */
void rtw_btcoex_rx_ampdu_apply(PADAPTER padapter);
void rtw_btcoex_LPS_Enter(PADAPTER padapter);
u8 rtw_btcoex_LPS_Leave(PADAPTER padapter);

#endif /* __RTW_BTCOEX_H__ */
#endif /* CONFIG_BT_COEXIST */

void rtw_btcoex_set_ant_info(PADAPTER padapter);
void rtw_btcoex_connect_notify(PADAPTER, u8 join_type);

                                                                                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/rtw_mi.h                                                                      0000644 0001750 0001750 00000026360 14214766567 015105  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_MI_H_
#define __RTW_MI_H_

void rtw_mi_update_union_chan_inf(_adapter *adapter, u8 ch, u8 offset , u8 bw);
u8 rtw_mi_stayin_union_ch_chk(_adapter *adapter);
u8 rtw_mi_stayin_union_band_chk(_adapter *adapter);

int rtw_mi_get_ch_setting_union_by_ifbmp(struct dvobj_priv *dvobj, u8 ifbmp, u8 *ch, u8 *bw, u8 *offset);
int rtw_mi_get_ch_setting_union(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset);
int rtw_mi_get_ch_setting_union_no_self(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset);

struct mi_state {
	u8 sta_num;			/* WIFI_STATION_STATE */
	u8 ld_sta_num;		/* WIFI_STATION_STATE && _FW_LINKED */
	u8 lg_sta_num;		/* WIFI_STATION_STATE && _FW_UNDER_LINKING */
#ifdef CONFIG_TDLS
	u8 ld_tdls_num;		/* adapter.tdlsinfo.link_established */
#endif
#ifdef CONFIG_AP_MODE
	u8 ap_num;			/* WIFI_AP_STATE && _FW_LINKED */
	u8 starting_ap_num;	/*WIFI_FW_AP_STATE*/
	u8 ld_ap_num;		/* WIFI_AP_STATE && _FW_LINKED && asoc_sta_count > 2 */
#endif
	u8 adhoc_num;		/* (WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE) && _FW_LINKED */
	u8 ld_adhoc_num;	/* (WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE) && _FW_LINKED && asoc_sta_count > 2 */
#ifdef CONFIG_RTW_MESH
	u8 mesh_num;		/* WIFI_MESH_STATE &&  _FW_LINKED */
	u8 ld_mesh_num;		/* WIFI_MESH_STATE &&  _FW_LINKED && asoc_sta_count > 2 */
#endif
	u8 scan_num;		/* WIFI_SITE_MONITOR */
	u8 scan_enter_num;	/* WIFI_SITE_MONITOR && !SCAN_DISABLE && !SCAN_BACK_OP */
	u8 uwps_num;		/* WIFI_UNDER_WPS */
#ifdef CONFIG_IOCTL_CFG80211
	#ifdef CONFIG_P2P
	u8 roch_num;
	#endif
	u8 mgmt_tx_num;
#endif
#ifdef CONFIG_P2P
	u8 p2p_device_num;
	u8 p2p_gc;
	u8 p2p_go;
#endif
	u8 union_ch;
	u8 union_bw;
	u8 union_offset;
};

#define MSTATE_STA_NUM(_mstate)			((_mstate)->sta_num)
#define MSTATE_STA_LD_NUM(_mstate)		((_mstate)->ld_sta_num)
#define MSTATE_STA_LG_NUM(_mstate)		((_mstate)->lg_sta_num)

#ifdef CONFIG_TDLS
#define MSTATE_TDLS_LD_NUM(_mstate)		((_mstate)->ld_tdls_num)
#else
#define MSTATE_TDLS_LD_NUM(_mstate)		0
#endif

#ifdef CONFIG_AP_MODE
#define MSTATE_AP_NUM(_mstate)			((_mstate)->ap_num)
#define MSTATE_AP_STARTING_NUM(_mstate)	((_mstate)->starting_ap_num)
#define MSTATE_AP_LD_NUM(_mstate)		((_mstate)->ld_ap_num)
#else
#define MSTATE_AP_NUM(_mstate)			0
#define MSTATE_AP_STARTING_NUM(_mstate) 0
#define MSTATE_AP_LD_NUM(_mstate)		0
#endif

#define MSTATE_ADHOC_NUM(_mstate)		((_mstate)->adhoc_num)
#define MSTATE_ADHOC_LD_NUM(_mstate)	((_mstate)->ld_adhoc_num)

#ifdef CONFIG_RTW_MESH
#define MSTATE_MESH_NUM(_mstate)		((_mstate)->mesh_num)
#define MSTATE_MESH_LD_NUM(_mstate)		((_mstate)->ld_mesh_num)
#else
#define MSTATE_MESH_NUM(_mstate)		0
#define MSTATE_MESH_LD_NUM(_mstate)		0
#endif

#define MSTATE_SCAN_NUM(_mstate)		((_mstate)->scan_num)
#define MSTATE_SCAN_ENTER_NUM(_mstate)	((_mstate)->scan_enter_num)
#define MSTATE_WPS_NUM(_mstate)			((_mstate)->uwps_num)

#if defined(CONFIG_IOCTL_CFG80211) && defined(CONFIG_P2P)
#define MSTATE_ROCH_NUM(_mstate)		((_mstate)->roch_num)
#else
#define MSTATE_ROCH_NUM(_mstate)		0
#endif

#ifdef CONFIG_P2P
#define MSTATE_P2P_DV_NUM(_mstate)		((_mstate)->p2p_device_num)
#define MSTATE_P2P_GC_NUM(_mstate)		((_mstate)->p2p_gc)
#define MSTATE_P2P_GO_NUM(_mstate)		((_mstate)->p2p_go)
#else
#define MSTATE_P2P_DV_NUM(_mstate)		0
#define MSTATE_P2P_GC_NUM(_mstate)		0
#define MSTATE_P2P_GO_NUM(_mstate)		0
#endif

#if defined(CONFIG_IOCTL_CFG80211)
#define MSTATE_MGMT_TX_NUM(_mstate)		((_mstate)->mgmt_tx_num)
#else
#define MSTATE_MGMT_TX_NUM(_mstate)		0
#endif

#define MSTATE_U_CH(_mstate)			((_mstate)->union_ch)
#define MSTATE_U_BW(_mstate)			((_mstate)->union_bw)
#define MSTATE_U_OFFSET(_mstate)		((_mstate)->union_offset)

#define rtw_mi_get_union_chan(adapter)	adapter_to_dvobj(adapter)->iface_state.union_ch
#define rtw_mi_get_union_bw(adapter)		adapter_to_dvobj(adapter)->iface_state.union_bw
#define rtw_mi_get_union_offset(adapter)	adapter_to_dvobj(adapter)->iface_state.union_offset

#define rtw_mi_get_assoced_sta_num(adapter)	DEV_STA_LD_NUM(adapter_to_dvobj(adapter))
#define rtw_mi_get_ap_num(adapter)			DEV_AP_NUM(adapter_to_dvobj(adapter))
#define rtw_mi_get_mesh_num(adapter)		DEV_MESH_NUM(adapter_to_dvobj(adapter))
u8 rtw_mi_get_assoc_if_num(_adapter *adapter);

/* For now, not return union_ch/bw/offset */
void rtw_mi_status_by_ifbmp(struct dvobj_priv *dvobj, u8 ifbmp, struct mi_state *mstate);
void rtw_mi_status(_adapter *adapter, struct mi_state *mstate);
void rtw_mi_status_no_self(_adapter *adapter, struct mi_state *mstate);
void rtw_mi_status_no_others(_adapter *adapter, struct mi_state *mstate);

/* For now, not handle union_ch/bw/offset */
void rtw_mi_status_merge(struct mi_state *d, struct mi_state *a);

void rtw_mi_update_iface_status(struct mlme_priv *pmlmepriv, sint state);

u8 rtw_mi_netif_stop_queue(_adapter *padapter);
u8 rtw_mi_buddy_netif_stop_queue(_adapter *padapter);

u8 rtw_mi_netif_wake_queue(_adapter *padapter);
u8 rtw_mi_buddy_netif_wake_queue(_adapter *padapter);

u8 rtw_mi_netif_carrier_on(_adapter *padapter);
u8 rtw_mi_buddy_netif_carrier_on(_adapter *padapter);
u8 rtw_mi_netif_carrier_off(_adapter *padapter);
u8 rtw_mi_buddy_netif_carrier_off(_adapter *padapter);

u8 rtw_mi_netif_caroff_qstop(_adapter *padapter);
u8 rtw_mi_buddy_netif_caroff_qstop(_adapter *padapter);
u8 rtw_mi_netif_caron_qstart(_adapter *padapter);
u8 rtw_mi_buddy_netif_caron_qstart(_adapter *padapter);

void rtw_mi_scan_abort(_adapter *adapter, bool bwait);
void rtw_mi_buddy_scan_abort(_adapter *adapter, bool bwait);
u32 rtw_mi_start_drv_threads(_adapter *adapter);
u32 rtw_mi_buddy_start_drv_threads(_adapter *adapter);
void rtw_mi_stop_drv_threads(_adapter *adapter);
void rtw_mi_buddy_stop_drv_threads(_adapter *adapter);
void rtw_mi_cancel_all_timer(_adapter *adapter);
void rtw_mi_buddy_cancel_all_timer(_adapter *adapter);
void rtw_mi_reset_drv_sw(_adapter *adapter);
void rtw_mi_buddy_reset_drv_sw(_adapter *adapter);

extern void rtw_intf_start(_adapter *adapter);
extern void rtw_intf_stop(_adapter *adapter);
void rtw_mi_intf_start(_adapter *adapter);
void rtw_mi_buddy_intf_start(_adapter *adapter);
void rtw_mi_intf_stop(_adapter *adapter);
void rtw_mi_buddy_intf_stop(_adapter *adapter);

#ifdef CONFIG_NEW_NETDEV_HDL
u8 rtw_mi_hal_iface_init(_adapter *padapter);
#endif
void rtw_mi_suspend_free_assoc_resource(_adapter *adapter);
void rtw_mi_buddy_suspend_free_assoc_resource(_adapter *adapter);

#ifdef CONFIG_SET_SCAN_DENY_TIMER
void rtw_mi_set_scan_deny(_adapter *adapter, u32 ms);
void rtw_mi_buddy_set_scan_deny(_adapter *adapter, u32 ms);
#else
#define rtw_mi_set_scan_deny(adapter, ms) do {} while (0)
#define rtw_mi_buddy_set_scan_deny(adapter, ms) do {} while (0)
#endif

u8 rtw_mi_is_scan_deny(_adapter *adapter);
u8 rtw_mi_buddy_is_scan_deny(_adapter *adapter);

void rtw_mi_beacon_update(_adapter *padapter);
void rtw_mi_buddy_beacon_update(_adapter *padapter);

void rtw_mi_hal_dump_macaddr(_adapter *padapter);
void rtw_mi_buddy_hal_dump_macaddr(_adapter *padapter);

#ifdef CONFIG_PCI_HCI
void rtw_mi_xmit_tasklet_schedule(_adapter *padapter);
void rtw_mi_buddy_xmit_tasklet_schedule(_adapter *padapter);
#endif

u8 rtw_mi_busy_traffic_check(_adapter *padapter, bool check_sc_interval);
u8 rtw_mi_buddy_busy_traffic_check(_adapter *padapter, bool check_sc_interval);

u8 rtw_mi_check_mlmeinfo_state(_adapter *padapter, u32 state);
u8 rtw_mi_buddy_check_mlmeinfo_state(_adapter *padapter, u32 state);

u8 rtw_mi_check_fwstate(_adapter *padapter, sint state);
u8 rtw_mi_buddy_check_fwstate(_adapter *padapter, sint state);
enum {
	MI_LINKED,
	MI_ASSOC,
	MI_UNDER_WPS,
	MI_AP_MODE,
	MI_AP_ASSOC,
	MI_ADHOC,
	MI_ADHOC_ASSOC,
	MI_MESH,
	MI_MESH_ASSOC,
	MI_STA_NOLINK, /* this is misleading, but not used now */
	MI_STA_LINKED,
	MI_STA_LINKING,
};
u8 rtw_mi_check_status(_adapter *adapter, u8 type);

void dump_dvobj_mi_status(void *sel, const char *fun_name, _adapter *adapter);
#ifdef DBG_IFACE_STATUS
#define DBG_IFACE_STATUS_DUMP(adapter)	dump_dvobj_mi_status(RTW_DBGDUMP, __func__, adapter)
#endif
void dump_mi_status(void *sel, struct dvobj_priv *dvobj);

u8 rtw_mi_traffic_statistics(_adapter *padapter);
u8 rtw_mi_check_miracast_enabled(_adapter *padapter);

#ifdef CONFIG_XMIT_THREAD_MODE
u8 rtw_mi_check_pending_xmitbuf(_adapter *padapter);
u8 rtw_mi_buddy_check_pending_xmitbuf(_adapter *padapter);
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
#ifdef CONFIG_RTL8822B
	#include <rtl8822b_hal.h>
#elif defined(CONFIG_RTL8822C)
	#include <rtl8822c_hal.h>
#else
	extern s32 _dequeue_writeport(PADAPTER padapter);
#endif
u8 rtw_mi_dequeue_writeport(_adapter *padapter);
u8 rtw_mi_buddy_dequeue_writeport(_adapter *padapter);
#endif

void rtw_mi_adapter_reset(_adapter *padapter);
void rtw_mi_buddy_adapter_reset(_adapter *padapter);

u8 rtw_mi_dynamic_check_timer_handlder(_adapter *padapter);
u8 rtw_mi_buddy_dynamic_check_timer_handlder(_adapter *padapter);

extern void rtw_iface_dynamic_chk_wk_hdl(_adapter *padapter);
u8 rtw_mi_dynamic_chk_wk_hdl(_adapter *padapter);
u8 rtw_mi_buddy_dynamic_chk_wk_hdl(_adapter *padapter);

u8 rtw_mi_os_xmit_schedule(_adapter *padapter);
u8 rtw_mi_buddy_os_xmit_schedule(_adapter *padapter);

u8 rtw_mi_report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
u8 rtw_mi_buddy_report_survey_event(_adapter *padapter, union recv_frame *precv_frame);

extern void sreset_start_adapter(_adapter *padapter);
extern void sreset_stop_adapter(_adapter *padapter);
u8 rtw_mi_sreset_adapter_hdl(_adapter *padapter, u8 bstart);
u8 rtw_mi_buddy_sreset_adapter_hdl(_adapter *padapter, u8 bstart);
#if defined(DBG_CONFIG_ERROR_RESET) && defined(CONFIG_CONCURRENT_MODE)
void rtw_mi_ap_info_restore(_adapter *adapter);
#endif

u8 rtw_mi_tx_beacon_hdl(_adapter *padapter);
u8 rtw_mi_buddy_tx_beacon_hdl(_adapter *padapter);

u8 rtw_mi_set_tx_beacon_cmd(_adapter *padapter);
u8 rtw_mi_buddy_set_tx_beacon_cmd(_adapter *padapter);

#ifdef CONFIG_P2P
u8 rtw_mi_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state);
u8 rtw_mi_buddy_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state);
u8 rtw_mi_stay_in_p2p_mode(_adapter *padapter);
u8 rtw_mi_buddy_stay_in_p2p_mode(_adapter *padapter);
#endif

_adapter *rtw_get_iface_by_id(_adapter *padapter, u8 iface_id);
_adapter *rtw_get_iface_by_macddr(_adapter *padapter, const u8 *mac_addr);
_adapter *rtw_get_iface_by_hwport(_adapter *padapter, u8 hw_port);

void rtw_mi_buddy_clone_bcmc_packet(_adapter *padapter, union recv_frame *precvframe, u8 *pphy_status);

#ifdef CONFIG_PCI_HCI
/*API be create temporary for MI, caller is interrupt-handler, PCIE's interrupt handler cannot apply to multi-AP*/
_adapter *rtw_mi_get_ap_adapter(_adapter *padapter);
#endif

u8 rtw_mi_get_ld_sta_ifbmp(_adapter *adapter);
u8 rtw_mi_get_ap_mesh_ifbmp(_adapter *adapter);
void rtw_mi_update_ap_bmc_camid(_adapter *padapter, u8 camid_a, u8 camid_b);

#endif /*__RTW_MI_H_*/
                                                                                                                                                                                                                                                                                rtl8822bu/src/include/rtl8710b_recv.h                                                               0000644 0001750 0001750 00000006555 14214766567 016112  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_RECV_H__
#define __RTL8710B_RECV_H__

#define RECV_BLK_SZ 512
#define RECV_BLK_CNT 16
#define RECV_BLK_TH RECV_BLK_CNT

#if defined(CONFIG_USB_HCI)
	#ifndef MAX_RECVBUF_SZ
		#ifdef CONFIG_MINIMAL_MEMORY_USAGE
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#else
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
				#elif defined(CONFIG_PLATFORM_HISILICON)
				#define MAX_RECVBUF_SZ (16384) /* 16k */
			#else
				#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
				/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
				/* #define MAX_RECVBUF_SZ (20480) */ /* 20K */
				/* #define MAX_RECVBUF_SZ (10240)  */ /* 10K */
				/* #define MAX_RECVBUF_SZ (16384) */ /* 16k - 92E RX BUF :16K */
			#endif
		#endif
	#endif /* !MAX_RECVBUF_SZ */
#endif

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

/*-----------------------------------------------------------------*/
/*	RTL8710B RX BUFFER DESC                                      */
/*-----------------------------------------------------------------*/
/*DWORD 0*/
#define SET_RX_BUFFER_DESC_DATA_LENGTH_8710B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_BUFFER_DESC_LS_8710B(__pRxStatusDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 15, 1, __Value)
#define SET_RX_BUFFER_DESC_FS_8710B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 1, __Value)
#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_8710B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 15, __Value)

#define GET_RX_BUFFER_DESC_OWN_8710B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)
#define GET_RX_BUFFER_DESC_LS_8710B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_BUFFER_DESC_FS_8710B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 1)
#ifdef USING_RX_TAG
	#define GET_RX_BUFFER_DESC_RX_TAG_8710B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 13)
#else
	#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_8710B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 15)
#endif

/*DWORD 1*/
#define SET_RX_BUFFER_PHYSICAL_LOW_8710B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+4, 0, 32, __Value)

/*DWORD 2*/
#ifdef CONFIG_64BIT_DMA
	#define SET_RX_BUFFER_PHYSICAL_HIGH_8710B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+8, 0, 32, __Value)
#else
	#define SET_RX_BUFFER_PHYSICAL_HIGH_8710B(__pRxStatusDesc, __Value)
#endif

#ifdef CONFIG_USB_HCI
	int rtl8710bu_init_recv_priv(_adapter *padapter);
	void rtl8710bu_free_recv_priv(_adapter *padapter);
	void rtl8710bu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
#endif

void rtl8710b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8710B_RECV_H__ */
                                                                                                                                                   rtl8822bu/src/include/Hal8723BPhyCfg.h                                                              0000644 0001750 0001750 00000005123 14214766567 016031  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8723BPHYCFG_H__
#define __INC_HAL8723BPHYCFG_H__

/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters End-------------------------------*/


/*------------------------------Define structure----------------------------*/

/*------------------------------Define structure End----------------------------*/

/*--------------------------Exported Function prototype---------------------*/
u32
PHY_QueryBBReg_8723B(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask
);

void
PHY_SetBBReg_8723B(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask,
		u32		Data
);

u32
PHY_QueryRFReg_8723B(
		PADAPTER			Adapter,
		enum rf_path			eRFPath,
		u32				RegAddr,
		u32				BitMask
);

void
PHY_SetRFReg_8723B(
		PADAPTER			Adapter,
		enum rf_path			eRFPath,
		u32				RegAddr,
		u32				BitMask,
		u32				Data
);

/* MAC/BB/RF HAL config */
int PHY_BBConfig8723B(PADAPTER	Adapter);

int PHY_RFConfig8723B(PADAPTER	Adapter);

s32 PHY_MACConfig8723B(PADAPTER padapter);

int
PHY_ConfigRFWithParaFile_8723B(
		PADAPTER			Adapter,
		u8					*pFileName,
	enum rf_path				eRFPath
);

void
PHY_SetTxPowerIndex_8723B(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

void
PHY_SetTxPowerLevel8723B(
		PADAPTER		Adapter,
		u8			channel
);

void
PHY_SetSwChnlBWMode8723B(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void phy_set_rf_path_switch_8723b(
		struct dm_struct		*phydm,
		bool		bMain
);

/*--------------------------Exported Function prototype End---------------------*/

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                             rtl8822bu/src/include/rtl8188f_rf.h                                                                 0000644 0001750 0001750 00000001530 14214766567 015563  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_RF_H__
#define __RTL8188F_RF_H__

int	PHY_RF6052_Config8188F(PADAPTER		Adapter);

void
PHY_RF6052SetBandwidth8188F(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);

#endif
                                                                                                                                                                        rtl8822bu/src/include/rtl8812a_dm.h                                                                 0000644 0001750 0001750 00000002012 14214766567 015535  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_DM_H__
#define __RTL8812A_DM_H__

void rtl8812_init_dm_priv(PADAPTER Adapter);
void rtl8812_deinit_dm_priv(PADAPTER Adapter);
void rtl8812_InitHalDm(PADAPTER Adapter);
void rtl8812_HalDmWatchDog(PADAPTER Adapter);

/* void rtl8192c_dm_CheckTXPowerTracking(PADAPTER Adapter); */

/* void rtl8192c_dm_RF_Saving(PADAPTER pAdapter, u8 bForceInNormal); */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/rtw_bt_mp.h                                                                   0000644 0001750 0001750 00000017267 14214766567 015607  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __RTW_BT_MP_H
#define __RTW_BT_MP_H


#if (MP_DRIVER == 1)

#pragma pack(1)

/* definition for BT_UP_OP_BT_READY */
#define	MP_BT_NOT_READY						0
#define	MP_BT_READY							1

/* definition for BT_UP_OP_BT_SET_MODE */
typedef enum _MP_BT_MODE {
	MP_BT_MODE_RF_TXRX_TEST_MODE							= 0,
	MP_BT_MODE_BT20_DUT_TEST_MODE							= 1,
	MP_BT_MODE_BT40_DIRECT_TEST_MODE						= 2,
	MP_BT_MODE_CONNECT_TEST_MODE							= 3,
	MP_BT_MODE_MAX
} MP_BT_MODE, *PMP_BT_MODE;


/* definition for BT_UP_OP_BT_SET_TX_RX_PARAMETER */
typedef struct _BT_TXRX_PARAMETERS {
	u8		txrxChannel;
	u32		txrxTxPktCnt;
	u8		txrxTxPktInterval;
	u8		txrxPayloadType;
	u8		txrxPktType;
	u16		txrxPayloadLen;
	u32		txrxPktHeader;
	u8		txrxWhitenCoeff;
	u8		txrxBdaddr[6];
	u8		txrxTxGainIndex;
} BT_TXRX_PARAMETERS, *PBT_TXRX_PARAMETERS;

/* txrxPktType */
typedef enum _MP_BT_PKT_TYPE {
	MP_BT_PKT_DH1							= 0,
	MP_BT_PKT_DH3							= 1,
	MP_BT_PKT_DH5							= 2,
	MP_BT_PKT_2DH1							= 3,
	MP_BT_PKT_2DH3							= 4,
	MP_BT_PKT_2DH5							= 5,
	MP_BT_PKT_3DH1							= 6,
	MP_BT_PKT_3DH3							= 7,
	MP_BT_PKT_3DH5							= 8,
	MP_BT_PKT_LE							= 9,
	MP_BT_PKT_MAX
} MP_BT_PKT_TYPE, *PMP_BT_PKT_TYPE;
/* txrxPayloadType */
typedef enum _MP_BT_PAYLOAD_TYPE {
	MP_BT_PAYLOAD_01010101					= 0,
	MP_BT_PAYLOAD_ALL_1						= 1,
	MP_BT_PAYLOAD_ALL_0						= 2,
	MP_BT_PAYLOAD_11110000					= 3,
	MP_BT_PAYLOAD_PRBS9						= 4,
	MP_BT_PAYLOAD_MAX						= 8,
} MP_BT_PAYLOAD_TYPE, *PMP_BT_PAYLOAD_TYPE;


/* definition for BT_UP_OP_BT_TEST_CTRL */
typedef enum _MP_BT_TEST_CTRL {
	MP_BT_TEST_STOP_ALL_TESTS						= 0,
	MP_BT_TEST_START_RX_TEST						= 1,
	MP_BT_TEST_START_PACKET_TX_TEST					= 2,
	MP_BT_TEST_START_CONTINUOUS_TX_TEST			= 3,
	MP_BT_TEST_START_INQUIRY_SCAN_TEST				= 4,
	MP_BT_TEST_START_PAGE_SCAN_TEST					= 5,
	MP_BT_TEST_START_INQUIRY_PAGE_SCAN_TEST			= 6,
	MP_BT_TEST_START_LEGACY_CONNECT_TEST			= 7,
	MP_BT_TEST_START_LE_CONNECT_TEST_INITIATOR		= 8,
	MP_BT_TEST_START_LE_CONNECT_TEST_ADVERTISER	= 9,
	MP_BT_TEST_MAX
} MP_BT_TEST_CTRL, *PMP_BT_TEST_CTRL;


typedef enum _RTL_EXT_C2H_EVT {
	EXT_C2H_WIFI_FW_ACTIVE_RSP = 0,
	EXT_C2H_TRIG_BY_BT_FW = 1,
	MAX_EXT_C2HEVENT
} RTL_EXT_C2H_EVT;

/* OP codes definition between the user layer and driver */
typedef enum _BT_CTRL_OPCODE_UPPER {
	BT_UP_OP_BT_READY										= 0x00,
	BT_UP_OP_BT_SET_MODE									= 0x01,
	BT_UP_OP_BT_SET_TX_RX_PARAMETER						= 0x02,
	BT_UP_OP_BT_SET_GENERAL								= 0x03,
	BT_UP_OP_BT_GET_GENERAL								= 0x04,
	BT_UP_OP_BT_TEST_CTRL									= 0x05,
	BT_UP_OP_TEST_BT										= 0x06,
	BT_UP_OP_MAX
} BT_CTRL_OPCODE_UPPER, *PBT_CTRL_OPCODE_UPPER;


typedef enum _BT_SET_GENERAL {
	BT_GSET_REG											= 0x00,
	BT_GSET_RESET											= 0x01,
	BT_GSET_TARGET_BD_ADDR									= 0x02,
	BT_GSET_TX_PWR_FINETUNE								= 0x03,
	BT_SET_TRACKING_INTERVAL								= 0x04,
	BT_SET_THERMAL_METER									= 0x05,
	BT_ENABLE_CFO_TRACKING									= 0x06,
	BT_GSET_UPDATE_BT_PATCH								= 0x07,
	BT_GSET_MAX
} BT_SET_GENERAL, *PBT_SET_GENERAL;

typedef enum _BT_GET_GENERAL {
	BT_GGET_REG											= 0x00,
	BT_GGET_STATUS											= 0x01,
	BT_GGET_REPORT											= 0x02,
	BT_GGET_AFH_MAP										= 0x03,
	BT_GGET_AFH_STATUS										= 0x04,
	BT_GGET_MAX
} BT_GET_GENERAL, *PBT_GET_GENERAL;

/* definition for BT_UP_OP_BT_SET_GENERAL */
typedef enum _BT_REG_TYPE {
	BT_REG_RF								= 0,
	BT_REG_MODEM							= 1,
	BT_REG_BLUEWIZE						= 2,
	BT_REG_VENDOR							= 3,
	BT_REG_LE								= 4,
	BT_REG_MAX
} BT_REG_TYPE, *PBT_REG_TYPE;

/* definition for BT_LO_OP_GET_AFH_MAP */
typedef enum _BT_AFH_MAP_TYPE {
	BT_AFH_MAP_RESULT						= 0,
	BT_AFH_MAP_WIFI_PSD_ONLY				= 1,
	BT_AFH_MAP_WIFI_CH_BW_ONLY				= 2,
	BT_AFH_MAP_BT_PSD_ONLY					= 3,
	BT_AFH_MAP_HOST_CLASSIFICATION_ONLY	= 4,
	BT_AFH_MAP_MAX
} BT_AFH_MAP_TYPE, *PBT_AFH_MAP_TYPE;

/* definition for BT_UP_OP_BT_GET_GENERAL */
typedef enum _BT_REPORT_TYPE {
	BT_REPORT_RX_PACKET_CNT				= 0,
	BT_REPORT_RX_ERROR_BITS				= 1,
	BT_REPORT_RSSI							= 2,
	BT_REPORT_CFO_HDR_QUALITY				= 3,
	BT_REPORT_CONNECT_TARGET_BD_ADDR		= 4,
	BT_REPORT_MAX
} BT_REPORT_TYPE, *PBT_REPORT_TYPE;

void
MPTBT_Test(
		PADAPTER	Adapter,
		u8		opCode,
		u8		byte1,
		u8		byte2,
		u8		byte3
);

uint
MPTBT_SendOidBT(
		PADAPTER		pAdapter,
		void				*InformationBuffer,
		u32				InformationBufferLength,
		u32 				*BytesRead,
		u32 				*BytesNeeded
);

void
MPTBT_FwC2hBtMpCtrl(
	PADAPTER	Adapter,
	u8 			*tmpBuf,
	u8			length
);

void MPh2c_timeout_handle(void *FunctionContext);

void mptbt_BtControlProcess(
	PADAPTER	Adapter,
	void			*pInBuf
);

#define	BT_H2C_MAX_RETRY								1
#define	BT_MAX_C2H_LEN								20

typedef struct _BT_REQ_CMD {
	u8       opCodeVer;
	u8       OpCode;
	u16      paraLength;
	u8       pParamStart[100];
} BT_REQ_CMD, *PBT_REQ_CMD;

typedef struct _BT_RSP_CMD {
	u16      status;
	u16      paraLength;
	u8       pParamStart[100];
} BT_RSP_CMD, *PBT_RSP_CMD;


typedef struct _BT_H2C {
	u8	opCodeVer:4;
	u8	reqNum:4;
	u8	opCode;
	u8	buf[100];
} BT_H2C, *PBT_H2C;



typedef struct _BT_EXT_C2H {
	u8	extendId;
	u8	statusCode:4;
	u8	retLen:4;
	u8	opCodeVer:4;
	u8	reqNum:4;
	u8	buf[100];
} BT_EXT_C2H, *PBT_EXT_C2H;


typedef enum _BT_OPCODE_STATUS {
	BT_OP_STATUS_SUCCESS									= 0x00, /* Success */
	BT_OP_STATUS_VERSION_MISMATCH							= 0x01,
	BT_OP_STATUS_UNKNOWN_OPCODE								= 0x02,
	BT_OP_STATUS_ERROR_PARAMETER							= 0x03,
	BT_OP_STATUS_MAX
} BT_OPCODE_STATUS, *PBT_OPCODE_STATUS;



/* OP codes definition between driver and bt fw */
typedef enum _BT_CTRL_OPCODE_LOWER {
	BT_LO_OP_GET_BT_VERSION									= 0x00,
	BT_LO_OP_RESET												= 0x01,
	BT_LO_OP_TEST_CTRL											= 0x02,
	BT_LO_OP_SET_BT_MODE										= 0x03,
	BT_LO_OP_SET_CHNL_TX_GAIN									= 0x04,
	BT_LO_OP_SET_PKT_TYPE_LEN									= 0x05,
	BT_LO_OP_SET_PKT_CNT_L_PL_TYPE								= 0x06,
	BT_LO_OP_SET_PKT_CNT_H_PKT_INTV							= 0x07,
	BT_LO_OP_SET_PKT_HEADER									= 0x08,
	BT_LO_OP_SET_WHITENCOEFF									= 0x09,
	BT_LO_OP_SET_BD_ADDR_L										= 0x0a,
	BT_LO_OP_SET_BD_ADDR_H										= 0x0b,
	BT_LO_OP_WRITE_REG_ADDR									= 0x0c,
	BT_LO_OP_WRITE_REG_VALUE									= 0x0d,
	BT_LO_OP_GET_BT_STATUS										= 0x0e,
	BT_LO_OP_GET_BD_ADDR_L										= 0x0f,
	BT_LO_OP_GET_BD_ADDR_H										= 0x10,
	BT_LO_OP_READ_REG											= 0x11,
	BT_LO_OP_SET_TARGET_BD_ADDR_L								= 0x12,
	BT_LO_OP_SET_TARGET_BD_ADDR_H								= 0x13,
	BT_LO_OP_SET_TX_POWER_CALIBRATION							= 0x14,
	BT_LO_OP_GET_RX_PKT_CNT_L									= 0x15,
	BT_LO_OP_GET_RX_PKT_CNT_H									= 0x16,
	BT_LO_OP_GET_RX_ERROR_BITS_L								= 0x17,
	BT_LO_OP_GET_RX_ERROR_BITS_H								= 0x18,
	BT_LO_OP_GET_RSSI											= 0x19,
	BT_LO_OP_GET_CFO_HDR_QUALITY_L								= 0x1a,
	BT_LO_OP_GET_CFO_HDR_QUALITY_H								= 0x1b,
	BT_LO_OP_GET_TARGET_BD_ADDR_L								= 0x1c,
	BT_LO_OP_GET_TARGET_BD_ADDR_H								= 0x1d,
	BT_LO_OP_GET_AFH_MAP_L										= 0x1e,
	BT_LO_OP_GET_AFH_MAP_M										= 0x1f,
	BT_LO_OP_GET_AFH_MAP_H										= 0x20,
	BT_LO_OP_GET_AFH_STATUS									= 0x21,
	BT_LO_OP_SET_TRACKING_INTERVAL								= 0x22,
	BT_LO_OP_SET_THERMAL_METER									= 0x23,
	BT_LO_OP_ENABLE_CFO_TRACKING								= 0x24,
	BT_LO_OP_MAX
} BT_CTRL_OPCODE_LOWER, *PBT_CTRL_OPCODE_LOWER;




#endif  /* #if(MP_DRIVER == 1) */

#endif /*  #ifndef __INC_MPT_BT_H */
                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/rtw_p2p.h                                                                     0000644 0001750 0001750 00000017465 14214766567 015207  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_P2P_H_
#define __RTW_P2P_H_


u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 *pssid, u8 ussidlen, u8 *pdev_raddr);
u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
#ifdef CONFIG_WFD
int rtw_init_wifi_display_info(_adapter *padapter);
void rtw_wfd_enable(_adapter *adapter, bool on);
void rtw_wfd_set_ctrl_port(_adapter *adapter, u16 port);
void rtw_tdls_wfd_enable(_adapter *adapter, bool on);

u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled);
u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);

u32 rtw_append_beacon_wfd_ie(_adapter *adapter, u8 *pbuf);
u32 rtw_append_probe_req_wfd_ie(_adapter *adapter, u8 *pbuf);
u32 rtw_append_probe_resp_wfd_ie(_adapter *adapter, u8 *pbuf);
u32 rtw_append_assoc_req_wfd_ie(_adapter *adapter, u8 *pbuf);
u32 rtw_append_assoc_resp_wfd_ie(_adapter *adapter, u8 *pbuf);
#endif /*CONFIG_WFD */

void rtw_xframe_chk_wfd_ie(struct xmit_frame *xframe);

u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len);
u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe);
u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
int process_p2p_cross_connect_ie(PADAPTER padapter, u8 *IEs, u32 IELength);

s32 p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType, u8 *buf);

#ifdef CONFIG_P2P_PS
void	process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
void	p2p_ps_wk_hdl(_adapter *padapter, u8 p2p_ps_state);
u8	p2p_ps_wk_cmd(_adapter *padapter, u8 p2p_ps_state, u8 enqueue);
#endif /* CONFIG_P2P_PS */

#ifdef CONFIG_IOCTL_CFG80211
u8 roch_stay_in_cur_chan(_adapter *padapter);
void rtw_init_cfg80211_wifidirect_info(_adapter	*padapter);
int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx);
#endif /* CONFIG_IOCTL_CFG80211 */

void reset_global_wifidirect_info(_adapter *padapter);
void rtw_init_wifidirect_timers(_adapter *padapter);
void rtw_init_wifidirect_addrs(_adapter *padapter, u8 *dev_addr, u8 *iface_addr);
void init_wifidirect_info(_adapter *padapter, enum P2P_ROLE role);
int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role);

static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
{
	if (wdinfo->p2p_state != state) {
		/* wdinfo->pre_p2p_state = wdinfo->p2p_state; */
		wdinfo->p2p_state = state;
	}
}
static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
{
	if (wdinfo->pre_p2p_state != state)
		wdinfo->pre_p2p_state = state;
}
#if 0
static inline void _rtw_p2p_restore_state(struct wifidirect_info *wdinfo)
{
	if (wdinfo->pre_p2p_state != -1) {
		wdinfo->p2p_state = wdinfo->pre_p2p_state;
		wdinfo->pre_p2p_state = -1;
	}
}
#endif
void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role);

static inline int _rtw_p2p_state(struct wifidirect_info *wdinfo)
{
	return wdinfo->p2p_state;
}
static inline int _rtw_p2p_pre_state(struct wifidirect_info *wdinfo)
{
	return wdinfo->pre_p2p_state;
}
static inline int _rtw_p2p_role(struct wifidirect_info *wdinfo)
{
	return wdinfo->role;
}
static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
{
	return wdinfo->p2p_state == state;
}
static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
{
	return wdinfo->role == role;
}

#ifdef CONFIG_DBG_P2P
void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
/* void dbg_rtw_p2p_restore_state(struct wifidirect_info *wdinfo, const char *caller, int line); */
void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line);
#define rtw_p2p_set_state(wdinfo, state) dbg_rtw_p2p_set_state(wdinfo, state, __FUNCTION__, __LINE__)
#define rtw_p2p_set_pre_state(wdinfo, state) dbg_rtw_p2p_set_pre_state(wdinfo, state, __FUNCTION__, __LINE__)
#define rtw_p2p_set_role(wdinfo, role) dbg_rtw_p2p_set_role(wdinfo, role, __FUNCTION__, __LINE__)
/* #define rtw_p2p_restore_state(wdinfo) dbg_rtw_p2p_restore_state(wdinfo, __FUNCTION__, __LINE__) */
#else /* CONFIG_DBG_P2P */
#define rtw_p2p_set_state(wdinfo, state) _rtw_p2p_set_state(wdinfo, state)
#define rtw_p2p_set_pre_state(wdinfo, state) _rtw_p2p_set_pre_state(wdinfo, state)
#define rtw_p2p_set_role(wdinfo, role) _rtw_p2p_set_role(wdinfo, role)
/* #define rtw_p2p_restore_state(wdinfo) _rtw_p2p_restore_state(wdinfo) */
#endif /* CONFIG_DBG_P2P */

#define rtw_p2p_state(wdinfo) _rtw_p2p_state(wdinfo)
#define rtw_p2p_pre_state(wdinfo) _rtw_p2p_pre_state(wdinfo)
#define rtw_p2p_role(wdinfo) _rtw_p2p_role(wdinfo)
#define rtw_p2p_chk_state(wdinfo, state) _rtw_p2p_chk_state(wdinfo, state)
#define rtw_p2p_chk_role(wdinfo, role) _rtw_p2p_chk_role(wdinfo, role)

#define rtw_p2p_findphase_ex_set(wdinfo, value) \
	(wdinfo)->find_phase_state_exchange_cnt = (value)

#ifdef CONFIG_P2P
/* is this find phase exchange for social channel scan? */
#define rtw_p2p_findphase_ex_is_social(wdinfo)   \
	(wdinfo)->find_phase_state_exchange_cnt >= P2P_FINDPHASE_EX_SOCIAL_FIRST

/* should we need find phase exchange anymore? */
#define rtw_p2p_findphase_ex_is_needed(wdinfo) \
	((wdinfo)->find_phase_state_exchange_cnt < P2P_FINDPHASE_EX_MAX && \
	 (wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE && \
	 !(wdinfo)->rx_invitereq_info.scan_op_ch_only && \
	 !(wdinfo)->p2p_info.scan_op_ch_only)
#else
#define rtw_p2p_findphase_ex_is_social(wdinfo) 0
#define rtw_p2p_findphase_ex_is_needed(wdinfo) 0
#endif /* CONFIG_P2P */

#endif
                                                                                                                                                                                                           rtl8822bu/src/include/usb_ops.h                                                                     0000644 0001750 0001750 00000011573 14214766567 015256  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __USB_OPS_H_
#define __USB_OPS_H_


#define REALTEK_USB_VENQT_READ		0xC0
#define REALTEK_USB_VENQT_WRITE	0x40
#define REALTEK_USB_VENQT_CMD_REQ	0x05
#define REALTEK_USB_VENQT_CMD_IDX	0x00
#define REALTEK_USB_IN_INT_EP_IDX	1

enum {
	VENDOR_WRITE = 0x00,
	VENDOR_READ = 0x01,
};
#define ALIGNMENT_UNIT				16
#define MAX_VENDOR_REQ_CMD_SIZE	254		/* 8188cu SIE Support */
#define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE + ALIGNMENT_UNIT)

#ifdef PLATFORM_LINUX
#include <usb_ops_linux.h>
#endif /* PLATFORM_LINUX */

#ifdef CONFIG_RTL8188E
void rtl8188eu_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8188eu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif
#endif

#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
void rtl8812au_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8812au(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif
#endif

#ifdef CONFIG_RTL8814A
void rtl8814au_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8814au(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif
#endif /* CONFIG_RTL8814 */

#ifdef CONFIG_RTL8192E
void rtl8192eu_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8192eu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif

#endif

#ifdef CONFIG_RTL8188F
void rtl8188fu_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8188fu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif
#endif

#ifdef CONFIG_RTL8188GTV
void rtl8188gtvu_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8188gtvu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif
#endif

#ifdef CONFIG_RTL8723B
void rtl8723bu_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8723bu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif
#endif

#ifdef CONFIG_RTL8703B
void rtl8703bu_set_hw_type(struct dvobj_priv *pdvobj);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8703bu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif /* CONFIG_SUPPORT_USB_INT */
#endif /* CONFIG_RTL8703B */

void usb_set_intf_ops(_adapter *padapter, struct _io_ops *pops);

#ifdef CONFIG_RTL8723D
void rtl8723du_set_hw_type(struct dvobj_priv *pdvobj);
void rtl8723du_set_intf_ops(struct _io_ops *pops);
void rtl8723du_recv_tasklet(void *priv);
void rtl8723du_xmit_tasklet(void *priv);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8723du(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif /* CONFIG_SUPPORT_USB_INT */
#endif /* CONFIG_RTL8723D */

#ifdef CONFIG_RTL8710B
void rtl8710bu_set_hw_type(struct dvobj_priv *pdvobj);
void rtl8710bu_set_intf_ops(struct _io_ops *pops);
void rtl8710bu_recv_tasklet(void *priv);
void rtl8710bu_xmit_tasklet(void *priv);
#ifdef CONFIG_SUPPORT_USB_INT
void interrupt_handler_8710bu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif /* CONFIG_SUPPORT_USB_INT */
#endif /* CONFIG_RTL8710B */

#ifdef CONFIG_RTL8192F
void rtl8192fu_set_hw_type(struct dvobj_priv *pdvobj);
void rtl8192fu_xmit_tasklet(void *priv);
#ifdef CONFIG_SUPPORT_USB_INT
void rtl8192fu_interrupt_handler(_adapter *padapter, u16 pkt_len, u8 *pbuf);
#endif /* CONFIG_SUPPORT_USB_INT */
#endif /* CONFIG_RTL8192F */

enum RTW_USB_SPEED {
	RTW_USB_SPEED_UNKNOWN	= 0,
	RTW_USB_SPEED_1_1	= 1,
	RTW_USB_SPEED_2		= 2,
	RTW_USB_SPEED_3		= 3,
};

#define IS_FULL_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_1_1)
#define IS_HIGH_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_2)
#define IS_SUPER_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_3)

#define USB_SUPER_SPEED_BULK_SIZE	1024	/* usb 3.0 */
#define USB_HIGH_SPEED_BULK_SIZE	512		/* usb 2.0 */
#define USB_FULL_SPEED_BULK_SIZE	64		/* usb 1.1 */

static inline u8 rtw_usb_bulk_size_boundary(_adapter *padapter, int buf_len)
{
	u8 rst = _TRUE;

	if (IS_SUPER_SPEED_USB(padapter))
		rst = (0 == (buf_len) % USB_SUPER_SPEED_BULK_SIZE) ? _TRUE : _FALSE;
	else if (IS_HIGH_SPEED_USB(padapter))
		rst = (0 == (buf_len) % USB_HIGH_SPEED_BULK_SIZE) ? _TRUE : _FALSE;
	else
		rst = (0 == (buf_len) % USB_FULL_SPEED_BULK_SIZE) ? _TRUE : _FALSE;
	return rst;
}


#endif /* __USB_OPS_H_ */
                                                                                                                                     rtl8822bu/src/include/Hal8188FPhyReg.h                                                              0000644 0001750 0001750 00000107625 14214766567 016072  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8188FPHYREG_H__
#define __INC_HAL8188FPHYREG_H__

/*--------------------------Define Parameters-------------------------------*/

/* ************************************************************
 * Regsiter offset definition
 * ************************************************************ */

/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rTxAGC_B_Rate18_06				0x830
#define		rTxAGC_B_Rate54_24				0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00			0x83c

#define		rTxAGC_B_Mcs07_Mcs04			0x848
#define		rTxAGC_B_Mcs11_Mcs08			0x84c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rTxAGC_B_Mcs15_Mcs12			0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */

#define		rFPGA1_TxBlock				0x904	/* Useless now */
#define		rFPGA1_DebugSelect			0x908	/* Useless now */
#define		rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
#define	rS0S1_PathSwitch			0x948

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport            		0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower      	0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper      	0xa58  /* 0xa5c
 *
 * PageB(0xB00)
 *   */
#define		rPdp_AntA				0xb00
#define		rPdp_AntA_4				0xb04
#define		rConfig_Pmpd_AntA			0xb28
#define		rConfig_AntA				0xb68
#define		rConfig_AntB				0xb6c
#define		rPdp_AntB					0xb70
#define		rPdp_AntB_4				0xb74
#define		rConfig_Pmpd_AntB			0xb98
#define		rAPK						0xbd8

/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00			0xe10
#define		rTxAGC_A_Mcs07_Mcs04			0xe14
#define		rTxAGC_A_Mcs11_Mcs08			0xe18
#define		rTxAGC_A_Mcs15_Mcs12			0xe1c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/*  */

#define		RF_IQADJ_G1				0x01	/*  */
#define		RF_IQADJ_G2				0x02	/*  */
#define		RF_BS_PA_APSET_G1_G4		0x03
#define		RF_BS_PA_APSET_G5_G8		0x04
#define		RF_POW_TRSW				0x05	/*  */

#define		RF_GAIN_RX					0x06	/*  */
#define		RF_GAIN_TX					0x07	/*  */

#define		RF_TXM_IDAC				0x08	/*  */
#define		RF_IPA_G					0x09	/*  */
#define		RF_TXBIAS_G				0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A					0x0C	/*  */
#define		RF_TXBIAS_A				0x0D
#define		RF_BS_PA_APSET_G9_G11	0x0E
#define		RF_BS_IQGEN				0x0F	/*  */

#define		RF_MODE1					0x10	/*  */
#define		RF_MODE2					0x11	/*  */

#define		RF_RX_AGC_HP				0x12	/*  */
#define		RF_TX_AGC					0x13	/*  */
#define		RF_BIAS						0x14	/*  */
#define		RF_IPA						0x15	/*  */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/*  */
#define		RF_MODE_AG				0x18	/*  */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/*  */

#define		RF_RX_G1					0x1A	/*  */
#define		RF_RX_G2					0x1B	/*  */

#define		RF_RX_BB2					0x1C	/*  */
#define		RF_RX_BB1					0x1D	/*  */

#define		RF_RCK1					0x1E	/*  */
#define		RF_RCK2					0x1F	/*  */

#define		RF_TX_G1					0x20	/*  */
#define		RF_TX_G2					0x21	/*  */
#define		RF_TX_G3					0x22	/*  */

#define		RF_TX_BB1					0x23	/*  */

#define		RF_T_METER					0x24	/*  */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define	RF_TX_BIAS_A				0x35
#define	RF_TX_BIAS_D				0x36
#define	RF_LOBF_9					0x38
#define 	RF_RXRF_A3					0x3C	/*	 */
#define	RF_TRSW					0x3F

#define	RF_TXRF_A2					0x41
#define	RF_TXPA_G4					0x46
#define	RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define		RF_RXG_MIX_SWBW				0x87
#define		RF_DBG_LP_RX2				0xDF
#define	RF_WE_LUT					0xEF
#define	RF_S0S1					0xB0

#define RF_TX_GAIN_OFFSET_8188F(_val) (abs((_val)) | (((_val) > 0) ? BIT5 : 0))

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bAntennaSelect		0x0300

#define		bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                  			0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    			0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  			0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI               		0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength          		0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         		0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW                		0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         		0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              		0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          		0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 		0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                		0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode				0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble			0x8	/* Useless */
#define		bCCKAntDiversity		0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate				0x3000
#define		bCCKDCCancel			0x0800
#define		bCCKISICancel			0x0400
#define		bCCKMatchFilter			0x0200
#define		bCCKEqualizer			0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart			0x300000
#define		bCCKCCACount			0x080000
#define		bCCKcs_lim				0x070000
#define		bCCKBistMode			0x80000000
#define		bCCKCCAMask			0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset			0xf0
#define		bCCKRxDCOffset			0xf
#define		bCCKCCAMode			0xc000
#define		bCCKFalseCS_lim			0x3f00
#define		bCCKCS_ratio			0xc00000
#define		bCCKCorgBit_sel			0x300000
#define		bCCKPD_lim				0x0f0000
#define		bCCKNewCCA			0x80000000
#define		bCCKRxHPofIG			0x8000
#define		bCCKRxIG				0x7f00
#define		bCCKLNAPolarity			0x800000
#define		bCCKRx1stGain			0x7f0000
#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC			0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType	0x0300
#define		bCCKRxDAGCEn			0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0				0x3f0000
#define		bCCKTxC1				0x3f000000
#define		bCCKTxC2				0x3f
#define		bCCKTxC3				0x3f00
#define		bCCKTxC4				0x3f0000
#define		bCCKTxC5				0x3f000000
#define		bCCKTxC6				0x3f
#define		bCCKTxC7				0x3f00
#define		bCCKDebugPort			0xff0000
#define		bCCKDACDebug			0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI				0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel			0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF				0x3	/* Useless */
#define		bShift_L					0xc0
#define		bGI_TH					0xc
#define		bRxPathA				0x1
#define		bRxPathB				0x2
#define		bRxPathC				0x4
#define		bRxPathD				0x8
#define		bTxPathA				0x1
#define		bTxPathB				0x2
#define		bTxPathC				0x4
#define		bTxPathD				0x8
#define		bTRSSIFreq				0x200
#define		bADCBackoff				0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode			0x1800000
#define		bRxDCNFType			0xe000000
#define		bRXIQImb_A				0x3ff
#define		bRXIQImb_B				0xfc00
#define		bRXIQImb_C				0x3f0000
#define		bRXIQImb_D				0xffc00000
#define		bDC_dc_Notch			0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH					0xf
#define		bPD_TH_Opt2			0xc000
#define		bPWED_TH				0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option				0x1000
#define		bMF_Win_L				0xe000
#define		bBW_Search_L			0x30000
#define		bwin_enh_L				0xc0000
#define		bBW_TH					0x700000
#define		bED_TH2				0x3800000
#define		bBW_option				0x4000000
#define		bRatio_TH				0x18000000
#define		bWindow_L				0xe0000000
#define		bSBD_Option				0x1
#define		bFrame_TH				0x1c
#define		bFS_Option				0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune				0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2			0x7
#define		bFrame_GI2_TH			0x38
#define		bGI2_Sync_en			0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum				0x1
#define		bCFOAcc				0x2
#define		bCFOStartOffset			0xc
#define		bCFOLookBack			0x70
#define		bCFOSumWeight			0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A				0x3ff
#define		bTXIQImb_B				0xfc00
#define		bTXIQImb_C				0x3f0000
#define		bTXIQImb_D				0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode			0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption			0x20000
#define		bCCADropThres			0xfff00000
#define		bEDCCA_H				0xf
#define		bEDCCA_L				0xf0
#define		bLambda_ED			0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn				0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En			0x10000000
#define		bRxQuickAGCEn			0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift				0x7f
#define		bTRSW_Tri_Only			0x80
#define		bPowerThres			0x300
#define		bRxAGCEn				0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin				0x4
#define		bRxHP_Ini				0x7
#define		bRxHP_TRLNA			0x70
#define		bRxHP_RSSI				0x700
#define		bRxHP_BBP1				0x7000
#define		bRxHP_BBP2				0x70000
#define		bRxHP_BBP3				0x700000
#define		bRSSI_H					0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW			0x7
#define		bRxSettle_LNA			0x38
#define		bRxSettle_RSSI			0x1c0
#define		bRxSettle_BBP			0xe00
#define		bRxSettle_RxHP			0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI			0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final				0x7000000
#define		bRxHTSettle_BBP			0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn			0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin			0x80000
#define		bRxHTAGCEn				0x100000
#define		bRxHTDAGCEn			0x200000
#define		bRxHTRxHP_BBP			0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH			0x3
#define		bRxPWRatioEn			0x4
#define		bRxMFHold				0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH			0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L			0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH				0xc0000000
#define		bDFSCnt0				0xff
#define		bDFSCnt1				0xff00
#define		bDFSFlag				0xf0000
#define		bMFWeightSum			0x300000
#define		bMinIdxTH				0x7f000000
#define		bDAFormat				0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain				0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn				0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss					0x20
#define		bCFOAntSumD			0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet			0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn				0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re		0x3f
#define		bSigTone_Im		0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail	0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail	0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync	0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength	12   /* total */
#define		bShortCFOFLength	11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength	11
#define		bLongCFOFLength	11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW			0x1
#define		bRxSC				0x6
#define		bRx_HT				0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg	0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain				0x3f
#define		bTableSel			0x40
#define		bTRSW				0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st				0xff
#define		bCSI2nd				0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd			0xff000000
#define		bSIGEVM			0xff
#define		bPWDB				0xff00
#define		bSGIEN				0x10000

#define		bSFactorQAM1		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode			0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType		0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO			0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC					0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF		0x20000
#define		bComChCFO			0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz			0x100000
#define		bUChCfg				0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C	0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW		0x18
#define		bRTL8256_RxLPFBW		0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW		0xc	/* Useless */
#define		bRTL8258_RxLPFBW		0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0				0x1	/* Useless */
#define		bByte1				0x2
#define		bByte2				0x4
#define		bByte3				0x8
#define		bWord0				0x3
#define		bWord1				0xc
#define		bDWord				0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1			0xff00
#define		bMaskByte2			0xff0000
#define		bMaskByte3			0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord			0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes		0xffffff00
#define		bMask12Bits			0xfff
#define		bMaskH4Bits			0xf0000000
#define		bMaskOFDM_D		0xffc00000
#define		bMaskCCK			0x3f3f3f3f


#define		bEnable			0x1	/* Useless */
#define		bDisable		0x0

#define		LeftAntenna		0x0	/* Useless */
#define		RightAntenna	0x1

#define		tCheckTxStatus		500   /* 500ms */ /* Useless */
#define		tUpdateRxCounter	100   /* 100ms */

#define		rateCCK		0	/* Useless */
#define		rateOFDM	1
#define		rateHT		2

/* define Register-End */
#define		bPMAC_End			0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

/*--------------------------Define Parameters-------------------------------*/


/* BB Register Definition
 *
 * 4. Page9(0x900)
 *   */
#define rDPDT_control				0x92c
#define rfe_ctrl_anta_src				0x930
#define rS0S1_PathSwitch			0x948
#define	BBrx_DFIR						0x954
#define AGC_table_select				0xb2c

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA						0xb00
#define rPdp_AntA_4						0xb04
#define rPdp_AntA_8						0xb08
#define rPdp_AntA_C						0xb0c
#define rPdp_AntA_10					0xb10
#define rPdp_AntA_14					0xb14
#define rPdp_AntA_18					0xb18
#define rPdp_AntA_1C					0xb1c
#define rPdp_AntA_20					0xb20
#define rPdp_AntA_24					0xb24

#define rConfig_Pmpd_AntA				0xb28
#define rConfig_ram64x16				0xb2c

#define rBndA							0xb30
#define rHssiPar						0xb34

#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c

#define rPdp_AntB						0xb70
#define rPdp_AntB_4						0xb74
#define rPdp_AntB_8						0xb78
#define rPdp_AntB_C						0xb7c
#define rPdp_AntB_10					0xb80
#define rPdp_AntB_14					0xb84
#define rPdp_AntB_18					0xb88
#define rPdp_AntB_1C					0xb8c
#define rPdp_AntB_20					0xb90
#define rPdp_AntB_24					0xb94

#define rConfig_Pmpd_AntB				0xb98

#define rBndB							0xba0

#define rAPK							0xbd8
#define rPm_Rx0_AntA					0xbdc
#define rPm_Rx1_AntA					0xbe0
#define rPm_Rx2_AntA					0xbe4
#define rPm_Rx3_AntA					0xbe8
#define rPm_Rx0_AntB					0xbec
#define rPm_Rx1_AntB					0xbf0
#define rPm_Rx2_AntB					0xbf4
#define rPm_Rx3_AntB					0xbf8

#endif
                                                                                                           rtl8822bu/src/include/osdep_service_bsd.h                                                           0000644 0001750 0001750 00000052024 14214766567 017262  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __OSDEP_BSD_SERVICE_H_
#define __OSDEP_BSD_SERVICE_H_


#include <sys/cdefs.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/sysctl.h>
#include <sys/lock.h>
#include <sys/mutex.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/endian.h>
#include <sys/kdb.h>
#include <sys/kthread.h>
#include <sys/malloc.h>
#include <sys/time.h>
#include <machine/atomic.h>
#include <machine/bus.h>
#include <machine/resource.h>
#include <sys/rman.h>

#include <net/bpf.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <net/ethernet.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <net/route.h>


#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>
#include <if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_regdomain.h>
#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_ratectl.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include "usbdevs.h"

#define	USB_DEBUG_VAR rum_debug
#include <dev/usb/usb_debug.h>

#if 1 //Baron porting from linux, it's all temp solution, needs to check again
#include <sys/sema.h>
#include <sys/pcpu.h> /* XXX for PCPU_GET */
//	typedef struct 	semaphore _sema;
	typedef struct 	sema _sema;
//	typedef	spinlock_t	_lock;
	typedef	struct mtx	_lock;
	typedef struct mtx 		_mutex;
	typedef struct rtw_timer_list _timer;
	struct list_head {
	struct list_head *next, *prev;
	};
	struct	__queue	{
		struct	list_head	queue;	
		_lock	lock;
	};

	typedef	struct mbuf _pkt;
	typedef struct mbuf	_buffer;
	
	typedef struct	__queue	_queue;
	typedef struct	list_head	_list;
	typedef	int	_OS_STATUS;
	//typedef u32	_irqL;
	typedef unsigned long _irqL;
	typedef	struct	ifnet * _nic_hdl;
	
	typedef pid_t		_thread_hdl_;
//	typedef struct thread		_thread_hdl_;
	typedef void		thread_return;
	typedef void*	thread_context;

	typedef void timer_hdl_return;
	typedef void* timer_hdl_context;
	typedef struct work_struct _workitem;
	typedef struct task _tasklet;

#define   KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
/* emulate a modern version */
#define LINUX_VERSION_CODE KERNEL_VERSION(2, 6, 35)

#define WIRELESS_EXT -1
#define HZ hz
#define spin_lock_irqsave mtx_lock_irqsave
#define spin_lock_bh mtx_lock_irqsave
#define mtx_lock_irqsave(lock, x) mtx_lock(lock)//{local_irq_save((x)); mtx_lock_spin((lock));}
//#define IFT_RTW	0xf9 //ifnet allocate type for RTW
#define free_netdev if_free
#define LIST_CONTAINOR(ptr, type, member) \
        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
#define container_of(p,t,n) (t*)((p)-&(((t*)0)->n))
/* 
 * Linux timers are emulated using FreeBSD callout functions
 * (and taskqueue functionality).
 *
 * Currently no timer stats functionality.
 *
 * See (linux_compat) processes.c
 *
 */
struct rtw_timer_list {
	struct callout callout;
	void (*function)(void *);
	void *arg;
};

struct workqueue_struct;
struct work_struct;
typedef void (*work_func_t)(struct work_struct *work);
/* Values for the state of an item of work (work_struct) */
typedef enum work_state {
        WORK_STATE_UNSET = 0,
        WORK_STATE_CALLOUT_PENDING = 1,
        WORK_STATE_TASK_PENDING = 2,
        WORK_STATE_WORK_CANCELLED = 3        
} work_state_t;

struct work_struct {
        struct task task; /* FreeBSD task */
        work_state_t state; /* the pending or otherwise state of work. */
        work_func_t func;       
};
#define spin_unlock_irqrestore mtx_unlock_irqrestore
#define spin_unlock_bh mtx_unlock_irqrestore
#define mtx_unlock_irqrestore(lock,x)    mtx_unlock(lock);
extern void	_rtw_spinlock_init(_lock *plock);

//modify private structure to match freebsd
#define BITS_PER_LONG 32
union ktime {
	s64	tv64;
#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
	struct {
#ifdef __BIG_ENDIAN
	s32	sec, nsec;
#else
	s32	nsec, sec;
#endif
	} tv;
#endif
};
#define kmemcheck_bitfield_begin(name)
#define kmemcheck_bitfield_end(name)
#define CHECKSUM_NONE 0
typedef unsigned char *sk_buff_data_t;
typedef union ktime ktime_t;		/* Kill this */

void rtw_mtx_lock(_lock *plock);
	
void rtw_mtx_unlock(_lock *plock);

/** 
 *	struct sk_buff - socket buffer
 *	@next: Next buffer in list
 *	@prev: Previous buffer in list
 *	@sk: Socket we are owned by
 *	@tstamp: Time we arrived
 *	@dev: Device we arrived on/are leaving by
 *	@transport_header: Transport layer header
 *	@network_header: Network layer header
 *	@mac_header: Link layer header
 *	@_skb_refdst: destination entry (with norefcount bit)
 *	@sp: the security path, used for xfrm
 *	@cb: Control buffer. Free for use by every layer. Put private vars here
 *	@len: Length of actual data
 *	@data_len: Data length
 *	@mac_len: Length of link layer header
 *	@hdr_len: writable header length of cloned skb
 *	@csum: Checksum (must include start/offset pair)
 *	@csum_start: Offset from skb->head where checksumming should start
 *	@csum_offset: Offset from csum_start where checksum should be stored
 *	@local_df: allow local fragmentation
 *	@cloned: Head may be cloned (check refcnt to be sure)
 *	@nohdr: Payload reference only, must not modify header
 *	@pkt_type: Packet class
 *	@fclone: skbuff clone status
 *	@ip_summed: Driver fed us an IP checksum
 *	@priority: Packet queueing priority
 *	@users: User count - see {datagram,tcp}.c
 *	@protocol: Packet protocol from driver
 *	@truesize: Buffer size 
 *	@head: Head of buffer
 *	@data: Data head pointer
 *	@tail: Tail pointer
 *	@end: End pointer
 *	@destructor: Destruct function
 *	@mark: Generic packet mark
 *	@nfct: Associated connection, if any
 *	@ipvs_property: skbuff is owned by ipvs
 *	@peeked: this packet has been seen already, so stats have been
 *		done for it, don't do them again
 *	@nf_trace: netfilter packet trace flag
 *	@nfctinfo: Relationship of this skb to the connection
 *	@nfct_reasm: netfilter conntrack re-assembly pointer
 *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
 *	@skb_iif: ifindex of device we arrived on
 *	@rxhash: the packet hash computed on receive
 *	@queue_mapping: Queue mapping for multiqueue devices
 *	@tc_index: Traffic control index
 *	@tc_verd: traffic control verdict
 *	@ndisc_nodetype: router type (from link layer)
 *	@dma_cookie: a cookie to one of several possible DMA operations
 *		done by skb DMA functions
 *	@secmark: security marking
 *	@vlan_tci: vlan tag control information
 */

struct sk_buff {
	/* These two members must be first. */
	struct sk_buff		*next;
	struct sk_buff		*prev;

	ktime_t			tstamp;

	struct sock		*sk;
	//struct net_device	*dev;
	struct ifnet *dev;

	/*
	 * This is the control buffer. It is free to use for every
	 * layer. Please put your private variables there. If you
	 * want to keep them across layers you have to do a skb_clone()
	 * first. This is owned by whoever has the skb queued ATM.
	 */
	char			cb[48] __aligned(8);

	unsigned long		_skb_refdst;
#ifdef CONFIG_XFRM
	struct	sec_path	*sp;
#endif
	unsigned int		len,
				data_len;
	u16			mac_len,
				hdr_len;
	union {
		u32		csum;
		struct {
			u16	csum_start;
			u16	csum_offset;
		}smbol2;
	}smbol1;
	u32			priority;
	kmemcheck_bitfield_begin(flags1);
	u8			local_df:1,
				cloned:1,
				ip_summed:2,
				nohdr:1,
				nfctinfo:3;
	u8			pkt_type:3,
				fclone:2,
				ipvs_property:1,
				peeked:1,
				nf_trace:1;
	kmemcheck_bitfield_end(flags1);
	u16			protocol;

	void			(*destructor)(struct sk_buff *skb);
#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
	struct nf_conntrack	*nfct;
	struct sk_buff		*nfct_reasm;
#endif
#ifdef CONFIG_BRIDGE_NETFILTER
	struct nf_bridge_info	*nf_bridge;
#endif

	int			skb_iif;
#ifdef CONFIG_NET_SCHED
	u16			tc_index;	/* traffic control index */
#ifdef CONFIG_NET_CLS_ACT
	u16			tc_verd;	/* traffic control verdict */
#endif
#endif

	u32			rxhash;

	kmemcheck_bitfield_begin(flags2);
	u16			queue_mapping:16;
#ifdef CONFIG_IPV6_NDISC_NODETYPE
	u8			ndisc_nodetype:2,
				deliver_no_wcard:1;
#else
	u8			deliver_no_wcard:1;
#endif
	kmemcheck_bitfield_end(flags2);

	/* 0/14 bit hole */

#ifdef CONFIG_NET_DMA
	dma_cookie_t		dma_cookie;
#endif
#ifdef CONFIG_NETWORK_SECMARK
	u32			secmark;
#endif
	union {
		u32		mark;
		u32		dropcount;
	}symbol3;

	u16			vlan_tci;

	sk_buff_data_t		transport_header;
	sk_buff_data_t		network_header;
	sk_buff_data_t		mac_header;
	/* These elements must be at the end, see alloc_skb() for details.  */
	sk_buff_data_t		tail;
	sk_buff_data_t		end;
	unsigned char		*head,
				*data;
	unsigned int		truesize;
	atomic_t		users;
};
struct sk_buff_head {
	/* These two members must be first. */
	struct sk_buff	*next;
	struct sk_buff	*prev;

	u32		qlen;
	_lock	lock;
};
#define skb_tail_pointer(skb)	skb->tail
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp = skb_tail_pointer(skb);
	//SKB_LINEAR_ASSERT(skb);
	skb->tail += len;
	skb->len  += len;
	return tmp;
}

static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len -= len;
	if(skb->len < skb->data_len)
		printf("%s(),%d,error!\n",__FUNCTION__,__LINE__);
	return skb->data += len;
}
static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
{
	#ifdef PLATFORM_FREEBSD
	return __skb_pull(skb, len);
	#else
	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
	#endif //PLATFORM_FREEBSD
}
static inline u32 skb_queue_len(const struct sk_buff_head *list_)
{
	return list_->qlen;
}
static inline void __skb_insert(struct sk_buff *newsk,
				struct sk_buff *prev, struct sk_buff *next,
				struct sk_buff_head *list)
{
	newsk->next = next;
	newsk->prev = prev;
	next->prev  = prev->next = newsk;
	list->qlen++;
}
static inline void __skb_queue_before(struct sk_buff_head *list,
				      struct sk_buff *next,
				      struct sk_buff *newsk)
{
	__skb_insert(newsk, next->prev, next, list);
}
static inline void skb_queue_tail(struct sk_buff_head *list,
				   struct sk_buff *newsk)
{
	mtx_lock(&list->lock);
	__skb_queue_before(list, (struct sk_buff *)list, newsk);
	mtx_unlock(&list->lock);
}
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
		list = NULL;
	return list;
}
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff *next, *prev;

	list->qlen--;
	next	   = skb->next;
	prev	   = skb->prev;
	skb->next  = skb->prev = NULL;
	next->prev = prev;
	prev->next = next;
}

static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
{
	mtx_lock(&list->lock);

	struct sk_buff *skb = skb_peek(list);
	if (skb)
		__skb_unlink(skb, list);

	mtx_unlock(&list->lock);

	return skb;
}
static inline void skb_reserve(struct sk_buff *skb, int len)
{
	skb->data += len;
	skb->tail += len;
}
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
	list->qlen = 0;
}
/*
 * This function creates a split out lock class for each invocation;
 * this is needed for now since a whole lot of users of the skb-queue
 * infrastructure in drivers have different locking usage (in hardirq)
 * than the networking core (in softirq only). In the long run either the
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	_rtw_spinlock_init(&list->lock);
	__skb_queue_head_init(list);
}
unsigned long copy_from_user(void *to, const void *from, unsigned long n);
unsigned long copy_to_user(void *to, const void *from, unsigned long n);
struct sk_buff * dev_alloc_skb(unsigned int size);
struct sk_buff *skb_clone(const struct sk_buff *skb);
void dev_kfree_skb_any(struct sk_buff *skb);
#endif //Baron porting from linux, it's all temp solution, needs to check again


#if 1 // kenny add Linux compatibility code for Linux USB driver
#include <dev/usb/usb_compat_linux.h>

#define __init		// __attribute ((constructor))
#define __exit		// __attribute ((destructor))

/*
 * Definitions for module_init and module_exit macros.
 *
 * These macros will use the SYSINIT framework to call a specified
 * function (with no arguments) on module loading or unloading.
 * 
 */

void module_init_exit_wrapper(void *arg);

#define module_init(initfn)                             \
        SYSINIT(mod_init_ ## initfn,                    \
                SI_SUB_KLD, SI_ORDER_FIRST,             \
                module_init_exit_wrapper, initfn)

#define module_exit(exitfn)                             \
        SYSUNINIT(mod_exit_ ## exitfn,                  \
                  SI_SUB_KLD, SI_ORDER_ANY,             \
                  module_init_exit_wrapper, exitfn)

/*
 * The usb_register and usb_deregister functions are used to register
 * usb drivers with the usb subsystem. 
 */
int usb_register(struct usb_driver *driver);
int usb_deregister(struct usb_driver *driver);

/*
 * usb_get_dev and usb_put_dev - increment/decrement the reference count 
 * of the usb device structure.
 *
 * Original body of usb_get_dev:
 *
 *       if (dev)
 *               get_device(&dev->dev);
 *       return dev;
 *
 * Reference counts are not currently used in this compatibility
 * layer. So these functions will do nothing.
 */
static inline struct usb_device *
usb_get_dev(struct usb_device *dev)
{
        return dev;
}

static inline void 
usb_put_dev(struct usb_device *dev)
{
        return;
}


// rtw_usb_compat_linux
int rtw_usb_submit_urb(struct urb *urb, uint16_t mem_flags);
int rtw_usb_unlink_urb(struct urb *urb);
int rtw_usb_clear_halt(struct usb_device *dev, struct usb_host_endpoint *uhe);
int rtw_usb_control_msg(struct usb_device *dev, struct usb_host_endpoint *uhe,
    uint8_t request, uint8_t requesttype,
    uint16_t value, uint16_t index, void *data,
    uint16_t size, usb_timeout_t timeout);
int rtw_usb_set_interface(struct usb_device *dev, uint8_t iface_no, uint8_t alt_index);
int rtw_usb_setup_endpoint(struct usb_device *dev,
    struct usb_host_endpoint *uhe, usb_size_t bufsize);
struct urb *rtw_usb_alloc_urb(uint16_t iso_packets, uint16_t mem_flags);
struct usb_host_endpoint *rtw_usb_find_host_endpoint(struct usb_device *dev, uint8_t type, uint8_t ep);
struct usb_host_interface *rtw_usb_altnum_to_altsetting(const struct usb_interface *intf, uint8_t alt_index);
struct usb_interface *rtw_usb_ifnum_to_if(struct usb_device *dev, uint8_t iface_no);
void *rtw_usbd_get_intfdata(struct usb_interface *intf);
void rtw_usb_linux_register(void *arg);
void rtw_usb_linux_deregister(void *arg);
void rtw_usb_linux_free_device(struct usb_device *dev);
void rtw_usb_free_urb(struct urb *urb);
void rtw_usb_init_urb(struct urb *urb);
void rtw_usb_kill_urb(struct urb *urb);
void rtw_usb_set_intfdata(struct usb_interface *intf, void *data);
void rtw_usb_fill_bulk_urb(struct urb *urb, struct usb_device *udev,
    struct usb_host_endpoint *uhe, void *buf,
    int length, usb_complete_t callback, void *arg);
int rtw_usb_bulk_msg(struct usb_device *udev, struct usb_host_endpoint *uhe,
    void *data, int len, uint16_t *pactlen, usb_timeout_t timeout);
void *usb_get_intfdata(struct usb_interface *intf);
int usb_linux_init_endpoints(struct usb_device *udev);



typedef struct urb *  PURB;

typedef unsigned gfp_t;
#define __GFP_WAIT      ((gfp_t)0x10u)  /* Can wait and reschedule? */
#define __GFP_HIGH      ((gfp_t)0x20u)  /* Should access emergency pools? */
#define __GFP_IO        ((gfp_t)0x40u)  /* Can start physical IO? */
#define __GFP_FS        ((gfp_t)0x80u)  /* Can call down to low-level FS? */
#define __GFP_COLD      ((gfp_t)0x100u) /* Cache-cold page required */
#define __GFP_NOWARN    ((gfp_t)0x200u) /* Suppress page allocation failure warning */
#define __GFP_REPEAT    ((gfp_t)0x400u) /* Retry the allocation.  Might fail */
#define __GFP_NOFAIL    ((gfp_t)0x800u) /* Retry for ever.  Cannot fail */
#define __GFP_NORETRY   ((gfp_t)0x1000u)/* Do not retry.  Might fail */
#define __GFP_NO_GROW   ((gfp_t)0x2000u)/* Slab internal usage */
#define __GFP_COMP      ((gfp_t)0x4000u)/* Add compound page metadata */
#define __GFP_ZERO      ((gfp_t)0x8000u)/* Return zeroed page on success */
#define __GFP_NOMEMALLOC ((gfp_t)0x10000u) /* Don't use emergency reserves */
#define __GFP_HARDWALL   ((gfp_t)0x20000u) /* Enforce hardwall cpuset memory allocs */

/* This equals 0, but use constants in case they ever change */
#define GFP_NOWAIT      (GFP_ATOMIC & ~__GFP_HIGH)
/* GFP_ATOMIC means both !wait (__GFP_WAIT not set) and use emergency pool */
#define GFP_ATOMIC      (__GFP_HIGH)
#define GFP_NOIO        (__GFP_WAIT)
#define GFP_NOFS        (__GFP_WAIT | __GFP_IO)
#define GFP_KERNEL      (__GFP_WAIT | __GFP_IO | __GFP_FS)
#define GFP_USER        (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
#define GFP_HIGHUSER    (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \
                         __GFP_HIGHMEM)


#endif // kenny add Linux compatibility code for Linux USB

__inline static _list *get_next(_list	*list)
{
	return list->next;
}	

__inline static _list	*get_list_head(_queue	*queue)
{
	return (&(queue->queue));
}

	
#define LIST_CONTAINOR(ptr, type, member) \
        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))	

        
__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
{
	spin_lock_irqsave(plock, *pirqL);
}

__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
{
	spin_unlock_irqrestore(plock, *pirqL);
}

__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
{
	spin_lock_irqsave(plock, *pirqL);
}

__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
{
	spin_unlock_irqrestore(plock, *pirqL);
}

__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
{
	spin_lock_bh(plock, *pirqL);
}

__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
{
	spin_unlock_bh(plock, *pirqL);
}

__inline static void _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{

		mtx_lock(pmutex);

}


__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{

		mtx_unlock(pmutex);

}
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
	prev->next = next;
}
static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
}
__inline static void rtw_list_delete(_list *plist)
{
	__list_del(plist->prev, plist->next);
	INIT_LIST_HEAD(plist);
}

static inline void timer_hdl(void *ctx)
{
	_timer *timer = (_timer *)ctx;

	rtw_mtx_lock(NULL);
	if (callout_pending(&timer->callout)) {
		/* callout was reset */
		rtw_mtx_unlock(NULL);
		return;
	}

	if (!callout_active(&timer->callout)) {
		/* callout was stopped */
		rtw_mtx_unlock(NULL);
		return;
	}

	callout_deactivate(&timer->callout);

	timer->function(timer->arg);

	rtw_mtx_unlock(NULL);
}

static inline void _init_timer(_timer *ptimer, _nic_hdl padapter, void *pfunc, void *cntx)
{
	ptimer->function = pfunc;
	ptimer->arg = cntx;
	callout_init(&ptimer->callout, CALLOUT_MPSAFE);
}

__inline static void _set_timer(_timer *ptimer,u32 delay_time)
{	
	if (ptimer->function && ptimer->arg) {
		rtw_mtx_lock(NULL);
		callout_reset(&ptimer->callout, delay_time, timer_hdl, ptimer);
		rtw_mtx_unlock(NULL);
	}
}

__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
{
	rtw_mtx_lock(NULL);
	callout_drain(&ptimer->callout);
	rtw_mtx_unlock(NULL);
	*bcancelled = 1; /* assume an pending timer to be canceled */
}

__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
{
	printf("%s Not implement yet! \n",__FUNCTION__);
}

__inline static void _set_workitem(_workitem *pwork)
{
	printf("%s Not implement yet! \n",__FUNCTION__);
//	schedule_work(pwork);
}

//
// Global Mutex: can only be used at PASSIVE level.
//

#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
{                                                               \
}

#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
{                                                               \
}

#define ATOMIC_INIT(i)  { (i) }

static __inline void thread_enter(char *name);

//Atomic integer operations
typedef uint32_t ATOMIC_T ;

#define rtw_netdev_priv(netdev) (((struct ifnet *)netdev)->if_softc)

#define rtw_free_netdev(netdev) if_free((netdev))

#define NDEV_FMT "%s"
#define NDEV_ARG(ndev) ""
#define ADPT_FMT "%s"
#define ADPT_ARG(adapter) ""
#define FUNC_NDEV_FMT "%s"
#define FUNC_NDEV_ARG(ndev) __func__
#define FUNC_ADPT_FMT "%s"
#define FUNC_ADPT_ARG(adapter) __func__

#define STRUCT_PACKED

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8192e_recv.h                                                               0000644 0001750 0001750 00000022144 14214766567 016111  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_RECV_H__
#define __RTL8192E_RECV_H__

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifdef CONFIG_MINIMAL_MEMORY_USAGE
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#else
			#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
				#define MAX_RECVBUF_SZ (rtw_rtkm_get_buff_size()) /*depend rtkm*/
			#elif defined(CONFIG_PLATFORM_HISILICON)
				#define MAX_RECVBUF_SZ (16384) /* 16k */
			#else
				#define MAX_RECVBUF_SZ (32768) /* 32k */
			#endif
			/* #define MAX_RECVBUF_SZ (20480) */ /* 20K */
			/* #define MAX_RECVBUF_SZ (10240)  */ /* 10K */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16k - 92E RX BUF :16K */
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k		 */
			#ifdef CONFIG_PLATFORM_NOVATEK_NT72668
				#undef MAX_RECVBUF_SZ
				#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
			#endif /* CONFIG_PLATFORM_NOVATEK_NT72668 */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI)

	#define MAX_RECVBUF_SZ (16384)

#endif


/* Rx smooth factor */
#define Rx_Smooth_Factor (20)

/* *************
 * [1] Rx Buffer Descriptor (for PCIE) buffer descriptor architecture
 * DWORD 0 */
#define SET_RX_BUFFER_DESC_DATA_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 15, 1, __Value)
#define SET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 1, __Value)
#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 15, __Value)

#define GET_RX_BUFFER_DESC_OWN_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)
#define GET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 1)
#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 15)


/* DWORD 1 */
#define SET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+4, 0, 32, __Value)
#define GET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 0, 32)

/* DWORD 2 */
#define SET_RX_BUFFER_PHYSICAL_HIGH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+8, 0, 32, __Value)

/* *************
 * [2] Rx Descriptor
 * DWORD 0 */
#define GET_RX_STATUS_DESC_PKT_LEN_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICVERR_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_EOR_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_OWN_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)


#define SET_RX_STATUS_DESC_PKT_LEN_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_92E(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_TID_92E(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_MACID_VLD_92E(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 12, 1)
#define GET_RX_STATUS_DESC_AMSDU_92E(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_A1_FITS_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 16, 4)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHKERR_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_IPVER_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_IS_TCPUDP_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHK_VLD_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_MC_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_92E(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#define GET_RX_STATUS_DESC_RX_IS_QOS_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)

#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_HWRSVD_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 24, 4)
#define GET_RX_STATUS_DESC_FCS_OK_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 31, 1)
#define GET_RX_STATUS_DESC_RPT_SEL_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_HTC_92E(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_92E(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#define GET_RX_STATUS_DESC_DMA_AGG_NUM_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)

#define GET_RX_STATUS_DESC_PATTERN_MATCH_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_WAKE_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

/* DWORD 6 */
#define GET_RX_STATUS_DESC_SPLCP_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 1)
#define GET_RX_STATUS_DESC_LDPC_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 1, 1)
#define GET_RX_STATUS_DESC_STBC_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 2, 1)
#define GET_RX_STATUS_DESC_BW_92E(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 4, 2)


/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

#define GET_RX_STATUS_DESC_BUFF_ADDR_92E(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
#define GET_RX_STATUS_DESC_BUFF_ADDR64_92E(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)


#ifdef CONFIG_SDIO_HCI
	s32 rtl8192es_init_recv_priv(PADAPTER padapter);
	void rtl8192es_free_recv_priv(PADAPTER padapter);
	s32 rtl8192es_recv_hdl(_adapter *padapter);
#endif

#ifdef CONFIG_USB_HCI
	void rtl8192eu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
	s32 rtl8192eu_init_recv_priv(PADAPTER padapter);
	void rtl8192eu_free_recv_priv(PADAPTER padapter);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8192ee_init_recv_priv(PADAPTER padapter);
	void rtl8192ee_free_recv_priv(PADAPTER padapter);
#endif

void rtl8192e_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8192E_RECV_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8192f_cmd.h                                                                0000644 0001750 0001750 00000025537 14214766567 015727  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_CMD_H__
#define __RTL8192F_CMD_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

enum h2c_cmd_8192F {
	/* Common Class: 000 */
	H2C_8192F_RSVD_PAGE = 0x00,
	H2C_8192F_MEDIA_STATUS_RPT = 0x01,
	H2C_8192F_SCAN_ENABLE = 0x02,
	H2C_8192F_KEEP_ALIVE = 0x03,
	H2C_8192F_DISCON_DECISION = 0x04,	
	H2C_8192F_PSD_OFFLOAD = 0x05,	
	H2C_8192F_AP_OFFLOAD = 0x08,	
	H2C_8192F_BCN_RSVDPAGE = 0x09,	
	H2C_8192F_PROBERSP_RSVDPAGE = 0x0A,	
	H2C_8192F_FCS_RSVDPAGE = 0x10,	
	H2C_8192F_FCS_INFO = 0x11,	
	H2C_8192F_AP_WOW_GPIO_CTRL = 0x13,

	/* PoweSave Class: 001 */
	H2C_8192F_SET_PWR_MODE = 0x20,
	H2C_8192F_PS_TUNING_PARA = 0x21,
	H2C_8192F_PS_TUNING_PARA2 = 0x22,
	H2C_8192F_P2P_LPS_PARAM = 0x23,	
	H2C_8192F_P2P_PS_OFFLOAD = 0x24,	
	H2C_8192F_PS_SCAN_ENABLE = 0x25,	
	H2C_8192F_SAP_PS_ = 0x26,
	H2C_8192F_INACTIVE_PS_ = 0x27,/* Inactive_PS */
	H2C_8192F_FWLPS_IN_IPS_ = 0x28,

	/* Dynamic Mechanism Class: 010 */
	H2C_8192F_MACID_CFG = 0x40,	
	H2C_8192F_TXBF = 0x41,	
	H2C_8192F_RSSI_SETTING = 0x42,	
	H2C_8192F_AP_REQ_TXRPT = 0x43,	
	H2C_8192F_INIT_RATE_COLLECT = 0x44,	
	H2C_8192F_RA_PARA_ADJUST = 0x46,

	/* BT Class: 011 */
	H2C_8192F_B_TYPE_TDMA = 0x60,
	H2C_8192F_BT_INFO = 0x61,
	H2C_8192F_FORCE_BT_TXPWR = 0x62,
	H2C_8192F_BT_IGNORE_WLANACT = 0x63,
	H2C_8192F_DAC_SWING_VALUE = 0x64,
	H2C_8192F_ANT_SEL_RSV = 0x65,
	H2C_8192F_WL_OPMODE = 0x66,
	H2C_8192F_BT_MP_OPER = 0x67,
	H2C_8192F_BT_CONTROL = 0x68,
	H2C_8192F_BT_WIFI_CTRL = 0x69,
	H2C_8192F_BT_FW_PATCH = 0x6A,
	H2C_8192F_BT_WLAN_CALIBRATION = 0x6D,

	/* WOWLAN Class: 100 */
	H2C_8192F_WOWLAN = 0x80,
	H2C_8192F_REMOTE_WAKE_CTRL = 0x81,
	H2C_8192F_AOAC_GLOBAL_INFO = 0x82,	
	H2C_8192F_AOAC_RSVD_PAGE = 0x83,	
	H2C_8192F_AOAC_RSVD_PAGE2 = 0x84,
	H2C_8192F_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_8192F_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_8192F_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_8192F_P2P_OFFLOAD_RSVD_PAGE = 0x8A,	
	H2C_8192F_P2P_OFFLOAD = 0x8B,

	H2C_8192F_RESET_TSF = 0xC0,
	H2C_8192F_MAXID,
};

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * _RSVDPAGE_LOC_CMD_0x00 */
#define SET_8192F_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192F_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8192F_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8192F_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8192F_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/*_MEDIA_STATUS_RPT_PARM_CMD_0x01*/
#define SET_8192F_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8192F_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8192F_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8192F_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
/* _PWR_MOD_CMD_0x20 */
#define SET_8192F_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192F_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8192F_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8192F_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8192F_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8192F_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8192F_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8192F_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _PS_TUNE_PARAM_CMD_0x21 */
#define SET_8192F_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192F_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8192F_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
#define SET_8192F_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
#define SET_8192F_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _MACID_CFG_CMD_0x40 */
#define SET_8192F_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
#define SET_8192F_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)

/* _RSSI_SETTING_CMD_0x42 */
#define SET_8192F_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192F_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
#define SET_8192F_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _AP_REQ_TXRPT_CMD_0x43 */
#define SET_8192F_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192F_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _FORCE_BT_TXPWR_CMD_0x62 */
#define SET_8192F_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)

/* _FORCE_BT_MP_OPER_CMD_0x67 */
#define SET_8192F_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_8192F_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_8192F_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8192F_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_8192F_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8192F_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)

/* _BT_FW_PATCH_0x6A */
#define SET_8192F_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8192F_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8192F_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8192F_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_8192F_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)

/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    Function Statement     --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

/* host message to firmware cmd */
void rtl8192f_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8192f_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
/* s32 rtl8192f__set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable); */
void rtl8192f_set_FwPsTuneParam_cmd(PADAPTER padapter);
void rtl8192f_download_rsvd_page(PADAPTER padapter, u8 mstatus);
#ifdef CONFIG_BT_COEXIST
void rtl8192f_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P
void rtl8192f_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
void rtl8192f_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
#endif
#endif

#ifdef CONFIG_P2P_WOWLAN
void rtl8192f_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
#endif

s32 FillH2CCmd8192F(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8192F(_adapter *padapter, bool wowlan);
#endif
                                                                                                                                                                 rtl8822bu/src/include/rtl8723b_dm.h                                                                 0000644 0001750 0001750 00000002614 14214766567 015547  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_DM_H__
#define __RTL8723B_DM_H__
/* ************************************************************
 * Description:
 *
 * This file is for 8723B dynamic mechanism only
 *
 *
 * ************************************************************ */

/* ************************************************************
 * structure and define
 * ************************************************************ */

/* ************************************************************
 * function prototype
 * ************************************************************ */

void rtl8723b_init_dm_priv(PADAPTER padapter);
void rtl8723b_deinit_dm_priv(PADAPTER padapter);

void rtl8723b_InitHalDm(PADAPTER padapter);
void rtl8723b_HalDmWatchDog(PADAPTER padapter);
#endif
                                                                                                                    rtl8822bu/src/include/rtl8812a_xmit.h                                                               0000644 0001750 0001750 00000036244 14214766567 016134  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_XMIT_H__
#define __RTL8812A_XMIT_H__


/* For 88e early mode */
#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)

/*
 * defined for TX DESC Operation
 *   */

#define MAX_TID (15)

/* OFFSET 0 */
#define OFFSET_SZ	0
#define OFFSET_SHT	16
#define BMC			BIT(24)
#define LSG			BIT(26)
#define FSG			BIT(27)
#define OWN		BIT(31)


/* OFFSET 4 */
#define PKT_OFFSET_SZ		0
#define QSEL_SHT			8
#define RATE_ID_SHT			16
#define NAVUSEHDR			BIT(20)
#define SEC_TYPE_SHT		22
#define PKT_OFFSET_SHT		26

/* OFFSET 8 */
#define AGG_EN				BIT(12)
#define AGG_BK				BIT(16)
#define AMPDU_DENSITY_SHT	20
#define ANTSEL_A			BIT(24)
#define ANTSEL_B			BIT(25)
#define TX_ANT_CCK_SHT		26
#define TX_ANTL_SHT			28
#define TX_ANT_HT_SHT		30

/* OFFSET 12 */
#define SEQ_SHT				16
#define EN_HWSEQ			BIT(31)

/* OFFSET 16 */
#define QOS					BIT(6)
#define	HW_SSN				BIT(7)
#define USERATE				BIT(8)
#define DISDATAFB			BIT(10)
#define CTS_2_SELF			BIT(11)
#define	RTS_EN				BIT(12)
#define	HW_RTS_EN			BIT(13)
#define DATA_SHORT			BIT(24)
#define PWR_STATUS_SHT	15
#define DATA_SC_SHT		20
#define DATA_BW				BIT(25)

/* OFFSET 20 */
#define	RTY_LMT_EN			BIT(17)

/* OFFSET 20 */
#define SGI					BIT(6)
#define USB_TXAGG_NUM_SHT	24

typedef struct txdescriptor_8812 {
	/* Offset 0 */
	u32 pktlen:16;
	u32 offset:8;
	u32 bmc:1;
	u32 htc:1;
	u32 ls:1;
	u32 fs:1;
	u32 linip:1;
	u32 noacm:1;
	u32 gf:1;
	u32 own:1;

	/* Offset 4 */
	u32 macid:6;
	u32 rsvd0406:2;
	u32 qsel:5;
	u32 rd_nav_ext:1;
	u32 lsig_txop_en:1;
	u32 pifs:1;
	u32 rate_id:4;
	u32 navusehdr:1;
	u32 en_desc_id:1;
	u32 sectype:2;
	u32 rsvd0424:2;
	u32 pkt_offset:5;	/* unit: 8 bytes */
	u32 rsvd0431:1;

	/* Offset 8 */
	u32 rts_rc:6;
	u32 data_rc:6;
	u32 agg_en:1;
	u32 rd_en:1;
	u32 bar_rty_th:2;
	u32 bk:1;
	u32 morefrag:1;
	u32 raw:1;
	u32 ccx:1;
	u32 ampdu_density:3;
	u32 bt_null:1;
	u32 ant_sel_a:1;
	u32 ant_sel_b:1;
	u32 tx_ant_cck:2;
	u32 tx_antl:2;
	u32 tx_ant_ht:2;

	/* Offset 12 */
	u32 nextheadpage:8;
	u32 tailpage:8;
	u32 seq:12;
	u32 cpu_handle:1;
	u32 tag1:1;
	u32 trigger_int:1;
	u32 hwseq_en:1;

	/* Offset 16 */
	u32 rtsrate:5;
	u32 ap_dcfe:1;
	u32 hwseq_sel:2;
	u32 userate:1;
	u32 disrtsfb:1;
	u32 disdatafb:1;
	u32 cts2self:1;
	u32 rtsen:1;
	u32 hw_rts_en:1;
	u32 port_id:1;
	u32 pwr_status:3;
	u32 wait_dcts:1;
	u32 cts2ap_en:1;
	u32 data_sc:2;
	u32 data_stbc:2;
	u32 data_short:1;
	u32 data_bw:1;
	u32 rts_short:1;
	u32 rts_bw:1;
	u32 rts_sc:2;
	u32 vcs_stbc:2;

	/* Offset 20 */
	u32 datarate:6;
	u32 sgi:1;
	u32 try_rate:1;
	u32 data_ratefb_lmt:5;
	u32 rts_ratefb_lmt:4;
	u32 rty_lmt_en:1;
	u32 data_rt_lmt:6;
	u32 usb_txagg_num:8;

	/* Offset 24 */
	u32 txagg_a:5;
	u32 txagg_b:5;
	u32 use_max_len:1;
	u32 max_agg_num:5;
	u32 mcsg1_max_len:4;
	u32 mcsg2_max_len:4;
	u32 mcsg3_max_len:4;
	u32 mcs7_sgi_max_len:4;

	/* Offset 28 */
	u32 checksum:16;	/* TxBuffSize(PCIe)/CheckSum(USB) */
	u32 mcsg4_max_len:4;
	u32 mcsg5_max_len:4;
	u32 mcsg6_max_len:4;
	u32 mcs15_sgi_max_len:4;

	/* Offset 32 */
	u32 rsvd32;

	/* Offset 36 */
	u32 rsvd36;
} TXDESC_8812, *PTXDESC_8812;


/* Dword 0 */
#define GET_TX_DESC_OWN_8812(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
#define SET_TX_DESC_PKT_SIZE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define SET_TX_DESC_OFFSET_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define SET_TX_DESC_BMC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_LAST_SEG_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
#define SET_TX_DESC_FIRST_SEG_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_LINIP_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
#define SET_TX_DESC_NO_ACM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
#define SET_TX_DESC_OWN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

/* Dword 1 */
#define SET_TX_DESC_MACID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_8812(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)

/* Dword 2 */
#define SET_TX_DESC_PAID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
#define SET_TX_DESC_CCA_RTS_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_8812(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_8812(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_AGG_BREAK_8812(__pTxDesc, __Value)				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define SET_TX_DESC_RAW_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define SET_TX_DESC_SPE_RPT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_INT_8812(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_GID_8812(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)

/* Dword 3 */
#define SET_TX_DESC_WHEADER_LEN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
#define SET_TX_DESC_CHK_EN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
#define SET_TX_DESC_EARLY_MODE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
#define SET_TX_DESC_HWSEQ_SEL_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_NAV_USE_HDR_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
#define SET_TX_DESC_USE_MAX_LEN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_NDPA_8812(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_8812(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)

/* Dword 5 */
#define SET_TX_DESC_DATA_SC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_8812(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_LDPC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
#define SET_TX_DESC_DATA_STBC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_CTROL_STBC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
#define SET_TX_DESC_TX_ANT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 4, __Value)

/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_ANTSEL_A_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
#define SET_TX_DESC_ANTSEL_B_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
#define SET_TX_DESC_ANTSEL_C_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
#define SET_TX_DESC_ANTSEL_D_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)
#define SET_TX_DESC_MBSSID_8821(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)

/* Dword 7 */
#define SET_TX_DESC_TX_BUFFER_SIZE_8812(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#define SET_TX_DESC_TX_DESC_CHECKSUM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#define SET_TX_DESC_USB_TXAGG_NUM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
#ifdef CONFIG_SDIO_HCI
#define SET_TX_DESC_SDIO_TXSEQ_8812(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
#endif

/* Dword 8 */
#define SET_TX_DESC_HWSEQ_EN_8812(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)

/* Dword 9 */
#define SET_TX_DESC_SEQ_8812(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)

/* Dword 10 */
#define SET_TX_DESC_TX_BUFFER_ADDRESS_8812(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
#define GET_TX_DESC_TX_BUFFER_ADDRESS_8812(__pTxDesc)	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)

/* Dword 11 */
#define SET_TX_DESC_NEXT_DESC_ADDRESS_8812(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)


#define SET_EARLYMODE_PKTNUM_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
#define SET_EARLYMODE_LEN3_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)

#ifdef CONFIG_TX_EARLY_MODE
	#define USB_DUMMY_OFFSET		2
#else
	#define USB_DUMMY_OFFSET		1
#endif
#define USB_DUMMY_LENGTH		(USB_DUMMY_OFFSET * PACKET_OFFSET_SZ)


void rtl8812a_cal_txdesc_chksum(u8 *ptxdesc);
void rtl8812a_fill_fake_txdesc(PADAPTER	padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8	IsBTQosNull, u8 bDataFrame);
void rtl8812a_fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
void rtl8812a_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
void rtl8812a_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
#if defined(CONFIG_CONCURRENT_MODE)
void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#ifdef CONFIG_USB_HCI
s32 rtl8812au_init_xmit_priv(PADAPTER padapter);
void rtl8812au_free_xmit_priv(PADAPTER padapter);
s32 rtl8812au_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8812au_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32	 rtl8812au_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
s32 rtl8812au_xmit_buf_handler(PADAPTER padapter);
void rtl8812au_xmit_tasklet(void *priv);
s32 rtl8812au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif

#ifdef CONFIG_PCI_HCI
s32 rtl8812ae_init_xmit_priv(PADAPTER padapter);
void rtl8812ae_free_xmit_priv(PADAPTER padapter);
struct xmit_buf *rtl8812ae_dequeue_xmitbuf(struct rtw_tx_ring *ring);
void	rtl8812ae_xmitframe_resume(_adapter *padapter);
s32 rtl8812ae_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8812ae_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32	rtl8812ae_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
void rtl8812ae_xmit_tasklet(void *priv);

#ifdef CONFIG_XMIT_THREAD_MODE
s32 rtl8812ae_xmit_buf_handler(_adapter *padapter);
#endif

#endif

#ifdef CONFIG_TX_EARLY_MODE
void UpdateEarlyModeInfo8812(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif

void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, u8 *ptxdesc);

u8	BWMapping_8812(PADAPTER Adapter, struct pkt_attrib *pattrib);

u8	SCMapping_8812(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif /* __RTL8812_XMIT_H__ */

#ifdef CONFIG_RTL8821A
#include "rtl8821a_xmit.h"
#endif /* CONFIG_RTL8821A */
                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/usb_osintf.h                                                                  0000644 0001750 0001750 00000001667 14214766567 015762  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __USB_OSINTF_H
#define __USB_OSINTF_H

#include <usb_vendor_req.h>

#define USBD_HALTED(Status) ((u32)(Status) >> 30 == 3)


u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv, RT_USB_BREQUEST brequest, RT_USB_WVALUE wvalue, u8 windex, void *data, u8 datalen, u8 isdirectionin);


#endif
                                                                         rtl8822bu/src/include/usb_vendor_req.h                                                              0000644 0001750 0001750 00000003625 14214766567 016620  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _USB_VENDOR_REQUEST_H_
#define _USB_VENDOR_REQUEST_H_

/* 4	Set/Get Register related wIndex/Data */
#define	RT_USB_RESET_MASK_OFF		0
#define	RT_USB_RESET_MASK_ON		1
#define	RT_USB_SLEEP_MASK_OFF		0
#define	RT_USB_SLEEP_MASK_ON		1
#define	RT_USB_LDO_ON				1
#define	RT_USB_LDO_OFF				0

/* 4	Set/Get SYSCLK related	wValue or Data */
#define	RT_USB_SYSCLK_32KHZ		0
#define	RT_USB_SYSCLK_40MHZ		1
#define	RT_USB_SYSCLK_60MHZ		2


typedef enum _RT_USB_BREQUEST {
	RT_USB_SET_REGISTER		= 1,
	RT_USB_SET_SYSCLK		= 2,
	RT_USB_GET_SYSCLK		= 3,
	RT_USB_GET_REGISTER		= 4
} RT_USB_BREQUEST;


typedef enum _RT_USB_WVALUE {
	RT_USB_RESET_MASK	=	1,
	RT_USB_SLEEP_MASK	=	2,
	RT_USB_USB_HRCPWM	=	3,
	RT_USB_LDO			=	4,
	RT_USB_BOOT_TYPE	=	5
} RT_USB_WVALUE;


#if 0
BOOLEAN usbvendorrequest(PCE_USB_DEVICE	CEdevice, RT_USB_BREQUEST bRequest, RT_USB_WVALUE wValue, u8 wIndex, void *Data, u8 DataLength, BOOLEAN isDirectionIn);
BOOLEAN CEusbGetStatusRequest(PCE_USB_DEVICE CEdevice, u16 Op, u16 Index, void *Data);
BOOLEAN CEusbFeatureRequest(PCE_USB_DEVICE CEdevice, u16 Op, u16 FeatureSelector, u16 Index);
BOOLEAN CEusbGetDescriptorRequest(PCE_USB_DEVICE CEdevice, short urbLength, u8 DescriptorType, u8 Index, u16 LanguageId, void *TransferBuffer, u32 TransferBufferLength);
#endif

#endif
                                                                                                           rtl8822bu/src/include/rtl8812a_led.h                                                                0000644 0001750 0001750 00000002747 14214766567 015720  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_LED_H__
#define __RTL8812A_LED_H__
#ifdef CONFIG_RTW_LED
#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
void rtl8812au_InitSwLeds(PADAPTER padapter);
void rtl8812au_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
void rtl8812ae_InitSwLeds(PADAPTER padapter);
void rtl8812ae_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
void rtl8821as_InitSwLeds(PADAPTER padapter);
void rtl8821as_DeInitSwLeds(PADAPTER padapter);
#endif
#endif/*CONFIG_RTW_SW_LED*/
#endif/*#ifdef CONFIG_RTW_LED*/

#ifdef CONFIG_SDIO_HCI
void rtl8821as_init_led_circuit(PADAPTER adapter);
#endif

#endif /*__RTL8812A_LED_H__*/
                         rtl8822bu/src/include/rtl8812a_sreset.h                                                             0000644 0001750 0001750 00000001626 14214766567 016454  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL88812A_SRESET_H_
#define _RTL8812A_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
extern void rtl8812_sreset_xmit_status_check(_adapter *padapter);
extern void rtl8812_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                          rtl8822bu/src/include/drv_conf.h                                                                    0000755 0001750 0001750 00000041703 14214766567 015405  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_CONF_H__
#define __DRV_CONF_H__
#include "autoconf.h"
#include "hal_ic_cfg.h"

#define CONFIG_RSSI_PRIORITY
#ifdef CONFIG_RTW_REPEATER_SON
	#ifndef CONFIG_AP
		#define CONFIG_AP
	#endif
	#ifndef CONFIG_CONCURRENT_MODE
		#define CONFIG_CONCURRENT_MODE
	#endif
	#ifndef CONFIG_BR_EXT
		#define CONFIG_BR_EXT
	#endif
	#ifndef CONFIG_RTW_REPEATER_SON_ID
		#define CONFIG_RTW_REPEATER_SON_ID			0x02040608
	#endif
	//#define CONFIG_RTW_REPEATER_SON_ROOT
	#ifndef CONFIG_RTW_REPEATER_SON_ROOT
		#define CONFIG_LAYER2_ROAMING_ACTIVE
	#endif
	#undef CONFIG_POWER_SAVING
#endif

#if defined(CONFIG_MCC_MODE) && (!defined(CONFIG_CONCURRENT_MODE))

	#error "Enable CONCURRENT_MODE before enable MCC MODE\n"

#endif

#if defined(CONFIG_MCC_MODE) && defined(CONFIG_BT_COEXIST)

	#error "Disable BT COEXIST before enable MCC MODE\n"

#endif

#if defined(CONFIG_MCC_MODE) && defined(CONFIG_TDLS)

	#error "Disable TDLS before enable MCC MODE\n"

#endif

#if defined(CONFIG_RTW_80211R) && !defined(CONFIG_LAYER2_ROAMING)

	#error "Enable CONFIG_LAYER2_ROAMING before enable CONFIG_RTW_80211R\n"

#endif

/* Older Android kernel doesn't has CONFIG_ANDROID defined,
 * add this to force CONFIG_ANDROID defined */
#ifdef CONFIG_PLATFORM_ANDROID
	#ifndef CONFIG_ANDROID
		#define CONFIG_ANDROID
	#endif
#endif

#ifdef CONFIG_ANDROID
	/* Some Android build will restart the UI while non-printable ascii is passed
	* between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID
	* for Android here. If you are sure there is no risk on your system about this,
	* mask this macro define to support non-printable ascii ssid.
	* #define CONFIG_VALIDATE_SSID */

	/* Android expect dbm as the rx signal strength unit */
	#define CONFIG_SIGNAL_DISPLAY_DBM
#endif

/*
#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(CONFIG_RESUME_IN_WORKQUEUE)
	#warning "You have CONFIG_HAS_EARLYSUSPEND enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
	#undef CONFIG_RESUME_IN_WORKQUEUE
#endif

#if defined(CONFIG_ANDROID_POWER) && defined(CONFIG_RESUME_IN_WORKQUEUE)
	#warning "You have CONFIG_ANDROID_POWER enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
	#undef CONFIG_RESUME_IN_WORKQUEUE
#endif
*/

#ifdef CONFIG_RESUME_IN_WORKQUEUE /* this can be removed, because there is no case for this... */
	#if !defined(CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
		#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
		#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
	#endif
#endif

/* About USB VENDOR REQ */
#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
	#define CONFIG_USB_VENDOR_REQ_MUTEX
#endif
#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
	#define CONFIG_USB_VENDOR_REQ_MUTEX
#endif

#ifdef CONFIG_WIFI_MONITOR
	/*	#define CONFIG_MONITOR_MODE_XMIT	*/
#endif

#ifdef CONFIG_CUSTOMER_ALIBABA_GENERAL
	#ifndef CONFIG_WIFI_MONITOR
		#define CONFIG_WIFI_MONITOR
	#endif
	#ifdef CONFIG_POWER_SAVING
		#undef CONFIG_POWER_SAVING
	#endif
#endif

#ifdef CONFIG_CUSTOMER01_SMART_ANTENNA
	#ifdef CONFIG_POWER_SAVING
		#undef CONFIG_POWER_SAVING
	#endif
	#ifdef CONFIG_BEAMFORMING
		#undef CONFIG_BEAMFORMING
	#endif
#endif

#ifdef CONFIG_AP_MODE
	#define CONFIG_LIMITED_AP_NUM 1
	#define CONFIG_TX_MCAST2UNI /* AP mode support IP multicast->unicast */
#endif

#ifdef CONFIG_RTW_MESH
	#ifndef CONFIG_RTW_MESH_ACNODE_PREVENT
	#define CONFIG_RTW_MESH_ACNODE_PREVENT 1
	#endif

	#ifndef CONFIG_RTW_MESH_OFFCH_CAND
	#define CONFIG_RTW_MESH_OFFCH_CAND 1
	#endif

	#ifndef CONFIG_RTW_MESH_PEER_BLACKLIST
	#define CONFIG_RTW_MESH_PEER_BLACKLIST 1
	#endif

	#ifndef CONFIG_RTW_MESH_CTO_MGATE_BLACKLIST
	#define CONFIG_RTW_MESH_CTO_MGATE_BLACKLIST 1
	#endif
	#ifndef CONFIG_RTW_MESH_CTO_MGATE_CARRIER
	#define CONFIG_RTW_MESH_CTO_MGATE_CARRIER CONFIG_RTW_MESH_CTO_MGATE_BLACKLIST
	#endif

	#ifndef CONFIG_RTW_MPM_TX_IES_SYNC_BSS
	#define CONFIG_RTW_MPM_TX_IES_SYNC_BSS 1
	#endif
	#if CONFIG_RTW_MPM_TX_IES_SYNC_BSS
		#ifndef CONFIG_RTW_MESH_AEK
		#define CONFIG_RTW_MESH_AEK
		#endif
	#endif

	#ifndef CONFIG_RTW_MESH_DATA_BMC_TO_UC
	#define CONFIG_RTW_MESH_DATA_BMC_TO_UC 1
	#endif
#endif

#if !defined(CONFIG_SCAN_BACKOP) && defined(CONFIG_AP_MODE)
#define CONFIG_SCAN_BACKOP
#endif

#define RTW_SCAN_SPARSE_MIRACAST 1
#define RTW_SCAN_SPARSE_BG 0
#define RTW_SCAN_SPARSE_ROAMING_ACTIVE 1

#ifndef CONFIG_TX_AC_LIFETIME
#define CONFIG_TX_AC_LIFETIME 1
#endif
#ifndef CONFIG_TX_ACLT_FLAGS
#define CONFIG_TX_ACLT_FLAGS 0x00
#endif
#ifndef CONFIG_TX_ACLT_CONF_DEFAULT
#define CONFIG_TX_ACLT_CONF_DEFAULT {0x0, 1024 * 1000, 1024 * 1000}
#endif
#ifndef CONFIG_TX_ACLT_CONF_AP_M2U
#define CONFIG_TX_ACLT_CONF_AP_M2U {0xF, 256 * 1000, 256 * 1000}
#endif
#ifndef CONFIG_TX_ACLT_CONF_MESH
#define CONFIG_TX_ACLT_CONF_MESH {0xF, 256 * 1000, 256 * 1000}
#endif

#ifndef CONFIG_RTW_HIQ_FILTER
	#define CONFIG_RTW_HIQ_FILTER 1
#endif

#ifndef CONFIG_RTW_ADAPTIVITY_EN
	#define CONFIG_RTW_ADAPTIVITY_EN 0
#endif

#ifndef CONFIG_RTW_ADAPTIVITY_MODE
	#define CONFIG_RTW_ADAPTIVITY_MODE 0
#endif

#ifndef CONFIG_RTW_ADAPTIVITY_TH_L2H_INI
	#define CONFIG_RTW_ADAPTIVITY_TH_L2H_INI 0
#endif

#ifndef CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF
	#define CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF 0
#endif

#ifndef CONFIG_RTW_EXCL_CHS
	#define CONFIG_RTW_EXCL_CHS {0}
#endif

#ifndef CONFIG_IEEE80211_BAND_5GHZ
	#if defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8821C) \
		|| defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8822C) \
		|| defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8814B)
	#define CONFIG_IEEE80211_BAND_5GHZ 1
	#else
	#define CONFIG_IEEE80211_BAND_5GHZ 0
	#endif
#endif

#ifndef CONFIG_DFS
#define CONFIG_DFS 1
#endif

#if CONFIG_IEEE80211_BAND_5GHZ && CONFIG_DFS && defined(CONFIG_AP_MODE)
	#if !defined(CONFIG_DFS_SLAVE_WITH_RADAR_DETECT)
	#define CONFIG_DFS_SLAVE_WITH_RADAR_DETECT 0
	#endif
	#if !defined(CONFIG_DFS_MASTER) || CONFIG_DFS_SLAVE_WITH_RADAR_DETECT
	#define CONFIG_DFS_MASTER
	#endif
	#if defined(CONFIG_DFS_MASTER) && !defined(CONFIG_RTW_DFS_REGION_DOMAIN)
	#define CONFIG_RTW_DFS_REGION_DOMAIN 0
	#endif
#else
	#undef CONFIG_DFS_MASTER
	#undef CONFIG_RTW_DFS_REGION_DOMAIN
	#define CONFIG_RTW_DFS_REGION_DOMAIN 0
	#undef CONFIG_DFS_SLAVE_WITH_RADAR_DETECT
	#define CONFIG_DFS_SLAVE_WITH_RADAR_DETECT 0
#endif

#ifndef CONFIG_TXPWR_BY_RATE_EN
#define CONFIG_TXPWR_BY_RATE_EN 2 /* by efuse */
#endif
#ifndef CONFIG_TXPWR_LIMIT_EN
#define CONFIG_TXPWR_LIMIT_EN 2 /* by efuse */
#endif

#ifndef CONFIG_RTW_CHPLAN
#define CONFIG_RTW_CHPLAN 0xFF /* RTW_CHPLAN_UNSPECIFIED */
#endif

/* compatible with old fashion configuration */
#if defined(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY)
	#undef CONFIG_TXPWR_BY_RATE_EN
	#undef CONFIG_TXPWR_LIMIT_EN
	#define CONFIG_TXPWR_BY_RATE_EN 1
	#define CONFIG_TXPWR_LIMIT_EN 1
#elif defined(CONFIG_CALIBRATE_TX_POWER_TO_MAX)
	#undef CONFIG_TXPWR_BY_RATE_EN
	#undef CONFIG_TXPWR_LIMIT_EN
	#define CONFIG_TXPWR_BY_RATE_EN 1
	#define CONFIG_TXPWR_LIMIT_EN 0
#endif

#ifndef RTW_DEF_MODULE_REGULATORY_CERT
	#define RTW_DEF_MODULE_REGULATORY_CERT 0
#endif

#if RTW_DEF_MODULE_REGULATORY_CERT
	/* force enable TX power by rate and TX power limit */
	#undef CONFIG_TXPWR_BY_RATE_EN
	#undef CONFIG_TXPWR_LIMIT_EN
	#define CONFIG_TXPWR_BY_RATE_EN 1
	#define CONFIG_TXPWR_LIMIT_EN 1
#endif

#if !CONFIG_TXPWR_LIMIT && CONFIG_TXPWR_LIMIT_EN
	#undef CONFIG_TXPWR_LIMIT
	#define CONFIG_TXPWR_LIMIT 1
#endif

#ifdef CONFIG_RTW_IPCAM_APPLICATION
	#undef CONFIG_TXPWR_BY_RATE_EN
	#define CONFIG_TXPWR_BY_RATE_EN 1
	#define CONFIG_RTW_CUSTOMIZE_BEEDCA		0x0000431C
	#define CONFIG_RTW_CUSTOMIZE_BWMODE		0x00
	#define CONFIG_RTW_CUSTOMIZE_RLSTA		0x30
#if defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8192F) || defined(CONFIG_RTL8822B)
	#define CONFIG_RTW_TX_NPATH_EN		/*	mutually incompatible with STBC_TX & Beamformer	*/
#endif
#endif
/*#define CONFIG_EXTEND_LOWRATE_TXOP			*/

#ifndef CONFIG_RTW_RX_AMPDU_SZ_LIMIT_1SS
	#define CONFIG_RTW_RX_AMPDU_SZ_LIMIT_1SS {0xFF, 0xFF, 0xFF, 0xFF}
#endif
#ifndef CONFIG_RTW_RX_AMPDU_SZ_LIMIT_2SS
	#define CONFIG_RTW_RX_AMPDU_SZ_LIMIT_2SS {0xFF, 0xFF, 0xFF, 0xFF}
#endif
#ifndef CONFIG_RTW_RX_AMPDU_SZ_LIMIT_3SS
	#define CONFIG_RTW_RX_AMPDU_SZ_LIMIT_3SS {0xFF, 0xFF, 0xFF, 0xFF}
#endif
#ifndef CONFIG_RTW_RX_AMPDU_SZ_LIMIT_4SS
	#define CONFIG_RTW_RX_AMPDU_SZ_LIMIT_4SS {0xFF, 0xFF, 0xFF, 0xFF}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_A
	#define CONFIG_RTW_TARGET_TX_PWR_2G_A {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_B
	#define CONFIG_RTW_TARGET_TX_PWR_2G_B {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_C
	#define CONFIG_RTW_TARGET_TX_PWR_2G_C {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_D
	#define CONFIG_RTW_TARGET_TX_PWR_2G_D {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_A
	#define CONFIG_RTW_TARGET_TX_PWR_5G_A {-1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_B
	#define CONFIG_RTW_TARGET_TX_PWR_5G_B {-1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_C
	#define CONFIG_RTW_TARGET_TX_PWR_5G_C {-1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_D
	#define CONFIG_RTW_TARGET_TX_PWR_5G_D {-1, -1, -1, -1, -1, -1, -1, -1, -1}
#endif

#ifndef CONFIG_RTW_AMPLIFIER_TYPE_2G
	#define CONFIG_RTW_AMPLIFIER_TYPE_2G 0
#endif

#ifndef CONFIG_RTW_AMPLIFIER_TYPE_5G
	#define CONFIG_RTW_AMPLIFIER_TYPE_5G 0
#endif

#ifndef CONFIG_RTW_RFE_TYPE
	#define CONFIG_RTW_RFE_TYPE 64
#endif

#ifndef CONFIG_RTW_GLNA_TYPE
	#define CONFIG_RTW_GLNA_TYPE 0
#endif

#ifndef CONFIG_RTW_PLL_REF_CLK_SEL
	#define CONFIG_RTW_PLL_REF_CLK_SEL 0x0F
#endif

#ifndef CONFIG_IFACE_NUMBER
	#ifdef CONFIG_CONCURRENT_MODE
		#define CONFIG_IFACE_NUMBER	2
	#else
		#define CONFIG_IFACE_NUMBER	1
	#endif
#endif

#ifndef CONFIG_CONCURRENT_MODE
	#if (CONFIG_IFACE_NUMBER > 1)
		#error "CONFIG_IFACE_NUMBER over 1,but CONFIG_CONCURRENT_MODE not defined"
	#endif
#endif

#if (CONFIG_IFACE_NUMBER == 0)
	#error "CONFIG_IFACE_NUMBER cound not be 0 !!"
#endif

#if defined(CONFIG_RTL8188E) || defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8188F) || \
defined(CONFIG_RTL8188GTV) || defined(CONFIG_RTL8192F) || \
defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8710B) || \
defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8703B) || defined(CONFIG_RTL8723D)
#define CONFIG_HWMPCAP_GEN1
#elif defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8822C) /*|| defined(CONFIG_RTL8814A)*/
#define CONFIG_HWMPCAP_GEN2
#elif defined(CONFIG_RTL8814B) /*Address CAM - 128*/
#define CONFIG_HWMPCAP_GEN3
#endif

#if defined(CONFIG_HWMPCAP_GEN1) && (CONFIG_IFACE_NUMBER > 2) 
	#ifdef CONFIG_POWER_SAVING
	/*#warning "Disable PS when CONFIG_IFACE_NUMBER > 2"*/
	#undef CONFIG_POWER_SAVING
	#endif

	#ifdef CONFIG_WOWLAN
	#error "This IC can't support MI and WoWLan at the same time"
	#endif
#endif

#if defined(CONFIG_HWMPCAP_GEN1) && (CONFIG_IFACE_NUMBER > 3)
        #error " This IC can't support over 3 interfaces !!"
#endif

#if (CONFIG_IFACE_NUMBER > 4)
	#error "Not support over 4 interfaces yet !!"
#endif

#if (CONFIG_IFACE_NUMBER > 8)	/*IFACE_ID_MAX*/
	#error "HW count not support over 8 interfaces !!"
#endif

#if (CONFIG_IFACE_NUMBER > 2)
	#define CONFIG_MI_WITH_MBSSID_CAM

	#ifdef CONFIG_MI_WITH_MBSSID_CAM
		#define CONFIG_MBSSID_CAM
		#if defined(CONFIG_RUNTIME_PORT_SWITCH)
			#undef CONFIG_RUNTIME_PORT_SWITCH
		#endif
	#endif

	#ifdef CONFIG_AP_MODE
		#undef CONFIG_LIMITED_AP_NUM
		#define CONFIG_LIMITED_AP_NUM	2

		#define CONFIG_SUPPORT_MULTI_BCN

		#define CONFIG_SWTIMER_BASED_TXBCN

		#ifdef CONFIG_HWMPCAP_GEN2 /*CONFIG_RTL8822B/CONFIG_RTL8821C/CONFIG_RTL8822C*/
		#define CONFIG_FW_HANDLE_TXBCN

		#ifdef CONFIG_FW_HANDLE_TXBCN
			#ifdef CONFIG_SWTIMER_BASED_TXBCN
				#undef CONFIG_SWTIMER_BASED_TXBCN
			#endif
			#undef CONFIG_LIMITED_AP_NUM
			#define CONFIG_LIMITED_AP_NUM	4
		#endif

		#endif /*CONFIG_HWMPCAP_GEN2*/
	#endif /*CONFIG_AP_MODE*/

	#ifdef CONFIG_HWMPCAP_GEN2 /*CONFIG_RTL8822B/CONFIG_RTL8821C/CONFIG_RTL8822C*/
	#define CONFIG_CLIENT_PORT_CFG
	#define CONFIG_NEW_NETDEV_HDL
	#endif/*CONFIG_HWMPCAP_GEN2*/
#endif/*(CONFIG_IFACE_NUMBER > 2)*/

#define MACID_NUM_SW_LIMIT 32
#define SEC_CAM_ENT_NUM_SW_LIMIT 32

#if defined(CONFIG_WOWLAN) && (defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822C) || defined(CONFIG_RTL8814B))
	#define CONFIG_WOW_PATTERN_HW_CAM
#endif

#ifndef CONFIG_TSF_UPDATE_PAUSE_FACTOR
#define CONFIG_TSF_UPDATE_PAUSE_FACTOR 200
#endif

#ifndef CONFIG_TSF_UPDATE_RESTORE_FACTOR
#define CONFIG_TSF_UPDATE_RESTORE_FACTOR 5
#endif

/*
	Mark CONFIG_DEAUTH_BEFORE_CONNECT by Arvin 2015/07/20
	If the failure of Wi-Fi connection is due to some irregular disconnection behavior (like unplug dongle,
	power down etc.) in last time, we can unmark this flag to avoid some unpredictable response from AP.
*/
/*#define CONFIG_DEAUTH_BEFORE_CONNECT */

/*#define CONFIG_WEXT_DONT_JOIN_BYSSID	*/
/* #include <rtl871x_byteorder.h> */


/*#define CONFIG_DOSCAN_IN_BUSYTRAFFIC	*/
/*#define CONFIG_PHDYM_FW_FIXRATE		*/	/*	Another way to fix tx rate	*/

/*Don't release SDIO irq in suspend/resume procedure*/
#define CONFIG_RTW_SDIO_KEEP_IRQ	0

/*
 * Add by Lucas@2016/02/15
 * For RX Aggregation
 */
#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_RX_AGGREGATION)
	#define RTW_RX_AGGREGATION
#endif /* CONFIG_SDIO_HCI || CONFIG_USB_RX_AGGREGATION */

#ifdef CONFIG_RTW_HOSTAPD_ACS
	#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8814A)
		#ifndef CONFIG_FIND_BEST_CHANNEL
			#define CONFIG_FIND_BEST_CHANNEL
		#endif
	#else
		#ifdef CONFIG_FIND_BEST_CHANNEL
			#undef CONFIG_FIND_BEST_CHANNEL
		#endif
		#ifndef CONFIG_RTW_ACS
			#define CONFIG_RTW_ACS
		#endif
		#ifndef CONFIG_BACKGROUND_NOISE_MONITOR
			#define CONFIG_BACKGROUND_NOISE_MONITOR
		#endif
	#endif
#endif

#ifdef CONFIG_RTW_80211K
	#ifndef CONFIG_RTW_ACS
		#define CONFIG_RTW_ACS
	#endif
#endif /*CONFIG_RTW_80211K*/

#ifdef DBG_CONFIG_ERROR_RESET
#ifndef CONFIG_IPS
#define CONFIG_IPS
#endif
#endif

/* IPS */
#ifndef RTW_IPS_MODE
	#if defined(CONFIG_IPS)
		#define RTW_IPS_MODE 1
	#else
		#define RTW_IPS_MODE 0
	#endif
#endif /* !RTW_IPS_MODE */

#if (RTW_IPS_MODE > 1 || RTW_IPS_MODE < 0)
	#error "The CONFIG_IPS_MODE value is wrong. Please follow HowTo_enable_the_power_saving_functionality.pdf.\n"
#endif

/* LPS */
#ifndef RTW_LPS_MODE
	#if defined(CONFIG_LPS_PG) || defined(CONFIG_LPS_PG_DDMA)
		#define RTW_LPS_MODE 3
	#elif defined(CONFIG_LPS_LCLK)
		#define RTW_LPS_MODE 2
	#elif defined(CONFIG_LPS)
		#define RTW_LPS_MODE 1
	#else
		#define RTW_LPS_MODE 0
	#endif 
#endif /* !RTW_LPS_MODE */

#if (RTW_LPS_MODE > 3 || RTW_LPS_MODE < 0)
	#error "The CONFIG_LPS_MODE value is wrong. Please follow HowTo_enable_the_power_saving_functionality.pdf.\n"
#endif

#ifndef RTW_LPS_1T1R
#define RTW_LPS_1T1R 0
#endif

#ifndef RTW_WOW_LPS_1T1R
#define RTW_WOW_LPS_1T1R 0
#endif

/* WOW LPS */
#ifndef RTW_WOW_LPS_MODE
	#if defined(CONFIG_LPS_PG) || defined(CONFIG_LPS_PG_DDMA)
		#define RTW_WOW_LPS_MODE 3
	#elif defined(CONFIG_LPS_LCLK)
		#define RTW_WOW_LPS_MODE 2
	#elif defined(CONFIG_LPS)
		#define RTW_WOW_LPS_MODE 1
	#else
		#define RTW_WOW_LPS_MODE 0
	#endif
#endif /* !RTW_WOW_LPS_MODE */

#if (RTW_WOW_LPS_MODE > 3 || RTW_WOW_LPS_MODE < 0)
	#error "The RTW_WOW_LPS_MODE value is wrong. Please follow HowTo_enable_the_power_saving_functionality.pdf.\n"
#endif

#ifdef RTW_REDUCE_SCAN_SWITCH_CH_TIME
#ifndef CONFIG_RTL8822B
	#error "Only 8822B support RTW_REDUCE_SCAN_SWITCH_CH_TIME"
#endif
	#ifndef RTW_CHANNEL_SWITCH_OFFLOAD
		#define RTW_CHANNEL_SWITCH_OFFLOAD
	#endif
#endif

#define CONFIG_RTW_TPT_MODE 

#ifdef CONFIG_PCI_BCN_POLLING
#define CONFIG_BCN_ICF
#endif 

#ifndef CONFIG_PCI_MSI
#define CONFIG_RTW_PCI_MSI_DISABLE
#endif

#if defined(CONFIG_PCI_DYNAMIC_ASPM_L1_LATENCY) ||	\
    defined(CONFIG_PCI_DYNAMIC_ASPM_LINK_CTRL)
#define CONFIG_PCI_DYNAMIC_ASPM
#endif

#if 0
/* Debug related compiler flags */
#define DBG_THREAD_PID	/* Add thread pid to debug message prefix */
#define DBG_CPU_INFO	/* Add CPU info to debug message prefix */
#endif

#endif /* __DRV_CONF_H__ */
                                                             rtl8822bu/src/include/pci_osintf.h                                                                  0000644 0001750 0001750 00000004234 14214766567 015735  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __PCI_OSINTF_H
#define __PCI_OSINTF_H

#ifdef RTK_129X_PLATFORM
#define PCIE_SLOT1_MEM_START	0x9804F000
#define PCIE_SLOT1_MEM_LEN	0x1000
#define PCIE_SLOT1_CTRL_START	0x9804EC00

#define PCIE_SLOT2_MEM_START	0x9803C000
#define PCIE_SLOT2_MEM_LEN	0x1000
#define PCIE_SLOT2_CTRL_START	0x9803BC00

#define PCIE_MASK_OFFSET	0x100 /* mask offset from CTRL_START */
#define PCIE_TRANSLATE_OFFSET	0x104 /* translate offset from CTRL_START */
#endif

#define PCI_BC_CLK_REQ		BIT0
#define PCI_BC_ASPM_L0s		BIT1
#define PCI_BC_ASPM_L1		BIT2
#define PCI_BC_ASPM_L1Off	BIT3
//#define PCI_BC_ASPM_LTR	BIT4
//#define PCI_BC_ASPM_OBFF	BIT5

void	PlatformClearPciPMEStatus(PADAPTER Adapter);
void	rtw_pci_aspm_config(_adapter *padapter);
void	rtw_pci_aspm_config_l1off_general(_adapter *padapter, u8 eanble);
#ifdef CONFIG_64BIT_DMA
	u8	PlatformEnableDMA64(PADAPTER Adapter);
#endif
#ifdef CONFIG_PCI_DYNAMIC_ASPM
void rtw_pci_set_aspm_lnkctl(_adapter *padapter, u8 mode);
void rtw_pci_set_l1_latency(_adapter *padapter, u8 mode);

static inline void rtw_pci_dynamic_aspm_set_mode(_adapter *padapter, u8 mode)
{
	struct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);
	struct pci_priv	*pcipriv = &(pdvobjpriv->pcipriv);

	if (mode == pcipriv->aspm_mode)
		return;

	pcipriv->aspm_mode = mode;

#ifdef CONFIG_PCI_DYNAMIC_ASPM_LINK_CTRL
	rtw_pci_set_aspm_lnkctl(padapter, mode);
#endif
#ifdef CONFIG_PCI_DYNAMIC_ASPM_L1_LATENCY
	rtw_pci_set_l1_latency(padapter, mode);
#endif
}
#else
#define rtw_pci_dynamic_aspm_set_mode(adapter, mode)
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/gspi_osintf.h                                                                 0000644 0001750 0001750 00000001315 14214766567 016121  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __SDIO_OSINTF_H__
#define __SDIO_OSINTF_H__


#endif
                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/rtl8188f_cmd.h                                                                0000644 0001750 0001750 00000027105 14214766567 015725  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_CMD_H__
#define __RTL8188F_CMD_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

enum h2c_cmd_8188F {
	/* Common Class: 000 */
	H2C_8188F_RSVD_PAGE = 0x00,
	H2C_8188F_MEDIA_STATUS_RPT = 0x01,
	H2C_8188F_SCAN_ENABLE = 0x02,
	H2C_8188F_KEEP_ALIVE = 0x03,
	H2C_8188F_DISCON_DECISION = 0x04,
	H2C_8188F_PSD_OFFLOAD = 0x05,
	H2C_8188F_AP_OFFLOAD = 0x08,
	H2C_8188F_BCN_RSVDPAGE = 0x09,
	H2C_8188F_PROBERSP_RSVDPAGE = 0x0A,
	H2C_8188F_FCS_RSVDPAGE = 0x10,
	H2C_8188F_FCS_INFO = 0x11,
	H2C_8188F_AP_WOW_GPIO_CTRL = 0x13,

	/* PoweSave Class: 001 */
	H2C_8188F_SET_PWR_MODE = 0x20,
	H2C_8188F_PS_TUNING_PARA = 0x21,
	H2C_8188F_PS_TUNING_PARA2 = 0x22,
	H2C_8188F_P2P_LPS_PARAM = 0x23,
	H2C_8188F_P2P_PS_OFFLOAD = 0x24,
	H2C_8188F_PS_SCAN_ENABLE = 0x25,
	H2C_8188F_SAP_PS_ = 0x26,
	H2C_8188F_INACTIVE_PS_ = 0x27, /* Inactive_PS */
	H2C_8188F_FWLPS_IN_IPS_ = 0x28,

	/* Dynamic Mechanism Class: 010 */
	H2C_8188F_MACID_CFG = 0x40,
	H2C_8188F_TXBF = 0x41,
	H2C_8188F_RSSI_SETTING = 0x42,
	H2C_8188F_AP_REQ_TXRPT = 0x43,
	H2C_8188F_INIT_RATE_COLLECT = 0x44,
	H2C_8188F_RA_PARA_ADJUST = 0x46,

	/* BT Class: 011 */
	H2C_8188F_B_TYPE_TDMA = 0x60,
	H2C_8188F_BT_INFO = 0x61,
	H2C_8188F_FORCE_BT_TXPWR = 0x62,
	H2C_8188F_BT_IGNORE_WLANACT = 0x63,
	H2C_8188F_DAC_SWING_VALUE = 0x64,
	H2C_8188F_ANT_SEL_RSV = 0x65,
	H2C_8188F_WL_OPMODE = 0x66,
	H2C_8188F_BT_MP_OPER = 0x67,
	H2C_8188F_BT_CONTROL = 0x68,
	H2C_8188F_BT_WIFI_CTRL = 0x69,
	H2C_8188F_BT_FW_PATCH = 0x6A,
	H2C_8188F_BT_WLAN_CALIBRATION = 0x6D,

	/* WOWLAN Class: 100 */
	H2C_8188F_WOWLAN = 0x80,
	H2C_8188F_REMOTE_WAKE_CTRL = 0x81,
	H2C_8188F_AOAC_GLOBAL_INFO = 0x82,
	H2C_8188F_AOAC_RSVD_PAGE = 0x83,
	H2C_8188F_AOAC_RSVD_PAGE2 = 0x84,
	H2C_8188F_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_8188F_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_8188F_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_8188F_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
	H2C_8188F_P2P_OFFLOAD = 0x8B,

	H2C_8188F_RESET_TSF = 0xC0,
	H2C_8188F_MAXID,
};

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * _RSVDPAGE_LOC_CMD_0x00 */
#define SET_8188F_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8188F_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8188F_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8188F_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8188F_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _KEEP_ALIVE_CMD_0x03 */
#define SET_8188F_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8188F_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8188F_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8188F_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _DISCONNECT_DECISION_CMD_0x04 */
#define SET_8188F_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8188F_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8188F_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8188F_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)

/* _PWR_MOD_CMD_0x20 */
#define SET_8188F_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8188F_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8188F_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8188F_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8188F_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8188F_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8188F_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8188F_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _PS_TUNE_PARAM_CMD_0x21 */
#define SET_8188F_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8188F_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8188F_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
#define SET_8188F_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
#define SET_8188F_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _MACID_CFG_CMD_0x40 */
#define SET_8188F_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)

/* _RSSI_SETTING_CMD_0x42 */
#define SET_8188F_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8188F_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
#define SET_8188F_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _AP_REQ_TXRPT_CMD_0x43 */
#define SET_8188F_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8188F_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _FORCE_BT_TXPWR_CMD_0x62 */
#define SET_8188F_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)

/* _FORCE_BT_MP_OPER_CMD_0x67 */
#define SET_8188F_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_8188F_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_8188F_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8188F_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_8188F_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8188F_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)

/* _BT_FW_PATCH_0x6A */
#define SET_8188F_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)


/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    Function Statement     --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

/* host message to firmware cmd */
void rtl8188f_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8188f_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
void rtl8188f_fw_try_ap_cmd(PADAPTER padapter, u32 need_ack);
/* s32 rtl8188f_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable); */
void rtl8188f_set_FwPsTuneParam_cmd(PADAPTER padapter);
void rtl8188f_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
void rtl8188f_download_rsvd_page(PADAPTER padapter, u8 mstatus);
#ifdef CONFIG_BT_COEXIST
	void rtl8188f_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P
void rtl8188f_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
void rtl8188f_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
#endif
#endif

#ifdef CONFIG_P2P_WOWLAN
void rtl8188f_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
#endif

void rtl8188f_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);

s32 FillH2CCmd8188F(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8188F(_adapter *padapter, bool wowlan);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/HalPwrSeqCmd.h                                                                0000644 0001750 0001750 00000010033 14214766567 016064  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HALPWRSEQCMD_H__
#define __HALPWRSEQCMD_H__

#include <drv_types.h>

/*---------------------------------------------*/
/* 3 The value of cmd: 4 bits
 *---------------------------------------------*/
#define PWR_CMD_READ			0x00
/* offset: the read register offset
 * msk: the mask of the read value
 * value: N/A, left by 0
 * note: dirver shall implement this function by read & msk */

#define PWR_CMD_WRITE			0x01
/* offset: the read register offset
 * msk: the mask of the write bits
 * value: write value
 * note: driver shall implement this cmd by read & msk after write */

#define PWR_CMD_POLLING			0x02
/* offset: the read register offset
 * msk: the mask of the polled value
 * value: the value to be polled, masked by the msd field.
 * note: driver shall implement this cmd by
 * do {
 * if( (Read(offset) & msk) == (value & msk) )
 * break;
 * } while(not timeout); */

#define PWR_CMD_DELAY			0x03
/* offset: the value to delay
 * msk: N/A
 * value: the unit of delay, 0: us, 1: ms */

#define PWR_CMD_END				0x04
/* offset: N/A
 * msk: N/A
 * value: N/A */

/*---------------------------------------------*/
/* 3 The value of base: 4 bits
 *---------------------------------------------
    * define the base address of each block */
#define PWR_BASEADDR_MAC		0x00
#define PWR_BASEADDR_USB		0x01
#define PWR_BASEADDR_PCIE		0x02
#define PWR_BASEADDR_SDIO		0x03

/*---------------------------------------------*/
/* 3 The value of interface_msk: 4 bits
 *---------------------------------------------*/
#define	PWR_INTF_SDIO_MSK		BIT(0)
#define	PWR_INTF_USB_MSK		BIT(1)
#define	PWR_INTF_PCI_MSK		BIT(2)
#define	PWR_INTF_ALL_MSK		(BIT(0) | BIT(1) | BIT(2) | BIT(3))

/*---------------------------------------------*/
/* 3 The value of fab_msk: 4 bits
 *---------------------------------------------*/
#define	PWR_FAB_TSMC_MSK		BIT(0)
#define	PWR_FAB_UMC_MSK			BIT(1)
#define	PWR_FAB_ALL_MSK			(BIT(0) | BIT(1) | BIT(2) | BIT(3))

/*---------------------------------------------*/
/* 3 The value of cut_msk: 8 bits
 *---------------------------------------------*/
#define	PWR_CUT_TESTCHIP_MSK	BIT(0)
#define	PWR_CUT_A_MSK			BIT(1)
#define	PWR_CUT_B_MSK			BIT(2)
#define	PWR_CUT_C_MSK			BIT(3)
#define	PWR_CUT_D_MSK			BIT(4)
#define	PWR_CUT_E_MSK			BIT(5)
#define	PWR_CUT_F_MSK			BIT(6)
#define	PWR_CUT_G_MSK			BIT(7)
#define	PWR_CUT_ALL_MSK			0xFF


typedef enum _PWRSEQ_CMD_DELAY_UNIT_ {
	PWRSEQ_DELAY_US,
	PWRSEQ_DELAY_MS,
} PWRSEQ_DELAY_UNIT;

typedef struct _WL_PWR_CFG_ {
	u16 offset;
	u8 cut_msk;
	u8 fab_msk:4;
	u8 interface_msk:4;
	u8 base:4;
	u8 cmd:4;
	u8 msk;
	u8 value;
} WLAN_PWR_CFG, *PWLAN_PWR_CFG;


#define GET_PWR_CFG_OFFSET(__PWR_CMD)		((__PWR_CMD).offset)
#define GET_PWR_CFG_CUT_MASK(__PWR_CMD)		((__PWR_CMD).cut_msk)
#define GET_PWR_CFG_FAB_MASK(__PWR_CMD)		((__PWR_CMD).fab_msk)
#define GET_PWR_CFG_INTF_MASK(__PWR_CMD)	((__PWR_CMD).interface_msk)
#define GET_PWR_CFG_BASE(__PWR_CMD)			((__PWR_CMD).base)
#define GET_PWR_CFG_CMD(__PWR_CMD)			((__PWR_CMD).cmd)
#define GET_PWR_CFG_MASK(__PWR_CMD)			((__PWR_CMD).msk)
#define GET_PWR_CFG_VALUE(__PWR_CMD)		((__PWR_CMD).value)


/* ********************************************************************************
 *	Prototype of protected function.
 * ******************************************************************************** */
u8 HalPwrSeqCmdParsing(
	PADAPTER		padapter,
	u8				CutVersion,
	u8				FabVersion,
	u8				InterfaceType,
	WLAN_PWR_CFG	PwrCfgCmd[]);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/cmn_info/                                                                     0000755 0001750 0001750 00000000000 14214766567 015214  5                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 rtl8822bu/src/include/cmn_info/rtw_sta_info.h                                                       0000644 0001750 0001750 00000020402 14214766567 020061  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
 *
 *
 ******************************************************************************/

 /*This header file is for all driver teams to use the same station info.
If you want to change this file please make sure notify all driver teams maintainers.*/

/*Created by YuChen 20170301*/

#ifndef __INC_RTW_STA_INFO_H
#define __INC_RTW_STA_INFO_H

/*--------------------Define ---------------------------------------*/

#define STA_DM_CTRL_ACTIVE			BIT(0)
#define STA_DM_CTRL_CFO_TRACKING	BIT(1)

#ifdef CONFIG_BEAMFORMING
#define	BEAMFORMING_HT_BEAMFORMER_ENABLE	BIT(0)	/*Declare sta support beamformer*/
#define	BEAMFORMING_HT_BEAMFORMEE_ENABLE	BIT(1)	/*Declare sta support beamformee*/
#define	BEAMFORMING_HT_BEAMFORMER_TEST		BIT(2)	/*Transmiting Beamforming no matter the target supports it or not*/
#define	BEAMFORMING_HT_BEAMFORMER_STEER_NUM		(BIT(4)|BIT(5))		/*Sta Bfer's capability*/
#define	BEAMFORMING_HT_BEAMFORMEE_CHNL_EST_CAP	(BIT(6)|BIT(7))		/*Sta BFee's capability*/

#define	BEAMFORMING_VHT_BEAMFORMER_ENABLE	BIT(0)	/*Declare sta support beamformer*/
#define	BEAMFORMING_VHT_BEAMFORMEE_ENABLE	BIT(1)	/*Declare sta support beamformee*/
#define	BEAMFORMING_VHT_MU_MIMO_AP_ENABLE	BIT(2)	/*Declare sta support MU beamformer*/
#define	BEAMFORMING_VHT_MU_MIMO_STA_ENABLE	BIT(3)	/*Declare sta support MU beamformer*/
#define	BEAMFORMING_VHT_BEAMFORMER_TEST		BIT(4)	/*Transmiting Beamforming no matter the target supports it or not*/
#define	BEAMFORMING_VHT_BEAMFORMER_STS_CAP		(BIT(8)|BIT(9)|BIT(10))		/*Sta BFee's capability*/
#define	BEAMFORMING_VHT_BEAMFORMEE_SOUND_DIM	(BIT(12)|BIT(13)|BIT(14))	/*Sta Bfer's capability*/
#endif

#define HT_STBC_EN	BIT(0)
#define VHT_STBC_EN	BIT(1)

#define HT_LDPC_EN	BIT(0)
#define VHT_LDPC_EN	BIT(1)

#define	SM_PS_STATIC	0
#define	SM_PS_DYNAMIC	1
#define	SM_PS_INVALID	2
#define	SM_PS_DISABLE	3


/*cmn_sta_info.ra_sta_info.txrx_state*/
#define	TX_STATE				0
#define	RX_STATE				1
#define	BI_DIRECTION_STATE	2

/*--------------------Define Enum-----------------------------------*/
enum channel_width {
	CHANNEL_WIDTH_20		= 0,
	CHANNEL_WIDTH_40		= 1,
	CHANNEL_WIDTH_80		= 2,
	CHANNEL_WIDTH_160		= 3,
	CHANNEL_WIDTH_80_80	= 4,
	CHANNEL_WIDTH_5		= 5,
	CHANNEL_WIDTH_10	= 6,
	CHANNEL_WIDTH_MAX	= 7,
};

enum rf_type {
	RF_1T1R			= 0,
	RF_1T2R			= 1,
	RF_2T2R			= 2,
	RF_2T3R			= 3,
	RF_2T4R			= 4,
	RF_3T3R			= 5,
	RF_3T4R			= 6,
	RF_4T4R			= 7,
	RF_TYPE_MAX,
};

enum bb_path {
	BB_PATH_NON = 0,
	BB_PATH_A = 0x00000001,
	BB_PATH_B = 0x00000002,
	BB_PATH_C = 0x00000004,
	BB_PATH_D = 0x00000008,

	BB_PATH_AB = (BB_PATH_A | BB_PATH_B),
	BB_PATH_AC = (BB_PATH_A | BB_PATH_C),
	BB_PATH_AD = (BB_PATH_A | BB_PATH_D),
	BB_PATH_BC = (BB_PATH_B | BB_PATH_C),
	BB_PATH_BD = (BB_PATH_B | BB_PATH_D),
	BB_PATH_CD = (BB_PATH_C | BB_PATH_D),

	BB_PATH_ABC = (BB_PATH_A | BB_PATH_B | BB_PATH_C),
	BB_PATH_ABD = (BB_PATH_A | BB_PATH_B | BB_PATH_D),
	BB_PATH_ACD = (BB_PATH_A | BB_PATH_C | BB_PATH_D),
	BB_PATH_BCD = (BB_PATH_B | BB_PATH_C | BB_PATH_D),

	BB_PATH_ABCD = (BB_PATH_A | BB_PATH_B | BB_PATH_C | BB_PATH_D),
	BB_PATH_AUTO = 0xff /*for path diversity*/
};

enum rf_path {
	RF_PATH_A = 0,
	RF_PATH_B = 1,
	RF_PATH_C = 2,
	RF_PATH_D = 3,
	RF_PATH_AB,
	RF_PATH_AC,
	RF_PATH_AD,
	RF_PATH_BC,
	RF_PATH_BD,
	RF_PATH_CD,
	RF_PATH_ABC,
	RF_PATH_ABD,
	RF_PATH_ACD,
	RF_PATH_BCD,
	RF_PATH_ABCD,
};

enum rf_syn {
	RF_SYN0 = 0,
	RF_SYN1 = 1,
};

enum rfc_mode {
	rfc_4x4 = 0,
	rfc_2x2 = 1,
};

enum wireless_set {
	WIRELESS_CCK	= 0x00000001,
	WIRELESS_OFDM	= 0x00000002,
	WIRELESS_HT	= 0x00000004,
	WIRELESS_VHT	= 0x00000008,
};

/*--------------------Define MACRO---------------------------------*/

/*--------------------Define Struct-----------------------------------*/

#ifdef CONFIG_BEAMFORMING
struct bf_cmn_info {
	u8	ht_beamform_cap;		/*Sta capablity*/
	u16	vht_beamform_cap;		/*Sta capablity*/
	u16	p_aid;
	u8	g_id;
};
#endif
struct rssi_info {
	s8		rssi;
	s8		rssi_cck;
	s8		rssi_ofdm;
	u8		packet_map;
	u8		ofdm_pkt_cnt;
	u8		cck_pkt_cnt;
	u16		cck_sum_power;
	u8		is_send_rssi;
	u8		valid_bit;
	s16		rssi_acc;	/*accumulate RSSI for per packet MA sum*/
};

struct ra_sta_info {
	u8	rate_id;			/*[PHYDM] ratr_idx*/
	u8	rssi_level;			/*[PHYDM]*/
	u8	is_first_connect:1;		/*[PHYDM] CE: ra_rpt_linked, AP: H2C_rssi_rpt*/
	u8	is_support_sgi:1;		/*[driver]*/
	u8	is_vht_enable:2;		/*[driver]*/
	u8	disable_ra:1;			/*[driver]*/
	u8	disable_pt:1;			/*[driver] remove is_disable_power_training*/
	u8	txrx_state:2;			/*[PHYDM] 0: Tx, 1:Rx, 2:bi-direction*/
	u8	is_noisy:1;			/*[PHYDM]*/
	u8	curr_tx_rate;			/*[PHYDM] FW->Driver*/
	enum channel_width	ra_bw_mode;	/*[Driver] max bandwidth, for RA only*/
	enum channel_width	curr_tx_bw;	/*[PHYDM] FW->Driver*/
	u8	curr_retry_ratio;		/*[PHYDM] FW->Driver*/
	u64	ramask;
};

struct dtp_info {
	u8	dyn_tx_power;	/*Dynamic Tx power offset*/
	u8	last_tx_power;
	u8	sta_tx_high_power_lvl:4;
	u8	sta_last_dtp_lvl:4;
};

struct cmn_sta_info {
	u16	dm_ctrl;			/*[Driver]*/
	enum channel_width	bw_mode;	/*[Driver] max support BW*/
	u8	mac_id;				/*[Driver]*/
	u8	mac_addr[6];			/*[Driver]*/
	u16	aid;				/*[Driver]*/
	enum rf_type mimo_type;			/*[Driver] sta XTXR*/
	struct rssi_info	rssi_stat;	/*[PHYDM]*/
	struct ra_sta_info	ra_info;	/*[Driver&PHYDM]*/
	u16	tx_moving_average_tp;		/*[Driver] tx average MBps*/
	u16	rx_moving_average_tp;		/*[Driver] rx average MBps*/
	u8	stbc_en:2;			/*[Driver] really transmitt STBC*/
	u8	ldpc_en:2;			/*[Driver] really transmitt LDPC*/
	enum wireless_set	support_wireless_set;/*[Driver]*/
#ifdef CONFIG_BEAMFORMING
	struct bf_cmn_info	bf_info;	/*[Driver]*/
#endif
	u8	sm_ps:2;			/*[Driver]*/
	struct dtp_info dtp_stat;		/*[PHYDM] Dynamic Tx power offset*/
	/*u8		pw2cca_over_TH_cnt;*/
	/*u8		total_pw2cca_cnt;*/
};

struct phydm_phyinfo_fw_struct {
	u8		rx_rssi[4];	/* RSSI in 0~100 index */
};

struct phydm_phyinfo_struct {
	boolean		physts_rpt_valid; /* @if physts_rpt_valid is false, please ignore the parsing result in this structure*/
	u8		rx_pwdb_all;
	u8		signal_quality;				/* OFDM: signal_quality=rx_mimo_signal_quality[0], CCK: signal qualityin 0-100 index. */
	u8		rx_mimo_signal_strength[4];	/* RSSI in 0~100 index */
	s8		rx_mimo_signal_quality[4];		/* OFDM: per-path's EVM translate to 0~100% , no used for CCK*/
	u8		rx_mimo_evm_dbm[4];			/* per-path's original EVM (dbm) */
	s16		cfo_short[4];					/* per-path's cfo_short */
	s16		cfo_tail[4];					/* per-path's cfo_tail */
	s8		rx_power;					/* in dBm Translate from PWdB */
	s8		recv_signal_power;			/* Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures. */
	u8		bt_rx_rssi_percentage;
	u8		signal_strength;				/* in 0-100 index. */
	s8		rx_pwr[4];					/* per-path's pwdb */
	s8		rx_snr[4];					/* per-path's SNR	*/
	u8		ant_idx[4];	/*per-path's antenna index*/
/*ODM_PHY_STATUS_NEW_TYPE_SUPPORT*/
	u8		rx_count:2;					/* RX path counter---*/
	u8		band_width:3;
	u8		rxsc:4;						/* sub-channel---*/
	u8		channel;						/* channel number---*/
	u8		is_mu_packet:1;				/* is MU packet or not---boolean*/
	u8		is_beamformed:1;				/* BF packet---boolean*/
	u8		cnt_pw2cca;
	u8		cnt_cca2agc_rdy;
/*ODM_PHY_STATUS_NEW_TYPE_SUPPORT*/
};

struct phydm_perpkt_info_struct {
	u8		data_rate;
	u8		station_id;
	u8		is_cck_rate: 1;
	u8		rate_ss:3;			/*spatial stream of data rate*/
	u8		is_packet_match_bssid:1;	/*boolean*/
	u8		is_packet_to_self:1;		/*boolean*/
	u8		is_packet_beacon:1;		/*boolean*/
	u8		is_to_self:1;				/*boolean*/
	u8		ppdu_cnt;
};

/*--------------------Export global variable----------------------------*/

/*--------------------Function declaration-----------------------------*/

#endif
                                                                                                                                                                                                                                                              rtl8822bu/src/include/Hal8192EPhyReg.h                                                              0000644 0001750 0001750 00000107431 14214766567 016057  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*****************************************************************************
 *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
 *
 * Module:	__INC_HAL8192SPHYREG_H
 *
 *
 * Note:	1. Define PMAC/BB register map
 *			2. Define RF register map
 *			3. PMAC/BB register bit mask.
 *			4. RF reg bit mask.
 *			5. Other BB/RF relative definition.
 *
 *
 * Export:	Constants, macro, functions(API), global variables(None).
 *
 * Abbrev:
 *
 * History:
 *		Data		Who		Remark
 *      08/07/2007  MHC	1. Porting from 9x series PHYCFG.h.
 *							2. Reorganize code architecture.
 *	09/25/2008	MH		1. Add RL6052 register definition
 *
 *****************************************************************************/
#ifndef __INC_HAL8192EPHYREG_H
#define __INC_HAL8192EPHYREG_H


/*--------------------------Define Parameters-------------------------------*/

/* ************************************************************
 * 8192S Regsiter offset definition
 * ************************************************************ */

/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart				0x104
#define		rPMAC_TxLegacySIG			0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum			0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble		0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK		0x170
#define		rPMAC_OFDMRxCRC32Er		0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus				0x18c


/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define		rFPGA0_TxInfo					0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1				0x810	/* Useless now */
#define		rFPGA0_RFTiming2				0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter	0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888
#define		rFPGA0_AdDaClockEn			0x888	/* enable ad/da clock1 for dual-phy */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback		0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback		0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */

#define		rFPGA1_TxBlock				0x904	/* Useless now */
#define		rFPGA1_DebugSelect			0x908	/* Useless now */
#define		rFPGA1_TxInfo					0x90c	/* Useless now */ /* Status report?? */

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System					0xa00

#define		rCCK0_AFESetting				0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1			0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2			0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort				0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport			0xa50
#define		rCCK0_RxReport            			0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower      		0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper      		0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define		rPdp_AntA					0xb00
#define		rPdp_AntA_4				0xb04
#define		rConfig_Pmpd_AntA			0xb28
#define		rConfig_ram64x16				0xb2c

#define		rConfig_AntA					0xb68
#define		rConfig_AntB					0xb6c
#define		rPdp_AntB					0xb70
#define		rPdp_AntB_4					0xb74
#define		rConfig_Pmpd_AntB			0xb98
#define		rAPK							0xbd8



/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF					0xc00

#define		rOFDM0_TRxPathEnable			0xc04
#define		rOFDM0_TRMuxPar				0xc08
#define		rOFDM0_TRSWIsolation			0xc0c

#define		rOFDM0_XARxAFE				0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance    		0xc14  /* RxIQ imblance matrix */
#define		rOFDM0_XBRxAFE			0xc18
#define		rOFDM0_XBRxIQImbalance		0xc1c
#define		rOFDM0_XCRxAFE			0xc20
#define		rOFDM0_XCRxIQImbalance		0xc24
#define		rOFDM0_XDRxAFE			0xc28
#define		rOFDM0_XDRxIQImbalance		0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC			0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold		0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold			0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1		0xc70
#define		rOFDM0_AGCParameter2		0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_RxHPParameter		0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync			0xcf0
#define		rOFDM0_DFSReport			0xcf4


/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO					0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD					0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet				0xd3c
#define		rOFDM1_PseudoNoiseStateAB	0xd50
#define		rOFDM1_PseudoNoiseStateCD	0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1			0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2			0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3			0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB			0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD			0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR				0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00		0xe10
#define		rTxAGC_A_Mcs07_Mcs04		0xe14
#define		rTxAGC_A_Mcs11_Mcs08		0xe18
#define		rTxAGC_A_Mcs15_Mcs12		0xe1c

#define		rTxAGC_B_Rate18_06			0x830
#define		rTxAGC_B_Rate54_24			0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00		0x83c
#define		rTxAGC_B_Mcs07_Mcs04		0x848
#define		rTxAGC_B_Mcs11_Mcs08		0x84c
#define		rTxAGC_B_Mcs15_Mcs12		0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1			0x1
#define		rZebra1_TRxEnable2			0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain				0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl					0	/* Useless now */
#define		rRTL8256_TxLPF				19
#define		rRTL8256_RxLPF				11

/* RTL8258 */
#define		rRTL8258_TxLPF				0x11	/* Useless now */
#define		rRTL8258_RxLPF				0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/*  */

#define		RF_IQADJ_G1					0x01	/*  */
#define		RF_IQADJ_G2					0x02	/*  */

#define		RF_POW_TRSW				0x05	/*  */

#define		RF_GAIN_RX					0x06	/*  */
#define		RF_GAIN_TX					0x07	/*  */

#define		RF_TXM_IDAC					0x08	/*  */
#define		RF_IPA_G						0x09	/*  */
#define		RF_TXBIAS_G					0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A						0x0C	/*  */
#define		RF_TXBIAS_A					0x0D
#define		RF_BS_PA_APSET_G9_G11		0x0E
#define		RF_BS_IQGEN					0x0F	/*  */

#define		RF_MODE1					0x10	/*  */
#define		RF_MODE2					0x11	/*  */

#define		RF_RX_AGC_HP				0x12	/*  */
#define		RF_TX_AGC					0x13	/*  */
#define		RF_BIAS						0x14	/*  */
#define		RF_IPA						0x15	/*  */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY				0x17	/*  */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/*  */

#define		RF_RX_G1					0x1A	/*  */
#define		RF_RX_G2					0x1B	/*  */

#define		RF_RX_BB2					0x1C	/*  */
#define		RF_RX_BB1					0x1D	/*  */

#define		RF_RCK1						0x1E	/*  */
#define		RF_RCK2						0x1F	/*  */

#define		RF_TX_G1						0x20	/*  */
#define		RF_TX_G2						0x21	/*  */
#define		RF_TX_G3						0x22	/*  */

#define		RF_TX_BB1					0x23	/*  */

#define		RF_T_METER_8192E			0x42	/*  */
#define		RF_T_METER_88E				0x42
#define		RF_T_METER					0x24	/*  */

/* #endif */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */
#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define		RF_TX_BIAS_A					0x35
#define		RF_TX_BIAS_D					0x36
#define		RF_LOBF_9					0x38
#define		RF_RXRF_A3					0x3C	/*	 */
#define		RF_TRSW						0x3F

#define		RF_TXRF_A2					0x41
#define		RF_TXPA_G4					0x46
#define		RF_TXPA_A4					0x4B
#define		RF_0x52						0x52
#define		RF_LDO						0xB1
#define		RF_WE_LUT					0xEF


/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB					0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart					0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback				0x10
#define		bTxLSIG						0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength				0x1ffe0
#define		bOFDMTxParity				0x20000
#define		bTxHTSIG1					0xffffff
#define		bTxHTMCSRate				0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2					0xffffff
#define		bTxHTSmoothing				0x1
#define		bTxHTSounding				0x2
#define		bTxHTReserved				0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC					0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8					0x3fc00
#define		bCounterReset				0x10000
#define		bNumOfOFDMTx				0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval				0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader				0xffffffff
#define		bTxDataInit					0xff
#define		bTxHTMode					0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed				0xffffffff
#define		bCCKTxPreamble				0x1
#define		bCCKTxSFD					0xffff0000
#define		bCCKTxSIG					0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus				0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
#define		RF_TX_GAIN_OFFSET_8192E(_val)		((abs((_val)) << 1) | (((_val) > 0) ? BIT0 : 0))


/* 2. Page8(0x800) */
#define		bRFMOD						0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode					0x2
#define		bCCKTxSC						0x30
#define		bCCKEn						0x1000000
#define		bOFDMEn					0x2000000

#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC				0x3f

#define		bAntennaSelect			0x0300

#define		bXBTxAGC                  				0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC				0xf000
#define		bXDTxAGC				0xf0000

#define		bPAStart                  				0xf0000000	/* Useless now */
#define		bTRStart				0x00f00000
#define		bRFStart				0x0000f000
#define		bBBStart				0x000000f0
#define		bBBCCKStart			0x0000000f
#define		bPAEnd                    				0xf          /* Reg0x814 */
#define		bTREnd				0x0f000000
#define		bRFEnd				0x000f0000
#define		bCCAMask                  				0x000000f0   /* T2R */
#define		bR2RCCAMask			0x00000f00
#define		bHSSI_R2TDelay			0xf8000000
#define		bHSSI_T2RDelay			0xf80000
#define		bContTxHSSI               			0x400     /* chane gain at continue Tx */
#define		bIGFromCCK			0x200
#define		bAGCAddress			0x3f
#define		bRxHPTx				0x7000
#define		bRxHPT2R				0x38000
#define		bRxHPCCKIni			0xc0000
#define		bAGCTxCode			0xc00000
#define		bAGCRxCode			0x300000

#define		b3WireDataLength          			0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         		0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity			0x40000000
#define		b2GPAPEPolarity			0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData			0x1
#define		bRFSI_3WireClock			0x2
#define		bRFSI_3WireLoad			0x4
#define		bRFSI_3WireRW			0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW                		0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         		0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby	0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP	0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              		0x18000000	/* Useless */
#define		bAFEWatchDogEnable	0x20000000

#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x				0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          		0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode	0x40000
#define		bAD7InputCMMode	0x380000
#define		bAD7Current		0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx	0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx	0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint	0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport		0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 		0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                		0xff   /* reset debug page and LWord */
#define		bAntL				0x10
#define		bAntNonHT			0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode                		0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble              		0x8	/* Useless */
#define		bCCKAntDiversity			0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate			0x3000
#define		bCCKDCCancel		0x0800
#define		bCCKISICancel		0x0400
#define		bCCKMatchFilter		0x0200
#define		bCCKEqualizer		0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart		0x300000
#define		bCCKCCACount		0x080000
#define		bCCKcs_lim			0x070000
#define		bCCKBistMode		0x80000000
#define		bCCKCCAMask		0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset		0xf0
#define		bCCKRxDCOffset		0xf
#define		bCCKCCAMode		0xc000
#define		bCCKFalseCS_lim		0x3f00
#define		bCCKCS_ratio		0xc00000
#define		bCCKCorgBit_sel		0x300000
#define		bCCKPD_lim		0x0f0000
#define		bCCKNewCCA		0x80000000
#define		bCCKRxHPofIG		0x8000
#define		bCCKRxIG			0x7f00
#define		bCCKLNAPolarity		0x800000
#define		bCCKRx1stGain		0x7f0000
#define		bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC		0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType		0x0300
#define		bCCKRxDAGCEn		0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0			0x3f0000
#define		bCCKTxC1			0x3f000000
#define		bCCKTxC2			0x3f
#define		bCCKTxC3			0x3f00
#define		bCCKTxC4			0x3f0000
#define		bCCKTxC5			0x3f000000
#define		bCCKTxC6			0x3f
#define		bCCKTxC7			0x3f00
#define		bCCKDebugPort		0xff0000
#define		bCCKDACDebug		0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead	0x4000
#define		bCCKTRSSI			0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff	0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel		0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF                			0x3	/* Useless */
#define		bShift_L			0xc0
#define		bGI_TH			0xc
#define		bRxPathA			0x1
#define		bRxPathB			0x2
#define		bRxPathC			0x4
#define		bRxPathD			0x8
#define		bTxPathA			0x1
#define		bTxPathB			0x2
#define		bTxPathC			0x4
#define		bTxPathD			0x8
#define		bTRSSIFreq			0x200
#define		bADCBackoff			0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset		0xff00
#define		bRxDFIRMode		0x1800000
#define		bRxDCNFType		0xe000000
#define		bRXIQImb_A		0x3ff
#define		bRXIQImb_B			0xfc00
#define		bRXIQImb_C			0x3f0000
#define		bRXIQImb_D		0xffc00000
#define		bDC_dc_Notch		0x60000
#define		bRxNBINotch		0x1f000000
#define		bPD_TH			0xf
#define		bPD_TH_Opt2		0xc000
#define		bPWED_TH			0x700
#define		bIfMF_Win_L		0x800
#define		bPD_Option			0x1000
#define		bMF_Win_L			0xe000
#define		bBW_Search_L		0x30000
#define		bwin_enh_L			0xc0000
#define		bBW_TH			0x700000
#define		bED_TH2			0x3800000
#define		bBW_option			0x4000000
#define		bRatio_TH			0x18000000
#define		bWindow_L			0xe0000000
#define		bSBD_Option		0x1
#define		bFrame_TH			0x1c
#define		bFS_Option			0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune			0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2		0x7
#define		bFrame_GI2_TH		0x38
#define		bGI2_Sync_en		0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum		0x1
#define		bCFOAcc			0x2
#define		bCFOStartOffset		0xc
#define		bCFOLookBack		0x70
#define		bCFOSumWeight		0x80
#define		bDAGCEnable		0x10000
#define		bTXIQImb_A			0x3ff
#define		bTXIQImb_B			0xfc00
#define		bTXIQImb_C			0x3f0000
#define		bTXIQImb_D			0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset		0xff00
#define		bTxDFIRMode		0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption		0x20000
#define		bCCADropThres		0xfff00000
#define		bEDCCA_H			0xf
#define		bEDCCA_L			0xf0
#define		bLambda_ED		0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn		0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En		0x10000000
#define		bRxQuickAGCEn		0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift			0x7f
#define		bTRSW_Tri_Only		0x80
#define		bPowerThres		0x300
#define		bRxAGCEn			0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin		0x4
#define		bRxHP_Ini			0x7
#define		bRxHP_TRLNA		0x70
#define		bRxHP_RSSI			0x700
#define		bRxHP_BBP1		0x7000
#define		bRxHP_BBP2		0x70000
#define		bRxHP_BBP3		0x700000
#define		bRSSI_H                  			0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen                			0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW		0x7
#define		bRxSettle_LNA		0x38
#define		bRxSettle_RSSI		0x1c0
#define		bRxSettle_BBP		0xe00
#define		bRxSettle_RxHP		0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI		0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final			0x7000000
#define		bRxHTSettle_BBP		0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn		0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin		0x80000
#define		bRxHTAGCEn		0x100000
#define		bRxHTDAGCEn		0x200000
#define		bRxHTRxHP_BBP		0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH		0x3
#define		bRxPWRatioEn		0x4
#define		bRxMFHold			0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH		0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L		0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH			0xc0000000
#define		bDFSCnt0			0xff
#define		bDFSCnt1			0xff00
#define		bDFSFlag			0xf0000
#define		bMFWeightSum		0x300000
#define		bMinIdxTH			0x7f000000
#define		bDAFormat			0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain		0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn                  			0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss			0x20
#define		bCFOAntSumD		0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet		0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn			0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re			0x3f
#define		bSigTone_Im			0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail		0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail		0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync		0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength         		12   /* total */
#define		bShortCFOFLength         		11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength		11
#define		bLongCFOFLength		11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW		0x1
#define		bRxSC			0x6
#define		bRx_HT			0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg		0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain			0x3f
#define		bTableSel			0x40
#define		bTRSW			0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st			0xff
#define		bCSI2nd			0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd		0xff000000
#define		bSIGEVM			0xff
#define		bPWDB			0xff00
#define		bSGIEN			0x10000

#define		bSFactorQAM1             		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet          		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode		0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType             			0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO		0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC				0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF			0x20000
#define		bComChCFO		0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz		0x100000
#define		bUChCfg			0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn         		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C		0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable        		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1      	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW	0x18
#define		bRTL8256_RxLPFBW	0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW          	0xc	/* Useless */
#define		bRTL8258_RxLPFBW	0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0                    			0x1	/* Useless */
#define		bByte1			0x2
#define		bByte2			0x4
#define		bByte3			0x8
#define		bWord0			0x3
#define		bWord1			0xc
#define		bDWord			0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0                		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1		0xff00
#define		bMaskByte2		0xff0000
#define		bMaskByte3		0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord		0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes				0xffffff00
#define		bMask12Bits				0xfff
#define		bMaskH4Bits				0xf0000000
#define		bMaskOFDM_D			0xffc00000
#define		bMaskCCK				0x3f3f3f3f

/* for PutRFRegsetting & GetRFRegSetting BitMask
 * #define		bMask12Bits               0xfffff */	/* RF Reg mask bits
 * #define		bMask20Bits               0xfffff */	/* RF Reg mask bits T65 RF */
#define		bRFRegOffsetMask			0xfffff

#define		bEnable                   0x1	/* Useless */
#define		bDisable                  0x0

#define		LeftAntenna               			0x0	/* Useless */
#define		RightAntenna		0x1

#define		tCheckTxStatus            		500   /* 500ms */ /* Useless */
#define		tUpdateRxCounter          		100   /* 100ms */

#define		rateCCK     				0	/* Useless */
#define		rateOFDM				1
#define		rateHT					2

/* define Register-End */
#define		bPMAC_End                 		0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl              		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA                     			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3


/* RSSI Dump Message */
#define		rA_RSSIDump_92E			0xcb0
#define		rB_RSSIDump_92E			0xcb1
#define		rS1_RXevmDump_92E			0xcb2
#define		rS2_RXevmDump_92E			0xcb3
#define		rA_RXsnrDump_92E			0xcb4
#define		rB_RXsnrDump_92E			0xcb5
#define		rA_CfoShortDump_92E		0xcb6
#define		rB_CfoShortDump_92E		0xcb8
#define	rA_CfoLongDump_92E			0xcba
#define		rB_CfoLongDump_92E			0xcbc

/*--------------------------Define Parameters-------------------------------*/


#endif /* __INC_HAL8188EPHYREG_H */
                                                                                                                                                                                                                                       rtl8822bu/src/include/hal_pg.h                                                                      0000755 0001750 0001750 00000100453 14214766567 015035  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __HAL_PG_H__
#define __HAL_PG_H__

#define PPG_BB_GAIN_2G_TX_OFFSET_MASK	0x0F
#define PPG_BB_GAIN_2G_TXB_OFFSET_MASK	0xF0

#define PPG_BB_GAIN_5G_TX_OFFSET_MASK	0x1F
#define PPG_THERMAL_OFFSET_MASK			0x1F
#define KFREE_BB_GAIN_2G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_2G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
#define KFREE_BB_GAIN_2G_TXB_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_2G_TXB_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x10) ? ((_ppg_v) >> 5) : (-((_ppg_v) >> 5))))
#define KFREE_BB_GAIN_5G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_5G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
#define KFREE_THERMAL_OFFSET(_ppg_v) (((_ppg_v) == PPG_THERMAL_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))

/* ****************************************************
 *			EEPROM/Efuse PG Offset for 88EE/88EU/88ES
 * **************************************************** */
#define EEPROM_ChannelPlan_88E					0xB8
#define EEPROM_XTAL_88E						0xB9
#define EEPROM_THERMAL_METER_88E				0xBA
#define EEPROM_IQK_LCK_88E						0xBB

#define EEPROM_RF_BOARD_OPTION_88E			0xC1
#define EEPROM_RF_FEATURE_OPTION_88E			0xC2
#define EEPROM_RF_BT_SETTING_88E				0xC3
#define EEPROM_VERSION_88E						0xC4
#define EEPROM_CustomID_88E					0xC5
#define EEPROM_RF_ANTENNA_OPT_88E			0xC9
#define EEPROM_COUNTRY_CODE_88E				0xCB

/* RTL88EE */
#define EEPROM_MAC_ADDR_88EE					0xD0
#define EEPROM_VID_88EE						0xD6
#define EEPROM_DID_88EE						0xD8
#define EEPROM_SVID_88EE						0xDA
#define EEPROM_SMID_88EE						0xDC

/* RTL88EU */
#define EEPROM_MAC_ADDR_88EU					0xD7
#define EEPROM_VID_88EU						0xD0
#define EEPROM_PID_88EU						0xD2
#define EEPROM_USB_OPTIONAL_FUNCTION0		0xD4 /* 8188EU, 8192EU, 8812AU is the same */
#define EEPROM_USB_OPTIONAL_FUNCTION0_8811AU 0x104

/* RTL88ES */
#define EEPROM_MAC_ADDR_88ES					0x11A
/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8192EE/8192EU/8192ES
 * **************************************************** */
#define GET_PG_KFREE_ON_8192E(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8192E(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)

#define PPG_BB_GAIN_2G_TXA_OFFSET_8192E	0x1F6
#define PPG_THERMAL_OFFSET_8192E		0x1F5

#define	EEPROM_ChannelPlan_8192E				0xB8
#define	EEPROM_XTAL_8192E						0xB9
#define	EEPROM_THERMAL_METER_8192E			0xBA
#define	EEPROM_IQK_LCK_8192E					0xBB
#define	EEPROM_2G_5G_PA_TYPE_8192E			0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8192E	0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8192E	0xBF

#define	EEPROM_RF_BOARD_OPTION_8192E		0xC1
#define	EEPROM_RF_FEATURE_OPTION_8192E		0xC2
#define	EEPROM_RF_BT_SETTING_8192E			0xC3
#define	EEPROM_VERSION_8192E					0xC4
#define	EEPROM_CustomID_8192E				0xC5
#define	EEPROM_TX_BBSWING_2G_8192E			0xC6
#define	EEPROM_TX_BBSWING_5G_8192E			0xC7
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8192E	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8192E			0xC9
#define	EEPROM_RFE_OPTION_8192E				0xCA
#define	EEPROM_RFE_OPTION_8188E				0xCA
#define EEPROM_COUNTRY_CODE_8192E			0xCB

/* RTL8192EE */
#define	EEPROM_MAC_ADDR_8192EE				0xD0
#define	EEPROM_VID_8192EE						0xD6
#define	EEPROM_DID_8192EE						0xD8
#define	EEPROM_SVID_8192EE					0xDA
#define	EEPROM_SMID_8192EE					0xDC

/* RTL8192EU */
#define	EEPROM_MAC_ADDR_8192EU				0xD7
#define	EEPROM_VID_8192EU						0xD0
#define	EEPROM_PID_8192EU						0xD2
#define	EEPROM_PA_TYPE_8192EU		0xBC
#define	EEPROM_LNA_TYPE_2G_8192EU	0xBD
#define	EEPROM_LNA_TYPE_5G_8192EU	0xBF

/* RTL8192ES */
#define	EEPROM_MAC_ADDR_8192ES				0x11A
/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8812AE/8812AU/8812AS
 * *****************************************************/
#define EEPROM_USB_MODE_8812					0x08

#define EEPROM_ChannelPlan_8812				0xB8
#define EEPROM_XTAL_8812						0xB9
#define EEPROM_THERMAL_METER_8812			0xBA
#define EEPROM_IQK_LCK_8812					0xBB
#define EEPROM_2G_5G_PA_TYPE_8812			0xBC
#define EEPROM_2G_LNA_TYPE_GAIN_SEL_8812	0xBD
#define EEPROM_5G_LNA_TYPE_GAIN_SEL_8812	0xBF

#define EEPROM_RF_BOARD_OPTION_8812			0xC1
#define EEPROM_RF_FEATURE_OPTION_8812		0xC2
#define EEPROM_RF_BT_SETTING_8812				0xC3
#define EEPROM_VERSION_8812					0xC4
#define EEPROM_CustomID_8812					0xC5
#define EEPROM_TX_BBSWING_2G_8812			0xC6
#define EEPROM_TX_BBSWING_5G_8812			0xC7
#define EEPROM_TX_PWR_CALIBRATE_RATE_8812	0xC8
#define EEPROM_RF_ANTENNA_OPT_8812			0xC9
#define EEPROM_RFE_OPTION_8812				0xCA
#define EEPROM_COUNTRY_CODE_8812			0xCB

/* RTL8812AE */
#define EEPROM_MAC_ADDR_8812AE				0xD0
#define EEPROM_VID_8812AE						0xD6
#define EEPROM_DID_8812AE						0xD8
#define EEPROM_SVID_8812AE						0xDA
#define EEPROM_SMID_8812AE					0xDC

/* RTL8812AU */
#define EEPROM_MAC_ADDR_8812AU				0xD7
#define EEPROM_VID_8812AU						0xD0
#define EEPROM_PID_8812AU						0xD2
#define EEPROM_PA_TYPE_8812AU					0xBC
#define EEPROM_LNA_TYPE_2G_8812AU			0xBD
#define EEPROM_LNA_TYPE_5G_8812AU			0xBF

/* RTL8814AU */
#define	EEPROM_MAC_ADDR_8814AU				0xD8
#define	EEPROM_VID_8814AU						0xD0
#define	EEPROM_PID_8814AU						0xD2
#define	EEPROM_PA_TYPE_8814AU				0xBC
#define	EEPROM_LNA_TYPE_2G_8814AU			0xBD
#define	EEPROM_LNA_TYPE_5G_8814AU			0xBF

/* RTL8814AE */
#define EEPROM_MAC_ADDR_8814AE				0xD0
#define EEPROM_VID_8814AE						0xD6
#define EEPROM_DID_8814AE						0xD8
#define EEPROM_SVID_8814AE						0xDA
#define EEPROM_SMID_8814AE					0xDC

/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8814AU
 * **************************************************** */
#define GET_PG_KFREE_ON_8814A(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8814A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
#define GET_PG_TX_POWER_TRACKING_MODE_8814A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 6, 2)

#define KFREE_GAIN_DATA_LENGTH_8814A	22

#define PPG_BB_GAIN_2G_TXBA_OFFSET_8814A	0x3EE

#define PPG_THERMAL_OFFSET_8814A		0x3EF

#define EEPROM_USB_MODE_8814A				0x0E
#define EEPROM_ChannelPlan_8814				0xB8
#define EEPROM_XTAL_8814					0xB9
#define EEPROM_THERMAL_METER_8814			0xBA
#define	EEPROM_IQK_LCK_8814					0xBB


#define EEPROM_PA_TYPE_8814					0xBC
#define EEPROM_LNA_TYPE_AB_2G_8814			0xBD
#define	EEPROM_LNA_TYPE_CD_2G_8814			0xBE
#define EEPROM_LNA_TYPE_AB_5G_8814			0xBF
#define EEPROM_LNA_TYPE_CD_5G_8814			0xC0
#define	EEPROM_RF_BOARD_OPTION_8814			0xC1
#define	EEPROM_RF_BT_SETTING_8814			0xC3
#define	EEPROM_VERSION_8814					0xC4
#define	EEPROM_CustomID_8814				0xC5
#define	EEPROM_TX_BBSWING_2G_8814			0xC6
#define	EEPROM_TX_BBSWING_5G_8814			0xC7
#define EEPROM_TRX_ANTENNA_OPTION_8814		0xC9
#define	EEPROM_RFE_OPTION_8814				0xCA
#define EEPROM_COUNTRY_CODE_8814			0xCB

/*Extra Info for 8814A Initial Gain Fine Tune  suggested by Willis, JIRA: MP123*/
#define	EEPROM_IG_OFFSET_4_AB_2G_8814A				0x120
#define	EEPROM_IG_OFFSET_4_CD_2G_8814A				0x121
#define	EEPROM_IG_OFFSET_4_AB_5GL_8814A				0x122
#define	EEPROM_IG_OFFSET_4_CD_5GL_8814A				0x123
#define	EEPROM_IG_OFFSET_4_AB_5GM_8814A				0x124
#define	EEPROM_IG_OFFSET_4_CD_5GM_8814A				0x125
#define	EEPROM_IG_OFFSET_4_AB_5GH_8814A				0x126
#define	EEPROM_IG_OFFSET_4_CD_5GH_8814A				0x127

/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8821AE/8821AU/8821AS
 * **************************************************** */

#define GET_PG_KFREE_ON_8821A(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8821A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)

#define PPG_BB_GAIN_2G_TXA_OFFSET_8821A		0x1F6
#define PPG_THERMAL_OFFSET_8821A			0x1F5
#define PPG_BB_GAIN_5GLB1_TXA_OFFSET_8821A	0x1F4
#define PPG_BB_GAIN_5GLB2_TXA_OFFSET_8821A	0x1F3
#define PPG_BB_GAIN_5GMB1_TXA_OFFSET_8821A	0x1F2
#define PPG_BB_GAIN_5GMB2_TXA_OFFSET_8821A	0x1F1
#define PPG_BB_GAIN_5GHB_TXA_OFFSET_8821A	0x1F0

#define EEPROM_ChannelPlan_8821				0xB8
#define EEPROM_XTAL_8821						0xB9
#define EEPROM_THERMAL_METER_8821			0xBA
#define EEPROM_IQK_LCK_8821					0xBB


#define EEPROM_RF_BOARD_OPTION_8821			0xC1
#define EEPROM_RF_FEATURE_OPTION_8821		0xC2
#define EEPROM_RF_BT_SETTING_8821				0xC3
#define EEPROM_VERSION_8821					0xC4
#define EEPROM_CustomID_8821					0xC5
#define EEPROM_RF_ANTENNA_OPT_8821			0xC9

/* RTL8821AE */
#define EEPROM_MAC_ADDR_8821AE				0xD0
#define EEPROM_VID_8821AE						0xD6
#define EEPROM_DID_8821AE						0xD8
#define EEPROM_SVID_8821AE						0xDA
#define EEPROM_SMID_8821AE					0xDC

/* RTL8821AU */
#define EEPROM_PA_TYPE_8821AU					0xBC
#define EEPROM_LNA_TYPE_8821AU				0xBF

/* RTL8821AS */
#define EEPROM_MAC_ADDR_8821AS				0x11A

/* RTL8821AU */
#define EEPROM_MAC_ADDR_8821AU				0x107
#define EEPROM_VID_8821AU						0x100
#define EEPROM_PID_8821AU						0x102


/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8192 SE/SU
 * **************************************************** */
#define EEPROM_VID_92SE						0x0A
#define EEPROM_DID_92SE						0x0C
#define EEPROM_SVID_92SE						0x0E
#define EEPROM_SMID_92SE						0x10

#define EEPROM_MAC_ADDR_92S					0x12

#define EEPROM_TSSI_A_92SE						0x74
#define EEPROM_TSSI_B_92SE						0x75

#define EEPROM_Version_92SE					0x7C


#define EEPROM_VID_92SU						0x08
#define EEPROM_PID_92SU						0x0A

#define EEPROM_Version_92SU					0x50
#define EEPROM_TSSI_A_92SU						0x6b
#define EEPROM_TSSI_B_92SU						0x6c

/* ====================================================
	EEPROM/Efuse PG Offset for 8188FE/8188FU/8188FS
   ====================================================
 */

#define GET_PG_KFREE_ON_8188F(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8188F(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)

#define PPG_BB_GAIN_2G_TXA_OFFSET_8188F	0xEE
#define PPG_THERMAL_OFFSET_8188F		0xEF

#define	EEPROM_ChannelPlan_8188F			0xB8
#define	EEPROM_XTAL_8188F					0xB9
#define	EEPROM_THERMAL_METER_8188F			0xBA
#define	EEPROM_IQK_LCK_8188F				0xBB
#define	EEPROM_2G_5G_PA_TYPE_8188F			0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8188F	0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8188F	0xBF

#define	EEPROM_RF_BOARD_OPTION_8188F		0xC1
#define	EEPROM_FEATURE_OPTION_8188F			0xC2
#define	EEPROM_RF_BT_SETTING_8188F			0xC3
#define	EEPROM_VERSION_8188F				0xC4
#define	EEPROM_CustomID_8188F				0xC5
#define	EEPROM_TX_BBSWING_2G_8188F			0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8188F	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8188F			0xC9
#define	EEPROM_RFE_OPTION_8188F				0xCA
#define EEPROM_COUNTRY_CODE_8188F			0xCB
#define EEPROM_CUSTOMER_ID_8188F			0x7F
#define EEPROM_SUBCUSTOMER_ID_8188F			0x59

/* RTL8188FU */
#define EEPROM_MAC_ADDR_8188FU				0xD7
#define EEPROM_VID_8188FU					0xD0
#define EEPROM_PID_8188FU					0xD2
#define EEPROM_PA_TYPE_8188FU				0xBC
#define EEPROM_LNA_TYPE_2G_8188FU			0xBD
#define EEPROM_USB_OPTIONAL_FUNCTION0_8188FU 0xD4

/* RTL8188FS */
#define	EEPROM_MAC_ADDR_8188FS				0x11A
#define EEPROM_Voltage_ADDR_8188F			0x8

/* ====================================================
	EEPROM/Efuse PG Offset for 8188GTV/8188GTVS
   ====================================================
 */

#define GET_PG_KFREE_ON_8188GTV(_pg_m)				LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8188GTV(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)

#define PPG_BB_GAIN_2G_TXA_OFFSET_8188GTV	0xEE
#define PPG_THERMAL_OFFSET_8188GTV			0xEF

#define	EEPROM_ChannelPlan_8188GTV				0xB8
#define	EEPROM_XTAL_8188GTV						0xB9
#define	EEPROM_THERMAL_METER_8188GTV			0xBA
#define	EEPROM_IQK_LCK_8188GTV					0xBB
#define	EEPROM_2G_5G_PA_TYPE_8188GTV			0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8188GTV		0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8188GTV		0xBF

#define	EEPROM_RF_BOARD_OPTION_8188GTV			0xC1
#define	EEPROM_FEATURE_OPTION_8188GTV			0xC2
#define	EEPROM_RF_BT_SETTING_8188GTV			0xC3
#define	EEPROM_VERSION_8188GTV					0xC4
#define	EEPROM_CustomID_8188GTV					0xC5
#define	EEPROM_TX_BBSWING_2G_8188GTV			0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8188GTV	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8188GTV			0xC9
#define	EEPROM_RFE_OPTION_8188GTV				0xCA
#define EEPROM_COUNTRY_CODE_8188GTV				0xCB
#define EEPROM_CUSTOMER_ID_8188GTV				0x7F
#define EEPROM_SUBCUSTOMER_ID_8188GTV			0x59

/* RTL8188GTVU */
#define EEPROM_MAC_ADDR_8188GTVU				0xD7
#define EEPROM_VID_8188GTVU						0xD0
#define EEPROM_PID_8188GTVU						0xD2
#define EEPROM_PA_TYPE_8188GTVU					0xBC
#define EEPROM_LNA_TYPE_2G_8188GTVU				0xBD
#define EEPROM_USB_OPTIONAL_FUNCTION0_8188GTVU	0xD4

/* RTL8188GTVS */
#define	EEPROM_MAC_ADDR_8188GTVS				0x11A
#define EEPROM_Voltage_ADDR_8188GTV				0x8

/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8723BE/8723BU/8723BS
 * *****************************************************/
#define	EEPROM_ChannelPlan_8723B				0xB8
#define	EEPROM_XTAL_8723B						0xB9
#define	EEPROM_THERMAL_METER_8723B			0xBA
#define	EEPROM_IQK_LCK_8723B					0xBB
#define	EEPROM_2G_5G_PA_TYPE_8723B			0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8723B	0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8723B	0xBF

#define	EEPROM_RF_BOARD_OPTION_8723B		0xC1
#define	EEPROM_FEATURE_OPTION_8723B			0xC2
#define	EEPROM_RF_BT_SETTING_8723B			0xC3
#define	EEPROM_VERSION_8723B					0xC4
#define	EEPROM_CustomID_8723B				0xC5
#define	EEPROM_TX_BBSWING_2G_8723B			0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8723B	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8723B		0xC9
#define	EEPROM_RFE_OPTION_8723B				0xCA
#define EEPROM_COUNTRY_CODE_8723B			0xCB

/* RTL8723BE */
#define EEPROM_MAC_ADDR_8723BE				0xD0
#define EEPROM_VID_8723BE						0xD6
#define EEPROM_DID_8723BE						0xD8
#define EEPROM_SVID_8723BE						0xDA
#define EEPROM_SMID_8723BE						0xDC

/* RTL8723BU */
#define EEPROM_MAC_ADDR_8723BU				0x107
#define EEPROM_VID_8723BU						0x100
#define EEPROM_PID_8723BU						0x102
#define EEPROM_PA_TYPE_8723BU					0xBC
#define EEPROM_LNA_TYPE_2G_8723BU				0xBD


/* RTL8723BS */
#define	EEPROM_MAC_ADDR_8723BS				0x11A
#define EEPROM_Voltage_ADDR_8723B			0x8

/* ****************************************************
 *			EEPROM/Efuse PG Offset for 8703B
 * **************************************************** */
#define GET_PG_KFREE_ON_8703B(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8703B(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)

#define PPG_BB_GAIN_2G_TXA_OFFSET_8703B	0xEE
#define PPG_THERMAL_OFFSET_8703B		0xEF

#define	EEPROM_ChannelPlan_8703B				0xB8
#define	EEPROM_XTAL_8703B					0xB9
#define	EEPROM_THERMAL_METER_8703B			0xBA
#define	EEPROM_IQK_LCK_8703B					0xBB
#define	EEPROM_2G_5G_PA_TYPE_8703B			0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8703B	0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8703B	0xBF

#define	EEPROM_RF_BOARD_OPTION_8703B		0xC1
#define	EEPROM_FEATURE_OPTION_8703B			0xC2
#define	EEPROM_RF_BT_SETTING_8703B			0xC3
#define	EEPROM_VERSION_8703B					0xC4
#define	EEPROM_CustomID_8703B					0xC5
#define	EEPROM_TX_BBSWING_2G_8703B			0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8703B	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8703B		0xC9
#define	EEPROM_RFE_OPTION_8703B				0xCA
#define EEPROM_COUNTRY_CODE_8703B			0xCB

/* RTL8703BU */
#define EEPROM_MAC_ADDR_8703BU                          0x107
#define EEPROM_VID_8703BU                               0x100
#define EEPROM_PID_8703BU                               0x102
#define EEPROM_USB_OPTIONAL_FUNCTION0_8703BU            0x104
#define EEPROM_PA_TYPE_8703BU                           0xBC
#define EEPROM_LNA_TYPE_2G_8703BU                       0xBD

/* RTL8703BS */
#define	EEPROM_MAC_ADDR_8703BS				0x11A
#define	EEPROM_Voltage_ADDR_8703B			0x8

/*
 * ====================================================
 *	EEPROM/Efuse PG Offset for 8822B
 * ====================================================
 */
#define	EEPROM_ChannelPlan_8822B		0xB8
#define	EEPROM_XTAL_8822B			0xB9
#define	EEPROM_THERMAL_METER_8822B		0xBA
#define	EEPROM_IQK_LCK_8822B			0xBB
#define	EEPROM_2G_5G_PA_TYPE_8822B		0xBC
/* PATH A & PATH B */
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_AB_8822B	0xBD
/* PATH C & PATH D */
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_CD_8822B	0xBE
/* PATH A & PATH B */
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_AB_8822B	0xBF
/* PATH C & PATH D */
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_CD_8822B	0xC0

#define	EEPROM_RF_BOARD_OPTION_8822B		0xC1
#define	EEPROM_FEATURE_OPTION_8822B		0xC2
#define	EEPROM_RF_BT_SETTING_8822B		0xC3
#define	EEPROM_VERSION_8822B			0xC4
#define	EEPROM_CustomID_8822B			0xC5
#define	EEPROM_TX_BBSWING_2G_8822B		0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8822B	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8822B		0xC9
#define	EEPROM_RFE_OPTION_8822B			0xCA
#define EEPROM_COUNTRY_CODE_8822B		0xCB

/* RTL8822BU */
#define EEPROM_MAC_ADDR_8822BU			0x107
#define EEPROM_VID_8822BU			0x100
#define EEPROM_PID_8822BU			0x102
#define EEPROM_USB_OPTIONAL_FUNCTION0_8822BU	0x104
#define EEPROM_USB_MODE_8822BU			0x06

/* RTL8822BS */
#define	EEPROM_MAC_ADDR_8822BS			0x11A

/* RTL8822BE */
#define	EEPROM_MAC_ADDR_8822BE			0xD0
/*
 * ====================================================
 *	EEPROM/Efuse PG Offset for 8821C
 * ====================================================
 */
#define	EEPROM_CHANNEL_PLAN_8821C		0xB8
#define	EEPROM_XTAL_8821C			0xB9
#define	EEPROM_THERMAL_METER_8821C		0xBA
#define	EEPROM_IQK_LCK_8821C			0xBB
#define	EEPROM_2G_5G_PA_TYPE_8821C		0xBC
/* PATH A & PATH B */
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_AB_8821C	0xBD
/* PATH C & PATH D */
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_CD_8821C	0xBE
/* PATH A & PATH B */
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_AB_8821C	0xBF
/* PATH C & PATH D */
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_CD_8821C	0xC0

#define	EEPROM_RF_BOARD_OPTION_8821C		0xC1
#define	EEPROM_FEATURE_OPTION_8821C		0xC2
#define	EEPROM_RF_BT_SETTING_8821C		0xC3
#define	EEPROM_VERSION_8821C			0xC4
#define	EEPROM_CUSTOMER_ID_8821C			0xC5
#define	EEPROM_TX_BBSWING_2G_8821C		0xC6
#define	EEPROM_TX_BBSWING_5G_8821C		0xC7
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8821C	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8821C		0xC9
#define	EEPROM_RFE_OPTION_8821C			0xCA
#define EEPROM_COUNTRY_CODE_8821C		0xCB

/* RTL8821CU */
#define EEPROM_MAC_ADDR_8821CU			0x107
#define EEPROM_VID_8821CU					0x100
#define EEPROM_PID_8821CU					0x102
#define EEPROM_USB_OPTIONAL_FUNCTION0_8821CU	0x104
#define EEPROM_USB_MODE_8821CU			0x06

/* RTL8821CS */
#define	EEPROM_MAC_ADDR_8821CS			0x11A

/* RTL8821CE */
#define	EEPROM_MAC_ADDR_8821CE			0xD0
/* ****************************************************
 *	EEPROM/Efuse PG Offset for 8723D
 * **************************************************** */
#define GET_PG_KFREE_ON_8723D(_pg_m)	\
	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
#define GET_PG_KFREE_THERMAL_K_ON_8723D(_pg_m)	\
	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)

#define PPG_8723D_S1	0
#define PPG_8723D_S0	1

#define PPG_BB_GAIN_2G_TXA_OFFSET_8723D		0xEE
#define PPG_BB_GAIN_2G_TX_OFFSET_8723D		0x1EE
#define PPG_THERMAL_OFFSET_8723D		0xEF

#define	EEPROM_ChannelPlan_8723D		0xB8
#define	EEPROM_XTAL_8723D			0xB9
#define	EEPROM_THERMAL_METER_8723D		0xBA
#define	EEPROM_IQK_LCK_8723D			0xBB
#define	EEPROM_2G_5G_PA_TYPE_8723D		0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8723D	0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8723D	0xBF

#define	EEPROM_RF_BOARD_OPTION_8723D		0xC1
#define	EEPROM_FEATURE_OPTION_8723D		0xC2
#define	EEPROM_RF_BT_SETTING_8723D		0xC3
#define	EEPROM_VERSION_8723D			0xC4
#define	EEPROM_CustomID_8723D			0xC5
#define	EEPROM_TX_BBSWING_2G_8723D		0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8723D	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8723D		0xC9
#define	EEPROM_RFE_OPTION_8723D			0xCA
#define EEPROM_COUNTRY_CODE_8723D		0xCB

/* RTL8723DE */
#define EEPROM_MAC_ADDR_8723DE              0xD0
#define EEPROM_VID_8723DE                   0xD6
#define EEPROM_DID_8723DE                   0xD8
#define EEPROM_SVID_8723DE                  0xDA
#define EEPROM_SMID_8723DE                  0xDC

/* RTL8723DU */
#define EEPROM_MAC_ADDR_8723DU                  0x107
#define EEPROM_VID_8723DU                       0x100
#define EEPROM_PID_8723DU                       0x102
#define EEPROM_USB_OPTIONAL_FUNCTION0_8723DU    0x104

/* RTL8723BS */
#define	EEPROM_MAC_ADDR_8723DS			0x11A
#define	EEPROM_Voltage_ADDR_8723D		0x8

/*
 * ====================================================
 *	EEPROM/Efuse PG Offset for 8822C
 * ====================================================
 */
#define	EEPROM_TX_PWR_INX_8822C			0x10
#define	EEPROM_ChannelPlan_8822C		0xB8
#define	EEPROM_XTAL_8822C			0xB9
#define	EEPROM_IQK_LCK_8822C			0xBB
#define	EEPROM_2G_5G_PA_TYPE_8822C		0xBC
/* PATH A & PATH B */
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_AB_8822C	0xBD
/* PATH C & PATH D */
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_CD_8822C	0xBE
/* PATH A & PATH B */
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_AB_8822C	0xBF
/* PATH C & PATH D */
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_CD_8822C	0xC0

#define	EEPROM_RF_BOARD_OPTION_8822C		0xC1
#define	EEPROM_FEATURE_OPTION_8822C		0xC2
#define	EEPROM_RF_BT_SETTING_8822C		0xC3
#define	EEPROM_VERSION_8822C			0xC4
#define	EEPROM_CustomID_8822C			0xC5
#define	EEPROM_TX_BBSWING_2G_8822C		0xC6
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8822C	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8822C		0xC9
#define	EEPROM_RFE_OPTION_8822C			0xCA
#define EEPROM_COUNTRY_CODE_8822C		0xCB
#define	EEPROM_THERMAL_METER_A_8822C		0xD0
#define	EEPROM_THERMAL_METER_B_8822C		0xD1
/* RTL8822CU */
#define EEPROM_MAC_ADDR_8822CU			0x157
#define EEPROM_VID_8822CU			0x100
#define EEPROM_PID_8822CU			0x102
#define EEPROM_USB_OPTIONAL_FUNCTION0_8822CU	0x104
#define EEPROM_USB_MODE_8822CU			0x06

/* RTL8822CS */
#define	EEPROM_MAC_ADDR_8822CS			0x16A

/* RTL8822CE */
#define	EEPROM_MAC_ADDR_8822CE			0x120

/* ****************************************************
 *	EEPROM/Efuse PG Offset for 8192F
 * **************************************************** */
#define	EEPROM_ChannelPlan_8192F			0xB8
#define	EEPROM_XTAL_8192F					0xB9
#define	EEPROM_THERMAL_METER_8192F			0xBA
#define	EEPROM_IQK_LCK_8192F				0xBB
#define	EEPROM_2G_5G_PA_TYPE_8192F			0xBC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8192F	0xBD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8192F	0xBF

#define	EEPROM_RF_BOARD_OPTION_8192F		0xC1
#define	EEPROM_FEATURE_OPTION_8192F			0xC2
#define	EEPROM_RF_BT_SETTING_8192F			0xC3
#define	EEPROM_VERSION_8192F				0xC4
#define	EEPROM_CustomID_8192F				0xC5
#define	EEPROM_TX_BBSWING_2G_8192F			0xC6
#define	EEPROM_TX_BBSWING_5G_8192F			0xC7
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8192F	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8192F			0xC9
#define	EEPROM_RFE_OPTION_8192F				0xCA
#define EEPROM_COUNTRY_CODE_8192F			0xCB
/*RTL8192FS*/
#define	EEPROM_MAC_ADDR_8192FS				0x11A
#define EEPROM_Voltage_ADDR_8192F			0x8
/* RTL8192FU */
#define EEPROM_MAC_ADDR_8192FU					0x107
#define EEPROM_VID_8192FU							0x100
#define EEPROM_PID_8192FU							0x102
#define EEPROM_USB_OPTIONAL_FUNCTION0_8192FU	0x104
/* RTL8192FE */
#define EEPROM_MAC_ADDR_8192FE					0xD0
#define EEPROM_VID_8192FE							0xD6
#define EEPROM_DID_8192FE							0xD8
#define EEPROM_SVID_8192FE							0xDA
#define EEPROM_SMID_8192FE						0xDC

/* ****************************************************
 *	EEPROM/Efuse PG Offset for 8710B
 * **************************************************** */
#define RTL_EEPROM_ID_8710B 					0x8195
#define EEPROM_Default_ThermalMeter_8710B		0x1A

#define	EEPROM_CHANNEL_PLAN_8710B			0xC8
#define	EEPROM_XTAL_8710B					0xC9
#define	EEPROM_THERMAL_METER_8710B			0xCA
#define	EEPROM_IQK_LCK_8710B					0xCB
#define	EEPROM_2G_5G_PA_TYPE_8710B			0xCC
#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8710B	0xCD
#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8710B	0xCF
#define 	EEPROM_TX_KFREE_8710B				0xEE    //Physical  Efuse Address
#define 	EEPROM_THERMAL_8710B				0xEF    //Physical  Efuse Address
#define 	EEPROM_PACKAGE_TYPE_8710B			0xF8    //Physical  Efuse Address

#define EEPROM_RF_BOARD_OPTION_8710B		0x131
#define EEPROM_RF_FEATURE_OPTION_8710B		0x132
#define EEPROM_RF_BT_SETTING_8710B			0x133
#define EEPROM_VERSION_8710B					0x134
#define EEPROM_CUSTOM_ID_8710B				0x135
#define EEPROM_TX_BBSWING_2G_8710B			0x136
#define EEPROM_TX_BBSWING_5G_8710B			0x137
#define EEPROM_TX_PWR_CALIBRATE_RATE_8710B	0x138
#define EEPROM_RF_ANTENNA_OPT_8710B			0x139
#define EEPROM_RFE_OPTION_8710B				0x13A
#define EEPROM_COUNTRY_CODE_8710B			0x13B
#define EEPROM_COUNTRY_CODE_2_8710B			0x13C

#define EEPROM_MAC_ADDR_8710B 				0x11A
#define EEPROM_VID_8710BU						0x1C0
#define EEPROM_PID_8710BU						0x1C2

/* ****************************************************
 *	EEPROM/Efuse PG Offset for 8814B
 * **************************************************** */

#define	EEPROM_USB_MODE_8814BU			0x06
/* 0x10 ~ 0x63 = TX power area. */
#define	EEPROM_TX_PWR_INX_8814B			0x10
#define	EEPROM_ChannelPlan_8814B		0xB8
#define	EEPROM_XTAL_8814B			0xB9
#define	EEPROM_THERMAL_METER_8814B		0xBA
#define	EEPROM_IQK_LCK_8814B			0xBB

#define EEPROM_PA_TYPE_8814B			0xBC
#define EEPROM_LNA_TYPE_AB_2G_8814B		0xBD
#define	EEPROM_LNA_TYPE_CD_2G_8814B		0xBE
#define EEPROM_LNA_TYPE_AB_5G_8814B		0xBF
#define EEPROM_LNA_TYPE_CD_5G_8814B		0xC0
#define	EEPROM_RF_BOARD_OPTION_8814B		0xC1
#define	EEPROM_RF_FEATURE_OPTION_8814B		0xC2
#define	EEPROM_RF_BT_SETTING_8814B		0xC3
#define	EEPROM_VERSION_8814B			0xC4
#define	EEPROM_CustomID_8814B			0xC5
#define	EEPROM_TX_BBSWING_2G_8814B		0xC6
#define	EEPROM_TX_BBSWING_5G_8814B		0xC7
#define	EEPROM_TX_PWR_CALIBRATE_RATE_8814B	0xC8
#define	EEPROM_RF_ANTENNA_OPT_8814B		0xC9
#define	EEPROM_RFE_OPTION_8814B			0xCA
#define	EEPROM_COUNTRY_CODE_8814B		0xCB

#define	EEPROM_MAC_ADDR_8814BE			0x120
#define	EEPROM_VID_8814B			0x126
#define	EEPROM_DID_8814B			0x128
#define	EEPROM_SVID_8814B			0x12A
#define	EEPROM_SMID_8814B			0x12C

/* RTL8814BU */
#define EEPROM_MAC_ADDR_8814BU			0x157
#define EEPROM_VID_8814BU			0x150
#define EEPROM_PID_8814BU			0x152
#define EEPROM_USB_OPTIONAL_FUNCTION0_8814BU	0x154

/* ****************************************************
 *			EEPROM/Efuse Value Type
 * **************************************************** */
#define EETYPE_TX_PWR							0x0
#define EETYPE_MAX_RFE_8192F					0x31
/* ****************************************************
 *			EEPROM/Efuse Default Value
 * **************************************************** */
#define EEPROM_CID_DEFAULT					0x0
#define EEPROM_CID_DEFAULT_EXT				0xFF /* Reserved for Realtek */
#define EEPROM_CID_TOSHIBA						0x4
#define EEPROM_CID_CCX							0x10
#define EEPROM_CID_QMI							0x0D
#define EEPROM_CID_WHQL						0xFE

#define EEPROM_CHANNEL_PLAN_FCC				0x0
#define EEPROM_CHANNEL_PLAN_IC				0x1
#define EEPROM_CHANNEL_PLAN_ETSI				0x2
#define EEPROM_CHANNEL_PLAN_SPAIN			0x3
#define EEPROM_CHANNEL_PLAN_FRANCE			0x4
#define EEPROM_CHANNEL_PLAN_MKK				0x5
#define EEPROM_CHANNEL_PLAN_MKK1				0x6
#define EEPROM_CHANNEL_PLAN_ISRAEL			0x7
#define EEPROM_CHANNEL_PLAN_TELEC			0x8
#define EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
#define EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
#define EEPROM_CHANNEL_PLAN_NCC_TAIWAN		0xB
#define EEPROM_CHANNEL_PLAN_CHIAN			0XC
#define EEPROM_CHANNEL_PLAN_SINGAPORE_INDIA_MEXICO  0XD
#define EEPROM_CHANNEL_PLAN_KOREA			0xE
#define EEPROM_CHANNEL_PLAN_TURKEY	0xF
#define EEPROM_CHANNEL_PLAN_JAPAN	0x10
#define EEPROM_CHANNEL_PLAN_FCC_NO_DFS		0x11
#define EEPROM_CHANNEL_PLAN_JAPAN_NO_DFS	0x12
#define EEPROM_CHANNEL_PLAN_WORLD_WIDE_5G	0x13
#define EEPROM_CHANNEL_PLAN_TAIWAN_NO_DFS	0x14

#define EEPROM_USB_OPTIONAL1					0xE
#define EEPROM_CHANNEL_PLAN_BY_HW_MASK		0x80

#define RTL_EEPROM_ID							0x8129
#define EEPROM_Default_TSSI						0x0
#define EEPROM_Default_BoardType				0x02
#define EEPROM_Default_ThermalMeter			0x12
#define EEPROM_Default_ThermalMeter_92SU		0x7
#define EEPROM_Default_ThermalMeter_88E		0x18
#define EEPROM_Default_ThermalMeter_8812		0x18
#define	EEPROM_Default_ThermalMeter_8192E			0x1A
#define	EEPROM_Default_ThermalMeter_8723B		0x18
#define	EEPROM_Default_ThermalMeter_8703B		0x18
#define	EEPROM_Default_ThermalMeter_8723D		0x18
#define	EEPROM_Default_ThermalMeter_8188F		0x18
#define	EEPROM_Default_ThermalMeter_8188GTV		0x18
#define EEPROM_Default_ThermalMeter_8814A		0x18
#define	EEPROM_Default_ThermalMeter_8192F		0x1A

#define EEPROM_Default_CrystalCap				0x0
#define EEPROM_Default_CrystalCap_8723A		0x20
#define EEPROM_Default_CrystalCap_88E			0x20
#define EEPROM_Default_CrystalCap_8812			0x20
#define EEPROM_Default_CrystalCap_8814			0x20
#define EEPROM_Default_CrystalCap_8192E			0x20
#define EEPROM_Default_CrystalCap_8723B			0x20
#define EEPROM_Default_CrystalCap_8703B			0x20
#define EEPROM_Default_CrystalCap_8723D			0x20
#define EEPROM_Default_CrystalCap_8188F			0x20
#define EEPROM_Default_CrystalCap_8188GTV		0x20
#define EEPROM_Default_CrystalCap_8192F			0x20
#define EEPROM_Default_CrystalCap_8822C			0x3F
#define EEPROM_Default_CrystalCap_8814B			0x40
#define EEPROM_Default_CrystalFreq				0x0
#define EEPROM_Default_TxPowerLevel_92C		0x22
#define EEPROM_Default_TxPowerLevel_2G			0x2C
#define EEPROM_Default_TxPowerLevel_5G			0x22
#define EEPROM_Default_TxPowerLevel			0x22
#define EEPROM_Default_HT40_2SDiff				0x0
#define EEPROM_Default_HT20_Diff				2
#define EEPROM_Default_LegacyHTTxPowerDiff		0x3
#define EEPROM_Default_LegacyHTTxPowerDiff_92C	0x3
#define EEPROM_Default_LegacyHTTxPowerDiff_92D	0x4
#define EEPROM_Default_HT40_PwrMaxOffset		0
#define EEPROM_Default_HT20_PwrMaxOffset		0

#define EEPROM_Default_PID						0x1234
#define EEPROM_Default_VID						0x5678
#define EEPROM_Default_CustomerID				0xAB
#define EEPROM_Default_CustomerID_8188E		0x00
#define EEPROM_Default_SubCustomerID			0xCD
#define EEPROM_Default_Version					0

#define EEPROM_Default_externalPA_C9		0x00
#define EEPROM_Default_externalPA_CC		0xFF
#define EEPROM_Default_internalPA_SP3T_C9	0xAA
#define EEPROM_Default_internalPA_SP3T_CC	0xAF
#define EEPROM_Default_internalPA_SPDT_C9	0xAA
#ifdef CONFIG_PCI_HCI
	#define EEPROM_Default_internalPA_SPDT_CC	0xA0
#else
	#define EEPROM_Default_internalPA_SPDT_CC	0xFA
#endif
#define EEPROM_Default_PAType						0
#define EEPROM_Default_LNAType						0

/* New EFUSE default value */
#define EEPROM_DEFAULT_CHANNEL_PLAN		0x7F
#define EEPROM_DEFAULT_BOARD_OPTION		0x00
#define EEPROM_DEFAULT_RFE_OPTION_8192E 0xFF
#define EEPROM_DEFAULT_RFE_OPTION_8188E 0xFF
#define EEPROM_DEFAULT_RFE_OPTION		0x04
#define EEPROM_DEFAULT_FEATURE_OPTION	0x00
#define EEPROM_DEFAULT_BT_OPTION			0x10


#define EEPROM_DEFAULT_TX_CALIBRATE_RATE	0x00

/* PCIe related */
#define	EEPROM_PCIE_DEV_CAP_01				0xE0 /* Express device capability in PCIe configuration space, i.e., map to offset 0x74 */
#define	EEPROM_PCIE_DEV_CAP_02				0xE1 /* Express device capability in PCIe configuration space, i.e., map to offset 0x75 */


/*
 * For VHT series TX power by rate table.
 * VHT TX power by rate off setArray =
 * Band:-2G&5G = 0 / 1
 * RF: at most 4*4 = ABCD=0/1/2/3
 * CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
 *   */
#define TX_PWR_BY_RATE_NUM_BAND			2
#define TX_PWR_BY_RATE_NUM_RF			4
#define TX_PWR_BY_RATE_NUM_RATE			84

#define TXPWR_LMT_MAX_RF				4

/* ----------------------------------------------------------------------------
 * EEPROM/EFUSE data structure definition.
 * ---------------------------------------------------------------------------- */

/* For 88E new structure */

/*
2.4G:
{
{1,2},
{3,4,5},
{6,7,8},
{9,10,11},
{12,13},
{14}
}

5G:
{
{36,38,40},
{44,46,48},
{52,54,56},
{60,62,64},
{100,102,104},
{108,110,112},
{116,118,120},
{124,126,128},
{132,134,136},
{140,142,144},
{149,151,153},
{157,159,161},
{173,175,177},
}
*/
#define	MAX_RF_PATH				4
#define RF_PATH_MAX				MAX_RF_PATH
#define	MAX_CHNL_GROUP_24G		6
#define	MAX_CHNL_GROUP_5G		14

/* It must always set to 4, otherwise read efuse table sequence will be wrong. */
#define	MAX_TX_COUNT				4

typedef	enum _BT_Ant_NUM {
	Ant_x2	= 0,
	Ant_x1	= 1
} BT_Ant_NUM, *PBT_Ant_NUM;

typedef	enum _BT_CoType {
	BT_2WIRE		= 0,
	BT_ISSC_3WIRE	= 1,
	BT_ACCEL		= 2,
	BT_CSR_BC4		= 3,
	BT_CSR_BC8		= 4,
	BT_RTL8756		= 5,
	BT_RTL8723A		= 6,
	BT_RTL8821		= 7,
	BT_RTL8723B		= 8,
	BT_RTL8192E		= 9,
	BT_RTL8814A		= 10,
	BT_RTL8812A		= 11,
	BT_RTL8703B		= 12,
	BT_RTL8822B		= 13,
	BT_RTL8723D		= 14,
	BT_RTL8821C		= 15,
	BT_RTL8192F		= 16,
	BT_RTL8822C		= 17,
	BT_RTL8814B		= 18,
} BT_CoType, *PBT_CoType;

typedef	enum _BT_RadioShared {
	BT_Radio_Shared	= 0,
	BT_Radio_Individual	= 1,
} BT_RadioShared, *PBT_RadioShared;


#endif
                                                                                                                                                                                                                     rtl8822bu/src/include/rtw_sreset.h                                                                  0000644 0001750 0001750 00000003503 14214766567 015777  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_SRESET_H_
#define _RTW_SRESET_H_

/* #include <drv_types.h> */

enum {
	SRESET_TGP_NULL = 0,
	SRESET_TGP_XMIT_STATUS = 1,
	SRESET_TGP_LINK_STATUS = 2,
	SRESET_TGP_INFO = 99,
};

struct sreset_priv {
	_mutex	silentreset_mutex;
	u8	silent_reset_inprogress;
	u8	Wifi_Error_Status;
	systime last_tx_time;
	systime last_tx_complete_time;

	s32 dbg_trigger_point;
	u64 self_dect_tx_cnt;
	u64 self_dect_rx_cnt;
	u64 self_dect_fw_cnt;
	u64 tx_dma_status_cnt;
	u64 rx_dma_status_cnt;
	u8 rx_cnt;
	u8 self_dect_fw;
	u8 self_dect_case;
	u16 last_mac_rxff_ptr;
	u8 dbg_sreset_ctrl;
};



#define	WIFI_STATUS_SUCCESS		0
#define	USB_VEN_REQ_CMD_FAIL	BIT0
#define	USB_READ_PORT_FAIL		BIT1
#define	USB_WRITE_PORT_FAIL		BIT2
#define	WIFI_MAC_TXDMA_ERROR	BIT3
#define   WIFI_TX_HANG				BIT4
#define	WIFI_RX_HANG				BIT5
#define	WIFI_IF_NOT_EXIST			BIT6

void sreset_init_value(_adapter *padapter);
void sreset_reset_value(_adapter *padapter);
u8 sreset_get_wifi_status(_adapter *padapter);
void sreset_set_wifi_error_status(_adapter *padapter, u32 status);
void sreset_set_trigger_point(_adapter *padapter, s32 tgp);
bool sreset_inprogress(_adapter *padapter);
void sreset_reset(_adapter *padapter);

#endif
                                                                                                                                                                                             rtl8822bu/src/include/rtl8192e_dm.h                                                                 0000644 0001750 0001750 00000002017 14214766567 015547  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_DM_H__
#define __RTL8192E_DM_H__


void rtl8192e_init_dm_priv(PADAPTER Adapter);
void rtl8192e_deinit_dm_priv(PADAPTER Adapter);
void rtl8192e_InitHalDm(PADAPTER Adapter);
void rtl8192e_HalDmWatchDog(PADAPTER Adapter);

/* void rtl8192c_dm_CheckTXPowerTracking(PADAPTER Adapter); */

/* void rtl8192c_dm_RF_Saving(PADAPTER pAdapter, u8 bForceInNormal); */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/hal_sdio.h                                                                    0000644 0001750 0001750 00000007414 14214766567 015365  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_SDIO_H_
#define __HAL_SDIO_H_

#define ffaddr2deviceId(pdvobj, addr)	(pdvobj->Queue2Pipe[addr])

#ifndef RTW_HALMAC
extern const char *_sdio_tx_queue_str[];
#define sdio_tx_queue_str(_page_idx) (_page_idx >= SDIO_MAX_TX_QUEUE ? "UNKNOWN" : _sdio_tx_queue_str[_page_idx])
#endif

u8 rtw_hal_sdio_max_txoqt_free_space(_adapter *padapter);
u8 rtw_hal_sdio_query_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
void rtw_hal_sdio_update_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
void rtw_hal_set_sdio_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ, u8 div_num);
u32 rtw_hal_get_sdio_tx_max_length(PADAPTER padapter, u8 queue_idx);
bool sdio_power_on_check(PADAPTER padapter);

#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT
#if defined(CONFIG_RTL8188F) || defined(CONFIG_RTL8821A)
void rtw_hal_sdio_avail_page_threshold_init(_adapter *adapter);
void rtw_hal_sdio_avail_page_threshold_en(_adapter *adapter, u8 qidx);
#endif
#endif /* CONFIG_SDIO_TX_ENABLE_AVAL_INT */

#ifdef CONFIG_FW_C2H_REG
void sd_c2h_hisr_hdl(_adapter *adapter);
#endif

#if defined(CONFIG_RTL8188F) || defined (CONFIG_RTL8188GTV) || defined (CONFIG_RTL8192F)
#define SDIO_LOCAL_CMD_ADDR(addr) ((SDIO_LOCAL_DEVICE_ID << 13) | ((addr) & SDIO_LOCAL_MSK))
#endif

#ifdef CONFIG_SDIO_CHK_HCI_RESUME
bool sdio_chk_hci_resume(struct intf_hdl *pintfhdl);
void sdio_chk_hci_suspend(struct intf_hdl *pintfhdl);
#else
#define sdio_chk_hci_resume(pintfhdl) _FALSE
#define sdio_chk_hci_suspend(pintfhdl) do {} while (0)
#endif /* CONFIG_SDIO_CHK_HCI_RESUME */

#ifdef CONFIG_SDIO_INDIRECT_ACCESS
/* program indirect access register in sdio local to read/write page0 registers */
s32 sdio_iread(PADAPTER padapter, u32 addr, u8 size, u8 *v);
s32 sdio_iwrite(PADAPTER padapter, u32 addr, u8 size, u8 *v);
u8 sdio_iread8(struct intf_hdl *pintfhdl, u32 addr);
u16 sdio_iread16(struct intf_hdl *pintfhdl, u32 addr);
u32 sdio_iread32(struct intf_hdl *pintfhdl, u32 addr);
s32 sdio_iwrite8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
s32 sdio_iwrite16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
s32 sdio_iwrite32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
u32 cmd53_4byte_alignment(struct intf_hdl *pintfhdl, u32 addr);

#ifndef CONFIG_SDIO_TX_TASKLET
#ifdef SDIO_FREE_XMIT_BUF_SEMA
void _rtw_sdio_free_xmitbuf_sema_up(struct xmit_priv *xmit);
void _rtw_sdio_free_xmitbuf_sema_down(struct xmit_priv *xmit);
#ifdef DBG_SDIO_FREE_XMIT_BUF_SEMA
void dbg_rtw_sdio_free_xmitbuf_sema_up(struct xmit_priv *xmit, const char *caller);
void dbg_rtw_sdio_free_xmitbuf_sema_down(struct xmit_priv *xmit, const char *caller);
#define rtw_sdio_free_xmitbuf_sema_up(_xmit) dbg_rtw_sdio_free_xmitbuf_sema_up(_xmit, __func__)
#define rtw_sdio_free_xmitbuf_sema_down(_xmit) dbg_rtw_sdio_free_xmitbuf_sema_down(_xmit, __func__)
#else
#define rtw_sdio_free_xmitbuf_sema_up(_xmit) _rtw_sdio_free_xmitbuf_sema_up(_xmit)
#define rtw_sdio_free_xmitbuf_sema_down(_xmit) _rtw_sdio_free_xmitbuf_sema_down(_xmit)
#endif /* DBG_SDIO_FREE_XMIT_BUF_SEMA */
#endif /* SDIO_FREE_XMIT_BUF_SEMA */
#endif /* !CONFIG_SDIO_TX_TASKLET */

#endif /* __HAL_SDIO_H_ */
                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtl8812a_cmd.h                                                                0000644 0001750 0001750 00000015651 14214766567 015715  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_CMD_H__
#define __RTL8812A_CMD_H__

typedef enum _RTL8812_H2C_CMD {
	H2C_8812_RSVDPAGE = 0,
	H2C_8812_MSRRPT = 1,
	H2C_8812_SCAN = 2,
	H2C_8812_KEEP_ALIVE_CTRL = 3,
	H2C_8812_DISCONNECT_DECISION = 4,

	H2C_8812_INIT_OFFLOAD = 6,
	H2C_8812_AP_OFFLOAD = 8,
	H2C_8812_BCN_RSVDPAGE = 9,
	H2C_8812_PROBERSP_RSVDPAGE = 10,

	H2C_8812_SETPWRMODE = 0x20,
	H2C_8812_PS_TUNING_PARA = 0x21,
	H2C_8812_PS_TUNING_PARA2 = 0x22,
	H2C_8812_PS_LPS_PARA = 0x23,
	H2C_8812_P2P_PS_OFFLOAD = 0x24,
	H2C_8812_INACTIVE_PS = 0x27,
	H2C_8812_RA_MASK = 0x40,
	H2C_8812_TxBF = 0x41,
	H2C_8812_RSSI_REPORT = 0x42,
	H2C_8812_IQ_CALIBRATION = 0x45,
	H2C_8812_RA_PARA_ADJUST = 0x46,

	H2C_8812_BT_FW_PATCH = 0x6a,

	H2C_8812_WO_WLAN = 0x80,
	H2C_8812_REMOTE_WAKE_CTRL = 0x81,
	H2C_8812_AOAC_GLOBAL_INFO = 0x82,
	H2C_8812_AOAC_RSVDPAGE = 0x83,
	H2C_8812_FW_SWCHANNL = 0x87,

	H2C_8812_TSF_RESET = 0xC0,

	MAX_8812_H2CCMD
} RTL8812_H2C_CMD;

struct cmd_msg_parm {
	u8 eid; /* element id */
	u8 sz; /* sz */
	u8 buf[6];
};

enum {
	PWRS
};

struct H2C_SS_RFOFF_PARAM {
	u8 ROFOn; /* 1: on, 0:off */
	u16 gpio_period; /* unit: 1024 us */
} __attribute__((packed));



/* _RSVDPAGE_LOC_CMD0 */
#define SET_8812_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8812_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8812_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8812_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8812_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _SETPWRMODE_PARM */
#define SET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8812_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8812_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8812_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8812_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8812_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8812_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)							LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _P2P_PS_OFFLOAD */
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)


void	set_ra_ldpc_8812(struct cmn_sta_info *cmn_sta_info, BOOLEAN bLDPC);

/* host message to firmware cmd */
s32 fill_h2c_cmd_8812(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
void rtl8812_set_FwPwrMode_cmd(PADAPTER padapter, u8 PSMode);
void rtl8812_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
u8 rtl8812_set_rssi_cmd(PADAPTER padapter, u8 *param);
void rtl8812_set_wowlan_cmd(_adapter *padapter, u8 enable);
u8 GetTxBufferRsvdPageNum8812(_adapter *padapter, bool wowlan);

#ifdef CONFIG_BT_COEXIST
void rtl8812a_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P_PS
void rtl8812_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_FWLPS_IN_IPS
void rtl8812_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);
#endif

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
void rtl8812_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
#endif
#endif

/* ------------------------------------
 * C2H format
 * ------------------------------------ */

/* TX Beamforming */
#define GET_8812_C2H_TXBF_ORIGINATE(_Header)			LE_BITS_TO_1BYTE(_Header, 0, 8)
#define GET_8812_C2H_TXBF_MACID(_Header)				LE_BITS_TO_1BYTE((_Header + 1), 0, 8)



/* / TX Feedback Content */
#define	USEC_UNIT_FOR_8812_C2H_TX_RPT_QUEUE_TIME			256

#define	GET_8812_C2H_TX_RPT_QUEUE_SELECT(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 5)
#define	GET_8812_C2H_TX_RPT_PKT_BROCAST(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 5, 1)
#define	GET_8812_C2H_TX_RPT_LIFE_TIME_OVER(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 6, 1)
#define	GET_8812_C2H_TX_RPT_RETRY_OVER(_Header)				LE_BITS_TO_1BYTE((_Header + 0), 7, 1)
#define	GET_8812_C2H_TX_RPT_MAC_ID(_Header)					LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
#define	GET_8812_C2H_TX_RPT_DATA_RETRY_CNT(_Header)		LE_BITS_TO_1BYTE((_Header + 2), 0, 6)
#define	GET_8812_C2H_TX_RPT_QUEUE_TIME(_Header)				LE_BITS_TO_2BYTE((_Header + 3), 0, 16)	/* In unit of 256 microseconds. */
#define	GET_8812_C2H_TX_RPT_FINAL_DATA_RATE(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)

/* BT_FW_PATCH */
#define SET_8812_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((u8 *)(__pH2CCmd)+2, 0, 8, __Value)
#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((u8 *)(__pH2CCmd)+3, 0, 8, __Value)
#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((u8 *)(__pH2CCmd)+4, 0, 8, __Value)
#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((u8 *)(__pH2CCmd)+5, 0, 8, __Value)

s32 c2h_handler_8812a(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);

#endif/* __RTL8812A_CMD_H__ */
                                                                                       rtl8822bu/src/include/rtl8723d_sreset.h                                                             0000644 0001750 0001750 00000001631 14214766567 016454  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8723D_SRESET_H_
#define _RTL8723D_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8723d_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8723d_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                       rtl8822bu/src/include/rtw_ht.h                                                                      0000644 0001750 0001750 00000030055 14214766567 015107  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_HT_H_
#define _RTW_HT_H_

#define HT_CAP_IE_LEN 26
#define HT_OP_IE_LEN 22

struct ht_priv {
	u8	ht_option;
	u8	ampdu_enable;/* for enable Tx A-MPDU */
	u8	tx_amsdu_enable;/* for enable Tx A-MSDU */
	u8	bss_coexist;/* for 20/40 Bss coexist */

	/* u8	baddbareq_issued[16]; */
	u32	tx_amsdu_maxlen; /* 1: 8k, 0:4k ; default:8k, for tx */
	u32	rx_ampdu_maxlen; /* for rx reordering ctrl win_sz, updated when join_callback. */

	u8	rx_ampdu_min_spacing;

	u8	ch_offset;/* PRIME_CHNL_OFFSET */
	u8	sgi_20m;
	u8	sgi_40m;

	/* for processing Tx A-MPDU */
	u8	agg_enable_bitmap;
	/* u8	ADDBA_retry_count; */
	u8	candidate_tid_bitmap;

	u8	ldpc_cap;
	u8	stbc_cap;
	u8	beamform_cap;
	u8	smps_cap; /*spatial multiplexing power save mode. 0:static SMPS, 1:dynamic SMPS, 3:SMPS disabled, 2:reserved*/

	u8 op_present:1; /* ht_op is present */

	struct rtw_ieee80211_ht_cap ht_cap;
	u8 ht_op[HT_OP_IE_LEN];

};

#ifdef ROKU_PRIVATE
struct ht_priv_infra_ap {

	/*Infra mode, only store AP's info , not intersection of STA and AP*/
	u8	channel_width_infra_ap;
	u8	sgi_20m_infra_ap;
	u8	sgi_40m_infra_ap;
	u8	ldpc_cap_infra_ap;
	u8	stbc_cap_infra_ap;
	u8	MCS_set_infra_ap[16];
	u8	Rx_ss_infra_ap;
	u16	rx_highest_data_rate_infra_ap;
};
#endif /* ROKU_PRIVATE */

typedef enum AGGRE_SIZE {
	HT_AGG_SIZE_8K = 0,
	HT_AGG_SIZE_16K = 1,
	HT_AGG_SIZE_32K = 2,
	HT_AGG_SIZE_64K = 3,
	VHT_AGG_SIZE_128K = 4,
	VHT_AGG_SIZE_256K = 5,
	VHT_AGG_SIZE_512K = 6,
	VHT_AGG_SIZE_1024K = 7,
} AGGRE_SIZE_E, *PAGGRE_SIZE_E;

#define	LDPC_HT_ENABLE_RX			BIT0
#define	LDPC_HT_ENABLE_TX			BIT1
#define	LDPC_HT_TEST_TX_ENABLE		BIT2
#define	LDPC_HT_CAP_TX				BIT3

#define	STBC_HT_ENABLE_RX			BIT0
#define	STBC_HT_ENABLE_TX			BIT1
#define	STBC_HT_TEST_TX_ENABLE		BIT2
#define	STBC_HT_CAP_TX				BIT3

/* ------------------------------------------------------------
 * The HT Control field
 * ------------------------------------------------------------ */
#define SET_HT_CTRL_CSI_STEERING(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+2, 6, 2, _val)
#define SET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+3, 0, 1, _val)
#define GET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+3, 0, 1)

/* 20/40 BSS Coexist */
#define SET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 1, _val)
#define GET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 1)

/* HT Capabilities Info field */
#define HT_CAP_ELE_CAP_INFO(_pEleStart)					((u8 *)(_pEleStart))
#define GET_HT_CAP_ELE_LDPC_CAP(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 1)
#define GET_HT_CAP_ELE_CHL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 1, 1)
#define GET_HT_CAP_ELE_SM_PS(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 2, 2)
#define GET_HT_CAP_ELE_GREENFIELD(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 4, 1)
#define GET_HT_CAP_ELE_SHORT_GI20M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 5, 1)
#define GET_HT_CAP_ELE_SHORT_GI40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 6, 1)
#define GET_HT_CAP_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 7, 1)
#define GET_HT_CAP_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 0, 2)
#define GET_HT_CAP_ELE_DELAYED_BA(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 2, 1)
#define GET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 3, 1)
#define GET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 4, 1)
#define GET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 6, 1)
#define GET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart)	LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 7, 1)

#define SET_HT_CAP_ELE_LDPC_CAP(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 1, _val)
#define SET_HT_CAP_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 1, 1, _val)
#define SET_HT_CAP_ELE_SM_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 2, 2, _val)
#define SET_HT_CAP_ELE_GREENFIELD(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 4, 1, _val)
#define SET_HT_CAP_ELE_SHORT_GI20M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 5, 1, _val)
#define SET_HT_CAP_ELE_SHORT_GI40M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 6, 1, _val)
#define SET_HT_CAP_ELE_TX_STBC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 7, 1, _val)
#define SET_HT_CAP_ELE_RX_STBC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2, _val)
#define SET_HT_CAP_ELE_DELAYED_BA(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1, _val)
#define SET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1, _val)
#define SET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 4, 1, _val)
#define SET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 6, 1, _val)
#define SET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 7, 1, _val)

/* A-MPDU Parameters field */
#define HT_CAP_ELE_AMPDU_PARA(_pEleStart)				(((u8 *)(_pEleStart))+2)
#define GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(_pEleStart)	LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+2, 0, 2)
#define GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+2, 2, 3)

#define HT_AMPDU_PARA_FMT "%02x " \
	"MAX AMPDU len:%u bytes, MIN MPDU Start Spacing:%u"

#define HT_AMPDU_PARA_ARG(x) \
	*((u8 *)(x)) \
	, (1 << (13+GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(((u8 *)x)-2)))-1 \
	, GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(((u8 *)x)-2)

#define SET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2, _val)
#define SET_HT_CAP_ELE_MIN_MPDU_S_SPACE(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 3, _val)

/* Supported MCS Set field */
#define HT_CAP_ELE_SUP_MCS_SET(_pEleStart)				(((u8 *)(_pEleStart))+3)
#define HT_CAP_ELE_RX_MCS_MAP(_pEleStart)				HT_CAP_ELE_SUP_MCS_SET(_pEleStart)
#define GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(_pEleStart)	LE_BITS_TO_2BYTE(((u8 *)(_pEleStart))+13, 0, 10)
#define GET_HT_CAP_ELE_TX_MCS_DEF(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 0, 1)
#define GET_HT_CAP_ELE_TRX_MCS_NEQ(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 1, 1)
#define GET_HT_CAP_ELE_TX_MAX_SS(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 2, 2)
#define GET_HT_CAP_ELE_TX_UEQM(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 4, 1)

#define HT_RX_MCS_BMP_FMT "%02x %02x %02x %02x %02x%02x%02x%02x%02x%02x"
#define HT_RX_MCS_BMP_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9]

#define HT_SUP_MCS_SET_FMT HT_RX_MCS_BMP_FMT \
	/* "\n%02x%02x%02x%02x%02x%02x" */\
	" %uMbps %s%s%s"
#define HT_SUP_MCS_SET_ARG(x) HT_RX_MCS_BMP_ARG(x) \
	/*,((u8 *)(x))[10], ((u8 *)(x))[11], ((u8 *)(x))[12], ((u8 *)(x))[13], ((u8 *)(x))[14], ((u8 *)(x))[15] */\
	, GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(((u8 *)x)-3) \
	, GET_HT_CAP_ELE_TX_MCS_DEF(((u8 *)x)-3) ? "TX_MCS_DEF " : "" \
	, GET_HT_CAP_ELE_TRX_MCS_NEQ(((u8 *)x)-3) ? "TRX_MCS_NEQ " : "" \
	, GET_HT_CAP_ELE_TX_UEQM(((u8 *)x)-3) ? "TX_UEQM " : ""

/* TXBF Capabilities */
#define SET_HT_CAP_TXBF_RECEIVE_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 3, 1, ((u8)_val))
#define SET_HT_CAP_TXBF_TRANSMIT_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 4, 1, ((u8)_val))
#define SET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 10, 1, ((u8)_val))
#define SET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 15, 2, ((u8)_val))
#define SET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 23, 2, ((u8)_val))
#define SET_HT_CAP_TXBF_CHNL_ESTIMATION_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 27, 2, ((u8)_val))


#define GET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 10, 1)
#define GET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 15, 2)
#define GET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart)		LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 23, 2)
#define GET_HT_CAP_TXBF_CHNL_ESTIMATION_NUM_ANTENNAS(_pEleStart)		LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 27, 2)

/* HT Operation element */

#define GET_HT_OP_ELE_PRI_CHL(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 8)
#define SET_HT_OP_ELE_PRI_CHL(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 8, _val)

/* HT Operation Info field */
#define HT_OP_ELE_OP_INFO(_pEleStart)						(((u8 *)(_pEleStart)) + 1)
#define GET_HT_OP_ELE_2ND_CHL_OFFSET(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2)
#define GET_HT_OP_ELE_STA_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1)
#define GET_HT_OP_ELE_RIFS_MODE(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1)
#define GET_HT_OP_ELE_HT_PROTECT(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2)
#define GET_HT_OP_ELE_NON_GREEN_PRESENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 1)
#define GET_HT_OP_ELE_OBSS_NON_HT_PRESENT(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 4, 1)
#define GET_HT_OP_ELE_DUAL_BEACON(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 4, 6, 1)
#define GET_HT_OP_ELE_DUAL_CTS(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 4, 7, 1)
#define GET_HT_OP_ELE_STBC_BEACON(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 0, 1)
#define GET_HT_OP_ELE_LSIG_TXOP_PROTECT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 1, 1)
#define GET_HT_OP_ELE_PCO_ACTIVE(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1)
#define GET_HT_OP_ELE_PCO_PHASE(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1)

#define SET_HT_OP_ELE_2ND_CHL_OFFSET(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2, _val)
#define SET_HT_OP_ELE_STA_CHL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1, _val)
#define SET_HT_OP_ELE_RIFS_MODE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1, _val)
#define SET_HT_OP_ELE_HT_PROTECT(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2, _val)
#define SET_HT_OP_ELE_NON_GREEN_PRESENT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 1, _val)
#define SET_HT_OP_ELE_OBSS_NON_HT_PRESENT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 4, 1, _val)
#define SET_HT_OP_ELE_DUAL_BEACON(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 4, 6, 1, _val)
#define SET_HT_OP_ELE_DUAL_CTS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 4, 7, 1, _val)
#define SET_HT_OP_ELE_STBC_BEACON(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 0, 1, _val)
#define SET_HT_OP_ELE_LSIG_TXOP_PROTECT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 1, 1, _val)
#define SET_HT_OP_ELE_PCO_ACTIVE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1, _val)
#define SET_HT_OP_ELE_PCO_PHASE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1, _val)

#endif /* _RTL871X_HT_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/drv_types_pci.h                                                               0000644 0001750 0001750 00000002564 14214766567 016456  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_TYPES_PCI_H__
#define __DRV_TYPES_PCI_H__

#ifdef PLATFORM_LINUX
	#include <linux/pci.h>
#endif

#define	INTEL_VENDOR_ID				0x8086
#define	SIS_VENDOR_ID					0x1039
#define	ATI_VENDOR_ID					0x1002
#define	ATI_DEVICE_ID					0x7914
#define	AMD_VENDOR_ID					0x1022

#define PCI_VENDER_ID_REALTEK		0x10ec

enum aspm_mode {
	ASPM_MODE_UND,
	ASPM_MODE_PERF,
	ASPM_MODE_PS,
	ASPM_MODE_DEF,
};

struct pci_priv {
	BOOLEAN		pci_clk_req;

	u8	pciehdr_offset;

	u8	linkctrl_reg;
	u8	pcibridge_linkctrlreg;

	u8	amd_l1_patch;

#ifdef CONFIG_PCI_DYNAMIC_ASPM
	u8	aspm_mode;
#endif
};

typedef struct _RT_ISR_CONTENT {
	union {
		u32			IntArray[2];
		u32			IntReg4Byte;
		u16			IntReg2Byte;
	};
} RT_ISR_CONTENT, *PRT_ISR_CONTENT;

#endif
                                                                                                                                            rtl8822bu/src/include/rtl8703b_hal.h                                                                0000644 0001750 0001750 00000022432 14214766567 015711  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_HAL_H__
#define __RTL8703B_HAL_H__

#include "hal_data.h"

#include "rtl8703b_spec.h"
#include "rtl8703b_rf.h"
#include "rtl8703b_dm.h"
#include "rtl8703b_recv.h"
#include "rtl8703b_xmit.h"
#include "rtl8703b_cmd.h"
#include "rtl8703b_led.h"
#include "Hal8703BPwrSeq.h"
#include "Hal8703BPhyReg.h"
#include "Hal8703BPhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8703b_sreset.h"
#endif

#define FW_8703B_SIZE			0x8000
#define FW_8703B_START_ADDRESS	0x1000
#define FW_8703B_END_ADDRESS		0x1FFF /* 0x5FFF */

#define IS_FW_HEADER_EXIST_8703B(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x03B0)

typedef struct _RT_FIRMWARE {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_8703B_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8703B, *PRT_FIRMWARE_8703B;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
typedef struct _RT_8703B_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u16		Subversion;	/* FW Subversion, default 0x00 */

	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u16		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8703B_FIRMWARE_HDR, *PRT_8703B_FIRMWARE_HDR;

#define DRIVER_EARLY_INT_TIME_8703B		0x05
#define BCN_DMA_ATIME_INT_TIME_8703B		0x02

/* for 8703B
 * TX 32K, RX 16K, Page size 128B for TX, 8B for RX */
#define PAGE_SIZE_TX_8703B			128
#define PAGE_SIZE_RX_8703B			8

#define TX_DMA_SIZE_8703B			0x8000	/* 32K(TX) */
#define RX_DMA_SIZE_8703B			0x4000	/* 16K(RX) */

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8703B	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8703B	0x80	/* 128B, reserved for tx report */
#endif
#define RX_DMA_BOUNDARY_8703B		(RX_DMA_SIZE_8703B - RX_DMA_RESERVED_SIZE_8703B - 1)


/* Note: We will divide number of page equally for each queue other than public queue! */

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8703B
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/

#define BCNQ_PAGE_NUM_8703B		(MAX_BEACON_LEN/PAGE_SIZE_TX_8703B + 6) /*0x08*/

/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt: 1 PNO: 6
 * NS offload: 2NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8703B	0x0b
#else
	#define WOWLAN_PAGE_NUM_8703B	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
	#undef WOWLAN_PAGE_NUM_8703B
	#define WOWLAN_PAGE_NUM_8703B	0x15
#endif

#ifdef CONFIG_AP_WOWLAN
	#define AP_WOWLAN_PAGE_NUM_8703B	0x02
#endif

#define TX_TOTAL_PAGE_NUMBER_8703B	(0xFF - BCNQ_PAGE_NUM_8703B - WOWLAN_PAGE_NUM_8703B)
#define TX_PAGE_BOUNDARY_8703B		(TX_TOTAL_PAGE_NUMBER_8703B + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8703B	TX_TOTAL_PAGE_NUMBER_8703B
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8703B		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8703B + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8703B */
#define NORMAL_PAGE_NUM_HPQ_8703B		0x0C
#define NORMAL_PAGE_NUM_LPQ_8703B		0x02
#define NORMAL_PAGE_NUM_NPQ_8703B		0x02

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8703B		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8703B		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8703B		0x20


#include "HalVerDef.h"
#include "hal_com.h"

#define EFUSE_OOB_PROTECT_BYTES		15

#define HAL_EFUSE_MEMORY

#define HWSET_MAX_SIZE_8703B			256
#define EFUSE_REAL_CONTENT_LEN_8703B		256
#define EFUSE_MAP_LEN_8703B				512
#define EFUSE_MAX_SECTION_8703B			64

#define EFUSE_IC_ID_OFFSET			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8703B)

#define EFUSE_ACCESS_ON			0x69
#define EFUSE_ACCESS_OFF			0x00

/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define BANK_NUM		1
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	128
#define EFUSE_BT_REAL_CONTENT_LEN		(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)
#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION			(EFUSE_BT_MAP_LEN / 8)
#define EFUSE_PROTECT_BYTES_BANK		16

typedef enum tag_Package_Definition {
	PACKAGE_DEFAULT,
	PACKAGE_QFN68,
	PACKAGE_TFBGA90,
	PACKAGE_TFBGA80,
	PACKAGE_TFBGA79
} PACKAGE_TYPE_E;

#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

/* rtl8703b_hal_init.c */
s32 rtl8703b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void rtl8703b_FirmwareSelfReset(PADAPTER padapter);
void rtl8703b_InitializeFirmwareVars(PADAPTER padapter);

void rtl8703b_InitAntenna_Selection(PADAPTER padapter);
void rtl8703b_DeinitAntenna_Selection(PADAPTER padapter);
void rtl8703b_CheckAntenna_Selection(PADAPTER padapter);
void rtl8703b_init_default_value(PADAPTER padapter);

s32 rtl8703b_InitLLTTable(PADAPTER padapter);

s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
s32 CardDisableWithoutHWSM(PADAPTER padapter);

/* EFuse */
u8 GetEEPROMSize8703B(PADAPTER padapter);
void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
void Hal_EfuseParseTxPowerInfo_8703B(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
void Hal_EfuseParseBTCoexistInfo_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseEEPROMVer_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseChnlPlan_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseAntennaDiversity_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseXtal_8703B(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseThermalMeter_8703B(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseVoltage_8703B(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);
void Hal_EfuseParseBoardType_8703B(PADAPTER Adapter,	u8	*PROMContent, BOOLEAN AutoloadFail);

void rtl8703b_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8703b(_adapter *adapter);
u8 SetHwReg8703B(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8703B(PADAPTER padapter, u8 variable, u8 *val);
u8 SetHalDefVar8703B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8703B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);

/* register */
void rtl8703b_InitBeaconParameters(PADAPTER padapter);
void rtl8703b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
void	_InitBurstPktLen_8703BS(PADAPTER Adapter);
void _InitLTECoex_8703BS(PADAPTER Adapter);
void _InitMacAPLLSetting_8703B(PADAPTER Adapter);
void _8051Reset8703(PADAPTER padapter);
#ifdef CONFIG_WOWLAN
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void rtl8703b_start_thread(_adapter *padapter);
void rtl8703b_stop_thread(_adapter *padapter);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void rtl8703bs_init_checkbthang_workqueue(_adapter *adapter);
	void rtl8703bs_free_checkbthang_workqueue(_adapter *adapter);
	void rtl8703bs_cancle_checkbthang_workqueue(_adapter *adapter);
	void rtl8703bs_hal_check_bt_hang(_adapter *adapter);
#endif

#ifdef CONFIG_GPIO_WAKEUP
	void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
#endif
#ifdef CONFIG_MP_INCLUDED
int FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
#endif
void CCX_FwC2HTxRpt_8703b(PADAPTER padapter, u8 *pdata, u8 len);

u8 MRateToHwRate8703B(u8  rate);
u8 HwRateToMRate8703B(u8	 rate);

void Hal_ReadRFGainOffset(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);

#ifdef CONFIG_PCI_HCI
	BOOLEAN	InterruptRecognized8703BE(PADAPTER Adapter);
	void	UpdateInterruptMask8703BE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
#endif

#endif
                                                                                                                                                                                                                                      rtl8822bu/src/include/Hal8723DPhyCfg.h                                                              0000644 0001750 0001750 00000005115 14214766567 016034  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8723DPHYCFG_H__
#define __INC_HAL8723DPHYCFG_H__

/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters End-------------------------------*/


/*------------------------------Define structure----------------------------*/

/*------------------------------Define structure End----------------------------*/

/*--------------------------Exported Function prototype---------------------*/
u32
PHY_QueryBBReg_8723D(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask
);

void
PHY_SetBBReg_8723D(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask,
		u32		Data
);

u32
PHY_QueryRFReg_8723D(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask
);

void
PHY_SetRFReg_8723D(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask,
		u32				Data
);

/* MAC/BB/RF HAL config */
int PHY_BBConfig8723D(PADAPTER	Adapter);

int PHY_RFConfig8723D(PADAPTER	Adapter);

s32 PHY_MACConfig8723D(PADAPTER padapter);

int
PHY_ConfigRFWithParaFile_8723D(
		PADAPTER			Adapter,
		u8				*pFileName,
	enum rf_path				eRFPath
);

void
PHY_SetTxPowerIndex_8723D(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

void
PHY_SetTxPowerLevel8723D(
		PADAPTER		Adapter,
		u8			channel
);

void
PHY_SetSwChnlBWMode8723D(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void phy_set_rf_path_switch_8723d(
		struct dm_struct		*phydm,
		bool		bMain
);
/*--------------------------Exported Function prototype End---------------------*/

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/rtl8814be_hal.h                                                               0000644 0001750 0001750 00000002074 14214766567 016061  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8814BE_HAL_H_
#define _RTL8814BE_HAL_H_

#include <drv_types.h>		/* PADAPTER */

#define RT_BCN_INT_MASKS	(BIT_BCNDMAINT0_MSK_8814B |	\
				 BIT_TXBCN0OK_MSK_8814B |	\
				 BIT_TXBCN0ERR_MSK_8814B |	\
				 BIT_BCNDERR0_MSK_8814B)

/* rtl8814be_ops.c */
void UpdateInterruptMask8814BE(PADAPTER, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
u16 get_txbd_rw_reg(u16 q_idx);


#endif /* _RTL8814BE_HAL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtw_odm.h                                                                     0000644 0001750 0001750 00000006610 14214766567 015253  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_ODM_H__
#define __RTW_ODM_H__

#include <drv_types.h>
#include "../hal/phydm/phydm_types.h"
/*
* This file provides utilities/wrappers for rtw driver to use ODM
*/
typedef enum _HAL_PHYDM_OPS {
	HAL_PHYDM_DIS_ALL_FUNC,
	HAL_PHYDM_FUNC_SET,
	HAL_PHYDM_FUNC_CLR,
	HAL_PHYDM_ABILITY_BK,
	HAL_PHYDM_ABILITY_RESTORE,
	HAL_PHYDM_ABILITY_SET,
	HAL_PHYDM_ABILITY_GET,
} HAL_PHYDM_OPS;


#define DYNAMIC_FUNC_DISABLE		(0x0)
	u32 rtw_phydm_ability_ops(_adapter *adapter, HAL_PHYDM_OPS ops, u32 ability);

#define rtw_phydm_func_disable_all(adapter)	\
		rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0)

#ifdef CONFIG_RTW_ACS
#define rtw_phydm_func_for_offchannel(adapter) \
		do { \
			rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0); \
			if (rtw_odm_adaptivity_needed(adapter)) \
				rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ODM_BB_ADAPTIVITY); \
			if (IS_ACS_ENABLE(adapter))\
				rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ODM_BB_ENV_MONITOR); \
		} while (0)
#else
#define rtw_phydm_func_for_offchannel(adapter) \
		do { \
			rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0); \
			if (rtw_odm_adaptivity_needed(adapter)) \
				rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ODM_BB_ADAPTIVITY); \
		} while (0)
#endif

#define rtw_phydm_func_clr(adapter, ability)	\
		rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_CLR, ability)

#define rtw_phydm_ability_backup(adapter)	\
		rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_BK, 0)

#define rtw_phydm_ability_restore(adapter)	\
		rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_RESTORE, 0)


static inline u32 rtw_phydm_ability_get(_adapter *adapter)
{
	return rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_GET, 0);
}


void rtw_odm_init_ic_type(_adapter *adapter);

void rtw_odm_adaptivity_config_msg(void *sel, _adapter *adapter);

bool rtw_odm_adaptivity_needed(_adapter *adapter);
void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter);
void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 th_l2h_ini, s8 th_edcca_hl_diff);
void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter);
void rtw_odm_acquirespinlock(_adapter *adapter,	enum rt_spinlock_type type);
void rtw_odm_releasespinlock(_adapter *adapter,	enum rt_spinlock_type type);

#ifdef CONFIG_DFS_MASTER
void rtw_odm_radar_detect_reset(_adapter *adapter);
void rtw_odm_radar_detect_disable(_adapter *adapter);
void rtw_odm_radar_detect_enable(_adapter *adapter);
BOOLEAN rtw_odm_radar_detect(_adapter *adapter);
u8 rtw_odm_radar_detect_polling_int_ms(struct dvobj_priv *dvobj);
#endif /* CONFIG_DFS_MASTER */

void rtw_odm_parse_rx_phy_status_chinfo(union recv_frame *rframe, u8 *phys);

#if defined(CONFIG_RTL8822C) && defined(CONFIG_LPS_PG)
void odm_lps_pg_debug_8822c(void *dm_void);
#endif

#endif /* __RTW_ODM_H__ */
                                                                                                                        rtl8822bu/src/include/Hal8821APwrSeq.h                                                              0000644 0001750 0001750 00000043225 14214766567 016075  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8821
#define REALTEK_POWER_SEQUENCE_8821

#include "HalPwrSeqCmd.h"

/*
	Check document WM-20130516-JackieLau-RTL8821A_Power_Architecture-R10.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS	25
#define	RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS	15
#define	RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS	15
#define	RTL8821A_TRANS_SUS_TO_CARDEMU_STEPS	15
#define RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS	15
#define	RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS	15
#define	RTL8821A_TRANS_PDN_TO_CARDEMU_STEPS	15
#define	RTL8821A_TRANS_ACT_TO_LPS_STEPS	15
#define	RTL8821A_TRANS_LPS_TO_ACT_STEPS	15
#define	RTL8821A_TRANS_END_STEPS	1


#define RTL8821A_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3 | BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[12:11]=0*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3), 0},/* disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	\
	{0x004F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*0x4C[24] = 0x4F[0] = 1, switch DPDT_SEL_P output from WL BB */\
	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT5 | BIT4), (BIT5 | BIT4)},/*0x66[13] = 0x67[5] = 1, switch for PAPE_G/PAPE_A from WL BB ; 0x66[12] = 0x67[4] = 1, switch LNAON from WL BB */\
	{0x0025, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, 0},/*anapar_mac<118> , 0x25[6]=0 by wlan single function*/\
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable GPIO9 interrupt mode*/\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable HSISR GPIO9 interrupt*/\
	{0x007A, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3A},/*0x7A = 0x3A start BT*/\
	{0x002E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF , 0x82 },/* 0x2C[23:12]=0x820 ; XTAL trim */ \
	{0x0010, PWR_CUT_A_MSK , PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 , BIT6 },/* 0x10[6]=1 ; MPsW0x2CvA0x10[6]]1~WLAN */ \


#define RTL8821A_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x004F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*0x4C[24] = 0x4F[0] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/   \


#define RTL8821A_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, (BIT4 | BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8821A_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8821A_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8821A_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/


#define RTL8821A_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK | PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8821A_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8821A_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8821A_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8821A_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8821A_power_on_flow[RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_radio_off_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_card_disable_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_card_enable_flow[RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS + RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_suspend_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_resume_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_hwpdn_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_enter_lps_flow[RTL8821A_TRANS_ACT_TO_LPS_STEPS + RTL8821A_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8821A_leave_lps_flow[RTL8821A_TRANS_LPS_TO_ACT_STEPS + RTL8821A_TRANS_END_STEPS];

#endif
                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/drv_types.h                                                                   0000644 0001750 0001750 00000134341 14214766567 015622  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*-------------------------------------------------------------------------------

	For type defines and data structure defines

--------------------------------------------------------------------------------*/


#ifndef __DRV_TYPES_H__
#define __DRV_TYPES_H__

#include <drv_conf.h>
#include <basic_types.h>
#include <osdep_service.h>
#include <rtw_byteorder.h>
#include <wlan_bssdef.h>
#include <wifi.h>
#include <ieee80211.h>
#ifdef CONFIG_ARP_KEEP_ALIVE
	#include <net/neighbour.h>
	#include <net/arp.h>
#endif

#ifdef PLATFORM_OS_XP
	#include <drv_types_xp.h>
#endif

#ifdef PLATFORM_OS_CE
	#include <drv_types_ce.h>
#endif

#ifdef PLATFORM_LINUX
	#include <drv_types_linux.h>
#endif

enum _NIC_VERSION {

	RTL8711_NIC,
	RTL8712_NIC,
	RTL8713_NIC,
	RTL8716_NIC

};

typedef struct _ADAPTER _adapter, ADAPTER, *PADAPTER;

#include <rtw_debug.h>
#include <cmn_info/rtw_sta_info.h>
#include <rtw_rf.h>
#include "../core/rtw_chplan.h"

#ifdef CONFIG_80211N_HT
	#include <rtw_ht.h>
#endif

#ifdef CONFIG_80211AC_VHT
	#include <rtw_vht.h>
#endif

#include <rtw_cmd.h>
#include <cmd_osdep.h>
#include <rtw_security.h>
#include <rtw_xmit.h>
#include <xmit_osdep.h>
#include <rtw_recv.h>
#include <rtw_rm.h>

#ifdef CONFIG_BEAMFORMING
	#include <rtw_beamforming.h>
#endif

#include <recv_osdep.h>
#include <rtw_efuse.h>
#include <rtw_sreset.h>
#include <hal_intf.h>
#include <hal_com.h>
#include<hal_com_h2c.h>
#include <hal_com_led.h>
#include "../hal/hal_dm.h"
#include <rtw_qos.h>
#include <rtw_pwrctrl.h>
#include <rtw_mlme.h>
#include <mlme_osdep.h>
#include <rtw_io.h>
#include <rtw_ioctl.h>
#include <rtw_ioctl_set.h>
#include <rtw_ioctl_query.h>
#include <osdep_intf.h>
#include <rtw_eeprom.h>
#include "sta_info.h"
#include <rtw_event.h>
#include <rtw_mlme_ext.h>
#include <rtw_mi.h>
#include <rtw_ap.h>
#ifdef CONFIG_RTW_MESH
#include "../core/mesh/rtw_mesh.h"
#endif
#include <rtw_efuse.h>
#include <rtw_version.h>
#include <rtw_odm.h>

#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
	#include <rtw_mem.h>
#endif

#include <rtw_p2p.h>

#ifdef CONFIG_TDLS
	#include <rtw_tdls.h>
#endif /* CONFIG_TDLS */

#ifdef CONFIG_WAPI_SUPPORT
	#include <rtw_wapi.h>
#endif /* CONFIG_WAPI_SUPPORT */

#ifdef CONFIG_MP_INCLUDED
	#include <rtw_mp.h>
#endif /* CONFIG_MP_INCLUDED */

#ifdef CONFIG_BR_EXT
	#include <rtw_br_ext.h>
#endif /* CONFIG_BR_EXT */

#ifdef CONFIG_IOL
	#include <rtw_iol.h>
#endif /* CONFIG_IOL */

#include <ip.h>
#include <if_ether.h>
#include <ethernet.h>
#include <circ_buf.h>

#include <rtw_android.h>

#include <rtw_btcoex_wifionly.h>
#include <rtw_btcoex.h>

#ifdef CONFIG_MCC_MODE
	#include <rtw_mcc.h>
#endif /*CONFIG_MCC_MODE */

#ifdef CONFIG_RTW_REPEATER_SON
	#include <rtw_rson.h>
#endif /*CONFIG_RTW_REPEATER_SON */

#define SPEC_DEV_ID_NONE BIT(0)
#define SPEC_DEV_ID_DISABLE_HT BIT(1)
#define SPEC_DEV_ID_ENABLE_PS BIT(2)
#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
#define SPEC_DEV_ID_ASSIGN_IFNAME BIT(5)

struct specific_device_id {

	u32		flags;

	u16		idVendor;
	u16		idProduct;

};

struct registry_priv {
	u8	chip_version;
	u8	rfintfs;
	u8	lbkmode;
	u8	hci;
	NDIS_802_11_SSID	ssid;
	u8	network_mode;	/* infra, ad-hoc, auto */
	u8	channel;/* ad-hoc support requirement */
	u8	wireless_mode;/* A, B, G, auto */
	u8	scan_mode;/* active, passive */
	u8	radio_enable;
	u8	preamble;/* long, short, auto */
	u8	vrtl_carrier_sense;/* Enable, Disable, Auto */
	u8	vcs_type;/* RTS/CTS, CTS-to-self */
	u16	rts_thresh;
	u16  frag_thresh;
	u8	adhoc_tx_pwr;
	u8	soft_ap;
	u8	power_mgnt;
	u8	ips_mode;
	u8	lps_level;
#ifdef CONFIG_LPS_1T1R
	u8	lps_1t1r;
#endif
	u8	lps_chk_by_tp;
#ifdef CONFIG_WOWLAN
	u8	wow_power_mgnt;
	u8	wow_lps_level;
	#ifdef CONFIG_LPS_1T1R
	u8	wow_lps_1t1r;
	#endif
#endif /* CONFIG_WOWLAN */
	u8	smart_ps;
#ifdef CONFIG_WMMPS_STA
	u8	wmm_smart_ps;
#endif /* CONFIG_WMMPS_STA */
	u8   usb_rxagg_mode;
	u8	dynamic_agg_enable;
	u8	long_retry_lmt;
	u8	short_retry_lmt;
	u16	busy_thresh;
	u16	max_bss_cnt;
	u8	ack_policy;
	u8	mp_mode;
#if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_RTW_CUSTOMER_STR)
	u8 mp_customer_str;
#endif
	u8  mp_dm;
	u8	software_encrypt;
	u8	software_decrypt;
#ifdef CONFIG_TX_EARLY_MODE
	u8   early_mode;
#endif
#ifdef CONFIG_NARROWBAND_SUPPORTING
	u8	rtw_nb_config;
#endif
	u8	acm_method;
	/* WMM */
	u8	wmm_enable;
#ifdef CONFIG_WMMPS_STA
	/* uapsd (unscheduled automatic power-save delivery) = a kind of wmmps */
	u8	uapsd_max_sp_len;
	/* BIT0: AC_VO UAPSD, BIT1: AC_VI UAPSD, BIT2: AC_BK UAPSD, BIT3: AC_BE UAPSD */
	u8	uapsd_ac_enable;
#endif /* CONFIG_WMMPS_STA */

	WLAN_BSSID_EX    dev_network;

#if CONFIG_TX_AC_LIFETIME
	u8 tx_aclt_flags;
	struct tx_aclt_conf_t tx_aclt_confs[TX_ACLT_CONF_NUM];
#endif

	u8 tx_bw_mode;
#ifdef CONFIG_AP_MODE
	u8 bmc_tx_rate;
#endif
#ifdef CONFIG_80211N_HT
	u8	ht_enable;
	/* 0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz */
	/* 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7 */
	/* 0x21 means enable 2.4G 40MHz & 5G 80MHz */
	u8	bw_mode;
	u8	ampdu_enable;/* for tx */
	u8	rx_stbc;
	u8	rx_ampdu_amsdu;/* Rx A-MPDU Supports A-MSDU is permitted */
	u8	tx_ampdu_amsdu;/* Tx A-MPDU Supports A-MSDU is permitted */
	u8 rx_ampdu_sz_limit_by_nss_bw[4][4]; /* 1~4SS, BW20~BW160 */
	/* Short GI support Bit Map */
	/* BIT0 - 20MHz, 1: support, 0: non-support */
	/* BIT1 - 40MHz, 1: support, 0: non-support */
	/* BIT2 - 80MHz, 1: support, 0: non-support */
	/* BIT3 - 160MHz, 1: support, 0: non-support */
	u8	short_gi;
	/* BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx */
	u8	ldpc_cap;
	/* BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx */
	u8	stbc_cap;
	#if defined(CONFIG_RTW_TX_NPATH_EN)
	u8	tx_npath;
	#endif
	#if defined(CONFIG_RTW_PATH_DIV)
	u8 path_div;
	#endif
	/*
	 * BIT0: Enable VHT SU Beamformer
	 * BIT1: Enable VHT SU Beamformee
	 * BIT2: Enable VHT MU Beamformer, depend on VHT SU Beamformer
	 * BIT3: Enable VHT MU Beamformee, depend on VHT SU Beamformee
	 * BIT4: Enable HT Beamformer
	 * BIT5: Enable HT Beamformee
	 */
	u8	beamform_cap;
	u8	beamformer_rf_num;
	u8	beamformee_rf_num;
#endif /* CONFIG_80211N_HT */

#ifdef CONFIG_80211AC_VHT
	u8	vht_enable; /* 0:disable, 1:enable, 2:auto */
	u8	ampdu_factor;
	u8 vht_rx_mcs_map[2];
#endif /* CONFIG_80211AC_VHT */

	u8	lowrate_two_xmit;

	u8	low_power ;

	u8	wifi_spec;/* !turbo_mode */

	u8 rf_path; /*rf_config*/
	u8 tx_nss;
	u8 rx_nss;

	char alpha2[2];
	u8	channel_plan;
	u8	excl_chs[MAX_CHANNEL_NUM];
	u8	full_ch_in_p2p_handshake; /* 0: reply only softap channel, 1: reply full channel list*/

#ifdef CONFIG_BT_COEXIST
	u8	btcoex;
	u8	bt_iso;
	u8	bt_sco;
	u8	bt_ampdu;
	u8	ant_num;
	u8	single_ant_path;
#endif
	BOOLEAN	bAcceptAddbaReq;

	u8	antdiv_cfg;
	u8	antdiv_type;
	u8	drv_ant_band_switch;

	u8	switch_usb_mode;

	u8	usbss_enable;/* 0:disable,1:enable */
	u8	hwpdn_mode;/* 0:disable,1:enable,2:decide by EFUSE config */
	u8	hwpwrp_detect;/* 0:disable,1:enable */

	u8	hw_wps_pbc;/* 0:disable,1:enable */

#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
	char	adaptor_info_caching_file_path[PATH_LENGTH_MAX];
#endif

#ifdef CONFIG_LAYER2_ROAMING
	u8	max_roaming_times; /* the max number driver will try to roaming */
#endif

#ifdef CONFIG_IOL
	u8 fw_iol; /* enable iol without other concern */
#endif

#ifdef CONFIG_80211D
	u8 enable80211d;
#endif

	u8 ifname[16];
	u8 if2name[16];

	u8 notch_filter;

	/* for pll reference clock selction */
	u8 pll_ref_clk_sel;

	/* define for tx power adjust */
#if CONFIG_TXPWR_LIMIT
	u8	RegEnableTxPowerLimit;
#endif
	u8	RegEnableTxPowerByRate;

	u8 target_tx_pwr_valid;
	s8 target_tx_pwr_2g[RF_PATH_MAX][RATE_SECTION_NUM];
#if CONFIG_IEEE80211_BAND_5GHZ
	s8 target_tx_pwr_5g[RF_PATH_MAX][RATE_SECTION_NUM - 1];
#endif

	u8 tsf_update_pause_factor;
	u8 tsf_update_restore_factor;

	s8	TxBBSwing_2G;
	s8	TxBBSwing_5G;
	u8	AmplifierType_2G;
	u8	AmplifierType_5G;
	u8	bEn_RFE;
	u8	RFE_Type;
	u8	PowerTracking_Type;
	u8	GLNA_Type;
	u8  check_fw_ps;
	u8	RegPwrTrimEnable;

#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
	u8	load_phy_file;
	u8	RegDecryptCustomFile;
#endif
#ifdef CONFIG_CONCURRENT_MODE
	u8 virtual_iface_num;
#ifdef CONFIG_P2P
	u8 sel_p2p_iface;
#endif
#endif
	u8 qos_opt_enable;

	u8 hiq_filter;
	u8 adaptivity_en;
	u8 adaptivity_mode;
	s8 adaptivity_th_l2h_ini;
	s8 adaptivity_th_edcca_hl_diff;

	u8 boffefusemask;
	BOOLEAN bFileMaskEfuse;
	BOOLEAN bBTFileMaskEfuse;
#ifdef CONFIG_RTW_ACS
	u8 acs_auto_scan;
	u8 acs_mode;
#endif

#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
	u8 nm_mode;
#endif
	u32	reg_rxgain_offset_2g;
	u32	reg_rxgain_offset_5gl;
	u32	reg_rxgain_offset_5gm;
	u32	reg_rxgain_offset_5gh;

#ifdef CONFIG_DFS_MASTER
	u8 dfs_region_domain;
#endif

#ifdef CONFIG_MCC_MODE
	u8 en_mcc;
	u32 rtw_mcc_single_tx_cri;
	u32 rtw_mcc_ap_bw20_target_tx_tp;
	u32 rtw_mcc_ap_bw40_target_tx_tp;
	u32 rtw_mcc_ap_bw80_target_tx_tp;
	u32 rtw_mcc_sta_bw20_target_tx_tp;
	u32 rtw_mcc_sta_bw40_target_tx_tp;
	u32 rtw_mcc_sta_bw80_target_tx_tp;
	s8 rtw_mcc_policy_table_idx;
	u8 rtw_mcc_duration;
	u8 rtw_mcc_enable_runtime_duration;
	u8 rtw_mcc_phydm_offload;
#endif /* CONFIG_MCC_MODE */

#ifdef CONFIG_RTW_NAPI
	u8 en_napi;
#ifdef CONFIG_RTW_NAPI_DYNAMIC
	u32 napi_threshold;	/* unit: Mbps */
#endif /* CONFIG_RTW_NAPI_DYNAMIC */
#ifdef CONFIG_RTW_GRO
	u8 en_gro;
#endif /* CONFIG_RTW_GRO */
#endif /* CONFIG_RTW_NAPI */

#ifdef CONFIG_WOWLAN
	u8 wakeup_event;
	u8 suspend_type;
#endif

#ifdef CONFIG_SUPPORT_TRX_SHARED
	u8 trx_share_mode;
#endif
	u8 check_hw_status;
	u8 wowlan_sta_mix_mode;

#ifdef CONFIG_PCI_HCI
	u32 pci_aspm_config;
	u32 pci_dynamic_aspm_linkctrl;
#endif

	u8 iqk_fw_offload;
	u8 ch_switch_offload;

#ifdef CONFIG_TDLS
	u8 en_tdls;
#endif

#ifdef CONFIG_ADVANCE_OTA
	u8	adv_ota;
#endif

#ifdef CONFIG_FW_OFFLOAD_PARAM_INIT
	u8 fw_param_init;
#endif
#ifdef CONFIG_DYNAMIC_SOML
	u8 dyn_soml_en;
	u8 dyn_soml_train_num;
	u8 dyn_soml_interval;
	u8 dyn_soml_period;
	u8 dyn_soml_delay;
#endif
#ifdef CONFIG_FW_HANDLE_TXBCN
	u8 fw_tbtt_rpt;
#endif

#ifdef DBG_LA_MODE
	u8 la_mode_en;
#endif
	u32 phydm_ability;
	u32 halrf_ability;
#ifdef CONFIG_TDMADIG
	u8 tdmadig_en;
	u8 tdmadig_mode;
	u8 tdmadig_dynamic;
#endif/*CONFIG_TDMADIG*/
#ifdef CONFIG_RTW_MESH
	u8 peer_alive_based_preq;
#endif

	/*
	 * vht_2g4: use VHT rate on 2.4G or not
	 * 0: deny
	 * 1: allow
	 */
	u8 vht_2g4;
};

/* For registry parameters */
#define RGTRY_OFT(field) ((u32)FIELD_OFFSET(struct registry_priv, field))
#define RGTRY_SZ(field)   sizeof(((struct registry_priv *) 0)->field)

#define GetRegAmplifierType2G(_Adapter)	(_Adapter->registrypriv.AmplifierType_2G)
#define GetRegAmplifierType5G(_Adapter)	(_Adapter->registrypriv.AmplifierType_5G)

#define GetRegTxBBSwing_2G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_2G)
#define GetRegTxBBSwing_5G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_5G)

#define GetRegbENRFEType(_Adapter)	(_Adapter->registrypriv.bEn_RFE)
#define GetRegRFEType(_Adapter)	(_Adapter->registrypriv.RFE_Type)
#define GetRegGLNAType(_Adapter)	(_Adapter->registrypriv.GLNA_Type)
#define GetRegPowerTrackingType(_Adapter)	(_Adapter->registrypriv.PowerTracking_Type)

#define WOWLAN_IS_STA_MIX_MODE(_Adapter)	(_Adapter->registrypriv.wowlan_sta_mix_mode)
#define BSSID_OFT(field) ((u32)FIELD_OFFSET(WLAN_BSSID_EX, field))
#define BSSID_SZ(field)   sizeof(((PWLAN_BSSID_EX) 0)->field)

#define BW_MODE_2G(bw_mode) ((bw_mode) & 0x0F)
#define BW_MODE_5G(bw_mode) ((bw_mode) >> 4)
#ifdef CONFIG_80211N_HT
#define REGSTY_BW_2G(regsty) BW_MODE_2G((regsty)->bw_mode)
#define REGSTY_BW_5G(regsty) BW_MODE_5G((regsty)->bw_mode)
#else
#define REGSTY_BW_2G(regsty) CHANNEL_WIDTH_20
#define REGSTY_BW_5G(regsty) CHANNEL_WIDTH_20
#endif
#define REGSTY_IS_BW_2G_SUPPORT(regsty, bw) (REGSTY_BW_2G((regsty)) >= (bw))
#define REGSTY_IS_BW_5G_SUPPORT(regsty, bw) (REGSTY_BW_5G((regsty)) >= (bw))

#define REGSTY_IS_11AC_ENABLE(regsty) ((regsty)->vht_enable != 0)
#define REGSTY_IS_11AC_AUTO(regsty) ((regsty)->vht_enable == 2)

#define rtw_is_vht_2g4(adapter)		((adapter)->registrypriv.vht_2g4 != 0)
#define rtw_set_vht_2g4(adapter, enable) \
			((adapter)->registrypriv.vht_2g4 = (enable ? 1 : 0))

typedef struct rtw_if_operations {
	int __must_check (*read)(struct dvobj_priv *d, unsigned int addr, void *buf,
				size_t len, bool fixed);
	int __must_check (*write)(struct dvobj_priv *d, unsigned int addr, void *buf,
				 size_t len, bool fixed);
} RTW_IF_OPS, *PRTW_IF_OPS;

#ifdef CONFIG_SDIO_HCI
	#include <drv_types_sdio.h>
	#define INTF_DATA	SDIO_DATA
	#define INTF_OPS	PRTW_IF_OPS
#elif defined(CONFIG_GSPI_HCI)
	#include <drv_types_gspi.h>
	#define INTF_DATA GSPI_DATA
#elif defined(CONFIG_PCI_HCI)
	#include <drv_types_pci.h>
#endif

#define get_hw_port(adapter) (adapter->hw_port)

#ifdef CONFIG_CONCURRENT_MODE
	#define is_primary_adapter(adapter) (adapter->adapter_type == PRIMARY_ADAPTER)
	#define is_vir_adapter(adapter) (adapter->adapter_type == VIRTUAL_ADAPTER)
#else
	#define is_primary_adapter(adapter) (1)
	#define is_vir_adapter(adapter) (0)
#endif
#define GET_PRIMARY_ADAPTER(padapter) (((_adapter *)padapter)->dvobj->padapters[IFACE_ID0])
#define GET_IFACE_NUMS(padapter) (((_adapter *)padapter)->dvobj->iface_nums)
#define GET_ADAPTER(padapter, iface_id) (((_adapter *)padapter)->dvobj->padapters[iface_id])

#define GetDefaultAdapter(padapter)	padapter

enum _IFACE_ID {
	IFACE_ID0, /*PRIMARY_ADAPTER*/
	IFACE_ID1,
	IFACE_ID2,
	IFACE_ID3,
	IFACE_ID4,
	IFACE_ID5,
	IFACE_ID6,
	IFACE_ID7,
	IFACE_ID_MAX,
};

#define VIF_START_ID	1

#ifdef CONFIG_DBG_COUNTER

struct rx_logs {
	u32 intf_rx;
	u32 intf_rx_err_recvframe;
	u32 intf_rx_err_skb;
	u32 intf_rx_report;
	u32 core_rx;
	u32 core_rx_pre;
	u32 core_rx_pre_ver_err;
	u32 core_rx_pre_mgmt;
	u32 core_rx_pre_mgmt_err_80211w;
	u32 core_rx_pre_mgmt_err;
	u32 core_rx_pre_ctrl;
	u32 core_rx_pre_ctrl_err;
	u32 core_rx_pre_data;
	u32 core_rx_pre_data_wapi_seq_err;
	u32 core_rx_pre_data_wapi_key_err;
	u32 core_rx_pre_data_handled;
	u32 core_rx_pre_data_err;
	u32 core_rx_pre_data_unknown;
	u32 core_rx_pre_unknown;
	u32 core_rx_enqueue;
	u32 core_rx_dequeue;
	u32 core_rx_post;
	u32 core_rx_post_decrypt;
	u32 core_rx_post_decrypt_wep;
	u32 core_rx_post_decrypt_tkip;
	u32 core_rx_post_decrypt_aes;
	u32 core_rx_post_decrypt_wapi;
	u32 core_rx_post_decrypt_hw;
	u32 core_rx_post_decrypt_unknown;
	u32 core_rx_post_decrypt_err;
	u32 core_rx_post_defrag_err;
	u32 core_rx_post_portctrl_err;
	u32 core_rx_post_indicate;
	u32 core_rx_post_indicate_in_oder;
	u32 core_rx_post_indicate_reoder;
	u32 core_rx_post_indicate_err;
	u32 os_indicate;
	u32 os_indicate_ap_mcast;
	u32 os_indicate_ap_forward;
	u32 os_indicate_ap_self;
	u32 os_indicate_err;
	u32 os_netif_ok;
	u32 os_netif_err;
};

struct tx_logs {
	u32 os_tx;
	u32 os_tx_err_up;
	u32 os_tx_err_xmit;
	u32 os_tx_m2u;
	u32 os_tx_m2u_ignore_fw_linked;
	u32 os_tx_m2u_ignore_self;
	u32 os_tx_m2u_entry;
	u32 os_tx_m2u_entry_err_xmit;
	u32 os_tx_m2u_entry_err_skb;
	u32 os_tx_m2u_stop;
	u32 core_tx;
	u32 core_tx_err_pxmitframe;
	u32 core_tx_err_brtx;
	u32 core_tx_upd_attrib;
	u32 core_tx_upd_attrib_adhoc;
	u32 core_tx_upd_attrib_sta;
	u32 core_tx_upd_attrib_ap;
	u32 core_tx_upd_attrib_unknown;
	u32 core_tx_upd_attrib_dhcp;
	u32 core_tx_upd_attrib_icmp;
	u32 core_tx_upd_attrib_active;
	u32 core_tx_upd_attrib_err_ucast_sta;
	u32 core_tx_upd_attrib_err_ucast_ap_link;
	u32 core_tx_upd_attrib_err_sta;
	u32 core_tx_upd_attrib_err_link;
	u32 core_tx_upd_attrib_err_sec;
	u32 core_tx_ap_enqueue_warn_fwstate;
	u32 core_tx_ap_enqueue_warn_sta;
	u32 core_tx_ap_enqueue_warn_nosta;
	u32 core_tx_ap_enqueue_warn_link;
	u32 core_tx_ap_enqueue_warn_trigger;
	u32 core_tx_ap_enqueue_mcast;
	u32 core_tx_ap_enqueue_ucast;
	u32 core_tx_ap_enqueue;
	u32 intf_tx;
	u32 intf_tx_pending_ac;
	u32 intf_tx_pending_fw_under_survey;
	u32 intf_tx_pending_fw_under_linking;
	u32 intf_tx_pending_xmitbuf;
	u32 intf_tx_enqueue;
	u32 core_tx_enqueue;
	u32 core_tx_enqueue_class;
	u32 core_tx_enqueue_class_err_sta;
	u32 core_tx_enqueue_class_err_nosta;
	u32 core_tx_enqueue_class_err_fwlink;
	u32 intf_tx_direct;
	u32 intf_tx_direct_err_coalesce;
	u32 intf_tx_dequeue;
	u32 intf_tx_dequeue_err_coalesce;
	u32 intf_tx_dump_xframe;
	u32 intf_tx_dump_xframe_err_txdesc;
	u32 intf_tx_dump_xframe_err_port;
};

struct int_logs {
	u32 all;
	u32 err;
	u32 tbdok;
	u32 tbder;
	u32 bcnderr;
	u32 bcndma;
	u32 bcndma_e;
	u32 rx;
	u32 rx_rdu;
	u32 rx_fovw;
	u32 txfovw;
	u32 mgntok;
	u32 highdok;
	u32 bkdok;
	u32 bedok;
	u32 vidok;
	u32 vodok;
};

#endif /* CONFIG_DBG_COUNTER */

struct debug_priv {
	u32 dbg_sdio_free_irq_error_cnt;
	u32 dbg_sdio_alloc_irq_error_cnt;
	u32 dbg_sdio_free_irq_cnt;
	u32 dbg_sdio_alloc_irq_cnt;
	u32 dbg_sdio_deinit_error_cnt;
	u32 dbg_sdio_init_error_cnt;
	u32 dbg_suspend_error_cnt;
	u32 dbg_suspend_cnt;
	u32 dbg_resume_cnt;
	u32 dbg_resume_error_cnt;
	u32 dbg_deinit_fail_cnt;
	u32 dbg_carddisable_cnt;
	u32 dbg_carddisable_error_cnt;
	u32 dbg_ps_insuspend_cnt;
	u32	dbg_dev_unload_inIPS_cnt;
	u32 dbg_wow_leave_ps_fail_cnt;
	u32 dbg_scan_pwr_state_cnt;
	u32 dbg_downloadfw_pwr_state_cnt;
	u32 dbg_fw_read_ps_state_fail_cnt;
	u32 dbg_leave_ips_fail_cnt;
	u32 dbg_leave_lps_fail_cnt;
	u32 dbg_h2c_leave32k_fail_cnt;
	u32 dbg_diswow_dload_fw_fail_cnt;
	u32 dbg_enwow_dload_fw_fail_cnt;
	u32 dbg_ips_drvopen_fail_cnt;
	u32 dbg_poll_fail_cnt;
	u32 dbg_rpwm_toogle_cnt;
	u32 dbg_rpwm_timeout_fail_cnt;
	u32 dbg_sreset_cnt;
	u32 dbg_fw_mem_dl_error_cnt;
	u64 dbg_rx_fifo_last_overflow;
	u64 dbg_rx_fifo_curr_overflow;
	u64 dbg_rx_fifo_diff_overflow;
};

struct rtw_traffic_statistics {
	/* tx statistics */
	u64	tx_bytes;
	u64	tx_pkts;
	u64	tx_drop;
	u64	cur_tx_bytes;
	u64	last_tx_bytes;
	u32	cur_tx_tp; /* Tx throughput in Mbps. */

	/* rx statistics */
	u64	rx_bytes;
	u64	rx_pkts;
	u64	rx_drop;
	u64	cur_rx_bytes;
	u64	last_rx_bytes;
	u32	cur_rx_tp; /* Rx throughput in Mbps. */
};

#define SEC_CAP_CHK_BMC	BIT0

#define SEC_STATUS_STA_PK_GK_CONFLICT_DIS_BMC_SEARCH	BIT0

struct sec_cam_bmp {
	u32 m0;
#if (SEC_CAM_ENT_NUM_SW_LIMIT > 32)
	u32 m1;
#endif
#if (SEC_CAM_ENT_NUM_SW_LIMIT > 64)
	u32 m2;
#endif
#if (SEC_CAM_ENT_NUM_SW_LIMIT > 96)
	u32 m3;
#endif
};

struct cam_ctl_t {
	_lock lock;

	u8 sec_cap;
	u32 flags;

	u8 num;
	struct sec_cam_bmp used;

	_mutex sec_cam_access_mutex;
};

struct sec_cam_ent {
	u16 ctrl;
	u8 mac[ETH_ALEN];
	u8 key[16];
};

#define KEY_FMT "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
#define KEY_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9], ((u8 *)(x))[10], ((u8 *)(x))[11], \
	((u8 *)(x))[12], ((u8 *)(x))[13], ((u8 *)(x))[14], ((u8 *)(x))[15]

#define RTW_DEFAULT_MGMT_MACID 1

struct macid_bmp {
	u32 m0;
#if (MACID_NUM_SW_LIMIT > 32)
	u32 m1;
#endif
#if (MACID_NUM_SW_LIMIT > 64)
	u32 m2;
#endif
#if (MACID_NUM_SW_LIMIT > 96)
	u32 m3;
#endif
};

#ifdef CONFIG_CLIENT_PORT_CFG
struct clt_port_t{
	_lock lock;
	u8 bmp;
	s8 num;
};
#define get_clt_num(adapter) (adapter_to_dvobj(adapter)->clt_port.num)
#endif

struct macid_ctl_t {
	_lock lock;
	u8 num;
	struct macid_bmp used;
	struct macid_bmp bmc;
	struct macid_bmp if_g[CONFIG_IFACE_NUMBER];
	struct macid_bmp ch_g[2]; /* 2 ch concurrency */

	u8 iface_bmc[CONFIG_IFACE_NUMBER]; /* bmc TX macid for each iface*/

	u8 h2c_msr[MACID_NUM_SW_LIMIT];
	u8 bw[MACID_NUM_SW_LIMIT];
	u8 vht_en[MACID_NUM_SW_LIMIT];
	u32 rate_bmp0[MACID_NUM_SW_LIMIT];
	u32 rate_bmp1[MACID_NUM_SW_LIMIT];
	u8 op_num[H2C_MSR_ROLE_MAX]; /* number of macid having h2c_msr's OPMODE = 1 for specific ROLE */

	struct sta_info *sta[MACID_NUM_SW_LIMIT]; /* corresponding stainfo when macid is not shared */

	/* macid sleep registers */
#ifdef CONFIG_PROTSEL_MACSLEEP
	u16 reg_sleep_ctrl;
	u16 reg_sleep_info;
#else
	u16 reg_sleep_m0;
#if (MACID_NUM_SW_LIMIT > 32)
	u16 reg_sleep_m1;
#endif
#if (MACID_NUM_SW_LIMIT > 64)
	u16 reg_sleep_m2;
#endif
#if (MACID_NUM_SW_LIMIT > 96)
	u16 reg_sleep_m3;
#endif
#endif
};

/* used for rf_ctl_t.rate_bmp_cck_ofdm */
#define RATE_BMP_CCK		0x000F
#define RATE_BMP_OFDM		0xFFF0
#define RATE_BMP_HAS_CCK(_bmp_cck_ofdm)		(_bmp_cck_ofdm & RATE_BMP_CCK)
#define RATE_BMP_HAS_OFDM(_bmp_cck_ofdm)	(_bmp_cck_ofdm & RATE_BMP_OFDM)
#define RATE_BMP_GET_CCK(_bmp_cck_ofdm)		(_bmp_cck_ofdm & RATE_BMP_CCK)
#define RATE_BMP_GET_OFDM(_bmp_cck_ofdm)	((_bmp_cck_ofdm & RATE_BMP_OFDM) >> 4)

/* used for rf_ctl_t.rate_bmp_ht_by_bw */
#define RATE_BMP_HT_1SS		0x000000FF
#define RATE_BMP_HT_2SS		0x0000FF00
#define RATE_BMP_HT_3SS		0x00FF0000
#define RATE_BMP_HT_4SS		0xFF000000
#define RATE_BMP_HAS_HT_1SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_1SS)
#define RATE_BMP_HAS_HT_2SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_2SS)
#define RATE_BMP_HAS_HT_3SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_3SS)
#define RATE_BMP_HAS_HT_4SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_4SS)
#define RATE_BMP_GET_HT_1SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_1SS)
#define RATE_BMP_GET_HT_2SS(_bmp_ht)		((_bmp_ht & RATE_BMP_HT_2SS) >> 8)
#define RATE_BMP_GET_HT_3SS(_bmp_ht)		((_bmp_ht & RATE_BMP_HT_3SS) >> 16)
#define RATE_BMP_GET_HT_4SS(_bmp_ht)		((_bmp_ht & RATE_BMP_HT_4SS) >> 24)

/* used for rf_ctl_t.rate_bmp_vht_by_bw */
#define RATE_BMP_VHT_1SS	0x00000003FF
#define RATE_BMP_VHT_2SS	0x00000FFC00
#define RATE_BMP_VHT_3SS	0x003FF00000
#define RATE_BMP_VHT_4SS	0xFFC0000000
#define RATE_BMP_HAS_VHT_1SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_1SS)
#define RATE_BMP_HAS_VHT_2SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_2SS)
#define RATE_BMP_HAS_VHT_3SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_3SS)
#define RATE_BMP_HAS_VHT_4SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_4SS)
#define RATE_BMP_GET_VHT_1SS(_bmp_vht)		((u16)(_bmp_vht & RATE_BMP_VHT_1SS))
#define RATE_BMP_GET_VHT_2SS(_bmp_vht)		((u16)((_bmp_vht & RATE_BMP_VHT_2SS) >> 10))
#define RATE_BMP_GET_VHT_3SS(_bmp_vht)		((u16)((_bmp_vht & RATE_BMP_VHT_3SS) >> 20))
#define RATE_BMP_GET_VHT_4SS(_bmp_vht)		((u16)((_bmp_vht & RATE_BMP_VHT_4SS) >> 30))

#define TXPWR_LMT_REF_VHT_FROM_HT	BIT0
#define TXPWR_LMT_REF_HT_FROM_VHT	BIT1

#define TXPWR_LMT_HAS_CCK_1T	BIT0
#define TXPWR_LMT_HAS_CCK_2T	BIT1
#define TXPWR_LMT_HAS_CCK_3T	BIT2
#define TXPWR_LMT_HAS_CCK_4T	BIT3
#define TXPWR_LMT_HAS_OFDM_1T	BIT4
#define TXPWR_LMT_HAS_OFDM_2T	BIT5
#define TXPWR_LMT_HAS_OFDM_3T	BIT6
#define TXPWR_LMT_HAS_OFDM_4T	BIT7

#define OFFCHS_NONE			0
#define OFFCHS_LEAVING_OP	1
#define OFFCHS_LEAVE_OP		2
#define OFFCHS_BACKING_OP	3

struct rf_ctl_t {
	const struct country_chplan *country_ent;
	u8 ChannelPlan;
	u8 max_chan_nums;
	RT_CHANNEL_INFO channel_set[MAX_CHANNEL_NUM];
	struct p2p_channels channel_list;

	_mutex offch_mutex;
	u8 offch_state;

	/* used for debug or by tx power limit */
	u16 rate_bmp_cck_ofdm;		/* 20MHz */
	u32 rate_bmp_ht_by_bw[2];	/* 20MHz, 40MHz. 4SS supported */
	u64 rate_bmp_vht_by_bw[4];	/* 20MHz, 40MHz, 80MHz, 160MHz. 4SS supported */

#if CONFIG_TXPWR_LIMIT
	u8 highest_ht_rate_bw_bmp;
	u8 highest_vht_rate_bw_bmp;

	_mutex txpwr_lmt_mutex;
	_list reg_exc_list;
	u8 regd_exc_num;
	_list txpwr_lmt_list;
	u8 txpwr_regd_num;
	const char *regd_name;

	u8 txpwr_lmt_2g_cck_ofdm_state;
	#if CONFIG_IEEE80211_BAND_5GHZ
	u8 txpwr_lmt_5g_cck_ofdm_state;
	u8 txpwr_lmt_5g_20_40_ref;
	#endif
#endif

	bool ch_sel_within_same_band;

#if CONFIG_DFS
	u8 csa_ch;

#ifdef CONFIG_DFS_MASTER
	u8 dfs_region_domain;
	_timer radar_detect_timer;
	bool radar_detect_by_others;
	u8 radar_detect_enabled;
	bool radar_detected;

	u8 radar_detect_ch;
	u8 radar_detect_bw;
	u8 radar_detect_offset;

	systime cac_start_time;
	systime cac_end_time;
	u8 cac_force_stop;

#if CONFIG_DFS_SLAVE_WITH_RADAR_DETECT
	u8 dfs_slave_with_rd;
#endif
	u8 dfs_ch_sel_d_flags;

	u8 dbg_dfs_fake_radar_detect_cnt;
	u8 dbg_dfs_radar_detect_trigger_non;
	u8 dbg_dfs_choose_dfs_ch_first;
#endif /* CONFIG_DFS_MASTER */
#endif /* CONFIG_DFS */
};

#define RTW_CAC_STOPPED 0
#ifdef CONFIG_DFS_MASTER
#define IS_CAC_STOPPED(rfctl) ((rfctl)->cac_end_time == RTW_CAC_STOPPED)
#define IS_CH_WAITING(rfctl) (!IS_CAC_STOPPED(rfctl) && rtw_time_after((rfctl)->cac_end_time, rtw_get_current_time()))
#define IS_UNDER_CAC(rfctl) (IS_CH_WAITING(rfctl) && rtw_time_after(rtw_get_current_time(), (rfctl)->cac_start_time))
#define IS_RADAR_DETECTED(rfctl) ((rfctl)->radar_detected)
#else
#define IS_CAC_STOPPED(rfctl) 1
#define IS_CH_WAITING(rfctl) 0
#define IS_UNDER_CAC(rfctl) 0
#define IS_RADAR_DETECTED(rfctl) 0
#endif /* CONFIG_DFS_MASTER */

#if CONFIG_DFS_SLAVE_WITH_RADAR_DETECT
#define IS_DFS_SLAVE_WITH_RD(rfctl) ((rfctl)->dfs_slave_with_rd)
#else
#define IS_DFS_SLAVE_WITH_RD(rfctl) 0
#endif

#ifdef CONFIG_MBSSID_CAM
#define TOTAL_MBID_CAM_NUM	8
#define INVALID_CAM_ID			0xFF
struct mbid_cam_ctl_t {
	_lock lock;
	u8 bitmap;
	ATOMIC_T mbid_entry_num;
};
struct mbid_cam_cache {
	u8 iface_id;
	/*u8 role;*/ /*WIFI_STATION_STATE or WIFI_AP_STATE*/
	u8 mac_addr[ETH_ALEN];
};
#endif /*CONFIG_MBSSID_CAM*/

#ifdef RTW_HALMAC
struct halmac_indicator {
	struct submit_ctx *sctx;
	u8 *buffer;
	u32 buf_size;
	u32 ret_size;
	u32 status;
};

struct halmacpriv {
	/* flags */

	/* For asynchronous functions */
	struct halmac_indicator *indicator;

	/* Hardware parameters */
#ifdef CONFIG_SDIO_HCI
	/* Store hardware tx queue page number setting */
	u16 txpage[HW_QUEUE_ENTRY];
#endif /* CONFIG_SDIO_HCI */
};
#endif /* RTW_HALMAC */

#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
/*info for H2C-0x2C*/
struct dft_info {
	u8 port_id;
	u8 mac_id;
};
#endif

#ifdef CONFIG_HW_P0_TSF_SYNC
struct tsf_info {
	u8 sync_port;/*port_x's tsf sync to port_0*/
	u8 offset; /*tsf timer offset*/
};
#endif

struct protsel {
	_mutex mutex;		/* protect this structure */
	ATOMIC_T refcnt;	/* reference count */
	u32 sel;		/* save the last sel port */
};

#ifdef CONFIG_RTL8814B
#define MAX_BULKOUT_NUM 7
#ifdef CONFIG_USB_HCI
#define MAX_ENDPOINT_NUM 8
#endif
#else
#define MAX_BULKOUT_NUM 4
#ifdef CONFIG_USB_HCI
#define MAX_ENDPOINT_NUM 6
#endif
#endif

struct dvobj_priv {
	/*-------- below is common data --------*/
	u8	chip_type;
	u8	HardwareType;
	u8	interface_type;/*USB,SDIO,SPI,PCI*/

	ATOMIC_T	bSurpriseRemoved;
	ATOMIC_T	bDriverStopped;

	s32	processing_dev_remove;

	struct debug_priv drv_dbg;

	_mutex hw_init_mutex;
	_mutex h2c_fwcmd_mutex;

	_mutex ioctrl_mutex;

#ifdef CONFIG_RTW_CUSTOMER_STR
	_mutex customer_str_mutex;
	struct submit_ctx *customer_str_sctx;
	u8 customer_str[RTW_CUSTOMER_STR_LEN];
#endif

	_mutex setch_mutex;
	_mutex setbw_mutex;
	_mutex rf_read_reg_mutex;
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
	_mutex sd_indirect_access_mutex;
#endif

#ifdef CONFIG_SYSON_INDIRECT_ACCESS
	_mutex syson_indirect_access_mutex;	/* System On Reg R/W */
#endif

	unsigned char	oper_channel; /* saved channel info when call set_channel_bw */
	unsigned char	oper_bwmode;
	unsigned char	oper_ch_offset;/* PRIME_CHNL_OFFSET */
	systime on_oper_ch_time;

	_adapter *padapters[CONFIG_IFACE_NUMBER];/*IFACE_ID_MAX*/
	u8 iface_nums; /* total number of ifaces used runtime */
	struct mi_state iface_state;

#ifdef CONFIG_AP_MODE
	#ifdef CONFIG_SUPPORT_MULTI_BCN
	u8		nr_ap_if; /* total interface number of ap /go /mesh / nan mode. */
	u16		inter_bcn_space; /* unit:ms */
	_queue	ap_if_q;
	u8		vap_map;
	u8		fw_bcn_offload;
	u8		vap_tbtt_rpt_map;
	#endif /*CONFIG_SUPPORT_MULTI_BCN*/
	#ifdef CONFIG_RTW_REPEATER_SON
	struct rtw_rson_struct  rson_data;
	#endif
#endif
#ifdef CONFIG_CLIENT_PORT_CFG
	struct clt_port_t clt_port;
#endif

#ifdef CONFIG_HW_P0_TSF_SYNC
	struct tsf_info p0_tsf;
#endif
	systime periodic_tsf_update_etime;
	_timer periodic_tsf_update_end_timer;

	struct macid_ctl_t macid_ctl;

	struct cam_ctl_t cam_ctl;
	struct sec_cam_ent cam_cache[SEC_CAM_ENT_NUM_SW_LIMIT];

#ifdef CONFIG_MBSSID_CAM
	struct mbid_cam_ctl_t mbid_cam_ctl;
	struct mbid_cam_cache mbid_cam_cache[TOTAL_MBID_CAM_NUM];
#endif

	struct rf_ctl_t rf_ctl;

#if CONFIG_TX_AC_LIFETIME
	struct tx_aclt_conf_t tx_aclt_force_val;
	u8 tx_aclt_flags;
	struct tx_aclt_conf_t tx_aclt_confs[TX_ACLT_CONF_NUM];
#endif

	/* In /Out Pipe information */
	int	RtInPipe[2];
	int	RtOutPipe[MAX_BULKOUT_NUM];
	u8	Queue2Pipe[HW_QUEUE_ENTRY];/* for out pipe mapping */

	u8	irq_alloc;
	ATOMIC_T continual_io_error;

	ATOMIC_T disable_func;

	u8 xmit_block;
	_lock xmit_block_lock;

	struct pwrctrl_priv pwrctl_priv;

	struct rtw_traffic_statistics	traffic_stat;

#ifdef PLATFORM_LINUX
	_thread_hdl_ rtnl_lock_holder;

	#if defined(CONFIG_IOCTL_CFG80211) && defined(RTW_SINGLE_WIPHY)
	struct wiphy *wiphy;
	#endif
#endif /* PLATFORM_LINUX */

#ifdef CONFIG_SWTIMER_BASED_TXBCN
	_timer txbcn_timer;
#endif
	_timer dynamic_chk_timer; /* dynamic/periodic check timer */
	
#ifdef CONFIG_RTW_NAPI_DYNAMIC
	u8 en_napi_dynamic;
#endif /* CONFIG_RTW_NAPI_DYNAMIC */

#ifdef RTW_HALMAC
	void *halmac;
	struct halmacpriv hmpriv;
#endif /* RTW_HALMAC */

#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
	/*info for H2C-0x2C*/
	struct dft_info dft;
#endif

#ifdef CONFIG_RTW_WIFI_HAL
	u32 nodfs;
#endif

	/*-------- below is for SDIO INTERFACE --------*/

#ifdef INTF_DATA
	INTF_DATA intf_data;
#endif
#ifdef INTF_OPS
	INTF_OPS intf_ops;
#endif

	/*-------- below is for USB INTERFACE --------*/

#ifdef CONFIG_USB_HCI

	u8	usb_speed; /* 1.1, 2.0 or 3.0 */
	u8	nr_endpoint;
	u8	RtNumInPipes;
	u8	RtNumOutPipes;
	int	ep_num[MAX_ENDPOINT_NUM]; /* endpoint number */

	int	RegUsbSS;

	_sema	usb_suspend_sema;

#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
	_mutex  usb_vendor_req_mutex;
#endif

#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
	u8 *usb_alloc_vendor_req_buf;
	u8 *usb_vendor_req_buf;
#endif

#ifdef PLATFORM_LINUX
	struct usb_interface *pusbintf;
	struct usb_device *pusbdev;
#endif/* PLATFORM_LINUX */

#ifdef PLATFORM_FREEBSD
	struct usb_interface *pusbintf;
	struct usb_device *pusbdev;
#endif/* PLATFORM_FREEBSD */

#endif/* CONFIG_USB_HCI */

	/*-------- below is for PCIE INTERFACE --------*/

#ifdef CONFIG_PCI_HCI

#ifdef PLATFORM_LINUX
	struct pci_dev *ppcidev;

	/* PCI MEM map */
	unsigned long	pci_mem_end;	/* shared mem end	*/
	unsigned long	pci_mem_start;	/* shared mem start	*/

	/* PCI IO map */
	unsigned long	pci_base_addr;	/* device I/O address	*/

#ifdef RTK_129X_PLATFORM
	unsigned long	ctrl_start;
	/* PCI MASK addr */
	unsigned long	mask_addr;

	/* PCI TRANSLATE addr */
	unsigned long	tran_addr;

	_lock   io_reg_lock;
#endif

	/* PciBridge */
	struct pci_priv	pcipriv;

	unsigned int irq; /* get from pci_dev.irq, store to net_device.irq */
	u16	irqline;
	u8	irq_enabled;
	RT_ISR_CONTENT	isr_content;
	_lock	irq_th_lock;

	u8	bdma64;
#endif/* PLATFORM_LINUX */

#endif/* CONFIG_PCI_HCI */

#ifdef CONFIG_MCC_MODE
	struct mcc_obj_priv mcc_objpriv;
#endif /*CONFIG_MCC_MODE */

#ifdef CONFIG_RTW_TPT_MODE
	u8 tpt_mode; /* RTK T/P Testing Mode, 0:default mode */
	u32 edca_be_ul;
	u32 edca_be_dl;
#endif 
	/* also for RTK T/P Testing Mode */ 
	u8 scan_deny;

	/* protect sel to safely access */
#ifdef CONFIG_PROTSEL_PORT
	struct protsel protsel_port;
#endif
#ifdef CONFIG_PROTSEL_ATIMDTIM
	struct protsel protsel_atimdtim;
#endif
#ifdef CONFIG_PROTSEL_MACSLEEP
	struct protsel protsel_macsleep;
#endif
};

#define DEV_STA_NUM(_dvobj)			MSTATE_STA_NUM(&((_dvobj)->iface_state))
#define DEV_STA_LD_NUM(_dvobj)		MSTATE_STA_LD_NUM(&((_dvobj)->iface_state))
#define DEV_STA_LG_NUM(_dvobj)		MSTATE_STA_LG_NUM(&((_dvobj)->iface_state))
#define DEV_TDLS_LD_NUM(_dvobj)		MSTATE_TDLS_LD_NUM(&((_dvobj)->iface_state))
#define DEV_AP_NUM(_dvobj)			MSTATE_AP_NUM(&((_dvobj)->iface_state))
#define DEV_AP_STARTING_NUM(_dvobj)	MSTATE_AP_STARTING_NUM(&((_dvobj)->iface_state))
#define DEV_AP_LD_NUM(_dvobj)		MSTATE_AP_LD_NUM(&((_dvobj)->iface_state))
#define DEV_ADHOC_NUM(_dvobj)		MSTATE_ADHOC_NUM(&((_dvobj)->iface_state))
#define DEV_ADHOC_LD_NUM(_dvobj)	MSTATE_ADHOC_LD_NUM(&((_dvobj)->iface_state))
#define DEV_MESH_NUM(_dvobj)		MSTATE_MESH_NUM(&((_dvobj)->iface_state))
#define DEV_MESH_LD_NUM(_dvobj)		MSTATE_MESH_LD_NUM(&((_dvobj)->iface_state))
#define DEV_P2P_DV_NUM(_dvobj)		MSTATE_P2P_DV_NUM(&((_dvobj)->iface_state))
#define DEV_P2P_GC_NUM(_dvobj)		MSTATE_P2P_GC_NUM(&((_dvobj)->iface_state))
#define DEV_P2P_GO_NUM(_dvobj)		MSTATE_P2P_GO_NUM(&((_dvobj)->iface_state))
#define DEV_SCAN_NUM(_dvobj)		MSTATE_SCAN_NUM(&((_dvobj)->iface_state))
#define DEV_WPS_NUM(_dvobj)			MSTATE_WPS_NUM(&((_dvobj)->iface_state))
#define DEV_ROCH_NUM(_dvobj)		MSTATE_ROCH_NUM(&((_dvobj)->iface_state))
#define DEV_MGMT_TX_NUM(_dvobj)		MSTATE_MGMT_TX_NUM(&((_dvobj)->iface_state))
#define DEV_U_CH(_dvobj)			MSTATE_U_CH(&((_dvobj)->iface_state))
#define DEV_U_BW(_dvobj)			MSTATE_U_BW(&((_dvobj)->iface_state))
#define DEV_U_OFFSET(_dvobj)		MSTATE_U_OFFSET(&((_dvobj)->iface_state))

#define dvobj_to_pwrctl(dvobj) (&(dvobj->pwrctl_priv))
#define pwrctl_to_dvobj(pwrctl) container_of(pwrctl, struct dvobj_priv, pwrctl_priv)
#define dvobj_to_macidctl(dvobj) (&(dvobj->macid_ctl))
#define dvobj_to_sec_camctl(dvobj) (&(dvobj->cam_ctl))
#define dvobj_to_regsty(dvobj) (&(dvobj->padapters[IFACE_ID0]->registrypriv))
#if defined(CONFIG_IOCTL_CFG80211) && defined(RTW_SINGLE_WIPHY)
#define dvobj_to_wiphy(dvobj) ((dvobj)->wiphy)
#endif
#define dvobj_to_rfctl(dvobj) (&(dvobj->rf_ctl))
#define rfctl_to_dvobj(rfctl) container_of((rfctl), struct dvobj_priv, rf_ctl)

static inline void dev_set_surprise_removed(struct dvobj_priv *dvobj)
{
	ATOMIC_SET(&dvobj->bSurpriseRemoved, _TRUE);
}
static inline void dev_clr_surprise_removed(struct dvobj_priv *dvobj)
{
	ATOMIC_SET(&dvobj->bSurpriseRemoved, _FALSE);
}
static inline void dev_set_drv_stopped(struct dvobj_priv *dvobj)
{
	ATOMIC_SET(&dvobj->bDriverStopped, _TRUE);
}
static inline void dev_clr_drv_stopped(struct dvobj_priv *dvobj)
{
	ATOMIC_SET(&dvobj->bDriverStopped, _FALSE);
}
#define dev_is_surprise_removed(dvobj)	(ATOMIC_READ(&dvobj->bSurpriseRemoved) == _TRUE)
#define dev_is_drv_stopped(dvobj)		(ATOMIC_READ(&dvobj->bDriverStopped) == _TRUE)

#ifdef PLATFORM_LINUX
static inline struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
{
	/* todo: get interface type from dvobj and the return the dev accordingly */
#ifdef RTW_DVOBJ_CHIP_HW_TYPE
#endif

#ifdef CONFIG_USB_HCI
	return &dvobj->pusbintf->dev;
#endif
#ifdef CONFIG_SDIO_HCI
	return &dvobj->intf_data.func->dev;
#endif
#ifdef CONFIG_GSPI_HCI
	return &dvobj->intf_data.func->dev;
#endif
#ifdef CONFIG_PCI_HCI
	return &dvobj->ppcidev->dev;
#endif
}
#endif

_adapter *dvobj_get_port0_adapter(struct dvobj_priv *dvobj);
_adapter *dvobj_get_unregisterd_adapter(struct dvobj_priv *dvobj);
_adapter *dvobj_get_adapter_by_addr(struct dvobj_priv *dvobj, u8 *addr);
#define dvobj_get_primary_adapter(dvobj)	((dvobj)->padapters[IFACE_ID0])

enum _hw_port {
	HW_PORT0,
	HW_PORT1,
	HW_PORT2,
	HW_PORT3,
	HW_PORT4,
	MAX_HW_PORT,
};

#ifdef CONFIG_CLIENT_PORT_CFG
enum _client_port {
	CLT_PORT0 = HW_PORT1,
	CLT_PORT1 = HW_PORT2,
	CLT_PORT2 = HW_PORT3,
	CLT_PORT3 = HW_PORT4,
	CLT_PORT_INVALID = HW_PORT0,
};

#define MAX_CLIENT_PORT_NUM	4
#define get_clt_port(adapter) (adapter->client_port)
#endif

enum _ADAPTER_TYPE {
	PRIMARY_ADAPTER,
	VIRTUAL_ADAPTER,
	MAX_ADAPTER = 0xFF,
};

typedef enum _DRIVER_STATE {
	DRIVER_NORMAL = 0,
	DRIVER_DISAPPEAR = 1,
	DRIVER_REPLACE_DONGLE = 2,
} DRIVER_STATE;

#ifdef CONFIG_RTW_NAPI
enum _NAPI_STATE {
	NAPI_DISABLE = 0,
	NAPI_ENABLE = 1,
};
#endif

#ifdef CONFIG_MAC_LOOPBACK_DRIVER
typedef struct loopbackdata {
	_sema	sema;
	_thread_hdl_ lbkthread;
	u8 bstop;
	u32 cnt;
	u16 size;
	u16 txsize;
	u8 txbuf[0x8000];
	u16 rxsize;
	u8 rxbuf[0x8000];
	u8 msg[100];

} LOOPBACKDATA, *PLOOPBACKDATA;
#endif

#define ADAPTER_TX_BW_2G(adapter) BW_MODE_2G((adapter)->driver_tx_bw_mode)
#define ADAPTER_TX_BW_5G(adapter) BW_MODE_5G((adapter)->driver_tx_bw_mode)

struct _ADAPTER {
	int	DriverState;/* for disable driver using module, use dongle to replace module. */
	int	pid[3];/* process id from UI, 0:wps, 1:hostapd, 2:dhcpcd */
	int	bDongle;/* build-in module or external dongle */

	#if defined(CONFIG_AP_MODE) && defined(CONFIG_SUPPORT_MULTI_BCN)
	_list	list;
	u8 vap_id;
	#endif
	struct dvobj_priv *dvobj;
	struct	mlme_priv mlmepriv;
	struct	mlme_ext_priv mlmeextpriv;
	struct	cmd_priv	cmdpriv;
	struct	evt_priv	evtpriv;

#ifdef CONFIG_RTW_80211K
	struct	rm_priv		rmpriv;
#endif
	/* struct	io_queue	*pio_queue; */
	struct	io_priv	iopriv;
	struct	xmit_priv	xmitpriv;
	struct	recv_priv	recvpriv;
	struct	sta_priv	stapriv;
	struct	security_priv	securitypriv;
	_lock   security_key_mutex; /* add for CONFIG_IEEE80211W, none 11w also can use */
	struct	registry_priv	registrypriv;

#ifdef CONFIG_RTW_NAPI
	struct	napi_struct napi;
	u8	napi_state;
#endif

#ifdef CONFIG_MP_INCLUDED
	struct	mp_priv	mppriv;
#endif

#ifdef CONFIG_AP_MODE
	struct	hostapd_priv	*phostapdpriv;
#endif

#ifdef CONFIG_IOCTL_CFG80211
#ifdef CONFIG_P2P
	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
#endif /* CONFIG_P2P */
#endif /* CONFIG_IOCTL_CFG80211 */
	u32	setband;
	ATOMIC_T bandskip;

#ifdef CONFIG_P2P
	struct wifidirect_info	wdinfo;
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
	struct tdls_info	tdlsinfo;
#endif /* CONFIG_TDLS */

#ifdef CONFIG_WAPI_SUPPORT
	u8	WapiSupport;
	RT_WAPI_T	wapiInfo;
#endif

#ifdef CONFIG_RTW_REPEATER_SON
	u8	rtw_rson_scanstage;
#endif

#ifdef CONFIG_WFD
	struct wifi_display_info wfd_info;
#endif /* CONFIG_WFD */

#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
	struct bt_coex_info coex_info;
#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */

	ERROR_CODE		LastError; /* <20130613, Kordan> Only the functions associated with MP records the error code by now. */

	void *HalData;
	u32 hal_data_sz;
	struct hal_ops	hal_func;

	u32	IsrContent;
	u32	ImrContent;

	u8	EepromAddressSize;
	u8	bDriverIsGoingToUnload;
	u8	init_adpt_in_progress;
	u8	bHaltInProgress;
#ifdef CONFIG_GPIO_API
	u8	pre_gpio_pin;
	struct gpio_int_priv {
		u8 interrupt_mode;
		u8 interrupt_enable_mask;
		void (*callback[8])(u8 level);
	} gpiointpriv;
#endif
	_thread_hdl_ cmdThread;
#ifdef CONFIG_EVENT_THREAD_MODE
	_thread_hdl_ evtThread;
#endif
#ifdef CONFIG_XMIT_THREAD_MODE
	_thread_hdl_ xmitThread;
#endif
#ifdef CONFIG_RECV_THREAD_MODE
	_thread_hdl_ recvThread;
#endif
	u8 registered;

	void (*intf_start)(_adapter *adapter);
	void (*intf_stop)(_adapter *adapter);

#ifdef PLATFORM_LINUX
	_nic_hdl pnetdev;
	char old_ifname[IFNAMSIZ];

	/* used by rtw_rereg_nd_name related function */
	struct rereg_nd_name_data {
		_nic_hdl old_pnetdev;
		char old_ifname[IFNAMSIZ];
		u8 old_ips_mode;
		u8 old_bRegUseLed;
	} rereg_nd_name_priv;

	u8 ndev_unregistering;
	int bup;
	struct net_device_stats stats;
	struct iw_statistics iwstats;
	struct proc_dir_entry *dir_dev;/* for proc directory */
	struct proc_dir_entry *dir_odm;

#ifdef CONFIG_MCC_MODE
	struct proc_dir_entry *dir_mcc;
#endif /* CONFIG_MCC_MODE */

#ifdef CONFIG_IOCTL_CFG80211
	struct wireless_dev *rtw_wdev;
	struct rtw_wdev_priv wdev_data;

#if !defined(RTW_SINGLE_WIPHY)
	struct wiphy *wiphy;
#endif

#endif /* CONFIG_IOCTL_CFG80211 */

#endif /* PLATFORM_LINUX */

#ifdef PLATFORM_FREEBSD
	_nic_hdl pifp;
	int bup;
	_lock glock;
#endif /* PLATFORM_FREEBSD */
	u8 mac_addr[ETH_ALEN];
	int net_closed;

	u8 netif_up;

	u8 bLinkInfoDump;
	/*	Added by Albert 2012/10/26 */
	/*	The driver will show up the desired channel number when this flag is 1. */
	u8 bNotifyChannelChange;
	u8 bsta_tp_dump;
#ifdef CONFIG_P2P
	/*	Added by Albert 2012/12/06 */
	/*	The driver will show the current P2P status when the upper application reads it. */
	u8 bShowGetP2PState;
#endif
#ifdef CONFIG_AUTOSUSPEND
	u8	bDisableAutosuspend;
#endif

	u8 isprimary; /* is primary adapter or not */
	/* notes:
	**	if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER
	**	if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for VIRTUAL_ADAPTER
	**	refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff.*/
	u8 adapter_type;/*be used in  Multi-interface to recognize whether is PRIMARY_ADAPTER  or not(PRIMARY_ADAPTER/VIRTUAL_ADAPTER) .*/
	u8 hw_port; /*interface port type, it depends on HW port */

	#ifdef CONFIG_CLIENT_PORT_CFG
	u8 client_id;
	u8 client_port;
	#endif
	/*struct tsf_info tsf;*//*reserve define for 8814B*/

	/*extend to support multi interface*/
	u8 iface_id;

#ifdef CONFIG_BR_EXT
	_lock					br_ext_lock;
	/* unsigned int			macclone_completed; */
	struct nat25_network_db_entry	*nethash[NAT25_HASH_SIZE];
	int				pppoe_connection_in_progress;
	unsigned char			pppoe_addr[MACADDRLEN];
	unsigned char			scdb_mac[MACADDRLEN];
	unsigned char			scdb_ip[4];
	struct nat25_network_db_entry	*scdb_entry;
	unsigned char			br_mac[MACADDRLEN];
	unsigned char			br_ip[4];

	struct br_ext_info		ethBrExtInfo;
#endif /* CONFIG_BR_EXT */

#ifdef CONFIG_MAC_LOOPBACK_DRIVER
	PLOOPBACKDATA ploopback;
#endif
#ifdef CONFIG_AP_MODE
	u8 bmc_tx_rate;
#endif

	/* for debug purpose */
	u8 fix_rate;
	u8 fix_bw;
	u8 data_fb; /* data rate fallback, valid only when fix_rate is not 0xff */
	u8 power_offset;
	u8 driver_tx_bw_mode;
	u8 rsvd_page_offset;
	u8 rsvd_page_num;
#ifdef CONFIG_SUPPORT_FIFO_DUMP
	u8 fifo_sel;
	u32 fifo_addr;
	u32 fifo_size;
#endif

	u8 driver_vcs_en; /* Enable=1, Disable=0 driver control vrtl_carrier_sense for tx */
	u8 driver_vcs_type;/* force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1. */
	u8 driver_ampdu_spacing;/* driver control AMPDU Density for peer sta's rx */
	u8 driver_rx_ampdu_factor;/* 0xff: disable drv ctrl, 0:8k, 1:16k, 2:32k, 3:64k; */
	u8 driver_rx_ampdu_spacing;  /* driver control Rx AMPDU Density */
	u8 fix_rx_ampdu_accept;
	u8 fix_rx_ampdu_size; /* 0~127, TODO:consider each sta and each TID */
#ifdef CONFIG_TX_AMSDU
	u8 tx_amsdu;
	u16 tx_amsdu_rate;
#endif
	u8 driver_tx_max_agg_num; /*fix tx desc max agg num , 0xff: disable drv ctrl*/
#ifdef DBG_RX_COUNTER_DUMP
	u8 dump_rx_cnt_mode;/*BIT0:drv,BIT1:mac,BIT2:phy*/
	u32 drv_rx_cnt_ok;
	u32 drv_rx_cnt_crcerror;
	u32 drv_rx_cnt_drop;
#endif

#ifdef CONFIG_DBG_COUNTER
	struct rx_logs rx_logs;
	struct tx_logs tx_logs;
	struct int_logs int_logs;
#endif

#ifdef CONFIG_MCC_MODE
	struct mcc_adapter_priv mcc_adapterpriv;
#endif /* CONFIG_MCC_MODE */

#ifdef CONFIG_RTW_MESH
	struct rtw_mesh_cfg mesh_cfg;
	struct rtw_mesh_info mesh_info;
	_timer mesh_path_timer;
	_timer mesh_path_root_timer;
	_timer mesh_atlm_param_req_timer; /* airtime link metrics param request timer */
	_workitem mesh_work;
	unsigned long wrkq_flags;
#endif /* CONFIG_RTW_MESH */
};

#define adapter_to_dvobj(adapter) ((adapter)->dvobj)
#define adapter_to_regsty(adapter) dvobj_to_regsty(adapter_to_dvobj((adapter)))
#define adapter_to_pwrctl(adapter) dvobj_to_pwrctl(adapter_to_dvobj((adapter)))
#define adapter_wdev_data(adapter) (&((adapter)->wdev_data))
#if defined(RTW_SINGLE_WIPHY)
#define adapter_to_wiphy(adapter) dvobj_to_wiphy(adapter_to_dvobj(adapter))
#else
#define adapter_to_wiphy(adapter) ((adapter)->wiphy)
#endif

#define adapter_to_rfctl(adapter) dvobj_to_rfctl(adapter_to_dvobj((adapter)))
#define adapter_to_macidctl(adapter) dvobj_to_macidctl(adapter_to_dvobj((adapter)))

#define adapter_mac_addr(adapter) (adapter->mac_addr)
#ifdef CONFIG_RTW_CFGVENDOR_RANDOM_MAC_OUI
#define adapter_pno_mac_addr(adapter) \
	((adapter_wdev_data(adapter))->pno_mac_addr)
#endif

#define adapter_to_chset(adapter) (adapter_to_rfctl((adapter))->channel_set)

#define mlme_to_adapter(mlme) container_of((mlme), struct _ADAPTER, mlmepriv)
#define tdls_info_to_adapter(tdls) container_of((tdls), struct _ADAPTER, tdlsinfo)

#define rtw_get_chip_type(adapter) (((PADAPTER)adapter)->dvobj->chip_type)
#define rtw_get_hw_type(adapter) (((PADAPTER)adapter)->dvobj->HardwareType)
#define rtw_get_intf_type(adapter) (((PADAPTER)adapter)->dvobj->interface_type)

#define rtw_get_mi_nums(adapter) (((PADAPTER)adapter)->dvobj->iface_nums)

static inline void rtw_set_surprise_removed(_adapter *padapter)
{
	dev_set_surprise_removed(adapter_to_dvobj(padapter));
}
static inline void rtw_clr_surprise_removed(_adapter *padapter)
{
	dev_clr_surprise_removed(adapter_to_dvobj(padapter));
}
static inline void rtw_set_drv_stopped(_adapter *padapter)
{
	dev_set_drv_stopped(adapter_to_dvobj(padapter));
}
static inline void rtw_clr_drv_stopped(_adapter *padapter)
{
	dev_clr_drv_stopped(adapter_to_dvobj(padapter));
}
#define rtw_is_surprise_removed(padapter)	(dev_is_surprise_removed(adapter_to_dvobj(padapter)))
#define rtw_is_drv_stopped(padapter)		(dev_is_drv_stopped(adapter_to_dvobj(padapter)))

/*
 * Function disabled.
 *   */
#define DF_TX_BIT		BIT0			/*write_port_cancel*/
#define DF_RX_BIT		BIT1			/*read_port_cancel*/
#define DF_IO_BIT		BIT2

/* #define RTW_DISABLE_FUNC(padapter, func) (ATOMIC_ADD(&adapter_to_dvobj(padapter)->disable_func, (func))) */
/* #define RTW_ENABLE_FUNC(padapter, func) (ATOMIC_SUB(&adapter_to_dvobj(padapter)->disable_func, (func))) */
__inline static void RTW_DISABLE_FUNC(_adapter *padapter, int func_bit)
{
	int	df = ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func);
	df |= func_bit;
	ATOMIC_SET(&adapter_to_dvobj(padapter)->disable_func, df);
}

__inline static void RTW_ENABLE_FUNC(_adapter *padapter, int func_bit)
{
	int	df = ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func);
	df &= ~(func_bit);
	ATOMIC_SET(&adapter_to_dvobj(padapter)->disable_func, df);
}

#define RTW_CANNOT_RUN(padapter) \
	(rtw_is_surprise_removed(padapter) || \
	 rtw_is_drv_stopped(padapter))

#define RTW_IS_FUNC_DISABLED(padapter, func_bit) (ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func) & (func_bit))

#define RTW_CANNOT_IO(padapter) \
	(rtw_is_surprise_removed(padapter) || \
	 RTW_IS_FUNC_DISABLED((padapter), DF_IO_BIT))

#define RTW_CANNOT_RX(padapter) \
	(RTW_CANNOT_RUN(padapter) || \
	 RTW_IS_FUNC_DISABLED((padapter), DF_RX_BIT))

#define RTW_CANNOT_TX(padapter) \
	(RTW_CANNOT_RUN(padapter) || \
	 RTW_IS_FUNC_DISABLED((padapter), DF_TX_BIT))

#ifdef CONFIG_PNO_SUPPORT
int rtw_parse_ssid_list_tlv(char **list_str, pno_ssid_t *ssid, int max, int *bytes_left);
int rtw_dev_pno_set(struct net_device *net, pno_ssid_t *ssid, int num,
		    int pno_time, int pno_repeat, int pno_freq_expo_max);
#ifdef CONFIG_PNO_SET_DEBUG
	void rtw_dev_pno_debug(struct net_device *net);
#endif /* CONFIG_PNO_SET_DEBUG */
#endif /* CONFIG_PNO_SUPPORT */

int rtw_suspend_free_assoc_resource(_adapter *padapter);
#ifdef CONFIG_WOWLAN
	int rtw_suspend_wow(_adapter *padapter);
	int rtw_resume_process_wow(_adapter *padapter);
#endif

/* HCI Related header file */
#ifdef CONFIG_USB_HCI
	#include <usb_osintf.h>
	#include <usb_ops.h>
	#include <usb_hal.h>
#endif

#ifdef CONFIG_SDIO_HCI
	#include <sdio_osintf.h>
	#include <sdio_ops.h>
	#include <sdio_hal.h>
#endif

#ifdef CONFIG_GSPI_HCI
	#include <gspi_osintf.h>
	#include <gspi_ops.h>
	#include <gspi_hal.h>
#endif

#ifdef CONFIG_PCI_HCI
	#include <pci_osintf.h>
	#include <pci_ops.h>
	#include <pci_hal.h>
#endif

#endif /* __DRV_TYPES_H__ */
                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/rtl8703b_cmd.h                                                                0000644 0001750 0001750 00000027112 14214766567 015710  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_CMD_H__
#define __RTL8703B_CMD_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

enum h2c_cmd_8703B {
	/* Common Class: 000 */
	H2C_8703B_RSVD_PAGE = 0x00,
	H2C_8703B_MEDIA_STATUS_RPT = 0x01,
	H2C_8703B_SCAN_ENABLE = 0x02,
	H2C_8703B_KEEP_ALIVE = 0x03,
	H2C_8703B_DISCON_DECISION = 0x04,
	H2C_8703B_PSD_OFFLOAD = 0x05,
	H2C_8703B_AP_OFFLOAD = 0x08,
	H2C_8703B_BCN_RSVDPAGE = 0x09,
	H2C_8703B_PROBERSP_RSVDPAGE = 0x0A,
	H2C_8703B_FCS_RSVDPAGE = 0x10,
	H2C_8703B_FCS_INFO = 0x11,
	H2C_8703B_AP_WOW_GPIO_CTRL = 0x13,

	/* PoweSave Class: 001 */
	H2C_8703B_SET_PWR_MODE = 0x20,
	H2C_8703B_PS_TUNING_PARA = 0x21,
	H2C_8703B_PS_TUNING_PARA2 = 0x22,
	H2C_8703B_P2P_LPS_PARAM = 0x23,
	H2C_8703B_P2P_PS_OFFLOAD = 0x24,
	H2C_8703B_PS_SCAN_ENABLE = 0x25,
	H2C_8703B_SAP_PS_ = 0x26,
	H2C_8703B_INACTIVE_PS_ = 0x27, /* Inactive_PS */
	H2C_8703B_FWLPS_IN_IPS_ = 0x28,

	/* Dynamic Mechanism Class: 010 */
	H2C_8703B_MACID_CFG = 0x40,
	H2C_8703B_TXBF = 0x41,
	H2C_8703B_RSSI_SETTING = 0x42,
	H2C_8703B_AP_REQ_TXRPT = 0x43,
	H2C_8703B_INIT_RATE_COLLECT = 0x44,
	H2C_8703B_RA_PARA_ADJUST = 0x46,

	/* BT Class: 011 */
	H2C_8703B_B_TYPE_TDMA = 0x60,
	H2C_8703B_BT_INFO = 0x61,
	H2C_8703B_FORCE_BT_TXPWR = 0x62,
	H2C_8703B_BT_IGNORE_WLANACT = 0x63,
	H2C_8703B_DAC_SWING_VALUE = 0x64,
	H2C_8703B_ANT_SEL_RSV = 0x65,
	H2C_8703B_WL_OPMODE = 0x66,
	H2C_8703B_BT_MP_OPER = 0x67,
	H2C_8703B_BT_CONTROL = 0x68,
	H2C_8703B_BT_WIFI_CTRL = 0x69,
	H2C_8703B_BT_FW_PATCH = 0x6A,
	H2C_8703B_BT_WLAN_CALIBRATION = 0x6D,

	/* WOWLAN Class: 100 */
	H2C_8703B_WOWLAN = 0x80,
	H2C_8703B_REMOTE_WAKE_CTRL = 0x81,
	H2C_8703B_AOAC_GLOBAL_INFO = 0x82,
	H2C_8703B_AOAC_RSVD_PAGE = 0x83,
	H2C_8703B_AOAC_RSVD_PAGE2 = 0x84,
	H2C_8703B_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_8703B_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_8703B_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_8703B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
	H2C_8703B_P2P_OFFLOAD = 0x8B,

	H2C_8703B_RESET_TSF = 0xC0,
	H2C_8703B_MAXID,
};

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * _RSVDPAGE_LOC_CMD_0x00 */
#define SET_8703B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8703B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8703B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8703B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8703B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _KEEP_ALIVE_CMD_0x03 */
#define SET_8703B_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8703B_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8703B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8703B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _DISCONNECT_DECISION_CMD_0x04 */
#define SET_8703B_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8703B_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8703B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8703B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)

/* _PWR_MOD_CMD_0x20 */
#define SET_8703B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8703B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8703B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8703B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8703B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8703B_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8703B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8703B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _PS_TUNE_PARAM_CMD_0x21 */
#define SET_8703B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8703B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8703B_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
#define SET_8703B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
#define SET_8703B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _MACID_CFG_CMD_0x40 */
#define SET_8703B_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)

/* _RSSI_SETTING_CMD_0x42 */
#define SET_8703B_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8703B_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
#define SET_8703B_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _AP_REQ_TXRPT_CMD_0x43 */
#define SET_8703B_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8703B_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _FORCE_BT_TXPWR_CMD_0x62 */
#define SET_8703B_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)

/* _FORCE_BT_MP_OPER_CMD_0x67 */
#define SET_8703B_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_8703B_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_8703B_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8703B_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_8703B_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8703B_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)

/* _BT_FW_PATCH_0x6A */
#define SET_8703B_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)

/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    Function Statement     --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

/* host message to firmware cmd */
void rtl8703b_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8703b_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
void rtl8703b_fw_try_ap_cmd(PADAPTER padapter, u32 need_ack);
/* s32 rtl8703b_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable); */
void rtl8703b_set_FwPsTuneParam_cmd(PADAPTER padapter);
void rtl8703b_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
void rtl8703b_download_rsvd_page(PADAPTER padapter, u8 mstatus);
#ifdef CONFIG_BT_COEXIST
	void rtl8703b_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P
	void rtl8703b_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
	#ifdef CONFIG_TDLS_CH_SW
		void rtl8703b_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
	#endif
#endif

#ifdef CONFIG_P2P_WOWLAN
	void rtl8703b_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
#endif

void rtl8703b_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);

s32 FillH2CCmd8703B(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8703B(_adapter *padapter, bool wowlan);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/rtl8723b_rf.h                                                                 0000644 0001750 0001750 00000001530 14214766567 015552  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_RF_H__
#define __RTL8723B_RF_H__

int	PHY_RF6052_Config8723B(PADAPTER		Adapter);

void
PHY_RF6052SetBandwidth8723B(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);

#endif
                                                                                                                                                                        rtl8822bu/src/include/hal_com_h2c.h                                                                 0000644 0001750 0001750 00000105047 14214766567 015742  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __COMMON_H2C_H__
#define __COMMON_H2C_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * 88e, 8723b, 8812, 8821, 92e use the same FW code base */
enum h2c_cmd {
	/* Common Class: 000 */
	H2C_RSVD_PAGE = 0x00,
	H2C_MEDIA_STATUS_RPT = 0x01,
	H2C_SCAN_ENABLE = 0x02,
	H2C_KEEP_ALIVE = 0x03,
	H2C_DISCON_DECISION = 0x04,
	H2C_PSD_OFFLOAD = 0x05,
	H2C_CUSTOMER_STR_REQ = 0x06,
	H2C_AP_OFFLOAD = 0x08,
	H2C_BCN_RSVDPAGE = 0x09,
	H2C_PROBERSP_RSVDPAGE = 0x0A,
	H2C_FCS_RSVDPAGE = 0x10,
	H2C_FCS_INFO = 0x11,
	H2C_AP_WOW_GPIO_CTRL = 0x13,
#ifdef CONFIG_MCC_MODE
	H2C_MCC_RQT_TSF = 0x15,
	H2C_MCC_MACID_BITMAP = 0x16,
	H2C_MCC_LOCATION = 0x10,
	H2C_MCC_CTRL_V2 = 0x17,
	H2C_MCC_CTRL = 0x18,
	H2C_MCC_TIME_SETTING = 0x19,
	H2C_MCC_IQK_PARAM = 0x1A,
#endif /* CONFIG_MCC_MODE */
	H2C_CHNL_SWITCH_OPER_OFFLOAD = 0x1C,
	H2C_SINGLE_CHANNELSWITCH_V2 = 0x1D,

	/* PoweSave Class: 001 */
	H2C_SET_PWR_MODE = 0x20,
	H2C_PS_TUNING_PARA = 0x21,
	H2C_PS_TUNING_PARA2 = 0x22,
	H2C_P2P_LPS_PARAM = 0x23,
	H2C_P2P_PS_OFFLOAD = 0x24,
	H2C_PS_SCAN_ENABLE = 0x25,
	H2C_SAP_PS_ = 0x26,
	H2C_INACTIVE_PS_ = 0x27, /* Inactive_PS */
	H2C_FWLPS_IN_IPS_ = 0x28,
#ifdef CONFIG_LPS_POFF
	H2C_LPS_POFF_CTRL = 0x29,
	H2C_LPS_POFF_PARAM = 0x2A,
#endif
#ifdef CONFIG_LPS_PG
	H2C_LPS_PG_INFO = 0x2B,
#endif

#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
	H2C_DEFAULT_PORT_ID = 0x2C,
#endif
	/* Dynamic Mechanism Class: 010 */
	H2C_MACID_CFG = 0x40,
	H2C_TXBF = 0x41,
	H2C_RSSI_SETTING = 0x42,
	H2C_AP_REQ_TXRPT = 0x43,
	H2C_INIT_RATE_COLLECT = 0x44,
	H2C_IQ_CALIBRATION	= 0x45,

	H2C_RA_MASK_3SS = 0x46,/* for 8814A */
	H2C_RA_PARA_ADJUST = 0x47,/* CONFIG_RA_DBG_CMD */
	H2C_DYNAMIC_TX_PATH = 0x48,/* for 8814A */

	H2C_FW_TRACE_EN = 0x49,
#ifdef RTW_PER_CMD_SUPPORT_FW
	H2C_REQ_PER_RPT = 0x4e,
#endif
	/* BT Class: 011 */
	H2C_B_TYPE_TDMA = 0x60,
	H2C_BT_INFO = 0x61,
	H2C_FORCE_BT_TXPWR = 0x62,
	H2C_BT_IGNORE_WLANACT = 0x63,
	H2C_DAC_SWING_VALUE = 0x64,
	H2C_ANT_SEL_RSV = 0x65,
	H2C_WL_OPMODE = 0x66,
	H2C_BT_MP_OPER = 0x67,
	H2C_BT_CONTROL = 0x68,
	H2C_BT_WIFI_CTRL = 0x69,
	H2C_BT_FW_PATCH = 0x6A,
#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
	H2C_BTC_WL_PORT_ID = 0x71,
#endif
	/* WOWLAN Class: 100 */
	H2C_WOWLAN = 0x80,
	H2C_REMOTE_WAKE_CTRL = 0x81,
	H2C_AOAC_GLOBAL_INFO = 0x82,
	H2C_AOAC_RSVD_PAGE = 0x83,
	H2C_AOAC_RSVD_PAGE2 = 0x84,
	H2C_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_AOAC_RSVDPAGE3 = 0x88,
	H2C_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
	H2C_P2P_OFFLOAD = 0x8B,
#ifdef CONFIG_FW_HANDLE_TXBCN
	H2C_FW_BCN_OFFLOAD = 0xBA,
#endif
	H2C_RESET_TSF = 0xC0,
#ifdef CONFIG_FW_CORRECT_BCN
	H2C_BCNHWSEQ = 0xC5,
#endif
	H2C_CUSTOMER_STR_W1 = 0xC6,
	H2C_CUSTOMER_STR_W2 = 0xC7,
	H2C_CUSTOMER_STR_W3 = 0xC8,
#ifdef DBG_FW_DEBUG_MSG_PKT
	H2C_FW_DBG_MSG_PKT = 0xE1,
#endif /*DBG_FW_DEBUG_MSG_PKT*/
	H2C_MAXID,
};

#define H2C_INACTIVE_PS_LEN		4
#define H2C_RSVDPAGE_LOC_LEN		5
#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
#define H2C_DEFAULT_PORT_ID_LEN		2
#define H2C_MEDIA_STATUS_RPT_LEN		4
#else
#define H2C_MEDIA_STATUS_RPT_LEN		3
#endif
#define H2C_KEEP_ALIVE_CTRL_LEN	2
#define H2C_DISCON_DECISION_LEN		3
#define H2C_AP_OFFLOAD_LEN		3
#define H2C_AP_WOW_GPIO_CTRL_LEN	4
#define H2C_AP_PS_LEN			2
#define H2C_PWRMODE_LEN			7
#define H2C_PSTUNEPARAM_LEN			4
#define H2C_MACID_CFG_LEN		7
#define H2C_BTMP_OPER_LEN			5
#define H2C_WOWLAN_LEN			7
#define H2C_REMOTE_WAKE_CTRL_LEN	3
#define H2C_AOAC_GLOBAL_INFO_LEN	2
#define H2C_AOAC_RSVDPAGE_LOC_LEN	7
#define H2C_SCAN_OFFLOAD_CTRL_LEN	4
#define H2C_BT_FW_PATCH_LEN			6
#define H2C_RSSI_SETTING_LEN		4
#define H2C_AP_REQ_TXRPT_LEN		3
#define H2C_FORCE_BT_TXPWR_LEN		3
#define H2C_BCN_RSVDPAGE_LEN		5
#define H2C_PROBERSP_RSVDPAGE_LEN	5
#define H2C_P2PRSVDPAGE_LOC_LEN	5
#define H2C_P2P_OFFLOAD_LEN	3
#ifdef CONFIG_MCC_MODE
	#define H2C_MCC_CTRL_LEN			7
#ifdef CONFIG_MCC_MODE_V2
	#define H2C_MCC_LOCATION_LEN		7
#else
	#define H2C_MCC_LOCATION_LEN		3
#endif
	#define H2C_MCC_MACID_BITMAP_LEN	6
	#define H2C_MCC_RQT_TSF_LEN		1
	#define H2C_MCC_TIME_SETTING_LEN		6
	#define H2C_MCC_IQK_PARAM_LEN		7
#endif /* CONFIG_MCC_MODE */
#ifdef CONFIG_LPS_PG
#ifdef CONFIG_RTL8822C
	#define H2C_LPS_PG_INFO_LEN		4
#else
	#define H2C_LPS_PG_INFO_LEN		2
#endif
	#define H2C_LPSPG_LEN			16
#endif
#ifdef CONFIG_LPS_POFF
	#define H2C_LPS_POFF_CTRL_LEN		1
	#define H2C_LPS_POFF_PARAM_LEN		5
#endif

#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
#define H2C_BTC_WL_PORT_ID_LEN	1
#endif

#ifdef DBG_FW_DEBUG_MSG_PKT
	#define H2C_FW_DBG_MSG_PKT_LEN	2
#endif /*DBG_FW_DEBUG_MSG_PKT*/

#define H2C_SINGLE_CHANNELSWITCH_V2_LEN 2

#define eq_mac_addr(a, b)						(((a)[0] == (b)[0] && (a)[1] == (b)[1] && (a)[2] == (b)[2] && (a)[3] == (b)[3] && (a)[4] == (b)[4] && (a)[5] == (b)[5]) ? 1 : 0)
#define cp_mac_addr(des, src)					((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3], (des)[4] = (src)[4], (des)[5] = (src)[5])
#define cpIpAddr(des, src)					((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3])


#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
#define FW_WOWLAN_FUN_EN				BIT(0)
#define FW_WOWLAN_PATTERN_MATCH			BIT(1)
#define FW_WOWLAN_MAGIC_PKT				BIT(2)
#define FW_WOWLAN_UNICAST				BIT(3)
#define FW_WOWLAN_ALL_PKT_DROP			BIT(4)
#define FW_WOWLAN_GPIO_ACTIVE			BIT(5)
#define FW_WOWLAN_REKEY_WAKEUP			BIT(6)
#define FW_WOWLAN_DEAUTH_WAKEUP			BIT(7)

#define FW_WOWLAN_GPIO_WAKEUP_EN		BIT(0)
#define FW_FW_PARSE_MAGIC_PKT			BIT(1)

#define FW_REMOTE_WAKE_CTRL_EN			BIT(0)
#define FW_REALWOWLAN_EN				BIT(5)

#define FW_WOWLAN_KEEP_ALIVE_EN			BIT(0)
#define FW_ADOPT_USER					BIT(1)
#define FW_WOWLAN_KEEP_ALIVE_PKT_TYPE	BIT(2)

#define FW_REMOTE_WAKE_CTRL_EN			BIT(0)
#define FW_ARP_EN						BIT(1)
#define FW_REALWOWLAN_EN				BIT(5)
#define FW_WOW_FW_UNICAST_EN			BIT(7)

#define FW_IPS_DISABLE_BBRF		BIT(0)
#define FW_IPS_WRC				BIT(1)

#endif /* CONFIG_WOWLAN */

/* _RSVDPAGE_LOC_CMD_0x00 */
#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _MEDIA_STATUS_RPT_PARM_CMD_0x01 */
#define SET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 1, 1, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 2, 1, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 3, 1, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 4, 4, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 1, 0, 8, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 2, 0, 8, (__Value))
#define SET_H2CCMD_MSRRPT_PARM_PORT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 3, 0, 3, (__Value))

#define GET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 0, 1)
#define GET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 2, 1)
#define GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd)	LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 3, 1)
#define GET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd)			LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 4, 4)

#define H2C_MSR_ROLE_RSVD	0
#define H2C_MSR_ROLE_STA	1
#define H2C_MSR_ROLE_AP		2
#define H2C_MSR_ROLE_GC		3
#define H2C_MSR_ROLE_GO		4
#define H2C_MSR_ROLE_TDLS	5
#define H2C_MSR_ROLE_ADHOC	6
#define H2C_MSR_ROLE_MESH	7
#define H2C_MSR_ROLE_MAX	8

extern const char *const _h2c_msr_role_str[];
#define h2c_msr_role_str(role) (((role) >= H2C_MSR_ROLE_MAX) ? _h2c_msr_role_str[H2C_MSR_ROLE_MAX] : _h2c_msr_role_str[(role)])

#define H2C_MSR_FMT "%s %s%s"
#define H2C_MSR_ARG(h2c_msr) \
	GET_H2CCMD_MSRRPT_PARM_OPMODE((h2c_msr)) ? " C" : "", \
	h2c_msr_role_str(GET_H2CCMD_MSRRPT_PARM_ROLE((h2c_msr))), \
	GET_H2CCMD_MSRRPT_PARM_MIRACAST((h2c_msr)) ? (GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK((h2c_msr)) ? " MSINK" : " MSRC") : ""

s32 rtw_hal_set_FwMediaStatusRpt_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, bool macid_ind, u8 macid_end);
s32 rtw_hal_set_FwMediaStatusRpt_single_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid);
s32 rtw_hal_set_FwMediaStatusRpt_range_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, u8 macid_end);

/* _KEEP_ALIVE_CMD_0x03 */
#define SET_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_H2CCMD_KEEPALIVE_PARM_PORT_NUM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 3, __Value)
#define SET_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _DISCONNECT_DECISION_CMD_0x04 */
#define SET_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_DISCONDECISION_PARM_TRY_BCN_FAIL_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_H2CCMD_DISCONDECISION_PARM_DISCONNECT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_H2CCMD_DISCONDECISION_PORT_NUM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 3, __Value)
#define SET_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_H2CCMD_DISCONDECISION_PARM_TRY_OK_BCN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

#ifdef CONFIG_RTW_CUSTOMER_STR
#define RTW_CUSTOMER_STR_LEN 16
#define RTW_CUSTOMER_STR_FMT "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x"
#define RTW_CUSTOMER_STR_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9], ((u8 *)(x))[10], ((u8 *)(x))[11], \
	((u8 *)(x))[12], ((u8 *)(x))[13], ((u8 *)(x))[14], ((u8 *)(x))[15]

/* H2C_CUSTOMER_STR_REQ  0x06 */
#define H2C_CUSTOMER_STR_REQ_LEN 1
#define SET_H2CCMD_CUSTOMER_STR_REQ_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
s32 rtw_hal_h2c_customer_str_req(_adapter *adapter);
s32 rtw_hal_customer_str_read(_adapter *adapter, u8 *cs);

/* H2C_CUSTOMER_STR_W1 0xC6 */
#define H2C_CUSTOMER_STR_W1_LEN 7
#define SET_H2CCMD_CUSTOMER_STR_W1_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
#define H2CCMD_CUSTOMER_STR_W1_BYTE0(__pH2CCmd)				(((u8 *)(__pH2CCmd)) + 1)

/* H2C_CUSTOMER_STR_W2 0xC7 */
#define H2C_CUSTOMER_STR_W2_LEN 7
#define SET_H2CCMD_CUSTOMER_STR_W2_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
#define H2CCMD_CUSTOMER_STR_W2_BYTE6(__pH2CCmd)				(((u8 *)(__pH2CCmd)) + 1)

/* H2C_CUSTOMER_STR_W3 0xC8 */
#define H2C_CUSTOMER_STR_W3_LEN 5
#define SET_H2CCMD_CUSTOMER_STR_W3_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
#define H2CCMD_CUSTOMER_STR_W3_BYTE12(__pH2CCmd)			(((u8 *)(__pH2CCmd)) + 1)
s32 rtw_hal_h2c_customer_str_write(_adapter *adapter, const u8 *cs);
s32 rtw_hal_customer_str_write(_adapter *adapter, const u8 *cs);
#endif /* CONFIG_RTW_CUSTOMER_STR */

/* _AP_Offload 0x08 */
#define SET_H2CCMD_AP_WOWLAN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
/* _BCN_RsvdPage	0x09 */
#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_BCN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
/* _Probersp_RsvdPage 0x0a */
#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_ProbeRsp(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
/* _Probersp_RsvdPage 0x13 */
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_INDEX(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_PLUS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_HIGH_ACTIVE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_DURATION(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
/* _AP_PS 0x26 */
#define SET_H2CCMD_AP_WOW_PS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_AP_WOW_PS_32K_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_AP_WOW_PS_RF(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_H2CCMD_AP_WOW_PS_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)

/* INACTIVE_PS 0x27, duration unit is TBTT */
#define SET_H2CCMD_INACTIVE_PS_EN(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_INACTIVE_IGNORE_PS(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_INACTIVE_PERIOD_SCAN_EN(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_H2CCMD_INACTIVE_DISBBRF(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_H2CCMD_INACTIVE_PS_FREQ(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd + 1, 0, 8, __Value)
#define SET_H2CCMD_INACTIVE_PS_DURATION(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd + 2, 0, 8, __Value)
#define SET_H2CCMD_INACTIVE_PS_PERIOD_SCAN_TIME(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd + 3, 0, 8, __Value)

#ifdef CONFIG_LPS_POFF
/*PARTIAL OFF Control 0x29*/
#define SET_H2CCMD_LPS_POFF_CTRL_EN(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
/*PARTIAL OFF PARAM   0x2A*/
#define SET_H2CCMD_LPS_POFF_PARAM_RDVLD(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_LPS_POFF_PARAM_WRVLD(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_LPS_POFF_PARAM_STARTADDL(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_H2CCMD_LPS_POFF_PARAM_STARTADDH(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_H2CCMD_LPS_POFF_PARAM_ENDADDL(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_H2CCMD_LPS_POFF_PARAM_ENDADDH(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#endif

#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
/* DEFAULT PORT ID 0x2C*/
#define SET_H2CCMD_DFTPID_PORT_ID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 8, (__Value))
#define SET_H2CCMD_DFTPID_MAC_ID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 1, 0, 8, (__Value))
#endif

#ifdef CONFIG_MCC_MODE
/* MCC LOC CMD 0x10 */
#define SET_H2CCMD_MCC_RSVDPAGE_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_MCC_PWRIDX_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 3, 0, 1, __Value)
#define SET_H2CCMD_MCC_PWRIDX_OFFLOAD_RFNUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 3, 4, 4, __Value)
#define SET_H2CCMD_MCC_PWRIDX_RSVDPAGE_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 4, 0, 8, __Value)

/* MCC RQT TSF 0x15 */
#define SET_H2CCMD_MCC_RQT_TSFX(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_H2CCMD_MCC_RQT_TSFY(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)

/* MCC MAC ID CMD 0x16 */
#define SET_H2CCMD_MCC_MACID_BITMAP_L(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_MCC_MACID_BITMAP_H(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)

/* NEW MCC CTRL CMD 0x17 */
#define SET_H2CCMD_MCC_CTRL_V2_ORDER(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_TOTALNUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_CENTRAL_CH(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_PRIMARY_CH(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_BW(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 4, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_ROLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 3, __Value)			
#define SET_H2CCMD_MCC_CTRL_V2_INCURCH(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 3, 1, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_DIS_SW_RETRY(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 4, 1, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_DISTXNULL(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 5, 1, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_C2HRPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 6, 2, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_TSFX(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_NULL_EARLY(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 4, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_V2_UPDATE_PARM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 7, 1, __Value)


/* MCC CTRL CMD 0x18 */
#define SET_H2CCMD_MCC_CTRL_ORDER(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_TOTALNUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_CHIDX(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_MCC_CTRL_BW(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 2, __Value)
#define SET_H2CCMD_MCC_CTRL_BW40SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 2, 3, __Value)
#define SET_H2CCMD_MCC_CTRL_BW80SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 5, 3, __Value)
#define SET_H2CCMD_MCC_CTRL_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_H2CCMD_MCC_CTRL_ROLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 3, __Value)
#define SET_H2CCMD_MCC_CTRL_INCURCH(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 3, 1, __Value)
#define SET_H2CCMD_MCC_CTRL_RSVD0(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 4, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_RSVD1(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
#define SET_H2CCMD_MCC_CTRL_RFETYPE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 0, 4, __Value)
#define SET_H2CCMD_MCC_CTRL_DISTXNULL(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 4, 1, __Value)
#define SET_H2CCMD_MCC_CTRL_C2HRPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 5, 2, __Value)
#define SET_H2CCMD_MCC_CTRL_CHSCAN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 7, 1, __Value)

/* MCC Time CMD 0x19 */
#define SET_H2CCMD_MCC_TIME_SETTING_FW_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_MCC_TIME_SETTING_TSF_SYNC_OFFSET(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 7, __Value)
#define SET_H2CCMD_MCC_TIME_SETTING_START_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_MCC_TIME_SETTING_INTERVAL(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_H2CCMD_MCC_TIME_SETTING_EARLY_SWITCH_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define  SET_H2CCMD_MCC_TIME_SETTING_ORDER_BASE(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 4, __Value)
#define  SET_H2CCMD_MCC_TIME_SETTING_ORDER_SYNC(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 4, 4, __Value)
#define  SET_H2CCMD_MCC_TIME_SETTING_UPDATE(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 1, __Value)
#define  SET_H2CCMD_MCC_TIME_SETTING_ORDER0_DURATION(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 1, 7, __Value)

/* MCC IQK CMD 0x1A */
#define SET_H2CCMD_MCC_IQK_READY(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_MCC_IQK_ORDER(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 4, __Value)
#define SET_H2CCMD_MCC_IQK_PATH(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 2, __Value)
#define SET_H2CCMD_MCC_IQK_RX_L(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_MCC_IQK_RX_M1(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 2, __Value)
#define SET_H2CCMD_MCC_IQK_RX_M2(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 2, 6, __Value)
#define SET_H2CCMD_MCC_IQK_RX_H(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 4, __Value)
#define SET_H2CCMD_MCC_IQK_TX_L(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_H2CCMD_MCC_IQK_TX_M1(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 3, __Value)
#define SET_H2CCMD_MCC_IQK_TX_M2(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 3, 5, __Value)
#define SET_H2CCMD_MCC_IQK_TX_H(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 0, 6, __Value)
#endif /* CONFIG_MCC_MODE */

/* CHNL SWITCH OPER OFFLOAD 0x1C */
#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_CH_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_MODE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 2, __Value)
#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_40M_SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 2, 3, __Value)
#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_80M_SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 5, 3, __Value)
#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_RFE_TYPE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 2, 0, 4, __Value)

/* H2C_SINGLE_CHANNELSWITCH_V2 = 0x1D */
#define SET_H2CCMD_SINGLE_CH_SWITCH_V2_CENTRAL_CH_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_SINGLE_CH_SWITCH_V2_PRIMARY_CH_IDX(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 4, __Value)
#define SET_H2CCMD_SINGLE_CH_SWITCH_V2_BW(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 4, 4, __Value)


#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
#define SET_H2CCMD_BTC_WL_PORT_ID(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#endif

/* _WoWLAN PARAM_CMD_0x80 */
#define SET_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_H2CCMD_WOWLAN_ALL_PKT_DROP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_H2CCMD_WOWLAN_GPIO_ACTIVE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
#define SET_H2CCMD_WOWLAN_REKEY_WAKE_UP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
#define SET_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
#define SET_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 7, __Value)
#define SET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 7, 1, __Value)
#define SET_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 1, __Value)
#define SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 1, 7, __Value)
#define SET_H2CCMD_WOWLAN_DISABLE_UPHY(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 1, __Value)
#define SET_H2CCMD_WOWLAN_HST2DEV_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 1, 1, __Value)
#define SET_H2CCMD_WOWLAN_GPIO_DURATION_MS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 2, 1, __Value)
#define SET_H2CCMD_WOWLAN_CHANGE_UNIT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 2, 1, __Value)
#define SET_H2CCMD_WOWLAN_UNIT_FOR_UPHY_DISABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 3, 1, __Value)
#define SET_H2CCMD_WOWLAN_TAKE_PDN_UPHY_DIS_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 4, 1, __Value)
#define SET_H2CCMD_WOWLAN_GPIO_INPUT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 5, 1, __Value)
#define SET_H2CCMD_WOWLAN_DEV2HST_EN(__pH2CCmd, __Value) 	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 7, 1, __Value)
#define SET_H2CCMD_WOWLAN_TIME_FOR_UPHY_DISABLE(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
#define SET_H2CCMD_WOWLAN_RISE_HST2DEV(__pH2CCmd, __Value) 	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 2, 1, __Value)

/* _REMOTE_WAKEUP_CMD_0x81 */
#define SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_NDP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_NBNS_FILTER_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 2, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_TKIP_OFFLOAD_EN(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 3, 1, __Value)

#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 1, __Value)
#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_PARSING_UNTIL_WAKEUP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 4, 1, __Value)

/* AOAC_GLOBAL_INFO_0x82 */
#define SET_H2CCMD_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)

/* AOAC_RSVDPAGE_LOC_0x83 */
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NEIGHBOR_ADV(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#ifdef CONFIG_GTK_OL
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_EXT_MEM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
#endif /* CONFIG_GTK_OL */
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NDP_INFO(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 0, 8, __Value)

/* AOAC_RSVDPAGE_2_0x84 */

/* AOAC_RSVDPAGE_3_0x88 */
#ifdef CONFIG_PNO_SUPPORT
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NLO_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
#endif
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_AOAC_REPORT(__pH2CCmd, __Value) \
	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 8, __Value)

#ifdef CONFIG_PNO_SUPPORT
/* D0_Scan_Offload_Info_0x86 */
#define SET_H2CCMD_AOAC_NLO_FUN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 3, 1, __Value)
#define SET_H2CCMD_AOAC_NLO_IPS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 4, 1, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_PROBE_PACKET(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SCAN_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#endif /* CONFIG_PNO_SUPPORT */

#ifdef CONFIG_P2P_WOWLAN
/* P2P_RsvdPage_0x8a */
#define SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#endif /* CONFIG_P2P_WOWLAN */

#ifdef CONFIG_LPS_PG
#define SET_H2CCMD_LPSPG_SEC_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)/*SecurityCAM_En*/
#define SET_H2CCMD_LPSPG_MBID_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)/*BSSIDCAM_En*/
#define SET_H2CCMD_LPSPG_PMC_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)/*PatternMatchCAM_En*/
#define SET_H2CCMD_LPSPG_MACID_SEARCH_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)/*MACIDSearch_En*/
#define SET_H2CCMD_LPSPG_TXSC_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)/*TXSC_En*/
#define SET_H2CCMD_LPSPG_MU_RATE_TB_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)/*MURateTable_En*/
#define SET_H2CCMD_LPSPG_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)/*Loc_LPS_PG*/
#define SET_H2CCMD_LPSPG_DPK_INFO_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)/*Loc_LPS_PG_DPK_info*/
#define SET_H2CCMD_LPSPG_IQK_INFO_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 3, 0, 8, __Value)/*Loc_IQK_result*/
#endif

#ifdef DBG_FW_DEBUG_MSG_PKT
#define SET_H2CCMD_FW_DBG_MSG_PKT_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)/*sniffer_dbg_en*/
#define SET_H2CCMD_RSVDPAGE_LOC_FW_DBG_MSG_PKT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value) /*loc_debug_packet*/
#endif /*DBG_FW_DEBUG_MSG_PKT*/

#ifdef DBG_RSVD_PAGE_CFG
#define RSVD_PAGE_CFG(ops, v1, v2, v3)	\
	RTW_INFO("=== [RSVD][%s]-NeedPage:%d, TotalPageNum:%d TotalPacketLen:%d ===\n",	\
		ops, v1, v2, v3)
#else
#define RSVD_PAGE_CFG(ops, v1, v2, v3) do {} while (0)
#endif

/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */
typedef struct _RSVDPAGE_LOC {
	u8 LocProbeRsp;
	u8 LocPsPoll;
	u8 LocNullData;
	u8 LocQosNull;
	u8 LocBTQosNull;
#ifdef CONFIG_WOWLAN
	u8 LocRemoteCtrlInfo;
	u8 LocArpRsp;
	u8 LocNbrAdv;
	u8 LocGTKRsp;
	u8 LocGTKInfo;
	u8 LocProbeReq;
	u8 LocNetList;
#ifdef CONFIG_GTK_OL
	u8 LocGTKEXTMEM;
#endif /* CONFIG_GTK_OL */
	u8 LocNDPInfo;
	u8 LocAOACReport;
#ifdef CONFIG_PNO_SUPPORT
	u8 LocPNOInfo;
	u8 LocScanInfo;
	u8 LocSSIDInfo;
	u8 LocProbePacket;
#endif /* CONFIG_PNO_SUPPORT */
#endif /* CONFIG_WOWLAN	 */
	u8 LocApOffloadBCN;
#ifdef CONFIG_P2P_WOWLAN
	u8 LocP2PBeacon;
	u8 LocP2PProbeRsp;
	u8 LocNegoRsp;
	u8 LocInviteRsp;
	u8 LocPDRsp;
#endif /* CONFIG_P2P_WOWLAN */
#ifdef DBG_FW_DEBUG_MSG_PKT
	u8 loc_fw_dbg_msg_pkt;
#endif /*DBG_FW_DEBUG_MSG_PKT*/
} RSVDPAGE_LOC, *PRSVDPAGE_LOC;

struct rsvd_page_cache_t {
	char *name;
	u8 loc;
	u8 page_num;
	u8 *data;
	u32 size;
};

bool rsvd_page_cache_update_all(struct rsvd_page_cache_t *cache, u8 loc
	, u8 txdesc_len, u32 page_size, u8 *info, u32 info_len);
bool rsvd_page_cache_update_data(struct rsvd_page_cache_t *cache, u8 *info
	, u32 info_len);
void rsvd_page_cache_free_data(struct rsvd_page_cache_t *cache);
void rsvd_page_cache_free(struct rsvd_page_cache_t *cache);

#endif
void dump_TX_FIFO(PADAPTER padapter, u8 page_num, u16 page_size);
u8 rtw_hal_set_fw_media_status_cmd(_adapter *adapter, u8 mstatus, u8 macid);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	/* WOW command function */
	void rtw_hal_set_fw_wow_related_cmd(_adapter *padapter, u8 enable);
	#ifdef CONFIG_P2P_WOWLAN
		/* H2C 0x8A */
		u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter *adapter, PRSVDPAGE_LOC rsvdpageloc);
		/* H2C 0x8B */
		u8 rtw_hal_set_p2p_wowlan_offload_cmd(_adapter *adapter);
	#endif /* CONFIG_P2P_WOWLAN */
#endif

#ifdef RTW_PER_CMD_SUPPORT_FW
u8 rtw_hal_set_req_per_rpt_cmd(_adapter *adapter, u8 group_macid,
			       u8 rpt_type, u32 macid_bitmap);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/rtl8723d_led.h                                                                0000644 0001750 0001750 00000003036 14214766567 015714  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_LED_H__
#define __RTL8723D_LED_H__

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8723du_InitSwLeds(PADAPTER padapter);
	void rtl8723du_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
	void rtl8723ds_InitSwLeds(PADAPTER padapter);
	void rtl8723ds_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_GSPI_HCI
	void rtl8723ds_InitSwLeds(PADAPTER padapter);
	void rtl8723ds_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
	void rtl8723de_InitSwLeds(PADAPTER padapter);
	void rtl8723de_DeInitSwLeds(PADAPTER padapter);
#endif

#endif /*#ifdef CONFIG_RTW_SW_LED*/
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/include/rtl8710b_xmit.h                                                               0000644 0001750 0001750 00000057313 14214766567 016132  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_XMIT_H__
#define __RTL8710B_XMIT_H__


#define MAX_TID (15)


#ifndef __INC_HAL8710BDESC_H
#define __INC_HAL8710BDESC_H

#define RX_STATUS_DESC_SIZE_8710B		24
#define RX_DRV_INFO_SIZE_UNIT_8710B 8


/* DWORD 0 */
#define SET_RX_STATUS_DESC_PKT_LEN_8710B(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_8710B(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_8710B(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

#define GET_RX_STATUS_DESC_PKT_LEN_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICV_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_EOR_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_OWN_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_TID_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_AMSDU_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_A1_FIT_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
#define GET_RX_STATUS_DESC_CHKERR_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_IPVER_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_IS_TCPUDP__8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_CHK_VLD_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_MC_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#define GET_RX_STATUS_DESC_RX_IS_QOS_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_RPT_SEL_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)
#define GET_RX_STATUS_DESC_FCS_OK_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 31, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_HTC_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#ifdef CONFIG_USB_RX_AGGREGATION
#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
#endif
#define GET_RX_STATUS_DESC_PATTERN_MATCH_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_MATCH_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_MATCH_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

/* DWORD 6 */
#define GET_RX_STATUS_DESC_MATCH_ID_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 7)

/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_8710B(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

#define GET_RX_STATUS_DESC_BUFF_ADDR_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
#define GET_RX_STATUS_DESC_BUFF_ADDR64_8710B(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)

#define SET_RX_STATUS_DESC_BUFF_ADDR_8710B(__pRxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)


/* Dword 0, rsvd: bit26, bit28 */
#define GET_TX_DESC_OWN_8710B(__pTxDesc)\
	LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

#define SET_TX_DESC_PKT_SIZE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define SET_TX_DESC_OFFSET_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define SET_TX_DESC_BMC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_AMSDU_PAD_EN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_NO_ACM_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)

/* Dword 1 */
#define SET_TX_DESC_MACID_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
#define SET_TX_DESC_MORE_DATA_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)

/* Dword 2  remove P_AID, G_ID field*/
#define SET_TX_DESC_CCA_RTS_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_NULL0_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
#define SET_TX_DESC_NULL1_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
#define SET_TX_DESC_BK_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define SET_TX_DESC_RAW_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define SET_TX_DESC_CCX_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_INT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_FTM_EN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 30, 1, __Value)

/* Dword 3 */
#define SET_TX_DESC_NAV_USE_HDR_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
#define SET_TX_DESC_HWSEQ_SEL_8710B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_PORT_ID_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 2, __Value)
#define SET_TX_DESC_USE_MAX_LEN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_TX_TRY_RATE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
#define SET_TX_DESC_PCTS_EN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
#define SET_TX_DESC_PCTS_MASK_IDX_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)

/* Dword 5 */
#define SET_TX_DESC_DATA_SC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_STBC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_RTS_STBC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
#define SET_TX_DESC_PATH_A_EN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 1, __Value)
#define SET_TX_DESC_TXPWR_OF_SET_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)

/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_MBSSID_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
#define SET_TX_DESC_RF_SEL_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)

/* Dword 7 */
#ifdef CONFIG_PCI_HCI
#define SET_TX_DESC_TX_BUFFER_SIZE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#ifdef CONFIG_USB_HCI
#define SET_TX_DESC_TX_DESC_CHECKSUM_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#ifdef CONFIG_SDIO_HCI
#define SET_TX_DESC_TX_TIMESTAMP_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 6, 18, __Value)
#endif

#define SET_TX_DESC_USB_TXAGG_NUM_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)

/* Dword 8 */
#define SET_TX_DESC_RTS_RC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
#define SET_TX_DESC_BAR_RC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
#define SET_TX_DESC_DATA_RC_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
#define SET_TX_DESC_HWSEQ_EN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
#define SET_TX_DESC_NEXTHEADPAGE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
#define SET_TX_DESC_TAILPAGE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)

/* Dword 9 */
#define SET_TX_DESC_PADDING_LEN_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
#define SET_TX_DESC_SEQ_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
#define SET_TX_DESC_FINAL_DATA_RATE_8710B(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 8, __Value)


#define SET_EARLYMODE_PKTNUM_8710B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_8710B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_8710B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_8710B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_8710B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
#define SET_EARLYMODE_LEN3_8710B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)


/*-----------------------------------------------------------------*/
/*	RTL8710B TX BUFFER DESC                                      */
/*-----------------------------------------------------------------*/
#ifdef CONFIG_64BIT_DMA
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+4, 0, 32, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+8, 0, 32, __Valeu)
#else
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu)	/* 64 BIT mode only */
#endif
/* ********************************************************* */

/* 64 bits  -- 32 bits */
/* =======     ======= */
/* Dword 0     0 */
#define SET_TX_BUFF_DESC_LEN_0_8710B(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 14, __Valeu)
#define SET_TX_BUFF_DESC_PSB_8710B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
#define SET_TX_BUFF_DESC_OWN_8710B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

/* Dword 1     1 */
#define SET_TX_BUFF_DESC_ADDR_LOW_0_8710B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
#define GET_TX_BUFF_DESC_ADDR_LOW_0_8710B(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0, 32)
/* Dword 2     NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_0_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 0, __Value)
#ifdef CONFIG_64BIT_DMA
	#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8710B(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+8, 0, 32)
#else
	#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8710B(__pTxDesc) 0
#endif
/* Dword 3     NA */
/* RESERVED 0 */
/* Dword 4     2 */
#define SET_TX_BUFF_DESC_LEN_1_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 1, __Value)
#define SET_TX_BUFF_DESC_AMSDU_1_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 5     3 */
#define SET_TX_BUFF_DESC_ADDR_LOW_1_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 6     NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_1_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 7     NA */
/*RESERVED 0 */
/* Dword 8     4 */
#define SET_TX_BUFF_DESC_LEN_2_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 2, __Value)
#define SET_TX_BUFF_DESC_AMSDU_2_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 9     5 */
#define SET_TX_BUFF_DESC_ADDR_LOW_2_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 10    NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_2_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 11    NA */
/*RESERVED 0 */
/* Dword 12    6 */
#define SET_TX_BUFF_DESC_LEN_3_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 3, __Value)
#define SET_TX_BUFF_DESC_AMSDU_3_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 13    7 */
#define SET_TX_BUFF_DESC_ADDR_LOW_3_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 14    NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_3_8710B(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 15    NA */
/*RESERVED 0 */


#endif
/* -----------------------------------------------------------
 *
 *	Rate
 *
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC8710B_RATE1M				0x00
#define DESC8710B_RATE2M				0x01
#define DESC8710B_RATE5_5M				0x02
#define DESC8710B_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC8710B_RATE6M				0x04
#define DESC8710B_RATE9M				0x05
#define DESC8710B_RATE12M				0x06
#define DESC8710B_RATE18M				0x07
#define DESC8710B_RATE24M				0x08
#define DESC8710B_RATE36M				0x09
#define DESC8710B_RATE48M				0x0a
#define DESC8710B_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC8710B_RATEMCS0				0x0c
#define DESC8710B_RATEMCS1				0x0d
#define DESC8710B_RATEMCS2				0x0e
#define DESC8710B_RATEMCS3				0x0f
#define DESC8710B_RATEMCS4				0x10
#define DESC8710B_RATEMCS5				0x11
#define DESC8710B_RATEMCS6				0x12
#define DESC8710B_RATEMCS7				0x13
#define DESC8710B_RATEMCS8				0x14
#define DESC8710B_RATEMCS9				0x15
#define DESC8710B_RATEMCS10		0x16
#define DESC8710B_RATEMCS11		0x17
#define DESC8710B_RATEMCS12		0x18
#define DESC8710B_RATEMCS13		0x19
#define DESC8710B_RATEMCS14		0x1a
#define DESC8710B_RATEMCS15		0x1b
#define DESC8710B_RATEVHTSS1MCS0		0x2c
#define DESC8710B_RATEVHTSS1MCS1		0x2d
#define DESC8710B_RATEVHTSS1MCS2		0x2e
#define DESC8710B_RATEVHTSS1MCS3		0x2f
#define DESC8710B_RATEVHTSS1MCS4		0x30
#define DESC8710B_RATEVHTSS1MCS5		0x31
#define DESC8710B_RATEVHTSS1MCS6		0x32
#define DESC8710B_RATEVHTSS1MCS7		0x33
#define DESC8710B_RATEVHTSS1MCS8		0x34
#define DESC8710B_RATEVHTSS1MCS9		0x35
#define DESC8710B_RATEVHTSS2MCS0		0x36
#define DESC8710B_RATEVHTSS2MCS1		0x37
#define DESC8710B_RATEVHTSS2MCS2		0x38
#define DESC8710B_RATEVHTSS2MCS3		0x39
#define DESC8710B_RATEVHTSS2MCS4		0x3a
#define DESC8710B_RATEVHTSS2MCS5		0x3b
#define DESC8710B_RATEVHTSS2MCS6		0x3c
#define DESC8710B_RATEVHTSS2MCS7		0x3d
#define DESC8710B_RATEVHTSS2MCS8		0x3e
#define DESC8710B_RATEVHTSS2MCS9		0x3f


#define	RX_HAL_IS_CCK_RATE_8710B(pDesc)\
	(GET_RX_STATUS_DESC_RX_RATE_8710B(pDesc) == DESC8710B_RATE1M || \
	 GET_RX_STATUS_DESC_RX_RATE_8710B(pDesc) == DESC8710B_RATE2M || \
	 GET_RX_STATUS_DESC_RX_RATE_8710B(pDesc) == DESC8710B_RATE5_5M || \
	 GET_RX_STATUS_DESC_RX_RATE_8710B(pDesc) == DESC8710B_RATE11M)

#ifdef CONFIG_TRX_BD_ARCH
	struct tx_desc;
#endif

void rtl8710b_cal_txdesc_chksum(struct tx_desc *ptxdesc);
void rtl8710b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
void rtl8710b_fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8710b_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8710b_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8710b_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);

#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8710bs_init_xmit_priv(PADAPTER padapter);
	void rtl8710bs_free_xmit_priv(PADAPTER padapter);
	s32 rtl8710bs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8710bs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8710bs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8710bs_xmit_buf_handler(PADAPTER padapter);
	thread_return rtl8710bs_xmit_thread(thread_context context);
	#define hal_xmit_handler rtl8710bs_xmit_buf_handler
#endif

#ifdef CONFIG_USB_HCI
	s32 rtl8710bu_xmit_buf_handler(PADAPTER padapter);
	#define hal_xmit_handler rtl8710bu_xmit_buf_handler
	s32 rtl8710bu_init_xmit_priv(PADAPTER padapter);
	void rtl8710bu_free_xmit_priv(PADAPTER padapter);
	s32 rtl8710bu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8710bu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	 rtl8710bu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8710bu_xmit_tasklet(void *priv);
	s32 rtl8710bu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
	void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8710be_init_xmit_priv(PADAPTER padapter);
	void rtl8710be_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8710be_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	void	rtl8710be_xmitframe_resume(_adapter *padapter);
	s32 rtl8710be_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8710be_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8710be_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8710be_xmit_tasklet(void *priv);
#endif

u8	BWMapping_8710B(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_8710B(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif
                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/rtw_ioctl.h                                                                   0000644 0001750 0001750 00000003013 14214766567 015600  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_IOCTL_H_
#define _RTW_IOCTL_H_

enum oid_type {
	QUERY_OID,
	SET_OID
};

struct oid_par_priv {
	void		*adapter_context;
	NDIS_OID	oid;
	void		*information_buf;
	u32		information_buf_len;
	u32		*bytes_rw;
	u32		*bytes_needed;
	enum oid_type	type_of_oid;
	u32		dbg;
};

#if defined(PLATFORM_LINUX) && defined(CONFIG_WIRELESS_EXT)
extern struct iw_handler_def  rtw_handlers_def;
#endif

extern void rtw_request_wps_pbc_event(_adapter *padapter);

#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
extern int rtw_vendor_ie_get_raw_data(struct net_device *, u32, char *, u32);
extern int rtw_vendor_ie_get_data(struct net_device*, int , char*);
extern int rtw_vendor_ie_get(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
extern int rtw_vendor_ie_set(struct net_device*, struct iw_request_info*, union iwreq_data*, char*);
#endif

#endif /*  #ifndef __INC_CEINFO_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/hal_btcoex.h                                                                  0000644 0001750 0001750 00000011015 14214766567 015703  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_BTCOEX_H__
#define __HAL_BTCOEX_H__

#include <drv_types.h>

/* Some variables can't get from outsrc BT-Coex,
 * so we need to save here */
typedef struct _BT_COEXIST {
	u8 bBtExist;
	u8 btTotalAntNum;
	u8 btChipType;
	u8 bInitlized;
	u8 btAntisolation;
} BT_COEXIST, *PBT_COEXIST;

void DBG_BT_INFO(u8 *dbgmsg);

void hal_btcoex_SetBTCoexist(PADAPTER padapter, u8 bBtExist);
u8 hal_btcoex_IsBtExist(PADAPTER padapter);
u8 hal_btcoex_IsBtDisabled(PADAPTER);
void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType);
void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum);

u8 hal_btcoex_Initialize(PADAPTER padapter);
void hal_btcoex_PowerOnSetting(PADAPTER padapter);
void hal_btcoex_AntInfoSetting(PADAPTER padapter);
void hal_btcoex_PowerOffSetting(PADAPTER padapter);
void hal_btcoex_PreLoadFirmware(PADAPTER padapter);
void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly);

void hal_btcoex_IpsNotify(PADAPTER padapter, u8 type);
void hal_btcoex_LpsNotify(PADAPTER padapter, u8 type);
void hal_btcoex_ScanNotify(PADAPTER padapter, u8 type);
void hal_btcoex_ConnectNotify(PADAPTER padapter, u8 action);
void hal_btcoex_MediaStatusNotify(PADAPTER padapter, u8 mediaStatus);
void hal_btcoex_SpecialPacketNotify(PADAPTER padapter, u8 pktType);
void hal_btcoex_IQKNotify(PADAPTER padapter, u8 state);
void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
void hal_btcoex_BtMpRptNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state);
void hal_btcoex_HaltNotify(PADAPTER padapter, u8 do_halt);
void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter);

void hal_btcoex_Hanlder(PADAPTER padapter);

s32 hal_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER padapter);
u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter);
void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual);
u8 hal_btcoex_1Ant(PADAPTER padapter);
u8 hal_btcoex_IsBtControlLps(PADAPTER);
u8 hal_btcoex_IsLpsOn(PADAPTER);
u8 hal_btcoex_RpwmVal(PADAPTER);
u8 hal_btcoex_LpsVal(PADAPTER);
u32 hal_btcoex_GetRaMask(PADAPTER);
u8 hal_btcoex_query_reduced_wl_pwr_lvl(PADAPTER padapter);
void hal_btcoex_set_reduced_wl_pwr_lvl(PADAPTER padapter, u8 val);
void hal_btcoex_do_reduce_wl_pwr_lvl(PADAPTER padapter);
void hal_btcoex_RecordPwrMode(PADAPTER padapter, u8 *pCmdBuf, u8 cmdLen);
void hal_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
void hal_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
u32 hal_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER);
u8 hal_btcoex_IsBtLinkExist(PADAPTER);
void hal_btcoex_SetBtPatchVersion(PADAPTER, u16 btHciVer, u16 btPatchVer);
void hal_btcoex_SetHciVersion(PADAPTER, u16 hciVersion);
void hal_btcoex_SendScanNotify(PADAPTER, u8 type);
void hal_btcoex_StackUpdateProfileInfo(void);
void hal_btcoex_pta_off_on_notify(PADAPTER padapter, u8 bBTON);
void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype);
#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
	int hal_btcoex_AntIsolationConfig_ParaFile(PADAPTER	Adapter, char *pFileName);
	int hal_btcoex_ParseAntIsolationConfigFile(PADAPTER Adapter, char	*buffer);
#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
u16 hal_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
u16 hal_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
void hal_btcoex_set_rfe_type(u8 type);
void hal_btcoex_switchband_notify(u8 under_scan, u8 band_type);
void hal_btcoex_WlFwDbgInfoNotify(PADAPTER padapter, u8* tmpBuf, u8 length);
void hal_btcoex_rx_rate_change_notify(PADAPTER padapter, u8 is_data_frame, u8 rate_id);
u16 hal_btcoex_btset_testode(PADAPTER padapter, u8 type);

#ifdef CONFIG_RF4CE_COEXIST
void hal_btcoex_set_rf4ce_link_state(u8 state);
u8 hal_btcoex_get_rf4ce_link_state(void);
#endif

#ifdef CONFIG_SDIO_HCI
#include <hal_sdio_coex.h>	/* sdio multi coex */
#endif

#endif /* !__HAL_BTCOEX_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/rtw_debug.h                                                                   0000644 0001750 0001750 00000064305 14214766567 015567  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_DEBUG_H__
#define __RTW_DEBUG_H__

/* driver log level*/
enum {
	_DRV_NONE_ = 0,
	_DRV_ALWAYS_ = 1,
	_DRV_ERR_ = 2,
	_DRV_WARNING_ = 3,
	_DRV_INFO_ = 4,
	_DRV_DEBUG_ = 5,
	_DRV_MAX_ = 6
};

#define DRIVER_PREFIX "RTW: "

#ifdef PLATFORM_OS_CE
extern void rtl871x_cedbg(const char *fmt, ...);
#endif

#ifdef PLATFORM_WINDOWS
	#define RTW_PRINT do {} while (0)
	#define RTW_ERR do {} while (0)
	#define RTW_WARN do {} while (0)
	#define RTW_INFO do {} while (0)
	#define RTW_DBG do {} while (0)
	#define RTW_PRINT_SEL do {} while (0)
	#define _RTW_PRINT do {} while (0)
	#define _RTW_ERR do {} while (0)
	#define _RTW_WARN do {} while (0)
	#define _RTW_INFO do {} while (0)
	#define _RTW_DBG do {} while (0)
	#define _RTW_PRINT_SEL do {} while (0)
#else
	#define RTW_PRINT(x, ...) do {} while (0)
	#define RTW_ERR(x, ...) do {} while (0)
	#define RTW_WARN(x,...) do {} while (0)
	#define RTW_INFO(x,...) do {} while (0)
	#define RTW_DBG(x,...) do {} while (0)
	#define RTW_PRINT_SEL(x,...) do {} while (0)
	#define _RTW_PRINT(x, ...) do {} while (0)
	#define _RTW_ERR(x, ...) do {} while (0)
	#define _RTW_WARN(x,...) do {} while (0)
	#define _RTW_INFO(x,...) do {} while (0)
	#define _RTW_DBG(x,...) do {} while (0)
	#define _RTW_PRINT_SEL(x,...) do {} while (0)
#endif

#define RTW_INFO_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
#define RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
#define RTW_PRINT_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)

#define RTW_DBG_EXPR(EXPR) do {} while (0)

#define RTW_DBGDUMP 0 /* 'stream' for _dbgdump */



#undef _dbgdump
#undef _seqdump

#if defined(PLATFORM_WINDOWS) && defined(PLATFORM_OS_XP)
	#define _dbgdump DbgPrint
	#define KERN_CONT
	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
#elif defined(PLATFORM_WINDOWS) && defined(PLATFORM_OS_CE)
	#define _dbgdump rtl871x_cedbg
	#define KERN_CONT
	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
#elif defined PLATFORM_LINUX
	#define _dbgdump printk
	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
	#define KERN_CONT
	#endif
	#define _seqdump seq_printf
#elif defined PLATFORM_FREEBSD
	#define _dbgdump printf
	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
	#define KERN_CONT
	#endif
	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
#endif

void RTW_BUF_DUMP_SEL(uint _loglevel, void *sel, u8 *_titlestring,
								bool _idx_show, const u8 *_hexdata, int _hexdatalen);

#ifdef CONFIG_RTW_DEBUG

#ifndef _OS_INTFS_C_
extern uint rtw_drv_log_level;
#endif

#if defined(_dbgdump)

#ifdef PLATFORM_LINUX
#ifdef DBG_THREAD_PID
#define T_PID_FMT	"(%5u) "
#define T_PID_ARG	current->pid
#else /* !DBG_THREAD_PID */
#define T_PID_FMT	"%s"
#define T_PID_ARG	""
#endif /* !DBG_THREAD_PID */

#ifdef DBG_CPU_INFO
#define CPU_INFO_FMT	"[%u] "
#define CPU_INFO_ARG	get_cpu()
#else /* !DBG_CPU_INFO */
#define CPU_INFO_FMT	"%s"
#define CPU_INFO_ARG	""
#endif /* !DBG_CPU_INFO */

/* Extra information in prefix */
#define EX_INFO_FMT	T_PID_FMT CPU_INFO_FMT
#define EX_INFO_ARG	T_PID_ARG, CPU_INFO_ARG
#else /* !PLATFORM_LINUX */
#define EX_INFO_FMT	"%s"
#define EX_INFO_ARG	""
#endif /* !PLATFORM_LINUX */

/* with driver-defined prefix */
#undef RTW_PRINT
#define RTW_PRINT(fmt, arg...)     \
	do {\
		if (_DRV_ALWAYS_ <= rtw_drv_log_level) {\
			_dbgdump(EX_INFO_FMT DRIVER_PREFIX fmt, \
				 EX_INFO_ARG, ##arg);\
		} \
	} while (0)

#undef RTW_ERR
#define RTW_ERR(fmt, arg...)     \
	do {\
		if (_DRV_ERR_ <= rtw_drv_log_level) {\
			_dbgdump(EX_INFO_FMT DRIVER_PREFIX "ERROR " fmt, \
				 EX_INFO_ARG, ##arg);\
		} \
	} while (0)


#undef RTW_WARN
#define RTW_WARN(fmt, arg...)     \
	do {\
		if (_DRV_WARNING_ <= rtw_drv_log_level) {\
			_dbgdump(EX_INFO_FMT DRIVER_PREFIX "WARN " fmt, \
				 EX_INFO_ARG, ##arg);\
		} \
	} while (0)

#undef RTW_INFO
#define RTW_INFO(fmt, arg...)     \
	do {\
		if (_DRV_INFO_ <= rtw_drv_log_level) {\
			_dbgdump(EX_INFO_FMT DRIVER_PREFIX fmt, \
				 EX_INFO_ARG, ##arg);\
		} \
	} while (0)


#undef RTW_DBG
#define RTW_DBG(fmt, arg...)     \
	do {\
		if (_DRV_DEBUG_ <= rtw_drv_log_level) {\
			_dbgdump(EX_INFO_FMT DRIVER_PREFIX fmt, \
				 EX_INFO_ARG, ##arg);\
		} \
	} while (0)

#undef RTW_INFO_DUMP
#define RTW_INFO_DUMP(_TitleString, _HexData, _HexDataLen)	\
	RTW_BUF_DUMP_SEL(_DRV_INFO_, RTW_DBGDUMP, _TitleString, _FALSE, _HexData, _HexDataLen)

#undef RTW_DBG_DUMP
#define RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen)	\
	RTW_BUF_DUMP_SEL(_DRV_DEBUG_, RTW_DBGDUMP, _TitleString, _FALSE, _HexData, _HexDataLen)


#undef RTW_PRINT_DUMP
#define RTW_PRINT_DUMP(_TitleString, _HexData, _HexDataLen)	\
	RTW_BUF_DUMP_SEL(_DRV_ALWAYS_, RTW_DBGDUMP, _TitleString, _FALSE, _HexData, _HexDataLen)

/* without driver-defined prefix */
#undef _RTW_PRINT
#define _RTW_PRINT(fmt, arg...)     \
	do {\
		if (_DRV_ALWAYS_ <= rtw_drv_log_level) {\
			_dbgdump(KERN_CONT fmt, ##arg);\
		} \
	} while (0)

#undef _RTW_ERR
#define _RTW_ERR(fmt, arg...)     \
	do {\
		if (_DRV_ERR_ <= rtw_drv_log_level) {\
			_dbgdump(KERN_CONT fmt, ##arg);\
		} \
	} while (0)


#undef _RTW_WARN
#define _RTW_WARN(fmt, arg...)     \
	do {\
		if (_DRV_WARNING_ <= rtw_drv_log_level) {\
			_dbgdump(KERN_CONT fmt, ##arg);\
		} \
	} while (0)

#undef _RTW_INFO
#define _RTW_INFO(fmt, arg...)     \
	do {\
		if (_DRV_INFO_ <= rtw_drv_log_level) {\
			_dbgdump(KERN_CONT fmt, ##arg);\
		} \
	} while (0)

#undef _RTW_DBG
#define _RTW_DBG(fmt, arg...)     \
	do {\
		if (_DRV_DEBUG_ <= rtw_drv_log_level) {\
			_dbgdump(KERN_CONT fmt, ##arg);\
		} \
	} while (0)


/* other debug APIs */
#undef RTW_DBG_EXPR
#define RTW_DBG_EXPR(EXPR) do { if (_DRV_DEBUG_ <= rtw_drv_log_level) EXPR; } while (0)

#endif /* defined(_dbgdump) */
#endif /* CONFIG_RTW_DEBUG */


#if defined(_seqdump)
/* dump message to selected 'stream' with driver-defined prefix */
#undef RTW_PRINT_SEL
#define RTW_PRINT_SEL(sel, fmt, arg...) \
	do {\
		if (sel == RTW_DBGDUMP)\
			RTW_PRINT(fmt, ##arg); \
		else {\
			_seqdump(sel, fmt, ##arg) /*rtw_warn_on(1)*/; \
		} \
	} while (0)

/* dump message to selected 'stream' */
#undef _RTW_PRINT_SEL
#define _RTW_PRINT_SEL(sel, fmt, arg...) \
	do {\
		if (sel == RTW_DBGDUMP)\
			_RTW_PRINT(fmt, ##arg); \
		else {\
			_seqdump(sel, fmt, ##arg) /*rtw_warn_on(1)*/; \
		} \
	} while (0)

/* dump message to selected 'stream' */
#undef RTW_DUMP_SEL
#define RTW_DUMP_SEL(sel, _HexData, _HexDataLen) \
	RTW_BUF_DUMP_SEL(_DRV_ALWAYS_, sel, NULL, _FALSE, _HexData, _HexDataLen)

#define RTW_MAP_DUMP_SEL(sel, _TitleString, _HexData, _HexDataLen) \
	RTW_BUF_DUMP_SEL(_DRV_ALWAYS_, sel, _TitleString, _TRUE, _HexData, _HexDataLen)
#endif /* defined(_seqdump) */


#ifdef CONFIG_DBG_COUNTER
	#define DBG_COUNTER(counter) counter++
#else
	#define DBG_COUNTER(counter)
#endif

void dump_drv_version(void *sel);
void dump_log_level(void *sel);
void dump_drv_cfg(void *sel);

#ifdef CONFIG_SDIO_HCI
void sd_f0_reg_dump(void *sel, _adapter *adapter);
void sdio_local_reg_dump(void *sel, _adapter *adapter);
#endif /* CONFIG_SDIO_HCI */

void mac_reg_dump(void *sel, _adapter *adapter);
void bb_reg_dump(void *sel, _adapter *adapter);
void bb_reg_dump_ex(void *sel, _adapter *adapter);
void rf_reg_dump(void *sel, _adapter *adapter);

void rtw_sink_rtp_seq_dbg(_adapter *adapter, u8 *ehdr_pos);

struct sta_info;
void sta_rx_reorder_ctl_dump(void *sel, struct sta_info *sta);

struct dvobj_priv;
void dump_tx_rate_bmp(void *sel, struct dvobj_priv *dvobj);
void dump_adapters_status(void *sel, struct dvobj_priv *dvobj);

struct sec_cam_ent;
void dump_sec_cam_ent(void *sel, struct sec_cam_ent *ent, int id);
void dump_sec_cam_ent_title(void *sel, u8 has_id);
void dump_sec_cam(void *sel, _adapter *adapter);
void dump_sec_cam_cache(void *sel, _adapter *adapter);

bool rtw_fwdl_test_trigger_chksum_fail(void);
bool rtw_fwdl_test_trigger_wintint_rdy_fail(void);
bool rtw_del_rx_ampdu_test_trigger_no_tx_fail(void);
u32 rtw_get_wait_hiq_empty_ms(void);
void rtw_sta_linking_test_set_start(void);
bool rtw_sta_linking_test_wait_done(void);
bool rtw_sta_linking_test_force_fail(void);
#ifdef CONFIG_AP_MODE
u16 rtw_ap_linking_test_force_auth_fail(void);
u16 rtw_ap_linking_test_force_asoc_fail(void);
#endif

#ifdef CONFIG_PROC_DEBUG
ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_read_reg(struct seq_file *m, void *v);
ssize_t proc_set_read_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_fwstate(struct seq_file *m, void *v);
int proc_get_sec_info(struct seq_file *m, void *v);
int proc_get_mlmext_state(struct seq_file *m, void *v);
#ifdef CONFIG_LAYER2_ROAMING
int proc_get_roam_flags(struct seq_file *m, void *v);
ssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_roam_param(struct seq_file *m, void *v);
ssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif /* CONFIG_LAYER2_ROAMING */
#ifdef CONFIG_RTW_80211R
int proc_get_ft_flags(struct seq_file *m, void *v);
ssize_t proc_set_ft_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
int proc_get_qos_option(struct seq_file *m, void *v);
int proc_get_ht_option(struct seq_file *m, void *v);
int proc_get_rf_info(struct seq_file *m, void *v);
int proc_get_scan_param(struct seq_file *m, void *v);
ssize_t proc_set_scan_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_scan_abort(struct seq_file *m, void *v);
#ifdef CONFIG_RTW_REPEATER_SON
int proc_get_rson_data(struct seq_file *m, void *v);
ssize_t proc_set_rson_data(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
int proc_get_survey_info(struct seq_file *m, void *v);
ssize_t proc_set_survey_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_ap_info(struct seq_file *m, void *v);
#ifdef ROKU_PRIVATE
int proc_get_infra_ap(struct seq_file *m, void *v);
#endif /* ROKU_PRIVATE */
ssize_t proc_reset_trx_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_trx_info(struct seq_file *m, void *v);
ssize_t proc_set_tx_power_offset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_tx_power_offset(struct seq_file *m, void *v);
int proc_get_rate_ctl(struct seq_file *m, void *v);
int proc_get_wifi_spec(struct seq_file *m, void *v);
ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_bw_ctl(struct seq_file *m, void *v);
ssize_t proc_set_bw_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#ifdef DBG_RX_COUNTER_DUMP
int proc_get_rx_cnt_dump(struct seq_file *m, void *v);
ssize_t proc_set_rx_cnt_dump(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif

#ifdef CONFIG_AP_MODE
int proc_get_bmc_tx_rate(struct seq_file *m, void *v);
ssize_t proc_set_bmc_tx_rate(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif /*CONFIG_AP_MODE*/

int proc_get_ps_dbg_info(struct seq_file *m, void *v);
ssize_t proc_set_ps_dbg_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_del_rx_ampdu_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_sta_linking_test(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#ifdef CONFIG_AP_MODE
ssize_t proc_set_ap_linking_test(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif

int proc_get_rx_stat(struct seq_file *m, void *v);
int proc_get_tx_stat(struct seq_file *m, void *v);
#ifdef CONFIG_AP_MODE
int proc_get_all_sta_info(struct seq_file *m, void *v);
#endif /* CONFIG_AP_MODE */

#ifdef DBG_MEMORY_LEAK
int proc_get_malloc_cnt(struct seq_file *m, void *v);
#endif /* DBG_MEMORY_LEAK */

#ifdef CONFIG_FIND_BEST_CHANNEL
int proc_get_best_channel(struct seq_file *m, void *v);
ssize_t proc_set_best_channel(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif /* CONFIG_FIND_BEST_CHANNEL */

int proc_get_trx_info_debug(struct seq_file *m, void *v);

#ifdef CONFIG_HUAWEI_PROC
int proc_get_huawei_trx_info(struct seq_file *m, void *v);
#endif

int proc_get_rx_signal(struct seq_file *m, void *v);
ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_hw_status(struct seq_file *m, void *v);
ssize_t proc_set_hw_status(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_mac_rptbuf(struct seq_file *m, void *v);

#ifdef CONFIG_80211N_HT
int proc_get_ht_enable(struct seq_file *m, void *v);
ssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_bw_mode(struct seq_file *m, void *v);
ssize_t proc_set_bw_mode(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_ampdu_enable(struct seq_file *m, void *v);
ssize_t proc_set_ampdu_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

void dump_regsty_rx_ampdu_size_limit(void *sel, _adapter *adapter);
int proc_get_rx_ampdu(struct seq_file *m, void *v);
ssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

void rtw_dump_dft_phy_cap(void *sel, _adapter *adapter);
void rtw_get_dft_phy_cap(void *sel, _adapter *adapter);
void rtw_dump_drv_phy_cap(void *sel, _adapter *adapter);

int proc_get_rx_stbc(struct seq_file *m, void *v);
ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_stbc_cap(struct seq_file *m, void *v);
ssize_t proc_set_stbc_cap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_ldpc_cap(struct seq_file *m, void *v);
ssize_t proc_set_ldpc_cap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#ifdef CONFIG_BEAMFORMING
int proc_get_txbf_cap(struct seq_file *m, void *v);
ssize_t proc_set_txbf_cap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
int proc_get_rx_ampdu_factor(struct seq_file *m, void *v);
ssize_t proc_set_rx_ampdu_factor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_tx_max_agg_num(struct seq_file *m, void *v);
ssize_t proc_set_tx_max_agg_num(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_rx_ampdu_density(struct seq_file *m, void *v);
ssize_t proc_set_rx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_tx_ampdu_density(struct seq_file *m, void *v);
ssize_t proc_set_tx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#ifdef CONFIG_TX_AMSDU
int proc_get_tx_amsdu(struct seq_file *m, void *v);
ssize_t proc_set_tx_amsdu(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_tx_amsdu_rate(struct seq_file *m, void *v);
ssize_t proc_set_tx_amsdu_rate(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
#endif /* CONFIG_80211N_HT */

int proc_get_en_fwps(struct seq_file *m, void *v);
ssize_t proc_set_en_fwps(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#if 0
int proc_get_two_path_rssi(struct seq_file *m, void *v);
int proc_get_rssi_disp(struct seq_file *m, void *v);
ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif

#ifdef CONFIG_BT_COEXIST
int proc_get_btcoex_dbg(struct seq_file *m, void *v);
ssize_t proc_set_btcoex_dbg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_btcoex_info(struct seq_file *m, void *v);
#ifdef CONFIG_RF4CE_COEXIST
int proc_get_rf4ce_state(struct seq_file *m, void *v);
ssize_t proc_set_rf4ce_state(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
#endif /* CONFIG_BT_COEXIST */

#if defined(DBG_CONFIG_ERROR_DETECT)
int proc_get_sreset(struct seq_file *m, void *v);
ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif /* DBG_CONFIG_ERROR_DETECT */

int proc_get_odm_adaptivity(struct seq_file *m, void *v);
ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#ifdef CONFIG_DBG_COUNTER
int proc_get_rx_logs(struct seq_file *m, void *v);
int proc_get_tx_logs(struct seq_file *m, void *v);
int proc_get_int_logs(struct seq_file *m, void *v);
#endif

#ifdef CONFIG_PCI_HCI
int proc_get_rx_ring(struct seq_file *m, void *v);
int proc_get_tx_ring(struct seq_file *m, void *v);
int proc_get_pci_aspm(struct seq_file *m, void *v);
int proc_get_pci_conf_space(struct seq_file *m, void *v);
ssize_t proc_set_pci_conf_space(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_pci_bridge_conf_space(struct seq_file *m, void *v);
ssize_t proc_set_pci_bridge_conf_space(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);


#ifdef DBG_TXBD_DESC_DUMP
int proc_get_tx_ring_ext(struct seq_file *m, void *v);
ssize_t proc_set_tx_ring_ext(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
#endif

#ifdef CONFIG_WOWLAN
int proc_get_pattern_info(struct seq_file *m, void *v);
ssize_t proc_set_pattern_info(struct file *file, const char __user *buffer,
		size_t count, loff_t *pos, void *data);
int proc_get_wakeup_event(struct seq_file *m, void *v);
ssize_t proc_set_wakeup_event(struct file *file, const char __user *buffer,
		size_t count, loff_t *pos, void *data);
int proc_get_wakeup_reason(struct seq_file *m, void *v);
#endif

#ifdef CONFIG_GPIO_WAKEUP
int proc_get_wowlan_gpio_info(struct seq_file *m, void *v);
ssize_t proc_set_wowlan_gpio_info(struct file *file, const char __user *buffer,
		size_t count, loff_t *pos, void *data);
#endif /*CONFIG_GPIO_WAKEUP*/

#ifdef CONFIG_P2P_WOWLAN
int proc_get_p2p_wowlan_info(struct seq_file *m, void *v);
#endif /* CONFIG_P2P_WOWLAN */

int proc_get_new_bcn_max(struct seq_file *m, void *v);
ssize_t proc_set_new_bcn_max(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#ifdef CONFIG_POWER_SAVING
int proc_get_ps_info(struct seq_file *m, void *v);
ssize_t proc_set_ps_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#ifdef CONFIG_WMMPS_STA	
int proc_get_wmmps_info(struct seq_file *m, void *v);
ssize_t proc_set_wmmps_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif /* CONFIG_WMMPS_STA */
#endif /* CONFIG_POWER_SAVING */

#ifdef CONFIG_TDLS
int proc_get_tdls_enable(struct seq_file *m, void *v);
ssize_t proc_set_tdls_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_tdls_info(struct seq_file *m, void *v);
#endif

int proc_get_monitor(struct seq_file *m, void *v);
ssize_t proc_set_monitor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#ifdef DBG_XMIT_BLOCK
int proc_get_xmit_block(struct seq_file *m, void *v);
ssize_t proc_set_xmit_block(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif

#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
int proc_get_rtkm_info(struct seq_file *m, void *v);
#endif /* CONFIG_PREALLOC_RX_SKB_BUFFER */

#ifdef CONFIG_IEEE80211W
ssize_t proc_set_tx_sa_query(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_tx_sa_query(struct seq_file *m, void *v);
ssize_t proc_set_tx_deauth(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_tx_deauth(struct seq_file *m, void *v);
ssize_t proc_set_tx_auth(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_tx_auth(struct seq_file *m, void *v);
#endif /* CONFIG_IEEE80211W */

#endif /* CONFIG_PROC_DEBUG */

int proc_get_efuse_map(struct seq_file *m, void *v);
ssize_t proc_set_efuse_map(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#ifdef CONFIG_CUSTOMER01_SMART_ANTENNA
int proc_get_pathb_phase(struct seq_file *m, void *v);
ssize_t proc_set_pathb_phase(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif

#ifdef CONFIG_MCC_MODE
int proc_get_mcc_info(struct seq_file *m, void *v);
ssize_t proc_set_mcc_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_duration(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#ifdef CONFIG_MCC_PHYDM_OFFLOAD
ssize_t proc_set_mcc_phydm_offload_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif
ssize_t proc_set_mcc_single_tx_criteria(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_ap_bw20_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_ap_bw40_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_ap_bw80_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_sta_bw20_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_sta_bw40_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
ssize_t proc_set_mcc_sta_bw80_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_mcc_policy_table(struct seq_file *m, void *v);
#endif /* CONFIG_MCC_MODE */

int proc_get_ack_timeout(struct seq_file *m, void *v);
ssize_t proc_set_ack_timeout(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

int proc_get_fw_offload(struct seq_file *m, void *v);
ssize_t proc_set_fw_offload(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);

#ifdef CONFIG_FW_HANDLE_TXBCN
ssize_t proc_set_fw_tbtt_rpt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_fw_tbtt_rpt(struct seq_file *m, void *v);
#endif

#ifdef CONFIG_DBG_RF_CAL
int proc_get_iqk_info(struct seq_file *m, void *v);
ssize_t proc_set_iqk(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_lck_info(struct seq_file *m, void *v);
ssize_t proc_set_lck(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
#endif /*CONFIG_DBG_RF_CAL*/

#ifdef CONFIG_CTRL_TXSS_BY_TP
ssize_t proc_set_txss_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_txss_tp(struct seq_file *m, void *v);
#ifdef DBG_CTRL_TXSS
ssize_t proc_set_txss_ctrl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_txss_ctrl(struct seq_file *m, void *v);
#endif
#endif

#ifdef CONFIG_LPS_CHK_BY_TP
ssize_t proc_set_lps_chk_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_lps_chk_tp(struct seq_file *m, void *v);
#endif

#ifdef CONFIG_SUPPORT_STATIC_SMPS
ssize_t proc_set_smps(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
int proc_get_smps(struct seq_file *m, void *v);
#endif

#define _drv_always_		1
#define _drv_emerg_			2
#define _drv_alert_			3
#define _drv_crit_			4
#define _drv_err_			5
#define _drv_warning_		6
#define _drv_notice_		7
#define _drv_info_			8
#define _drv_dump_			9
#define _drv_debug_			10

#define _module_rtl871x_xmit_c_		BIT(0)
#define _module_xmit_osdep_c_		BIT(1)
#define _module_rtl871x_recv_c_		BIT(2)
#define _module_recv_osdep_c_		BIT(3)
#define _module_rtl871x_mlme_c_		BIT(4)
#define _module_mlme_osdep_c_		BIT(5)
#define _module_rtl871x_sta_mgt_c_		BIT(6)
#define _module_rtl871x_cmd_c_			BIT(7)
#define _module_cmd_osdep_c_		BIT(8)
#define _module_rtl871x_io_c_				BIT(9)
#define _module_io_osdep_c_		BIT(10)
#define _module_os_intfs_c_			BIT(11)
#define _module_rtl871x_security_c_		BIT(12)
#define _module_rtl871x_eeprom_c_			BIT(13)
#define _module_hal_init_c_		BIT(14)
#define _module_hci_hal_init_c_		BIT(15)
#define _module_rtl871x_ioctl_c_		BIT(16)
#define _module_rtl871x_ioctl_set_c_		BIT(17)
#define _module_rtl871x_ioctl_query_c_	BIT(18)
#define _module_rtl871x_pwrctrl_c_			BIT(19)
#define _module_hci_intfs_c_			BIT(20)
#define _module_hci_ops_c_			BIT(21)
#define _module_osdep_service_c_			BIT(22)
#define _module_mp_			BIT(23)
#define _module_hci_ops_os_c_			BIT(24)
#define _module_rtl871x_ioctl_os_c		BIT(25)
#define _module_rtl8712_cmd_c_		BIT(26)
/* #define _module_efuse_			BIT(27) */
#define	_module_rtl8192c_xmit_c_ BIT(28)
#define _module_hal_xmit_c_	BIT(28)
#define _module_efuse_			BIT(29)
#define _module_rtl8712_recv_c_		BIT(30)
#define _module_rtl8712_led_c_		BIT(31)

#endif /* __RTW_DEBUG_H__ */
                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/rtl8192e_cmd.h                                                                0000644 0001750 0001750 00000013646 14214766567 015724  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_CMD_H__
#define __RTL8192E_CMD_H__

typedef enum _RTL8192E_H2C_CMD {
	H2C_8192E_RSVDPAGE	= 0x00,
	H2C_8192E_MSRRPT	= 0x01,
	H2C_8192E_SCAN		= 0x02,
	H2C_8192E_KEEP_ALIVE_CTRL = 0x03,
	H2C_8192E_DISCONNECT_DECISION = 0x04,
	H2C_8192E_INIT_OFFLOAD = 0x06,
	H2C_8192E_AP_OFFLOAD = 0x08,
	H2C_8192E_BCN_RSVDPAGE = 0x09,
	H2C_8192E_PROBERSP_RSVDPAGE = 0x0a,

	H2C_8192E_AP_WOW_GPIO_CTRL = 0x13,

	H2C_8192E_SETPWRMODE = 0x20,
	H2C_8192E_PS_TUNING_PARA = 0x21,
	H2C_8192E_PS_TUNING_PARA2 = 0x22,
	H2C_8192E_PS_LPS_PARA = 0x23,
	H2C_8192E_P2P_PS_OFFLOAD = 0x24,
	H2C_8192E_SAP_PS = 0x26,
	H2C_8192E_RA_MASK = 0x40,
	H2C_8192E_RSSI_REPORT = 0x42,
	H2C_8192E_RA_PARA_ADJUST = 0x46,

	H2C_8192E_WO_WLAN = 0x80,
	H2C_8192E_REMOTE_WAKE_CTRL = 0x81,
	H2C_8192E_AOAC_GLOBAL_INFO = 0x82,
	H2C_8192E_AOAC_RSVDPAGE = 0x83,

	/* Not defined in new 88E H2C CMD Format */
	H2C_8192E_SELECTIVE_SUSPEND_ROF_CMD,
	H2C_8192E_P2P_PS_MODE,
	H2C_8192E_PSD_RESULT,
	MAX_8192E_H2CCMD
} RTL8192E_H2C_CMD;

struct cmd_msg_parm {
	u8 eid; /* element id */
	u8 sz; /* sz */
	u8 buf[6];
};

enum {
	PWRS
};

typedef struct _SETPWRMODE_PARM {
	u8 Mode;/* 0:Active,1:LPS,2:WMMPS */
	/* u8 RLBM:4; */ /* 0:Min,1:Max,2: User define */
	u8 SmartPS_RLBM;/* LPS=0:PS_Poll,1:PS_Poll,2:NullData,WMM=0:PS_Poll,1:NullData */
	u8 AwakeInterval;	/* unit: beacon interval */
	u8 bAllQueueUAPSD;
	u8 PwrState;/* AllON(0x0c),RFON(0x04),RFOFF(0x00) */
} SETPWRMODE_PARM, *PSETPWRMODE_PARM;

struct H2C_SS_RFOFF_PARAM {
	u8 ROFOn; /* 1: on, 0:off */
	u16 gpio_period; /* unit: 1024 us */
} __attribute__((packed));


typedef struct JOINBSSRPT_PARM_92E {
	u8 OpMode;	/* RT_MEDIA_STATUS */
#ifdef CONFIG_WOWLAN
	u8 MacID;       /* MACID */
#endif /* CONFIG_WOWLAN */
} JOINBSSRPT_PARM_92E, *PJOINBSSRPT_PARM_92E;

/* move to hal_com_h2c.h
typedef struct _RSVDPAGE_LOC_92E {
	u8 LocProbeRsp;
	u8 LocPsPoll;
	u8 LocNullData;
	u8 LocQosNull;
	u8 LocBTQosNull;
} RSVDPAGE_LOC_92E, *PRSVDPAGE_LOC_92E;
*/


/* _SETPWRMODE_PARM */
#define SET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8192E_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8192E_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8192E_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8192E_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8192E_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8192E_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define GET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)						LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _P2P_PS_OFFLOAD */
#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)


/* host message to firmware cmd */
void rtl8192e_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8192e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
s32 FillH2CCmd_8192E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8192E(_adapter *padapter, bool wowlan);
/* u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period); */
s32 c2h_handler_8192e(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
#ifdef CONFIG_BT_COEXIST
	void rtl8192e_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P_PS
	void rtl8192e_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
	#ifdef CONFIG_TDLS_CH_SW
		void rtl8192e_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
	#endif
#endif

/* / TX Feedback Content */
#define	USEC_UNIT_FOR_8192E_C2H_TX_RPT_QUEUE_TIME			256

#define	GET_8192E_C2H_TX_RPT_QUEUE_SELECT(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 5)
#define	GET_8192E_C2H_TX_RPT_PKT_BROCAST(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 5, 1)
#define	GET_8192E_C2H_TX_RPT_LIFE_TIME_OVER(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 6, 1)
#define	GET_8192E_C2H_TX_RPT_RETRY_OVER(_Header)				LE_BITS_TO_1BYTE((_Header + 0), 7, 1)
#define	GET_8192E_C2H_TX_RPT_MAC_ID(_Header)					LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
#define	GET_8192E_C2H_TX_RPT_DATA_RETRY_CNT(_Header)		LE_BITS_TO_1BYTE((_Header + 2), 0, 6)
#define	GET_8192E_C2H_TX_RPT_QUEUE_TIME(_Header)				LE_BITS_TO_2BYTE((_Header + 3), 0, 16)	/* In unit of 256 microseconds. */
#define	GET_8192E_C2H_TX_RPT_FINAL_DATA_RATE(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)

#endif /* __RTL8192E_CMD_H__ */
                                                                                          rtl8822bu/src/include/autoconf.h                                                                    0000755 0001750 0001750 00000021411 14214766567 015415  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#define CONFIG_SINGLE_IMG
/* #define CONFIG_DISABLE_ODM */

/*
 * Public  General Config
 */
#define AUTOCONF_INCLUDED
#define RTL871X_MODULE_NAME "88x2BU"
#define DRV_NAME "rtl88x2bu"

/* Set CONFIG_RTL8822B from Makefile */
#ifndef CONFIG_RTL8822B
#define CONFIG_RTL8822B
#endif
#define CONFIG_USB_HCI	1
#define PLATFORM_LINUX	1

/*
 * Wi-Fi Functions Config
 */

#define CONFIG_80211N_HT
#define CONFIG_80211AC_VHT
#ifdef CONFIG_80211AC_VHT
	#ifndef CONFIG_80211N_HT
		#define CONFIG_80211N_HT
	#endif
#endif

#ifdef CONFIG_80211AC_VHT
	#define CONFIG_BEAMFORMING
#endif

/* set CONFIG_IOCTL_CFG80211 from Makefile */
#ifdef CONFIG_IOCTL_CFG80211
	/*
	 * Indecate new sta asoc through cfg80211_new_sta
	 * If kernel version >= 3.2 or
	 * version < 3.2 but already apply cfg80211 patch,
	 * RTW_USE_CFG80211_STA_EVENT must be defiend!
	 */
	/* Set RTW_USE_CFG80211_STA_EVENT from Makefile */
	/* #define RTW_USE_CFG80211_STA_EVENT */ /* Indecate new sta asoc through cfg80211_new_sta */
	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
	/* #define CONFIG_DEBUG_CFG80211 */
	/* #define CONFIG_DRV_ISSUE_PROV_REQ */ /* IOT FOR S2 */
	#define CONFIG_SET_SCAN_DENY_TIMER
#endif

/*
 * Internal  General Config
 */
/* #define CONFIG_H2CLBK */

#define RTW_HALMAC		/* Use HALMAC architecture, necessary for 8822B */
#define CONFIG_EMBEDDED_FWIMG	1
#if (CONFIG_EMBEDDED_FWIMG==1)
	#define	LOAD_FW_HEADER_FROM_DRIVER
#endif
/* #define CONFIG_FILE_FWIMG */

#define CONFIG_XMIT_ACK
#ifdef CONFIG_XMIT_ACK
	#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
#endif

#define CONFIG_RECV_REORDERING_CTRL	1

/* #define CONFIG_SUPPORT_USB_INT */
#ifdef CONFIG_SUPPORT_USB_INT
	/* #define CONFIG_USB_INTERRUPT_IN_PIPE  1 */
#endif /* CONFIG_SUPPORT_USB_INT */

#ifdef CONFIG_POWER_SAVING
	#define CONFIG_IPS	1
	#ifdef CONFIG_IPS
	/* #define CONFIG_IPS_LEVEL_2 1*/ /*enable this to set default IPS mode to IPS_LEVEL_2*/
	#define CONFIG_IPS_CHECK_IN_WD /* Do IPS Check in WatchDog.	*/
	/* #define CONFIG_FWLPS_IN_IPS */
	#endif
	/* #define SUPPORT_HW_RFOFF_DETECTED	1 */

	#define CONFIG_LPS	1
	#if defined(CONFIG_LPS)
		#define CONFIG_LPS_LCLK	1
	#endif

	#ifdef CONFIG_LPS_LCLK
		#ifdef CONFIG_POWER_SAVING
			/* #define CONFIG_XMIT_THREAD_MODE */
		#endif /* CONFIG_POWER_SAVING */
		#ifndef CONFIG_SUPPORT_USB_INT
			#define LPS_RPWM_WAIT_MS 300
			#define CONFIG_DETECT_CPWM_BY_POLLING
		#endif /* !CONFIG_SUPPORT_USB_INT */
		/* #define DBG_CHECK_FW_PS_STATE */
	#endif /* CONFIG_LPS_LCLK */

	#ifdef CONFIG_LPS
		#define CONFIG_WMMPS_STA 1
	#endif /* CONFIG_LPS */
#endif /*CONFIG_POWER_SAVING*/
	/* before link */
	/* #define CONFIG_ANTENNA_DIVERSITY */

	/* after link */
	#ifdef CONFIG_ANTENNA_DIVERSITY
	#define CONFIG_HW_ANTENNA_DIVERSITY
	#endif


/*#else*/	/* CONFIG_MP_INCLUDED */

/*#endif*/	/* CONFIG_MP_INCLUDED */

#define CONFIG_AP_MODE	1
#ifdef CONFIG_AP_MODE
	/* #define CONFIG_INTERRUPT_BASED_TXBCN */ /* Tx Beacon when driver BCN_OK ,BCN_ERR interrupt occurs */
	#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_INTERRUPT_BASED_TXBCN)
		#undef CONFIG_INTERRUPT_BASED_TXBCN
	#endif
	#ifdef CONFIG_INTERRUPT_BASED_TXBCN
		/* #define CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT */
		#define CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
	#endif

	#define CONFIG_NATIVEAP_MLME
	#ifndef CONFIG_NATIVEAP_MLME
		#define CONFIG_HOSTAPD_MLME	1
	#endif
	#define CONFIG_FIND_BEST_CHANNEL	1
#endif

#define CONFIG_P2P	1
#ifdef CONFIG_P2P
	/* The CONFIG_WFD is for supporting the Wi-Fi display */
	#define CONFIG_WFD

	#define CONFIG_P2P_REMOVE_GROUP_INFO

	/* #define CONFIG_DBG_P2P */

	#define CONFIG_P2P_PS
	/* #define CONFIG_P2P_IPS */
	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  /* replace CONFIG_P2P_CHK_INVITE_CH_LIST flag */
	/*#define CONFIG_P2P_INVITE_IOT*/
#endif

/*	Added by Kurt 20110511 */
#ifdef CONFIG_TDLS
	#define CONFIG_TDLS_DRIVER_SETUP
/*
	#ifndef CONFIG_WFD
		#define CONFIG_WFD
	#endif
*/
	/* #define CONFIG_TDLS_AUTOSETUP */
	#define CONFIG_TDLS_AUTOCHECKALIVE
	#define CONFIG_TDLS_CH_SW		/* Enable "CONFIG_TDLS_CH_SW" by default, however limit it to only work in wifi logo test mode but not in normal mode currently */
#endif


#define CONFIG_SKB_COPY	1 /* amsdu */

#define CONFIG_RTW_LED
#ifdef CONFIG_RTW_LED
	#define CONFIG_RTW_SW_LED
	#ifdef CONFIG_RTW_SW_LED
		/* #define CONFIG_RTW_LED_HANDLED_BY_CMD_THREAD */
	#endif
#endif /* CONFIG_RTW_LED */

#define USB_INTERFERENCE_ISSUE /* this should be checked in all usb interface */
#define CONFIG_GLOBAL_UI_PID

/*#define CONFIG_RTW_80211K*/

#define CONFIG_LAYER2_ROAMING
#define CONFIG_LAYER2_ROAMING_RESUME
/*#define CONFIG_ADAPTOR_INFO_CACHING_FILE */ /* now just applied on 8192cu only, should make it general... */
/*#define CONFIG_RESUME_IN_WORKQUEUE */
/*#define CONFIG_SET_SCAN_DENY_TIMER */
#define CONFIG_LONG_DELAY_ISSUE
#define CONFIG_NEW_SIGNAL_STAT_PROCESS
/* #define CONFIG_SIGNAL_DISPLAY_DBM */ /*display RX signal with dbm */
#ifdef CONFIG_SIGNAL_DISPLAY_DBM
/* #define CONFIG_BACKGROUND_NOISE_MONITOR */
#endif
#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */


/*
 * Interface  Related Config
 */

#ifndef CONFIG_MINIMAL_MEMORY_USAGE
	#define CONFIG_USB_TX_AGGREGATION	1
	#define CONFIG_USB_RX_AGGREGATION	1
#endif

/* #define CONFIG_REDUCE_USB_TX_INT	1 */ /* Trade-off: Improve performance, but may cause TX URBs blocked by USB Host/Bus driver on few platforms. */
/* #define CONFIG_EASY_REPLACEMENT	1 */

/*
 * CONFIG_USE_USB_BUFFER_ALLOC_XX uses Linux USB Buffer alloc API and is for Linux platform only now!
 */
/* #define CONFIG_USE_USB_BUFFER_ALLOC_TX 1 */	/* Trade-off: For TX path, improve stability on some platforms, but may cause performance degrade on other platforms. */
/* #define CONFIG_USE_USB_BUFFER_ALLOC_RX 1	*/ /* For RX path */
#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX

#else
	#define CONFIG_PREALLOC_RECV_SKB
	#ifdef CONFIG_PREALLOC_RECV_SKB
		/* #define CONFIG_FIX_NR_BULKIN_BUFFER */ /* only use PREALLOC_RECV_SKB buffer, don't alloc skb at runtime */
	#endif
#endif

/*
 * USB VENDOR REQ BUFFER ALLOCATION METHOD
 * if not set we'll use function local variable (stack memory)
 */
/* #define CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE */
#define CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC

#define CONFIG_USB_VENDOR_REQ_MUTEX
#define CONFIG_VENDOR_REQ_RETRY

/* #define CONFIG_USB_SUPPORT_ASYNC_VDN_REQ 1 */

/*
 * HAL  Related Config
 */
#define RTL8812A_RX_PACKET_INCLUDE_CRC	0

#define CONFIG_RX_PACKET_APPEND_FCS

/* #define CONFIG_ONLY_ONE_OUT_EP_TO_LOW	0 */

#define CONFIG_OUT_EP_WIFI_MODE	0

#define ENABLE_USB_DROP_INCORRECT_OUT

#define CONFIG_ADHOC_WORKAROUND_SETTING	1

#define ENABLE_NEW_RFE_TYPE	0

#define DISABLE_BB_RF	0

#ifdef CONFIG_MP_INCLUDED
	#define MP_DRIVER 1
	#define CONFIG_MP_IWPRIV_SUPPORT	1
	/*
	 #undef CONFIG_USB_TX_AGGREGATION
	 #undef CONFIG_USB_RX_AGGREGATION
	*/
#else
	#define MP_DRIVER 0
#endif

/*
 * Platform  Related Config
 */
#if defined(CONFIG_PLATFORM_ACTIONS_ATM702X)
	#ifdef CONFIG_USB_TX_AGGREGATION
		#undef CONFIG_USB_TX_AGGREGATION
	#endif
	#ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
		#define CONFIG_USE_USB_BUFFER_ALLOC_TX
	#endif
	#ifndef CONFIG_USE_USB_BUFFER_ALLOC_RX
		#define CONFIG_USE_USB_BUFFER_ALLOC_RX
	#endif
#endif

#ifdef CONFIG_BT_COEXIST
	/* for ODM and outsrc BT-Coex */
	#ifndef CONFIG_LPS
		#define CONFIG_LPS	/* download reserved page to FW */
	#endif
#endif /* !CONFIG_BT_COEXIST */



#ifdef CONFIG_USB_TX_AGGREGATION
/* #define CONFIG_TX_EARLY_MODE */
#endif

#define	RTL8188E_EARLY_MODE_PKT_NUM_10	0
/*#define CONFIG_CUSTOMER01_SMART_ANTENNA */

/*
 * Debug Related Config
 */
#define DBG	1

#define DBG_CONFIG_ERROR_DETECT

/* #define CONFIG_DIS_UPHY */
/*
#define DBG_CONFIG_ERROR_DETECT_INT
#define DBG_CONFIG_ERROR_RESET

#define DBG_IO
#define DBG_DELAY_OS
#define DBG_MEM_ALLOC
#define DBG_IOCTL

#define DBG_TX
#define DBG_XMIT_BUF
#define DBG_XMIT_BUF_EXT
#define DBG_TX_DROP_FRAME

#define DBG_RX_DROP_FRAME
#define DBG_RX_SEQ
#define DBG_RX_SIGNAL_DISPLAY_PROCESSING
#define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap"



#define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
#define DBG_ROAMING_TEST

#define DBG_HAL_INIT_PROFILING

#define DBG_MEMORY_LEAK	1
*/

/*#define DBG_FW_DEBUG_MSG_PKT*/  /* FW use this feature to tx debug broadcast pkt. This pkt include FW debug message*/
                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8822ce_hal.h                                                               0000755 0001750 0001750 00000001740 14214766567 016063  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822CE_HAL_H_
#define _RTL8822CE_HAL_H_

#include <drv_types.h>		/* PADAPTER */

#define RT_BCN_INT_MASKS	(BIT20 | BIT25 | BIT26 | BIT16)

/* rtl8822ce_ops.c */
void UpdateInterruptMask8822CE(PADAPTER, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
u16 get_txbd_rw_reg(u16 q_idx);


#endif /* _RTL8822CE_HAL_H_ */
                                rtl8822bu/src/include/rtw_efuse.h                                                                   0000644 0001750 0001750 00000024000 14214766567 015574  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_EFUSE_H__
#define __RTW_EFUSE_H__


#define	EFUSE_ERROE_HANDLE		1

#define	PG_STATE_HEADER		0x01
#define	PG_STATE_WORD_0		0x02
#define	PG_STATE_WORD_1		0x04
#define	PG_STATE_WORD_2		0x08
#define	PG_STATE_WORD_3		0x10
#define	PG_STATE_DATA			0x20

#define	PG_SWBYTE_H			0x01
#define	PG_SWBYTE_L			0x02

#define	PGPKT_DATA_SIZE		8

#define	EFUSE_WIFI				0
#define	EFUSE_BT				1

enum _EFUSE_DEF_TYPE {
	TYPE_EFUSE_MAX_SECTION				= 0,
	TYPE_EFUSE_REAL_CONTENT_LEN			= 1,
	TYPE_AVAILABLE_EFUSE_BYTES_BANK		= 2,
	TYPE_AVAILABLE_EFUSE_BYTES_TOTAL	= 3,
	TYPE_EFUSE_MAP_LEN					= 4,
	TYPE_EFUSE_PROTECT_BYTES_BANK		= 5,
	TYPE_EFUSE_CONTENT_LEN_BANK			= 6,
};

#define		EFUSE_MAX_MAP_LEN		1024

#define		EFUSE_MAX_HW_SIZE		1024
#define		EFUSE_MAX_SECTION_BASE	16
#define		EFUSE_MAX_SECTION_NUM	128
#define		EFUSE_MAX_BANK_SIZE		512

/*RTL8822B 8821C BT EFUSE Define 1 BANK 128 size logical map 1024*/
#ifdef RTW_HALMAC
#define BANK_NUM		1
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	128
#define EFUSE_BT_REAL_CONTENT_LEN		(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)
#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION			(EFUSE_BT_MAP_LEN / 8)
#ifdef CONFIG_RTL8822C
#define EFUSE_PROTECT_BYTES_BANK		54
#else
#define EFUSE_PROTECT_BYTES_BANK		16
#endif
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_BT_REAL_CONTENT_LEN - EFUSE_PROTECT_BYTES_BANK)
#endif

#define EXT_HEADER(header) ((header & 0x1F) == 0x0F)
#define ALL_WORDS_DISABLED(wde)	((wde & 0x0F) == 0x0F)
#define GET_HDR_OFFSET_2_0(header) ((header & 0xE0) >> 5)

#define		EFUSE_REPEAT_THRESHOLD_			3

#define IS_MASKED_MP(ic, txt, offset) (EFUSE_IsAddressMasked_MP_##ic##txt(offset))
#define IS_MASKED_TC(ic, txt, offset) (EFUSE_IsAddressMasked_TC_##ic##txt(offset))
#define GET_MASK_ARRAY_LEN_MP(ic, txt) (EFUSE_GetArrayLen_MP_##ic##txt())
#define GET_MASK_ARRAY_LEN_TC(ic, txt) (EFUSE_GetArrayLen_TC_##ic##txt())
#define GET_MASK_ARRAY_MP(ic, txt, offset) (EFUSE_GetMaskArray_MP_##ic##txt(offset))
#define GET_MASK_ARRAY_TC(ic, txt, offset) (EFUSE_GetMaskArray_TC_##ic##txt(offset))


#define IS_MASKED(ic, txt, offset) (IS_MASKED_MP(ic, txt, offset))
#define GET_MASK_ARRAY_LEN(ic, txt) (GET_MASK_ARRAY_LEN_MP(ic, txt))
#define GET_MASK_ARRAY(ic, txt, out) do { GET_MASK_ARRAY_MP(ic, txt, out); } while (0)

#ifdef CONFIG_BT_EFUSE_MASK
#define IS_BT_MASKED_MP(ic, txt, offset) (EFUSE_IsBTAddressMasked_MP_##ic##txt(offset))
#define GET_BT_MASK_ARRAY_LEN_MP(ic, txt) (EFUSE_GetBTArrayLen_MP_##ic##txt())
#define GET_BT_MASK_ARRAY_LEN_TC(ic, txt) (EFUSE_GetBTArrayLen_TC_##ic##txt())
#define GET_BT_MASK_ARRAY_MP(ic, txt, offset) (EFUSE_GetBTMaskArray_MP_##ic##txt(offset))

#define IS_BT_MASKED(ic, txt, offset) (IS_BT_MASKED_MP(ic,txt, offset))
#define GET_BT_MASK_ARRAY(ic, txt, out) do { GET_BT_MASK_ARRAY_MP(ic,txt, out); } while(0)
#define GET_BT_MASK_ARRAY_LEN(ic, txt) (GET_BT_MASK_ARRAY_LEN_MP(ic,txt))
#endif

/* *********************************************
 *	The following is for BT Efuse definition
 * ********************************************* */
#define		EFUSE_BT_MAX_MAP_LEN		1024
#define		EFUSE_MAX_BANK			4
#define		EFUSE_MAX_BT_BANK		(EFUSE_MAX_BANK-1)
/* *********************************************
 *--------------------------Define Parameters-------------------------------*/
#define		EFUSE_MAX_WORD_UNIT			4

/*------------------------------Define structure----------------------------*/
typedef struct PG_PKT_STRUCT_A {
	u8 offset;
	u8 word_en;
	u8 data[8];
	u8 word_cnts;
} PGPKT_STRUCT, *PPGPKT_STRUCT;

typedef enum {
	ERR_SUCCESS = 0,
	ERR_DRIVER_FAILURE,
	ERR_IO_FAILURE,
	ERR_WI_TIMEOUT,
	ERR_WI_BUSY,
	ERR_BAD_FORMAT,
	ERR_INVALID_DATA,
	ERR_NOT_ENOUGH_SPACE,
	ERR_WRITE_PROTECT,
	ERR_READ_BACK_FAIL,
	ERR_OUT_OF_RANGE
} ERROR_CODE;

/*------------------------------Define structure----------------------------*/
typedef struct _EFUSE_HAL {
	u8	fakeEfuseBank;
	u32	fakeEfuseUsedBytes;
	u8	fakeEfuseContent[EFUSE_MAX_HW_SIZE];
	u8	fakeEfuseInitMap[EFUSE_MAX_MAP_LEN];
	u8	fakeEfuseModifiedMap[EFUSE_MAX_MAP_LEN];
	u32	EfuseUsedBytes;
	u8	EfuseUsedPercentage;

	u16	BTEfuseUsedBytes;
	u8	BTEfuseUsedPercentage;
	u8	BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
	u8	BTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
	u8	BTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];

	u16	fakeBTEfuseUsedBytes;
	u8	fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
	u8	fakeBTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
	u8	fakeBTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];

	/* EFUSE Configuration, initialized in HAL_CmnInitPGData(). */
	const u16  MaxSecNum_WiFi;
	const u16  MaxSecNum_BT;
	const u16  WordUnit;
	const u16  PhysicalLen_WiFi;
	const u16  PhysicalLen_BT;
	const u16  LogicalLen_WiFi;
	const u16  LogicalLen_BT;
	const u16  BankSize;
	const u16  TotalBankNum;
	const u16  BankNum_WiFi;
	const u16  BankNum_BT;
	const u16  OOBProtectBytes;
	const u16  ProtectBytes;
	const u16  BankAvailBytes;
	const u16  TotalAvailBytes_WiFi;
	const u16  TotalAvailBytes_BT;
	const u16  HeaderRetry;
	const u16  DataRetry;

	ERROR_CODE	  Status;

} EFUSE_HAL, *PEFUSE_HAL;

extern u8 maskfileBuffer[64];
extern u8 btmaskfileBuffer[64];

/*------------------------Export global variable----------------------------*/
extern u8 fakeEfuseBank;
extern u32 fakeEfuseUsedBytes;
extern u8 fakeEfuseContent[];
extern u8 fakeEfuseInitMap[];
extern u8 fakeEfuseModifiedMap[];

extern u32 BTEfuseUsedBytes;
extern u8 BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
extern u8 BTEfuseInitMap[];
extern u8 BTEfuseModifiedMap[];

extern u32 fakeBTEfuseUsedBytes;
extern u8 fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
extern u8 fakeBTEfuseInitMap[];
extern u8 fakeBTEfuseModifiedMap[];
/*------------------------Export global variable----------------------------*/
#define		MAX_SEGMENT_SIZE			200
#define		MAX_SEGMENT_NUM			200
#define		MAX_BUF_SIZE				(MAX_SEGMENT_SIZE*MAX_SEGMENT_NUM)
#define		TMP_BUF_SIZE				100
#define		rtprintf					dcmd_Store_Return_Buf

u8	efuse_bt_GetCurrentSize(PADAPTER padapter, u16 *size);
u16	efuse_bt_GetMaxSize(PADAPTER padapter);
u16 efuse_GetavailableSize(PADAPTER adapter);

u8	efuse_GetCurrentSize(PADAPTER padapter, u16 *size);
u16	efuse_GetMaxSize(PADAPTER padapter);
u8	rtw_efuse_access(PADAPTER padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
u8	rtw_efuse_bt_access(PADAPTER adapter, u8 write, u16 addr, u16 cnts, u8 *data);

u8	rtw_efuse_mask_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
u8	rtw_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
u8	rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
u8	rtw_BT_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
u8	rtw_BT_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);

u16	Efuse_GetCurrentSize(PADAPTER pAdapter, u8 efuseType, BOOLEAN bPseudoTest);
u8	Efuse_CalculateWordCnts(u8 word_en);
void	ReadEFuseByte(PADAPTER Adapter, u16 _offset, u8 *pbuf, BOOLEAN bPseudoTest) ;
void	EFUSE_GetEfuseDefinition(PADAPTER pAdapter, u8 efuseType, u8 type, void *pOut, BOOLEAN bPseudoTest);
u8	efuse_OneByteRead(PADAPTER pAdapter, u16 addr, u8 *data, BOOLEAN	 bPseudoTest);
#define efuse_onebyte_read(adapter, addr, data, pseudo_test) efuse_OneByteRead((adapter), (addr), (data), (pseudo_test))

u8	efuse_OneByteWrite(PADAPTER pAdapter, u16 addr, u8 data, BOOLEAN	 bPseudoTest);

void	BTEfuse_PowerSwitch(PADAPTER pAdapter, u8	bWrite, u8	 PwrState);
void	Efuse_PowerSwitch(PADAPTER pAdapter, u8	bWrite, u8	 PwrState);
int	Efuse_PgPacketRead(PADAPTER pAdapter, u8 offset, u8 *data, BOOLEAN bPseudoTest);
int	Efuse_PgPacketWrite(PADAPTER pAdapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
void	efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata);
u8	Efuse_WordEnableDataWrite(PADAPTER pAdapter, u16 efuse_addr, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
void	EFUSE_ShadowMapUpdate(PADAPTER pAdapter, u8 efuseType, BOOLEAN bPseudoTest);
void	EFUSE_ShadowRead(PADAPTER pAdapter, u8 Type, u16 Offset, u32 *Value);
#define efuse_logical_map_read(adapter, type, offset, value) EFUSE_ShadowRead((adapter), (type), (offset), (value))

BOOLEAN rtw_file_efuse_IsMasked(PADAPTER pAdapter, u16 Offset, u8 *maskbuf);
BOOLEAN efuse_IsMasked(PADAPTER pAdapter, u16 Offset);

void	hal_ReadEFuse_BT_logic_map(
	PADAPTER	padapter,
	u16			_offset,
	u16			_size_byte,
	u8			*pbuf
);
u8	EfusePgPacketWrite_BT(
	PADAPTER	pAdapter,
	u8			offset,
	u8			word_en,
	u8			*pData,
	u8			bPseudoTest);

u16 rtw_get_bt_efuse_mask_arraylen(PADAPTER pAdapter);
void rtw_bt_efuse_mask_array(PADAPTER pAdapter, u8 *pArray);
u16 rtw_get_efuse_mask_arraylen(PADAPTER pAdapter);
void rtw_efuse_mask_array(PADAPTER pAdapter, u8 *pArray);
void rtw_efuse_analyze(PADAPTER	padapter, u8 Type, u8 Fake);

#define MAC_HIDDEN_MAX_BW_NUM 8
extern const u8 _mac_hidden_max_bw_to_hal_bw_cap[];
#define mac_hidden_max_bw_to_hal_bw_cap(max_bw) (((max_bw) >= MAC_HIDDEN_MAX_BW_NUM) ? 0 : _mac_hidden_max_bw_to_hal_bw_cap[(max_bw)])

#define MAC_HIDDEN_PROTOCOL_NUM 4
extern const u8 _mac_hidden_proto_to_hal_proto_cap[];
#define mac_hidden_proto_to_hal_proto_cap(proto) (((proto) >= MAC_HIDDEN_PROTOCOL_NUM) ? 0 : _mac_hidden_proto_to_hal_proto_cap[(proto)])

u8 mac_hidden_wl_func_to_hal_wl_func(u8 func);

#ifdef PLATFORM_LINUX
u8 rtw_efuse_file_read(PADAPTER padapter, u8 *filepatch, u8 *buf, u32 len);
#ifdef CONFIG_EFUSE_CONFIG_FILE
u32 rtw_read_efuse_from_file(const char *path, u8 *buf, int map_size);
u32 rtw_read_macaddr_from_file(const char *path, u8 *buf);
#endif /* CONFIG_EFUSE_CONFIG_FILE */
#endif /* PLATFORM_LINUX */

#endif
rtl8822bu/src/include/Hal8188FPhyCfg.h                                                              0000644 0001750 0001750 00000005201 14214766567 016037  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8188FPHYCFG_H__
#define __INC_HAL8188FPHYCFG_H__

/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters End-------------------------------*/


/*------------------------------Define structure----------------------------*/

/*------------------------------Define structure End----------------------------*/

/*--------------------------Exported Function prototype---------------------*/
u32
PHY_QueryBBReg_8188F(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask
);

void
PHY_SetBBReg_8188F(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask,
		u32		Data
);

u32
PHY_QueryRFReg_8188F(
		PADAPTER			Adapter,
		enum rf_path			eRFPath,
		u32				RegAddr,
		u32				BitMask
);

void
PHY_SetRFReg_8188F(
		PADAPTER			Adapter,
		enum rf_path			eRFPath,
		u32				RegAddr,
		u32				BitMask,
		u32				Data
);

/* MAC/BB/RF HAL config */
int PHY_BBConfig8188F(PADAPTER	Adapter);

int PHY_RFConfig8188F(PADAPTER	Adapter);

s32 PHY_MACConfig8188F(PADAPTER padapter);

int
PHY_ConfigRFWithParaFile_8188F(
		PADAPTER			Adapter,
		u8					*pFileName,
	enum rf_path				eRFPath
);

void
PHY_SetTxPowerIndex_8188F(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

void
PHY_SetTxPowerLevel8188F(
		PADAPTER		Adapter,
		u8			channel
);

void
PHY_SetSwChnlBWMode8188F(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void phy_set_rf_path_switch_8188f(
		struct		dm_struct *phydm,
		bool		bMain
);

void BBTurnOnBlock_8188F(_adapter *adapter);

/*--------------------------Exported Function prototype End---------------------*/

#endif
                                                                                                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/rtw_qos.h                                                                     0000644 0001750 0001750 00000004104 14214766567 015272  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/


#ifndef _RTW_QOS_H_
#define _RTW_QOS_H_

#define DRV_CFG_UAPSD_VO 	BIT0
#define DRV_CFG_UAPSD_VI 	BIT1
#define DRV_CFG_UAPSD_BK 	BIT2
#define DRV_CFG_UAPSD_BE 	BIT3

#define WMM_IE_UAPSD_VO 	BIT0
#define WMM_IE_UAPSD_VI 	BIT1
#define WMM_IE_UAPSD_BK 	BIT2
#define WMM_IE_UAPSD_BE 	BIT3

#define WMM_TID0 	BIT0
#define WMM_TID1 	BIT1
#define WMM_TID2 	BIT2
#define WMM_TID3 	BIT3
#define WMM_TID4 	BIT4
#define WMM_TID5 	BIT5
#define WMM_TID6 	BIT6
#define WMM_TID7 	BIT7

#define AP_SUPPORTED_UAPSD BIT7
/* TC = Traffic Category,  TID0~7 represents TC */
#define BIT_MASK_TID_TC 0xff
/* TS = Traffic Stream,  TID8~15 represents TS */
#define BIT_MASK_TID_TS 0xff00
#define ALL_TID_TC_SUPPORTED_UAPSD 0xff

struct	qos_priv	{

	unsigned int	  qos_option;	/* bit mask option: u-apsd, s-apsd, ts, block ack...		 */

#ifdef CONFIG_WMMPS_STA
	/* uapsd (unscheduled automatic power-save delivery) = a kind of wmmps */
	u8 uapsd_max_sp_len;
	/* declare uapsd_tid as a bitmap for the uapsd setting of TID 0~15 */
	u16 uapsd_tid;
	/* declare uapsd_tid_delivery_enabled as a bitmap for the delivery-enabled setting of TID 0~7 */
	u8 uapsd_tid_delivery_enabled;
	/* declare uapsd_tid_trigger_enabled as a bitmap for the trigger-enabled setting of TID 0~7 */
	u8 uapsd_tid_trigger_enabled;
	/* declare uapsd_ap_supported to record whether the connected ap  supports uapsd or not */
	u8 uapsd_ap_supported;
#endif /* CONFIG_WMMPS_STA */	

};


#endif /* _RTL871X_QOS_H_ */                                                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8710b_lps_poff.h                                                           0000644 0001750 0001750 00000005347 14214766567 016761  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

/******************************************** CONST  ************************/
#define NUM_OF_REGISTER_BANK	13
#define NUM_OF_TOTAL_DWORD (NUM_OF_REGISTER_BANK * 64)
#define TOTAL_LEN_FOR_HIOE ((NUM_OF_TOTAL_DWORD + 1) * 8)
#define LPS_POFF_STATIC_FILE_LEN (TOTAL_LEN_FOR_HIOE + TXDESC_SIZE)
#define LPS_POFF_DYNAMIC_FILE_LEN	(512 + TXDESC_SIZE)
/******************************************** CONST  ************************/

/******************************************** MACRO   ************************/
/* HOIE Entry Definition */
#define SET_HOIE_ENTRY_LOW_DATA(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE),	0, 16, __Value)
#define SET_HOIE_ENTRY_HIGH_DATA(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE), 16, 16, __Value)
#define SET_HOIE_ENTRY_MODE_SELECT(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 0, 1, __Value)
#define SET_HOIE_ENTRY_ADDRESS(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 1, 14, __Value)
#define SET_HOIE_ENTRY_BYTE_MASK(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 15, 4, __Value)
#define SET_HOIE_ENTRY_IO_LOCK(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 19, 1, __Value)
#define SET_HOIE_ENTRY_RD_EN(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 20, 1, __Value)
#define SET_HOIE_ENTRY_WR_EN(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 21, 1, __Value)
#define SET_HOIE_ENTRY_RAW_RW(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 22, 1, __Value)
#define SET_HOIE_ENTRY_RAW(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 23, 1, __Value)
#define SET_HOIE_ENTRY_IO_DELAY(__pHOIE, __Value) \
	SET_BITS_TO_LE_4BYTE((__pHOIE)+4, 24, 8, __Value)

/*********************Function Definition*******************************************/
void rtl8710b_lps_poff_init(PADAPTER padapter);
void rtl8710b_lps_poff_deinit(PADAPTER padapter);
bool rtl8710b_lps_poff_get_txbndy_status(PADAPTER padapter);
void rtl8710b_lps_poff_h2c_ctrl(PADAPTER padapter, u8 enable);
void rtl8710b_lps_poff_set_ps_mode(PADAPTER padapter, bool bEnterLPS);
bool rtl8710b_lps_poff_get_status(PADAPTER padapter);
void rtl8710b_lps_poff_wow(PADAPTER padapter);
                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/rtl8723b_spec.h                                                               0000755 0001750 0001750 00000026601 14214766567 016106  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_SPEC_H__
#define __RTL8723B_SPEC_H__

#include <drv_conf.h>


#define HAL_NAV_UPPER_UNIT_8723B		128		/* micro-second */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_RSV_CTRL_8723B				0x001C	/* 3 Byte */
#define REG_BT_WIFI_ANTENNA_SWITCH_8723B	0x0038
#define REG_HSISR_8723B					0x005c
#define REG_PAD_CTRL1_8723B		0x0064
#define REG_AFE_CTRL_4_8723B		0x0078
#define REG_HMEBOX_DBG_0_8723B	0x0088
#define REG_HMEBOX_DBG_1_8723B	0x008A
#define REG_HMEBOX_DBG_2_8723B	0x008C
#define REG_HMEBOX_DBG_3_8723B	0x008E
#define REG_HIMR0_8723B					0x00B0
#define REG_HISR0_8723B					0x00B4
#define REG_HIMR1_8723B					0x00B8
#define REG_HISR1_8723B					0x00BC
#define REG_PMC_DBG_CTRL2_8723B			0x00CC

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_C2HEVT_CMD_ID_8723B	0x01A0
#define REG_C2HEVT_CMD_LEN_8723B	0x01AE
#define REG_WOWLAN_WAKE_REASON 0x01C7
#define REG_WOWLAN_GTK_DBG1	0x630
#define REG_WOWLAN_GTK_DBG2	0x634

#define REG_HMEBOX_EXT0_8723B			0x01F0
#define REG_HMEBOX_EXT1_8723B			0x01F4
#define REG_HMEBOX_EXT2_8723B			0x01F8
#define REG_HMEBOX_EXT3_8723B			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_CONTROL_8723B		0x0286 /* Control the RX DMA. */
#define REG_RXDMA_MODE_CTRL_8723B		0x0290

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8723B		0x0300
#define	REG_INT_MIG_8723B				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_DESA_8723B			0x0308	/* TX Beacon Descriptor Address */
#define	REG_HQ_DESA_8723B				0x0310	/* TX High Queue Descriptor Address */
#define	REG_MGQ_DESA_8723B			0x0318	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_DESA_8723B			0x0320	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_DESA_8723B				0x0328	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_DESA_8723B			0x0330	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_DESA_8723B			0x0338	/* TX BK Queue Descriptor Address */
#define	REG_RX_DESA_8723B				0x0340	/* RX Queue	Descriptor Address */
#define	REG_DBI_WDATA_8723B			0x0348	/* DBI Write Data */
#define	REG_DBI_RDATA_8723B			0x034C	/* DBI Read Data */
#define	REG_DBI_ADDR_8723B				0x0350	/* DBI Address */
#define	REG_DBI_FLAG_8723B				0x0352	/* DBI Read/Write Flag */
#define	REG_MDIO_WDATA_8723B		0x0354	/* MDIO for Write PCIE PHY */
#define	REG_MDIO_RDATA_8723B			0x0356	/* MDIO for Reads PCIE PHY */
#define	REG_MDIO_CTL_8723B			0x0358	/* MDIO for Control */
#define	REG_DBG_SEL_8723B				0x0360	/* Debug Selection Register */
#define	REG_PCIE_HRPWM_8723B			0x0361	/* PCIe RPWM */
#define	REG_PCIE_HCPWM_8723B			0x0363	/* PCIe CPWM */
#define	REG_PCIE_MULTIFET_CTRL_8723B	0x036A	/* PCIE Multi-Fethc Control */

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_TXPKTBUF_BCNQ_BDNY_8723B	0x0424
#define REG_TXPKTBUF_MGQ_BDNY_8723B	0x0425
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8723B	0x045D
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW             0x0484
	#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_AMPDU_BURST_MODE_8723B	0x04BC

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_SECONDARY_CCA_CTRL_8723B	0x0577

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */


/* ************************************************************
 * SDIO Bus Specification
 * ************************************************************ */

/* -----------------------------------------------------
 * SDIO CMD Address Mapping
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * I/O bus domain (Host)
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * SDIO register
 * ----------------------------------------------------- */
#define SDIO_REG_HCPWM1_8723B	0x025 /* HCI Current Power Mode 1 */


/* ****************************************************************************
 *	8723 Regsiter Bit and Content definition
 * **************************************************************************** */

/* 2 HSISR
 * interrupt mask which needs to clear */
#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
		HSISR_SPS_OCP_INT |\
		HSISR_RON_INT |\
		HSISR_PDNINT |\
		HSISR_GPIO9_INT)

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#undef IS_E_CUT
#define IS_E_CUT(version)		FALSE
#undef IS_F_CUT
#define IS_F_CUT(version)		((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? TRUE : FALSE)

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define BIT_USB_RXDMA_AGG_EN	BIT(31)
#define RXDMA_AGG_MODE_EN		BIT(1)

#ifdef CONFIG_WOWLAN
	#define RXPKT_RELEASE_POLL		BIT(16)
	#define RXDMA_IDLE				BIT(17)
	#define RW_RELEASE_EN			BIT(18)
#endif

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */

/* ----------------------------------------------------------------------------
 * 8723B REG_CCK_CHECK						(offset 0x454)
 * ---------------------------------------------------------------------------- */
#define BIT_BCN_PORT_SEL		BIT(5)

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#ifdef CONFIG_RF_POWER_TRIM

	#ifdef CONFIG_RTL8723B
		#define EEPROM_RF_GAIN_OFFSET			0xC1
	#endif

	#define EEPROM_RF_GAIN_VAL				0x1F6
#endif /*CONFIG_RF_POWER_TRIM*/


/* ----------------------------------------------------------------------------
 * 8195 IMR/ISR bits						(offset 0xB0,  8bits)
 * ---------------------------------------------------------------------------- */
#define	IMR_DISABLED_8723B					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define	IMR_TIMER2_8723B					BIT(31)		/* Timeout interrupt 2 */
#define	IMR_TIMER1_8723B					BIT(30)		/* Timeout interrupt 1	 */
#define	IMR_PSTIMEOUT_8723B				BIT(29)		/* Power Save Time Out Interrupt */
#define	IMR_GTINT4_8723B					BIT(28)		/* When GTIMER4 expires, this bit is set to 1	 */
#define	IMR_GTINT3_8723B					BIT(27)		/* When GTIMER3 expires, this bit is set to 1	 */
#define	IMR_TXBCN0ERR_8723B				BIT(26)		/* Transmit Beacon0 Error			 */
#define	IMR_TXBCN0OK_8723B				BIT(25)		/* Transmit Beacon0 OK			 */
#define	IMR_TSF_BIT32_TOGGLE_8723B		BIT(24)		/* TSF Timer BIT(32) toggle indication interrupt			 */
#define	IMR_BCNDMAINT0_8723B				BIT(20)		/* Beacon DMA Interrupt 0			 */
#define	IMR_BCNDERR0_8723B				BIT(16)		/* Beacon Queue DMA OK0			 */
#define	IMR_HSISR_IND_ON_INT_8723B		BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define	IMR_BCNDMAINT_E_8723B			BIT(14)		/* Beacon DMA Interrupt Extension for Win7			 */
#define	IMR_ATIMEND_8723B				BIT(12)		/* CTWidnow End or ATIM Window End */
#define	IMR_C2HCMD_8723B					BIT(10)		/* CPU to Host Command INT Status, Write 1 clear	 */
#define	IMR_CPWM2_8723B					BIT(9)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_CPWM_8723B					BIT(8)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_HIGHDOK_8723B				BIT(7)			/* High Queue DMA OK	 */
#define	IMR_MGNTDOK_8723B				BIT(6)			/* Management Queue DMA OK	 */
#define	IMR_BKDOK_8723B					BIT(5)			/* AC_BK DMA OK		 */
#define	IMR_BEDOK_8723B					BIT(4)			/* AC_BE DMA OK	 */
#define	IMR_VIDOK_8723B					BIT(3)			/* AC_VI DMA OK		 */
#define	IMR_VODOK_8723B					BIT(2)			/* AC_VO DMA OK	 */
#define	IMR_RDU_8723B					BIT(1)			/* Rx Descriptor Unavailable	 */
#define	IMR_ROK_8723B					BIT(0)			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define	IMR_BCNDMAINT7_8723B				BIT(27)		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT6_8723B				BIT(26)		/* Beacon DMA Interrupt 6 */
#define	IMR_BCNDMAINT5_8723B				BIT(25)		/* Beacon DMA Interrupt 5 */
#define	IMR_BCNDMAINT4_8723B				BIT(24)		/* Beacon DMA Interrupt 4 */
#define	IMR_BCNDMAINT3_8723B				BIT(23)		/* Beacon DMA Interrupt 3 */
#define	IMR_BCNDMAINT2_8723B				BIT(22)		/* Beacon DMA Interrupt 2 */
#define	IMR_BCNDMAINT1_8723B				BIT(21)		/* Beacon DMA Interrupt 1 */
#define	IMR_BCNDOK7_8723B					BIT(20)		/* Beacon Queue DMA OK Interrupt 7 */
#define	IMR_BCNDOK6_8723B					BIT(19)		/* Beacon Queue DMA OK Interrupt 6 */
#define	IMR_BCNDOK5_8723B					BIT(18)		/* Beacon Queue DMA OK Interrupt 5 */
#define	IMR_BCNDOK4_8723B					BIT(17)		/* Beacon Queue DMA OK Interrupt 4 */
#define	IMR_BCNDOK3_8723B					BIT(16)		/* Beacon Queue DMA OK Interrupt 3 */
#define	IMR_BCNDOK2_8723B					BIT(15)		/* Beacon Queue DMA OK Interrupt 2 */
#define	IMR_BCNDOK1_8723B					BIT(14)		/* Beacon Queue DMA OK Interrupt 1 */
#define	IMR_ATIMEND_E_8723B				BIT(13)		/* ATIM Window End Extension for Win7 */
#define	IMR_TXERR_8723B					BIT(11)		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define	IMR_RXERR_8723B					BIT(10)		/* Rx Error Flag INT Status, Write 1 clear */
#define	IMR_TXFOVW_8723B					BIT(9)			/* Transmit FIFO Overflow */
#define	IMR_RXFOVW_8723B					BIT(8)			/* Receive FIFO Overflow */

#ifdef CONFIG_PCI_HCI
	/* #define IMR_RX_MASK		(IMR_ROK_8723B|IMR_RDU_8723B|IMR_RXFOVW_8723B) */
	#define IMR_TX_MASK			(IMR_VODOK_8723B | IMR_VIDOK_8723B | IMR_BEDOK_8723B | IMR_BKDOK_8723B | IMR_MGNTDOK_8723B | IMR_HIGHDOK_8723B)

	#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8723B | IMR_TXBCN0OK_8723B | IMR_TXBCN0ERR_8723B | IMR_BCNDERR0_8723B)

	#define RT_AC_INT_MASKS	(IMR_VIDOK_8723B | IMR_VODOK_8723B | IMR_BEDOK_8723B | IMR_BKDOK_8723B)
#endif

#endif /* __RTL8723B_SPEC_H__ */
                                                                                                                               rtl8822bu/src/include/rtl8703b_dm.h                                                                 0000644 0001750 0001750 00000002615 14214766567 015546  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_DM_H__
#define __RTL8703B_DM_H__
/* ************************************************************
 * Description:
 *
 * This file is for 8703B dynamic mechanism only
 *
 *
 * ************************************************************ */

/* ************************************************************
 * structure and define
 * ************************************************************ */

/* ************************************************************
 * function prototype
 * ************************************************************ */

void rtl8703b_init_dm_priv(PADAPTER padapter);
void rtl8703b_deinit_dm_priv(PADAPTER padapter);

void rtl8703b_InitHalDm(PADAPTER padapter);
void rtl8703b_HalDmWatchDog(PADAPTER padapter);

#endif
                                                                                                                   rtl8822bu/src/include/rtl8723d_rf.h                                                                 0000644 0001750 0001750 00000001515 14214766567 015557  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_RF_H__
#define __RTL8723D_RF_H__

int PHY_RF6052_Config8723D(PADAPTER pdapter);

void PHY_RF6052SetBandwidth8723D(PADAPTER Adapter, enum channel_width Bandwidth);
#endif
                                                                                                                                                                                   rtl8822bu/src/include/ieee80211_ext.h                                                               0000644 0001750 0001750 00000016413 14214766567 015765  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __IEEE80211_EXT_H
#define __IEEE80211_EXT_H

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#define WMM_OUI_TYPE 2
#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
#define WMM_VERSION 1

#define WPA_PROTO_WPA BIT(0)
#define WPA_PROTO_RSN BIT(1)

#define WPA_KEY_MGMT_IEEE8021X BIT(0)
#define WPA_KEY_MGMT_PSK BIT(1)
#define WPA_KEY_MGMT_NONE BIT(2)
#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
#define WPA_KEY_MGMT_WPA_NONE BIT(4)


#define WPA_CAPABILITY_PREAUTH BIT(0)
#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)


#define PMKID_LEN 16


#ifdef PLATFORM_LINUX
struct wpa_ie_hdr {
	u8 elem_id;
	u8 len;
	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
	u8 version[2]; /* little endian */
} __attribute__((packed));

struct rsn_ie_hdr {
	u8 elem_id; /* WLAN_EID_RSN */
	u8 len;
	u8 version[2]; /* little endian */
} __attribute__((packed));

struct wme_ac_parameter {
#if defined(CONFIG_LITTLE_ENDIAN)
	/* byte 1 */
	u8	aifsn:4,
	     acm:1,
	     aci:2,
	     reserved:1;

	/* byte 2 */
	u8	eCWmin:4,
	     eCWmax:4;
#elif defined(CONFIG_BIG_ENDIAN)
	/* byte 1 */
	u8	reserved:1,
	     aci:2,
	     acm:1,
	     aifsn:4;

	/* byte 2 */
	u8	eCWmax:4,
	     eCWmin:4;
#else
#error	"Please fix <endian.h>"
#endif

	/* bytes 3 & 4 */
	u16 txopLimit;
} __attribute__((packed));

struct wme_parameter_element {
	/* required fields for WME version 1 */
	u8 oui[3];
	u8 oui_type;
	u8 oui_subtype;
	u8 version;
	u8 acInfo;
	u8 reserved;
	struct wme_ac_parameter ac[4];

} __attribute__((packed));

#endif

#define WPA_PUT_LE16(a, val)			\
	do {					\
		(a)[1] = ((u16) (val)) >> 8;	\
		(a)[0] = ((u16) (val)) & 0xff;	\
	} while (0)

#define WPA_PUT_BE32(a, val)					\
	do {							\
		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
	} while (0)

#define WPA_PUT_LE32(a, val)					\
	do {							\
		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
	} while (0)

#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((u8 *) (a), (val))
/* #define RSN_SELECTOR_PUT(a, val) WPA_PUT_LE32((u8 *) (a), (val)) */



/* Action category code */
enum ieee80211_category {
	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	WLAN_CATEGORY_QOS = 1,
	WLAN_CATEGORY_DLS = 2,
	WLAN_CATEGORY_BACK = 3,
	WLAN_CATEGORY_HT = 7,
	WLAN_CATEGORY_WMM = 17,
};

/* SPECTRUM_MGMT action code */
enum ieee80211_spectrum_mgmt_actioncode {
	WLAN_ACTION_SPCT_MSR_REQ = 0,
	WLAN_ACTION_SPCT_MSR_RPRT = 1,
	WLAN_ACTION_SPCT_TPC_REQ = 2,
	WLAN_ACTION_SPCT_TPC_RPRT = 3,
	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
};

/* BACK action code */
enum ieee80211_back_actioncode {
	WLAN_ACTION_ADDBA_REQ = 0,
	WLAN_ACTION_ADDBA_RESP = 1,
	WLAN_ACTION_DELBA = 2,
};

/* HT features action code */
enum ieee80211_ht_actioncode {
	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
	WLAN_ACTION_SM_PS = 1,
	WLAN_ACTION_PSPM = 2,
	WLAN_ACTION_PCO_PHASE = 3,
	WLAN_ACTION_MIMO_CSI_MX = 4,
	WLAN_ACTION_MIMO_NONCP_BF = 5,
	WLAN_ACTION_MIMP_CP_BF = 6,
	WLAN_ACTION_ASEL_INDICATES_FB = 7,
	WLAN_ACTION_HI_INFO_EXCHG = 8,
};

/* BACK (block-ack) parties */
enum ieee80211_back_parties {
	WLAN_BACK_RECIPIENT = 0,
	WLAN_BACK_INITIATOR = 1,
	WLAN_BACK_TIMER = 2,
};

#ifdef PLATFORM_LINUX

struct ieee80211_mgmt {
	u16 frame_control;
	u16 duration;
	u8 da[6];
	u8 sa[6];
	u8 bssid[6];
	u16 seq_ctrl;
	union {
		struct {
			u16 auth_alg;
			u16 auth_transaction;
			u16 status_code;
			/* possibly followed by Challenge text */
			u8 variable[0];
		}  __attribute__((packed)) auth;
		struct {
			u16 reason_code;
		}  __attribute__((packed)) deauth;
		struct {
			u16 capab_info;
			u16 listen_interval;
			/* followed by SSID and Supported rates */
			u8 variable[0];
		}  __attribute__((packed)) assoc_req;
		struct {
			u16 capab_info;
			u16 status_code;
			u16 aid;
			/* followed by Supported rates */
			u8 variable[0];
		}  __attribute__((packed)) assoc_resp, reassoc_resp;
		struct {
			u16 capab_info;
			u16 listen_interval;
			u8 current_ap[6];
			/* followed by SSID and Supported rates */
			u8 variable[0];
		}  __attribute__((packed)) reassoc_req;
		struct {
			u16 reason_code;
		}  __attribute__((packed)) disassoc;
		struct {
			__le64 timestamp;
			u16 beacon_int;
			u16 capab_info;
			/* followed by some of SSID, Supported rates,
			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
			u8 variable[0];
		}  __attribute__((packed)) beacon;
		struct {
			/* only variable items: SSID, Supported rates */
			u8 variable[0];
		}  __attribute__((packed)) probe_req;
		struct {
			__le64 timestamp;
			u16 beacon_int;
			u16 capab_info;
			/* followed by some of SSID, Supported rates,
			 * FH Params, DS Params, CF Params, IBSS Params */
			u8 variable[0];
		}  __attribute__((packed)) probe_resp;
		struct {
			u8 category;
			union {
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 status_code;
					u8 variable[0];
				}  __attribute__((packed)) wme_action;
#if 0
				struct {
					u8 action_code;
					u8 element_id;
					u8 length;
					struct ieee80211_channel_sw_ie sw_elem;
				}  __attribute__((packed)) chan_switch;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 element_id;
					u8 length;
					struct ieee80211_msrment_ie msr_elem;
				}  __attribute__((packed)) measurement;
#endif
				struct {
					u8 action_code;
					u8 dialog_token;
					u16 capab;
					u16 timeout;
					u16 start_seq_num;
				}  __attribute__((packed)) addba_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					u16 status;
					u16 capab;
					u16 timeout;
				}  __attribute__((packed)) addba_resp;
				struct {
					u8 action_code;
					u16 params;
					u16 reason_code;
				}  __attribute__((packed)) delba;
				struct {
					u8 action_code;
					/* capab_info for open and confirm,
					 * reason for close
					 */
					u16 aux;
					/* Followed in plink_confirm by status
					 * code, AID and supported rates,
					 * and directly by supported rates in
					 * plink_open and plink_close
					 */
					u8 variable[0];
				}  __attribute__((packed)) plink_action;
				struct {
					u8 action_code;
					u8 variable[0];
				}  __attribute__((packed)) mesh_action;
			} __attribute__((packed)) u;
		}  __attribute__((packed)) action;
	} __attribute__((packed)) u;
} __attribute__((packed));

#endif

/* mgmt header + 1 byte category code */
#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)



#endif
                                                                                                                                                                                                                                                     rtl8822bu/src/include/Hal8812PhyReg.h                                                               0000644 0001750 0001750 00000060410 14214766567 015744  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8812PHYREG_H__
#define __INC_HAL8812PHYREG_H__
/*--------------------------Define Parameters-------------------------------*/
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/* BB Register Definition */

#define rCCAonSec_Jaguar		0x838
#define rPwed_TH_Jaguar			0x830

/* BW and sideband setting */
#define rBWIndication_Jaguar		0x834
#define rL1PeakTH_Jaguar			0x848
#define rFPGA0_XA_LSSIReadBack	0x8a0	/*Tranceiver LSSI Readback*/
#define rRFMOD_Jaguar			0x8ac	/* RF mode */
#define rADC_Buf_Clk_Jaguar		0x8c4
#define rRFECTRL_Jaguar			0x900
#define bRFMOD_Jaguar			0xc3
#define rCCK_System_Jaguar		0xa00   /* for cck sideband */
#define bCCK_System_Jaguar		0x10

/* Block & Path enable */
#define rOFDMCCKEN_Jaguar 		0x808 /* OFDM/CCK block enable */
#define bOFDMEN_Jaguar			0x20000000
#define bCCKEN_Jaguar			0x10000000
#define rRxPath_Jaguar			0x808	/* Rx antenna */
#define bRxPath_Jaguar			0xff
#define rTxPath_Jaguar			0x80c	/* Tx antenna */
#define bTxPath_Jaguar			0x0fffffff
#define rCCK_RX_Jaguar			0xa04	/* for cck rx path selection */
#define bCCK_RX_Jaguar			0x0c000000
#define rVhtlen_Use_Lsig_Jaguar	0x8c3	/* Use LSIG for VHT length */

/* RF read/write-related */
#define rHSSIRead_Jaguar			0x8b0  /* RF read addr */
#define bHSSIRead_addr_Jaguar		0xff
#define bHSSIRead_trigger_Jaguar	0x100
#define rA_PIRead_Jaguar			0xd04 /* RF readback with PI */
#define rB_PIRead_Jaguar			0xd44 /* RF readback with PI */
#define rA_SIRead_Jaguar			0xd08 /* RF readback with SI */
#define rB_SIRead_Jaguar			0xd48 /* RF readback with SI */
#define rRead_data_Jaguar			0xfffff
#define rA_LSSIWrite_Jaguar			0xc90 /* RF write addr */
#define rB_LSSIWrite_Jaguar			0xe90 /* RF write addr */
#define bLSSIWrite_data_Jaguar		0x000fffff
#define bLSSIWrite_addr_Jaguar		0x0ff00000



/* YN: mask the following register definition temporarily */
#define rFPGA0_XA_RFInterfaceOE			0x860	/* RF Channel switch */
#define rFPGA0_XB_RFInterfaceOE			0x864

#define rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define rFPGA0_XCD_RFInterfaceSW		0x874

/* #define rFPGA0_XAB_RFParameter		0x878 */	/* RF Parameter
 * #define rFPGA0_XCD_RFParameter		0x87c */

/* #define rFPGA0_AnalogParameter1		0x880 */	/* Crystal cap setting RF-R/W protection for parameter4??
 * #define rFPGA0_AnalogParameter2		0x884
 * #define rFPGA0_AnalogParameter3		0x888
 * #define rFPGA0_AdDaClockEn			0x888 */	/* enable ad/da clock1 for dual-phy
 * #define rFPGA0_AnalogParameter4		0x88c */


/* CCK TX scaling */
#define rCCK_TxFilter1_Jaguar		0xa20
#define bCCK_TxFilter1_C0_Jaguar	0x00ff0000
#define bCCK_TxFilter1_C1_Jaguar		0xff000000
#define rCCK_TxFilter2_Jaguar		0xa24
#define bCCK_TxFilter2_C2_Jaguar		0x000000ff
#define bCCK_TxFilter2_C3_Jaguar		0x0000ff00
#define bCCK_TxFilter2_C4_Jaguar		0x00ff0000
#define bCCK_TxFilter2_C5_Jaguar		0xff000000
#define rCCK_TxFilter3_Jaguar		0xa28
#define bCCK_TxFilter3_C6_Jaguar		0x000000ff
#define bCCK_TxFilter3_C7_Jaguar		0x0000ff00


/* YN: mask the following register definition temporarily
 * #define rPdp_AntA					0xb00
 * #define rPdp_AntA_4				0xb04
 * #define rConfig_Pmpd_AntA			0xb28
 * #define rConfig_AntA					0xb68
 * #define rConfig_AntB					0xb6c
 * #define rPdp_AntB					0xb70
 * #define rPdp_AntB_4					0xb74
 * #define rConfig_Pmpd_AntB			0xb98
 * #define rAPK							0xbd8 */

/* RXIQC */
#define rA_RxIQC_AB_Jaguar    	0xc10  /* RxIQ imblance matrix coeff. A & B */
#define rA_RxIQC_CD_Jaguar    	0xc14  /* RxIQ imblance matrix coeff. C & D */
#define rA_TxScale_Jaguar 		0xc1c  /* Pah_A TX scaling factor */
#define rB_TxScale_Jaguar 		0xe1c  /* Path_B TX scaling factor */
#define rB_RxIQC_AB_Jaguar    	0xe10  /* RxIQ imblance matrix coeff. A & B */
#define rB_RxIQC_CD_Jaguar    	0xe14  /* RxIQ imblance matrix coeff. C & D */
#define b_RxIQC_AC_Jaguar		0x02ff  /* bit mask for IQC matrix element A & C */
#define b_RxIQC_BD_Jaguar		0x02ff0000 /* bit mask for IQC matrix element A & C */


/* DIG-related */
#define rA_IGI_Jaguar				0xc50	/* Initial Gain for path-A */
#define rB_IGI_Jaguar				0xe50	/* Initial Gain for path-B */
#define rOFDM_FalseAlarm1_Jaguar	0xf48  /* counter for break */
#define rOFDM_FalseAlarm2_Jaguar	0xf4c  /* counter for spoofing */
#define rCCK_FalseAlarm_Jaguar        	0xa5c /* counter for cck false alarm */
#define b_FalseAlarm_Jaguar			0xffff
#define rCCK_CCA_Jaguar				0xa08	/* cca threshold */
#define bCCK_CCA_Jaguar				0x00ff0000

/* Tx Power Ttraining-related */
#define rA_TxPwrTraing_Jaguar		0xc54
#define rB_TxPwrTraing_Jaguar		0xe54

/* Report-related */
#define rOFDM_ShortCFOAB_Jaguar	0xf60
#define rOFDM_LongCFOAB_Jaguar		0xf64
#define rOFDM_EndCFOAB_Jaguar		0xf70
#define rOFDM_AGCReport_Jaguar		0xf84
#define rOFDM_RxSNR_Jaguar			0xf88
#define rOFDM_RxEVMCSI_Jaguar		0xf8c
#define rOFDM_SIGReport_Jaguar		0xf90

/* Misc functions */
#define rEDCCA_Jaguar				0x8a4 /* EDCCA */
#define bEDCCA_Jaguar				0xffff
#define rAGC_table_Jaguar			0x82c   /* AGC tabel select */
#define bAGC_table_Jaguar			0x3
#define b_sel5g_Jaguar    				0x1000 /* sel5g */
#define b_LNA_sw_Jaguar				0x8000 /* HW/WS control for LNA */
#define rFc_area_Jaguar				0x860   /* fc_area */
#define bFc_area_Jaguar				0x1ffe000
#define rSingleTone_ContTx_Jaguar	0x914

/* RFE */
#define rA_RFE_Pinmux_Jaguar	0xcb0  /* Path_A RFE cotrol pinmux */
#define rB_RFE_Pinmux_Jaguar	0xeb0 /* Path_B RFE control pinmux */
#define rA_RFE_Inv_Jaguar		0xcb4  /* Path_A RFE cotrol   */
#define rB_RFE_Inv_Jaguar		0xeb4 /* Path_B RFE control */
#define rA_RFE_Jaguar			0xcb8  /* Path_A RFE cotrol   */
#define rB_RFE_Jaguar			0xeb8 /* Path_B RFE control */
#define	rA_RFE_Inverse_Jaguar	0xCBC	/* Path_A RFE control inverse */
#define	rB_RFE_Inverse_Jaguar	0xEBC	/* Path_B RFE control inverse */
#define r_ANTSEL_SW_Jaguar		0x900 /* ANTSEL SW Control */
#define bMask_RFEInv_Jaguar		0x3ff00000
#define bMask_AntselPathFollow_Jaguar 0x00030000

/* TX AGC */
#define rTxAGC_A_CCK11_CCK1_JAguar				0xc20
#define rTxAGC_A_Ofdm18_Ofdm6_JAguar				0xc24
#define rTxAGC_A_Ofdm54_Ofdm24_JAguar			0xc28
#define rTxAGC_A_MCS3_MCS0_JAguar					0xc2c
#define rTxAGC_A_MCS7_MCS4_JAguar					0xc30
#define rTxAGC_A_MCS11_MCS8_JAguar				0xc34
#define rTxAGC_A_MCS15_MCS12_JAguar				0xc38
#define rTxAGC_A_Nss1Index3_Nss1Index0_JAguar	0xc3c
#define rTxAGC_A_Nss1Index7_Nss1Index4_JAguar	0xc40
#define rTxAGC_A_Nss2Index1_Nss1Index8_JAguar	0xc44
#define rTxAGC_A_Nss2Index5_Nss2Index2_JAguar	0xc48
#define rTxAGC_A_Nss2Index9_Nss2Index6_JAguar	0xc4c
#define rTxAGC_B_CCK11_CCK1_JAguar				0xe20
#define rTxAGC_B_Ofdm18_Ofdm6_JAguar				0xe24
#define rTxAGC_B_Ofdm54_Ofdm24_JAguar			0xe28
#define rTxAGC_B_MCS3_MCS0_JAguar					0xe2c
#define rTxAGC_B_MCS7_MCS4_JAguar					0xe30
#define rTxAGC_B_MCS11_MCS8_JAguar				0xe34
#define rTxAGC_B_MCS15_MCS12_JAguar				0xe38
#define rTxAGC_B_Nss1Index3_Nss1Index0_JAguar		0xe3c
#define rTxAGC_B_Nss1Index7_Nss1Index4_JAguar		0xe40
#define rTxAGC_B_Nss2Index1_Nss1Index8_JAguar		0xe44
#define rTxAGC_B_Nss2Index5_Nss2Index2_JAguar		0xe48
#define rTxAGC_B_Nss2Index9_Nss2Index6_JAguar		0xe4c
#define bTxAGC_byte0_Jaguar							0xff
#define bTxAGC_byte1_Jaguar							0xff00
#define bTxAGC_byte2_Jaguar							0xff0000
#define bTxAGC_byte3_Jaguar							0xff000000

/* IQK YN: temporaily mask this part
 * #define rFPGA0_IQK					0xe28
 * #define rTx_IQK_Tone_A				0xe30
 * #define rRx_IQK_Tone_A				0xe34
 * #define rTx_IQK_PI_A					0xe38
 * #define rRx_IQK_PI_A					0xe3c */

/* #define rTx_IQK						0xe40 */
/* #define rRx_IQK						0xe44 */
/* #define rIQK_AGC_Pts					0xe48 */
/* #define rIQK_AGC_Rsp					0xe4c */
/* #define rTx_IQK_Tone_B				0xe50 */
/* #define rRx_IQK_Tone_B				0xe54 */
/* #define rTx_IQK_PI_B					0xe58 */
/* #define rRx_IQK_PI_B					0xe5c */
/* #define rIQK_AGC_Cont				0xe60 */


/* AFE-related */
#define rA_AFEPwr1_Jaguar					0xc60 /* dynamic AFE power control */
#define rA_AFEPwr2_Jaguar					0xc64 /* dynamic AFE power control */
#define rA_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xc68
#define rA_Tx_CCKBBON_OFDMRFON_Jaguar	0xc6c
#define rA_Tx_OFDMBBON_Tx2Rx_Jaguar		0xc70
#define rA_Tx2Tx_RXCCK_Jaguar				0xc74
#define rA_Rx_OFDM_WaitRIFS_Jaguar			0xc78
#define rA_Rx2Rx_BT_Jaguar					0xc7c
#define rA_sleep_nav_Jaguar					0xc80
#define rA_pmpd_Jaguar						0xc84
#define rB_AFEPwr1_Jaguar					0xe60 /* dynamic AFE power control */
#define rB_AFEPwr2_Jaguar					0xe64 /* dynamic AFE power control */
#define rB_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xe68
#define rB_Tx_CCKBBON_OFDMRFON_Jaguar	0xe6c
#define rB_Tx_OFDMBBON_Tx2Rx_Jaguar		0xe70
#define rB_Tx2Tx_RXCCK_Jaguar				0xe74
#define rB_Rx_OFDM_WaitRIFS_Jaguar			0xe78
#define rB_Rx2Rx_BT_Jaguar					0xe7c
#define rB_sleep_nav_Jaguar					0xe80
#define rB_pmpd_Jaguar						0xe84


/* YN: mask these registers temporaily
 * #define rTx_Power_Before_IQK_A		0xe94
 * #define rTx_Power_After_IQK_A			0xe9c */

/* #define rRx_Power_Before_IQK_A		0xea0 */
/* #define rRx_Power_Before_IQK_A_2		0xea4 */
/* #define rRx_Power_After_IQK_A			0xea8 */
/* #define rRx_Power_After_IQK_A_2		0xeac */

/* #define rTx_Power_Before_IQK_B		0xeb4 */
/* #define rTx_Power_After_IQK_B			0xebc */

/* #define rRx_Power_Before_IQK_B		0xec0 */
/* #define rRx_Power_Before_IQK_B_2		0xec4 */
/* #define rRx_Power_After_IQK_B			0xec8 */
/* #define rRx_Power_After_IQK_B_2		0xecc */


/* RSSI Dump */
#define rA_RSSIDump_Jaguar			0xBF0
#define rB_RSSIDump_Jaguar			0xBF1
#define rS1_RXevmDump_Jaguar		0xBF4
#define rS2_RXevmDump_Jaguar		0xBF5
#define rA_RXsnrDump_Jaguar		0xBF6
#define rB_RXsnrDump_Jaguar		0xBF7
#define rA_CfoShortDump_Jaguar		0xBF8
#define rB_CfoShortDump_Jaguar		0xBFA
#define rA_CfoLongDump_Jaguar		0xBEC
#define rB_CfoLongDump_Jaguar		0xBEE


/* RF Register
 *   */
#define RF_AC_Jaguar				0x00	/*  */
#define RF_RF_Top_Jaguar			0x07	/*  */
#define RF_TXLOK_Jaguar				0x08	/*  */
#define RF_TXAPK_Jaguar				0x0B
#define RF_CHNLBW_Jaguar 			0x18	/* RF channel and BW switch */
#define RF_RCK1_Jaguar				0x1c	/*  */
#define RF_RCK2_Jaguar				0x1d
#define RF_RCK3_Jaguar			0x1e
#define RF_ModeTableAddr			0x30
#define RF_ModeTableData0			0x31
#define RF_ModeTableData1			0x32
#define RF_TxLCTank_Jaguar	0x54
#define RF_APK_Jaguar				0x63
#define RF_LCK						0xB4
#define RF_WeLut_Jaguar				0xEF

#define bRF_CHNLBW_MOD_AG_Jaguar	0x70300
#define bRF_CHNLBW_BW				0xc00


/*
 * RL6052 Register definition
 *   */
#define RF_AC						0x00	/*  */
#define RF_IPA_A					0x0C	/*  */
#define RF_TXBIAS_A					0x0D
#define RF_BS_PA_APSET_G9_G11		0x0E
#define RF_MODE1					0x10	/*  */
#define RF_MODE2					0x11	/*  */
#define RF_CHNLBW					0x18	/* RF channel and BW switch */
#define RF_RCK_OS					0x30	/* RF TX PA control */
#define RF_TXPA_G1					0x31	/* RF TX PA control */
#define RF_TXPA_G2					0x32	/* RF TX PA control */
#define RF_TXPA_G3					0x33	/* RF TX PA control */
#define RF_0x52						0x52
#define RF_WE_LUT					0xEF

#define RF_TX_GAIN_OFFSET_8812A(_val) ((abs((_val)) << 1) | (((_val) > 0) ? BIT0 : 0))
#define RF_TX_GAIN_OFFSET_8821A(_val) ((abs((_val)) << 1) | (((_val) > 0) ? BIT0 : 0))

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define bBBResetB					0x100	/* Useless now? */
#define bGlobalResetB				0x200
#define bOFDMTxStart				0x4
#define bCCKTxStart					0x8
#define bCRC32Debug					0x100
#define bPMACLoopback				0x10
#define bTxLSIG						0xffffff
#define bOFDMTxRate					0xf
#define bOFDMTxReserved			0x10
#define bOFDMTxLength				0x1ffe0
#define bOFDMTxParity				0x20000
#define bTxHTSIG1					0xffffff
#define bTxHTMCSRate				0x7f
#define bTxHTBW						0x80
#define bTxHTLength					0xffff00
#define bTxHTSIG2					0xffffff
#define bTxHTSmoothing				0x1
#define bTxHTSounding				0x2
#define bTxHTReserved				0x4
#define bTxHTAggreation				0x8
#define bTxHTSTBC					0x30
#define bTxHTAdvanceCoding			0x40
#define bTxHTShortGI					0x80
#define bTxHTNumberHT_LTF			0x300
#define bTxHTCRC8					0x3fc00
#define bCounterReset				0x10000
#define bNumOfOFDMTx				0xffff
#define bNumOfCCKTx					0xffff0000
#define bTxIdleInterval				0xffff
#define bOFDMService				0xffff0000
#define bTxMACHeader				0xffffffff
#define bTxDataInit					0xff
#define bTxHTMode					0x100
#define bTxDataType					0x30000
#define bTxRandomSeed				0xffffffff
#define bCCKTxPreamble				0x1
#define bCCKTxSFD					0xffff0000
#define bCCKTxSIG					0xff
#define bCCKTxService				0xff00
#define bCCKLengthExt				0x8000
#define bCCKTxLength				0xffff0000
#define bCCKTxCRC16					0xffff
#define bCCKTxStatus					0x1
#define bOFDMTxStatus				0x2


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define rPMAC_Reset					0x100
#define rPMAC_TxStart				0x104
#define rPMAC_TxLegacySIG			0x108
#define rPMAC_TxHTSIG1				0x10c
#define rPMAC_TxHTSIG2				0x110
#define rPMAC_PHYDebug				0x114
#define rPMAC_TxPacketNum			0x118
#define rPMAC_TxIdle					0x11c
#define rPMAC_TxMACHeader0			0x120
#define rPMAC_TxMACHeader1			0x124
#define rPMAC_TxMACHeader2			0x128
#define rPMAC_TxMACHeader3			0x12c
#define rPMAC_TxMACHeader4			0x130
#define rPMAC_TxMACHeader5			0x134
#define rPMAC_TxDataType			0x138
#define rPMAC_TxRandomSeed		0x13c
#define rPMAC_CCKPLCPPreamble		0x140
#define rPMAC_CCKPLCPHeader		0x144
#define rPMAC_CCKCRC16				0x148
#define rPMAC_OFDMRxCRC32OK		0x170
#define rPMAC_OFDMRxCRC32Er		0x174
#define rPMAC_OFDMRxParityEr		0x178
#define rPMAC_OFDMRxCRC8Er			0x17c
#define rPMAC_CCKCRxRC16Er			0x180
#define rPMAC_CCKCRxRC32Er			0x184
#define rPMAC_CCKCRxRC32OK			0x188
#define rPMAC_TxStatus				0x18c

/*
 * 3. Page8(0x800)
 *   */
#define rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define rFPGA0_TxInfo				0x804	/* Status report?? */
#define rFPGA0_PSDFunction			0x808
#define rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define rFPGA0_XA_HSSIParameter1	0x820	/* RF 3 wire register */
#define rFPGA0_XA_HSSIParameter2	0x824
#define rFPGA0_XB_HSSIParameter1	0x828
#define rFPGA0_XB_HSSIParameter2	0x82c

#define rFPGA0_XAB_SwitchControl	0x858	/* RF Channel switch */
#define rFPGA0_XCD_SwitchControl	0x85c

#define rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define rFPGA0_XCD_RFParameter		0x87c

#define rFPGA0_AnalogParameter1	0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define rFPGA0_AnalogParameter2	0x884
#define rFPGA0_AnalogParameter3	0x888
#define rFPGA0_AdDaClockEn			0x888	/* enable ad/da clock1 for dual-phy */
#define rFPGA0_AnalogParameter4	0x88c
#define rFPGA0_XB_LSSIReadBack		0x8a4
#define rFPGA0_XCD_RFPara	0x8b4

/*
 * 4. Page9(0x900)
 *   */
#define rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */

#define rFPGA1_TxBlock				0x904	/* Useless now */
#define rFPGA1_DebugSelect			0x908	/* Useless now */
#define rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */

/*
 * PageA(0xA00)
 *   */
#define rCCK0_System				0xa00
#define rCCK0_AFESetting				0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define	rCCK0_DSPParameter2			0xa1c	/* SQ threshold */
#define rCCK0_TxFilter1				0xa20
#define rCCK0_TxFilter2				0xa24
#define rCCK0_DebugPort				0xa28	/* debug port and Tx filter3 */
#define	rCCK0_FalseAlarmReport			0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA				0xb00
#define rPdp_AntA_4				0xb04
#define rConfig_Pmpd_AntA			0xb28
#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c
#define rPdp_AntB					0xb70
#define rPdp_AntB_4					0xb74
#define rConfig_Pmpd_AntB			0xb98
#define rAPK							0xbd8

/*
 * 6. PageC(0xC00)
 *   */
#define rOFDM0_LSTF					0xc00

#define rOFDM0_TRxPathEnable		0xc04
#define rOFDM0_TRMuxPar			0xc08
#define rOFDM0_TRSWIsolation		0xc0c

#define rOFDM0_XARxAFE				0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
#define rOFDM0_XBRxAFE		0xc18
#define rOFDM0_XBRxIQImbalance	0xc1c
#define rOFDM0_XCRxAFE		0xc20
#define rOFDM0_XCRxIQImbalance	0xc24
#define rOFDM0_XDRxAFE		0xc28
#define rOFDM0_XDRxIQImbalance	0xc2c

#define rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define rOFDM0_CFOandDAGC			0xc44  /* CFO & DAGC */
#define rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define rOFDM0_XAAGCCore2			0xc54
#define rOFDM0_XBAGCCore1			0xc58
#define rOFDM0_XBAGCCore2			0xc5c
#define rOFDM0_XCAGCCore1			0xc60
#define rOFDM0_XCAGCCore2			0xc64
#define rOFDM0_XDAGCCore1			0xc68
#define rOFDM0_XDAGCCore2			0xc6c

#define rOFDM0_AGCParameter1		0xc70
#define rOFDM0_AGCParameter2		0xc74
#define rOFDM0_AGCRSSITable		0xc78
#define rOFDM0_HTSTFAGC			0xc7c

#define rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define rOFDM0_XATxAFE				0xc84
#define rOFDM0_XBTxIQImbalance		0xc88
#define rOFDM0_XBTxAFE				0xc8c
#define rOFDM0_XCTxIQImbalance		0xc90
#define rOFDM0_XCTxAFE		0xc94
#define rOFDM0_XDTxIQImbalance		0xc98
#define rOFDM0_XDTxAFE				0xc9c

#define rOFDM0_RxIQExtAnta			0xca0
#define rOFDM0_TxCoeff1				0xca4
#define rOFDM0_TxCoeff2				0xca8
#define rOFDM0_TxCoeff3				0xcac
#define rOFDM0_TxCoeff4				0xcb0
#define rOFDM0_TxCoeff5				0xcb4
#define rOFDM0_TxCoeff6				0xcb8
#define rOFDM0_RxHPParameter		0xce0
#define rOFDM0_TxPseudoNoiseWgt	0xce4
#define rOFDM0_FrameSync			0xcf0
#define rOFDM0_DFSReport			0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define rOFDM1_LSTF					0xd00
#define rOFDM1_TRxPathEnable		0xd04

/*
 * 8. PageE(0xE00)
 *   */
#define rTxAGC_A_Rate18_06			0xe00
#define rTxAGC_A_Rate54_24			0xe04
#define rTxAGC_A_CCK1_Mcs32		0xe08
#define rTxAGC_A_Mcs03_Mcs00		0xe10
#define rTxAGC_A_Mcs07_Mcs04		0xe14
#define rTxAGC_A_Mcs11_Mcs08		0xe18
#define rTxAGC_A_Mcs15_Mcs12		0xe1c

#define rTxAGC_B_Rate18_06			0x830
#define rTxAGC_B_Rate54_24			0x834
#define rTxAGC_B_CCK1_55_Mcs32	0x838
#define rTxAGC_B_Mcs03_Mcs00		0x83c
#define rTxAGC_B_Mcs07_Mcs04		0x848
#define rTxAGC_B_Mcs11_Mcs08		0x84c
#define rTxAGC_B_Mcs15_Mcs12		0x868
#define rTxAGC_B_CCK11_A_CCK2_11	0x86c

#define rFPGA0_IQK					0xe28
#define rTx_IQK_Tone_A				0xe30
#define rRx_IQK_Tone_A				0xe34
#define rTx_IQK_PI_A				0xe38
#define rRx_IQK_PI_A				0xe3c

#define rTx_IQK						0xe40
#define rRx_IQK						0xe44
#define rIQK_AGC_Pts					0xe48
#define rIQK_AGC_Rsp				0xe4c
#define rTx_IQK_Tone_B				0xe50
#define rRx_IQK_Tone_B				0xe54
#define rTx_IQK_PI_B					0xe58
#define rRx_IQK_PI_B					0xe5c
#define rIQK_AGC_Cont				0xe60

#define rBlue_Tooth					0xe6c
#define rRx_Wait_CCA				0xe70
#define rTx_CCK_RFON				0xe74
#define rTx_CCK_BBON				0xe78
#define rTx_OFDM_RFON				0xe7c
#define rTx_OFDM_BBON				0xe80
#define rTx_To_Rx					0xe84
#define rTx_To_Tx					0xe88
#define rRx_CCK						0xe8c

#define rTx_Power_Before_IQK_A		0xe94
#define rTx_Power_After_IQK_A		0xe9c

#define rRx_Power_Before_IQK_A		0xea0
#define rRx_Power_Before_IQK_A_2	0xea4
#define rRx_Power_After_IQK_A		0xea8
#define rRx_Power_After_IQK_A_2		0xeac

#define rTx_Power_Before_IQK_B		0xeb4
#define rTx_Power_After_IQK_B		0xebc

#define rRx_Power_Before_IQK_B		0xec0
#define rRx_Power_Before_IQK_B_2	0xec4
#define rRx_Power_After_IQK_B		0xec8
#define rRx_Power_After_IQK_B_2		0xecc

#define rRx_OFDM					0xed0
#define rRx_Wait_RIFS				0xed4
#define rRx_TO_Rx					0xed8
#define rStandby						0xedc
#define rSleep						0xee0
#define rPMPD_ANAEN				0xeec


/* 2. Page8(0x800) */
#define bRFMOD						0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define bJapanMode					0x2
#define bCCKTxSC					0x30
#define bCCKEn						0x1000000
#define bOFDMEn						0x2000000
#define bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define bXCTxAGC			0xf000
#define bXDTxAGC			0xf0000

/* 4. PageA(0xA00) */
#define bCCKBBMode                			0x3	/* Useless */
#define bCCKTxPowerSaving		0x80
#define bCCKRxPowerSaving		0x40

#define bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define bCCKScramble              		0x8	/* Useless */
#define bCCKAntDiversity			0x8000
#define bCCKCarrierRecovery		0x4000
#define bCCKTxRate			0x3000
#define bCCKDCCancel			0x0800
#define bCCKISICancel			0x0400
#define bCCKMatchFilter		0x0200
#define bCCKEqualizer			0x0100
#define bCCKPreambleDetect		0x800000
#define bCCKFastFalseCCA		0x400000
#define bCCKChEstStart		0x300000
#define bCCKCCACount		0x080000
#define bCCKcs_lim			0x070000
#define bCCKBistMode			0x80000000
#define bCCKCCAMask			0x40000000
#define bCCKTxDACPhase		0x4
#define bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
#define bCCKr_cp_mode0		0x0100
#define bCCKTxDCOffset		0xf0
#define bCCKRxDCOffset		0xf
#define bCCKCCAMode			0xc000
#define bCCKFalseCS_lim		0x3f00
#define bCCKCS_ratio			0xc00000
#define bCCKCorgBit_sel		0x300000
#define bCCKPD_lim			0x0f0000
#define bCCKNewCCA		0x80000000
#define bCCKRxHPofIG		0x8000
#define bCCKRxIG			0x7f00
#define bCCKLNAPolarity		0x800000
#define bCCKRx1stGain		0x7f0000
#define bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
#define bCCKRxAGCSatLevel		0x1f000000
#define bCCKRxAGCSatCount		0xe0
#define bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
#define bCCKFixedRxAGC		0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define bCCKAntennaPolarity		0x2000
#define bCCKTxFilterType		0x0c00
#define bCCKRxAGCReportType		0x0300
#define bCCKRxDAGCEn		0x80000000
#define bCCKRxDAGCPeriod		0x20000000
#define bCCKRxDAGCSatLevel		0x1f000000
#define bCCKTimingRecovery		0x800000
#define bCCKTxC0			0x3f0000
#define bCCKTxC1			0x3f000000
#define bCCKTxC2			0x3f
#define bCCKTxC3			0x3f00
#define bCCKTxC4			0x3f0000
#define bCCKTxC5			0x3f000000
#define bCCKTxC6			0x3f
#define bCCKTxC7			0x3f00
#define bCCKDebugPort		0xff0000
#define bCCKDACDebug		0x0f000000
#define bCCKFalseAlarmEnable		0x8000
#define bCCKFalseAlarmRead		0x4000
#define bCCKTRSSI			0x7f
#define bCCKRxAGCReport		0xfe
#define bCCKRxReport_AntSel		0x80000000
#define bCCKRxReport_MFOff		0x40000000
#define bCCKRxRxReport_SQLoss	0x20000000
#define bCCKRxReport_Pktloss		0x10000000
#define bCCKRxReport_Lockedbit	0x08000000
#define bCCKRxReport_RateError	0x04000000
#define bCCKRxReport_RxRate		0x03000000
#define bCCKRxFACounterLower	0xff
#define bCCKRxFACounterUpper	0xff000000
#define bCCKRxHPAGCStart		0xe000
#define bCCKRxHPAGCFinal		0x1c00
#define bCCKRxFalseAlarmEnable	0x8000
#define bCCKFACounterFreeze		0x4000
#define bCCKTxPathSel		0x10000000
#define bCCKDefaultRxPath		0xc000000
#define bCCKOptionRxPath		0x3000000

/* 6. PageE(0xE00) */
#define bSTBCEn                  			0x4	/* Useless */
#define bAntennaMapping		0x10
#define bNss				0x20
#define bCFOAntSumD		0x200
#define bPHYCounterReset		0x8000000
#define bCFOReportGet			0x4000000
#define bOFDMContinueTx		0x10000000
#define bOFDMSingleCarrier		0x20000000
#define bOFDMSingleTone		0x40000000


/*
 * Other Definition
 *   */

#define bEnable                   0x1	/* Useless */
#define bDisable                  0x0

/* byte endable for srwrite */
#define bByte0                    		0x1	/* Useless */
#define bByte1		0x2
#define bByte2		0x4
#define bByte3		0x8
#define bWord0		0x3
#define bWord1		0xc
#define bDWord		0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define bMaskByte0                		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define bMaskByte1		0xff00
#define bMaskByte2		0xff0000
#define bMaskByte3		0xff000000
#define bMaskHWord	0xffff0000
#define bMaskLWord		0x0000ffff
#define bMaskDWord	0xffffffff
#define bMaskH3Bytes				0xffffff00
#define bMask12Bits				0xfff
#define bMaskH4Bits				0xf0000000
#define bMaskOFDM_D			0xffc00000
#define bMaskCCK				0x3f3f3f3f


/*--------------------------Define Parameters-------------------------------*/


#endif
                                                                                                                                                                                                                                                        rtl8822bu/src/include/Hal8188EPhyCfg.h                                                              0000644 0001750 0001750 00000014502 14214766567 016042  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8188EPHYCFG_H__
#define __INC_HAL8188EPHYCFG_H__


/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue		0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters-------------------------------*/


/*------------------------------Define structure----------------------------*/

#define	MAX_TX_COUNT_8188E			1

/* BB/RF related */


/*------------------------------Define structure----------------------------*/


/*------------------------Export global variable----------------------------*/
/*------------------------Export global variable----------------------------*/


/*------------------------Export Marco Definition---------------------------*/
/*------------------------Export Marco Definition---------------------------*/


/*--------------------------Exported Function prototype---------------------*/
/*
 * BB and RF register read/write
 *   */
u32	PHY_QueryBBReg8188E(PADAPTER	Adapter,
				u32		RegAddr,
				u32		BitMask);
void	PHY_SetBBReg8188E(PADAPTER	Adapter,
				u32		RegAddr,
				u32		BitMask,
				u32		Data);
u32	PHY_QueryRFReg8188E(PADAPTER	Adapter,
				enum rf_path		eRFPath,
				u32				RegAddr,
				u32				BitMask);
void	PHY_SetRFReg8188E(PADAPTER		Adapter,
				enum rf_path		eRFPath,
				u32				RegAddr,
				u32				BitMask,
				u32				Data);

/*
 * Initialization related function
 */
/* MAC/BB/RF HAL config */
int	PHY_MACConfig8188E(PADAPTER	Adapter);
int	PHY_BBConfig8188E(PADAPTER	Adapter);
int	PHY_RFConfig8188E(PADAPTER	Adapter);

/* RF config */
int	rtl8188e_PHY_ConfigRFWithParaFile( PADAPTER Adapter, u8 *pFileName, enum rf_path eRFPath);

/*
 * RF Power setting
 */
/* extern	BOOLEAN	PHY_SetRFPowerState(PADAPTER			Adapter,
 *										RT_RF_POWER_STATE	eRFPowerState); */

/*
 * BB TX Power R/W
 *   */
void	PHY_SetTxPowerLevel8188E(PADAPTER		Adapter,
					u8			channel);

void
PHY_SetTxPowerIndex_8188E(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

s8 phy_get_txpwr_target_extra_bias_8188e(_adapter *adapter, enum rf_path rfpath
	, RATE_SECTION rs, enum MGN_RATE rate, enum channel_width bw, BAND_TYPE band, u8 cch);

/*
 * Switch bandwidth for 8192S
 */
/* extern	void	PHY_SetBWModeCallback8192C(PRT_TIMER		pTimer	); */
void	PHY_SetBWMode8188E(PADAPTER			pAdapter,
				enum channel_width	ChnlWidth,
				unsigned char	Offset);

/*
 * Set FW CMD IO for 8192S.
 */
/* extern	BOOLEAN HalSetIO8192C(PADAPTER			Adapter,
 *								IO_TYPE				IOType); */

/*
 * Set A2 entry to fw for 8192S
 *   */
extern	void FillA2Entry8192C(PADAPTER			Adapter,
				u8				index,
				u8				*val);


/*
 * channel switch related funciton
 */
/* extern	void	PHY_SwChnlCallback8192C(PRT_TIMER		pTimer	); */
void	PHY_SwChnl8188E(PADAPTER		pAdapter,
				u8			channel);

void
PHY_SetSwChnlBWMode8188E(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void
PHY_SetRFEReg_8188E(
		PADAPTER		Adapter
);
/*
 * BB/MAC/RF other monitor API
 *   */
void phy_set_rf_path_switch_8188e(struct dm_struct	*phydm, bool		bMain);

extern	void
PHY_SwitchEphyParameter(
		PADAPTER			Adapter
);

extern	void
PHY_EnableHostClkReq(
		PADAPTER			Adapter
);

BOOLEAN
SetAntennaConfig92C(
		PADAPTER	Adapter,
		u8		DefaultAnt
);

/*--------------------------Exported Function prototype---------------------*/

/*
 * Initialization related function
 *
 * MAC/BB/RF HAL config */
/* extern s32 PHY_MACConfig8723(PADAPTER padapter);
 * s32 PHY_BBConfig8723(PADAPTER padapter);
 * s32 PHY_RFConfig8723(PADAPTER padapter); */



/* ******************************************************************
 * Note: If SIC_ENABLE under PCIE, because of the slow operation
 *	you should
 * 	2) "#define RTL8723_FPGA_VERIFICATION	1"				in Precomp.h.WlanE.Windows
 * 	3) "#define RTL8190_Download_Firmware_From_Header	0"	in Precomp.h.WlanE.Windows if needed.
 *   */
#if (RTL8188E_SUPPORT == 1) && (RTL8188E_FPGA_TRUE_PHY_VERIFICATION == 1)
	#define	SIC_ENABLE				1
	#define	SIC_HW_SUPPORT		1
#else
	#define	SIC_ENABLE				0
	#define	SIC_HW_SUPPORT		0
#endif
/* ****************************************************************** */


#define	SIC_MAX_POLL_CNT		5

#if (SIC_HW_SUPPORT == 1)
	#define	SIC_CMD_READY			0
	#define	SIC_CMD_PREWRITE		0x1
	#if (RTL8188E_SUPPORT == 1)
		#define	SIC_CMD_WRITE			0x40
		#define	SIC_CMD_PREREAD		0x2
		#define	SIC_CMD_READ			0x80
		#define	SIC_CMD_INIT			0xf0
		#define	SIC_INIT_VAL			0xff

		#define	SIC_INIT_REG			0x1b7
		#define	SIC_CMD_REG			0x1EB		/* 1byte */
		#define	SIC_ADDR_REG			0x1E8		/* 1b4~1b5, 2 bytes */
		#define	SIC_DATA_REG			0x1EC		/* 1b0~1b3 */
	#else
		#define	SIC_CMD_WRITE			0x11
		#define	SIC_CMD_PREREAD		0x2
		#define	SIC_CMD_READ			0x12
		#define	SIC_CMD_INIT			0x1f
		#define	SIC_INIT_VAL			0xff

		#define	SIC_INIT_REG			0x1b7
		#define	SIC_CMD_REG			0x1b6		/* 1byte */
		#define	SIC_ADDR_REG			0x1b4		/* 1b4~1b5, 2 bytes */
		#define	SIC_DATA_REG			0x1b0		/* 1b0~1b3 */
	#endif
#else
	#define	SIC_CMD_READY			0
	#define	SIC_CMD_WRITE			1
	#define	SIC_CMD_READ			2

	#if (RTL8188E_SUPPORT == 1)
		#define	SIC_CMD_REG			0x1EB		/* 1byte */
		#define	SIC_ADDR_REG			0x1E8		/* 1b9~1ba, 2 bytes */
		#define	SIC_DATA_REG			0x1EC		/* 1bc~1bf */
	#else
		#define	SIC_CMD_REG			0x1b8		/* 1byte */
		#define	SIC_ADDR_REG			0x1b9		/* 1b9~1ba, 2 bytes */
		#define	SIC_DATA_REG			0x1bc		/* 1bc~1bf */
	#endif
#endif

#if (SIC_ENABLE == 1)
	void SIC_Init( PADAPTER Adapter);
#endif


#endif /* __INC_HAL8192CPHYCFG_H */
                                                                                                                                                                                              rtl8822bu/src/include/rtl8821c_hal.h                                                                0000644 0001750 0001750 00000005176 14214766567 015721  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8821C_HAL_H_
#define _RTL8821C_HAL_H_

#include <osdep_service.h>		/* BIT(x) */
#include "../hal/halmac/halmac_api.h"	/* MAC REG definition */
#include "hal_data.h"
#include "rtl8821c_spec.h"
#include "../hal/rtl8821c/hal8821c_fw.h"

#ifdef CONFIG_USB_HCI
#include <rtl8821cu_hal.h>
#endif
#ifdef CONFIG_SDIO_HCI
#include <rtl8821cs_hal.h>
#endif
#ifdef CONFIG_PCI_HCI
#include <rtl8821ce_hal.h>
#endif

#ifdef CONFIG_SUPPORT_TRX_SHARED
#define FIFO_BLOCK_SIZE		32768 /*@Block size = 32K*/
#define RX_FIFO_EXPANDING	(1 * FIFO_BLOCK_SIZE)
#else
#define RX_FIFO_EXPANDING	0
#endif


#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			/* 8821C - RX FIFO :16K ,for RX agg DMA mode = 16K, Rx agg USB mode could large than 16k*/
			/* #define MAX_RECVBUF_SZ		(16384 + RX_FIFO_EXPANDING)*/
			/* For Max throughput issue , need to use USB AGG mode to replace DMA AGG mode*/
			#define MAX_RECVBUF_SZ (32768)

			/*#define MAX_RECVBUF_SZ_8821C (24576)*/ /* 24k*/
			/*#define MAX_RECVBUF_SZ_8821C (20480)*/ /*20K*/
			/*#define MAX_RECVBUF_SZ_8821C (10240) */ /*10K*/
			/*#define MAX_RECVBUF_SZ_8821C (15360)*/ /*15k < 16k*/
			/*#define MAX_RECVBUF_SZ_8821C (8192+1024)*/ /* 8K+1k*/
		#else
			#define MAX_RECVBUF_SZ (4096 + RX_FIFO_EXPANDING) /* about 4K */
		#endif
	#endif/* !MAX_RECVBUF_SZ*/

#elif defined(CONFIG_PCI_HCI)
	/*#ifndef CONFIG_MINIMAL_MEMORY_USAGE
	#define MAX_RECVBUF_SZ (9100)
	#else*/
	#define MAX_RECVBUF_SZ (4096 + RX_FIFO_EXPANDING) /* about 4K */
	/*#endif*/

#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	#define MAX_RECVBUF_SZ	(16384 + RX_FIFO_EXPANDING)
#endif

void init_hal_spec_rtl8821c(PADAPTER);
/* MP Functions */
#ifdef CONFIG_MP_INCLUDED
void rtl8821c_prepare_mp_txdesc(PADAPTER, struct mp_priv *);	/* rtw_mp.c */
void rtl8821c_mp_config_rfpath(PADAPTER);			/* hal_mp.c */
#endif
void rtl8821c_dl_rsvd_page(PADAPTER adapter, u8 mstatus);

#ifdef CONFIG_PCI_HCI
u16 get_txbd_rw_reg(u16 q_idx);
#endif

#endif /* _RTL8821C_HAL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/include/mlme_osdep.h                                                                  0000644 0001750 0001750 00000002060 14214766567 015717  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef	__MLME_OSDEP_H_
#define __MLME_OSDEP_H_

extern void rtw_os_indicate_disconnect(_adapter *adapter, u16 reason, u8 locally_generated);
extern int rtw_os_indicate_connect(_adapter *adapter);
void rtw_os_indicate_scan_done(_adapter *padapter, bool aborted);
extern void rtw_report_sec_ie(_adapter *adapter, u8 authmode, u8 *sec_ie);

void rtw_reset_securitypriv(_adapter *adapter);

#endif /* _MLME_OSDEP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                rtl8822bu/src/include/rtl8188f_recv.h                                                               0000644 0001750 0001750 00000004313 14214766567 016115  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_RECV_H__
#define __RTL8188F_RECV_H__

#if defined(CONFIG_USB_HCI)
	#ifndef MAX_RECVBUF_SZ

		#ifdef CONFIG_MINIMAL_MEMORY_USAGE
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#else
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
			#elif defined(CONFIG_PLATFORM_HISILICON)
				#define MAX_RECVBUF_SZ (16384) /* 16k */
			#else
				#define MAX_RECVBUF_SZ (32768) /* 32k */
			#endif
			/* #define MAX_RECVBUF_SZ (20480) */ /* 20K */
			/* #define MAX_RECVBUF_SZ (10240)  */ /* 10K */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16k - 92E RX BUF :16K */
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k		 */
		#endif
	#endif /* !MAX_RECVBUF_SZ */
#elif defined(CONFIG_PCI_HCI)
	#define MAX_RECVBUF_SZ (4000) /* about 4K */
#elif defined(CONFIG_SDIO_HCI)
	#define MAX_RECVBUF_SZ (RX_DMA_BOUNDARY_8188F + 1)
#endif /* CONFIG_SDIO_HCI */

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
s32 rtl8188fs_init_recv_priv(PADAPTER padapter);
void rtl8188fs_free_recv_priv(PADAPTER padapter);
s32 rtl8188fs_recv_hdl(_adapter *padapter);
#endif

#ifdef CONFIG_USB_HCI
int rtl8188fu_init_recv_priv(_adapter *padapter);
void rtl8188fu_free_recv_priv(_adapter *padapter);
void rtl8188fu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
#endif

#ifdef CONFIG_PCI_HCI
s32 rtl8188fe_init_recv_priv(PADAPTER padapter);
void rtl8188fe_free_recv_priv(PADAPTER padapter);
#endif

void rtl8188f_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8188F_RECV_H__ */
                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/rtw_beamforming.h                                                             0000644 0001750 0001750 00000021364 14214766567 016765  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_BEAMFORMING_H_
#define __RTW_BEAMFORMING_H_

#ifdef CONFIG_BEAMFORMING

#ifdef RTW_BEAMFORMING_VERSION_2
#define MAX_NUM_BEAMFORMEE_SU	2
#define MAX_NUM_BEAMFORMER_SU	2
#define MAX_NUM_BEAMFORMEE_MU	6
#define MAX_NUM_BEAMFORMER_MU	1

#define MAX_BEAMFORMEE_ENTRY_NUM	(MAX_NUM_BEAMFORMEE_SU + MAX_NUM_BEAMFORMEE_MU)
#define MAX_BEAMFORMER_ENTRY_NUM	(MAX_NUM_BEAMFORMER_SU + MAX_NUM_BEAMFORMER_MU)

/* <Note> Need to be defined by IC */
#define SU_SOUNDING_TIMEOUT	5	/* unit: ms */
#define MU_SOUNDING_TIMEOUT	8	/* unit: ms */

#define GET_BEAMFORM_INFO(adapter)	(&GET_HAL_DATA(adapter)->beamforming_info)
#define GetInitSoundCnt(_SoundPeriod, _MinSoundPeriod)	((_SoundPeriod)/(_MinSoundPeriod))

enum BEAMFORMING_CTRL_TYPE {
	BEAMFORMING_CTRL_ENTER = 0,
	BEAMFORMING_CTRL_LEAVE = 1,
	BEAMFORMING_CTRL_START_PERIOD = 2,
	BEAMFORMING_CTRL_END_PERIOD = 3,
	BEAMFORMING_CTRL_SOUNDING_FAIL = 4,
	BEAMFORMING_CTRL_SOUNDING_CLK = 5,
	BEAMFORMING_CTRL_SET_GID_TABLE = 6,
	BEAMFORMING_CTRL_SET_CSI_REPORT = 7,
};

enum _BEAMFORMING_STATE {
	BEAMFORMING_STATE_IDLE,
	BEAMFORMING_STATE_START,
	BEAMFORMING_STATE_END,
};

/*
 * typedef BEAMFORMING_CAP for phydm
 */
typedef enum beamforming_cap {
	BEAMFORMING_CAP_NONE = 0x0,
	BEAMFORMER_CAP_HT_EXPLICIT = 0x1,
	BEAMFORMEE_CAP_HT_EXPLICIT = 0x2,
	BEAMFORMER_CAP_VHT_SU = 0x4,			/* Self has er Cap, because Reg er  & peer ee */
	BEAMFORMEE_CAP_VHT_SU = 0x8, 			/* Self has ee Cap, because Reg ee & peer er */
	BEAMFORMER_CAP_VHT_MU = 0x10,			/* Self has er Cap, because Reg er & peer ee */
	BEAMFORMEE_CAP_VHT_MU = 0x20,			/* Self has ee Cap, because Reg ee & peer er */
	BEAMFORMER_CAP = 0x40,
	BEAMFORMEE_CAP = 0x80,
} BEAMFORMING_CAP;

enum _BEAMFORM_ENTRY_HW_STATE {
	BEAMFORM_ENTRY_HW_STATE_NONE,
	BEAMFORM_ENTRY_HW_STATE_ADD_INIT,
	BEAMFORM_ENTRY_HW_STATE_ADDING,
	BEAMFORM_ENTRY_HW_STATE_ADDED,
	BEAMFORM_ENTRY_HW_STATE_DELETE_INIT,
	BEAMFORM_ENTRY_HW_STATE_DELETING,
	BEAMFORM_ENTRY_HW_STATE_MAX
};

/* The sounding state is recorded by BFer. */
enum _SOUNDING_STATE {
	SOUNDING_STATE_NONE		= 0,
	SOUNDING_STATE_INIT		= 1,
	SOUNDING_STATE_SU_START		= 2,
	SOUNDING_STATE_SU_SOUNDDOWN	= 3,
	SOUNDING_STATE_MU_START		= 4,
	SOUNDING_STATE_MU_SOUNDDOWN	= 5,
	SOUNDING_STATE_SOUNDING_TIMEOUT	= 6,
	SOUNDING_STATE_MAX
};

struct beamformee_entry {
	u8 used;	/* _TRUE/_FALSE */
	u8 txbf;
	u8 sounding;
	/* Used to construct AID field of NDPA packet */
	u16 aid;
	/* Used to Set Reg42C in IBSS mode */
	u16 mac_id;
	/* Used to fill Reg42C & Reg714 to compare with P_AID of Tx DESC */
	u16 p_aid;
	u8 g_id;
	/* Used to fill Reg6E4 to fill Mac address of CSI report frame */
	u8 mac_addr[ETH_ALEN];
	/* Sounding BandWidth */
	enum channel_width sound_bw;
	u16 sound_period;

	enum beamforming_cap cap;
	enum _BEAMFORM_ENTRY_HW_STATE state;

	/* The BFee need to be sounded when count to zero */
	u8 SoundCnt;
	u8 bCandidateSoundingPeer;
	u8 bSoundingTimeout;
	u8 bDeleteSounding;
	/* Get the result through throughput and Tx rate from BB API */
	u8 bApplySounding;

	/* information for sounding judgement */
	systime tx_timestamp;
	u64 tx_bytes;

	u16 LogStatusFailCnt:5;	/* 0~21 */
	u16 DefaultCSICnt:5; /* 0~21 */
	u8 CSIMatrix[327];
	u16 CSIMatrixLen;

	u8 NumofSoundingDim;

	u8 comp_steering_num_of_bfer;


	/* SU-MIMO */
	u8 su_reg_index;

	/* MU-MIMO */
	u8 mu_reg_index;
	u8 gid_valid[8];
	u8 user_position[16];

	/* For 8822B C-cut workaround */
	/* If the flag set to _TRUE, do not sound this STA */
	u8 bSuspendSUCap;
};

struct beamformer_entry {
	u8 used;
	/* p_aid of BFer entry is probably not used */
	/* Used to fill Reg42C & Reg714 to compare with p_aid of Tx DESC */
	u16 p_aid;
	u8 g_id;
	u8 mac_addr[ETH_ALEN];

	enum beamforming_cap cap;
	enum _BEAMFORM_ENTRY_HW_STATE state;

	u8 NumofSoundingDim;

	/* SU-MIMO */
	u8 su_reg_index;

	/* MU-MIMO */
	u8 gid_valid[8];
	u8 user_position[16];
	u16 aid;
};

struct sounding_info {
	u8 su_sounding_list[MAX_NUM_BEAMFORMEE_SU];
	u8 mu_sounding_list[MAX_NUM_BEAMFORMEE_MU];

	enum _SOUNDING_STATE state;
	/*
	 * su_bfee_curidx is index for beamforming_info.bfee_entry[]
	 * range: 0~MAX_BEAMFORMEE_ENTRY_NUM
	 */
	u8 su_bfee_curidx;
	u8 candidate_mu_bfee_cnt;

	/* For sounding schedule maintenance */
	u16 min_sounding_period;
	/* Get from sounding list */
	/* Ex: SU STA1, SU STA2, MU STA(1~n) => the value will be 2+1=3 */
	u8 sound_remain_cnt_per_period;
};

struct _RT_CSI_INFO{
	u8 Nc;
	u8 Nr;
	u8 Ng;
	u8 CodeBook;
	u8 ChnlWidth;
	u8 bVHT;
};

struct beamforming_info {
	enum beamforming_cap beamforming_cap;
	enum _BEAMFORMING_STATE beamforming_state;
	struct beamformee_entry bfee_entry[MAX_BEAMFORMEE_ENTRY_NUM];
	struct beamformer_entry bfer_entry[MAX_BEAMFORMER_ENTRY_NUM];
	u8 sounding_sequence;
	u8 beamformee_su_cnt;
	u8 beamformer_su_cnt;
	u32 beamformee_su_reg_maping;
	u32 beamformer_su_reg_maping;
	/* For MU-MINO */
	u8 beamformee_mu_cnt;
	u8 beamformer_mu_cnt;
	u32 beamformee_mu_reg_maping;
	u8 first_mu_bfee_index;
	u8 mu_bfer_curidx;
	u8 cur_csi_rpt_rate;

	struct sounding_info sounding_info;
	/* schedule regular timer for sounding */
	_timer sounding_timer;
	/* moniter if soudning too long */
	_timer sounding_timeout_timer;

	/* For HW configuration */
	u8 SetHalBFEnterOnDemandCnt;
	u8 SetHalBFLeaveOnDemandCnt;
	u8 SetHalSoundownOnDemandCnt;
	u8 bSetBFHwConfigInProgess;

	/*
	 * Target CSI report info.
	 * Keep the first SU CSI report info for 8822B HW bug workaround.
	 */
	u8 bEnableSUTxBFWorkAround;
	struct _RT_CSI_INFO TargetCSIInfo;
	/* Only peform sounding to the first SU BFee */
	struct beamformee_entry *TargetSUBFee;

	/* For debug */
	s8 sounding_running;
};

enum beamforming_cap rtw_bf_bfee_get_entry_cap_by_macid(void *mlmepriv, u8 mac_id);
struct beamformer_entry *rtw_bf_bfer_get_entry_by_addr(PADAPTER, u8 *ra);
struct beamformee_entry *rtw_bf_bfee_get_entry_by_addr(PADAPTER, u8 *ra);
void rtw_bf_get_ndpa_packet(PADAPTER, union recv_frame *);
u32 rtw_bf_get_report_packet(PADAPTER, union recv_frame *);
u8 rtw_bf_send_vht_gid_mgnt_packet(PADAPTER, u8 *ra, u8 *gid, u8 *position);
void rtw_bf_get_vht_gid_mgnt_packet(PADAPTER, union recv_frame *);
void rtw_bf_init(PADAPTER);
void rtw_bf_cmd_hdl(PADAPTER, u8 type, u8 *pbuf);
u8 rtw_bf_cmd(PADAPTER, s32 type, u8 *pbuf, s32 size, u8 enqueue);
void rtw_bf_update_attrib(PADAPTER, struct pkt_attrib *, struct sta_info *);
void rtw_bf_c2h_handler(PADAPTER, u8 id, u8 *buf, u8 buf_len);
void rtw_bf_update_traffic(PADAPTER);

/* Compatible with old function name, only for using outside rtw_beamforming.c */
#define beamforming_get_entry_beam_cap_by_mac_id	rtw_bf_bfee_get_entry_cap_by_macid
#define rtw_beamforming_get_ndpa_frame			rtw_bf_get_ndpa_packet
#define rtw_beamforming_get_report_frame			rtw_bf_get_report_packet
#define rtw_beamforming_get_vht_gid_mgnt_frame		rtw_bf_get_vht_gid_mgnt_packet
#define beamforming_wk_hdl				rtw_bf_cmd_hdl
#define beamforming_wk_cmd				rtw_bf_cmd
#define update_attrib_txbf_info				rtw_bf_update_attrib

#define HT_BF_CAP(adapter) ((adapter)->mlmepriv.htpriv.beamform_cap)
#define VHT_BF_CAP(adapter) ((adapter)->mlmepriv.vhtpriv.beamform_cap)

#define IS_HT_BEAMFORMEE(adapter) \
		(HT_BF_CAP(adapter) & \
		(BEAMFORMING_HT_BEAMFORMEE_ENABLE))

#define IS_VHT_BEAMFORMEE(adapter) \
		(VHT_BF_CAP(adapter) & \
		(BEAMFORMING_VHT_BEAMFORMEE_ENABLE | \
		 BEAMFORMING_VHT_MU_MIMO_STA_ENABLE))

#define IS_BEAMFORMEE(adapter) (IS_HT_BEAMFORMEE(adapter) | \
				IS_VHT_BEAMFORMEE(adapter))

#else /* !RTW_BEAMFORMING_VERSION_2 */
/*PHYDM_BF - (BEAMFORMING_SUPPORT == 1)*/
enum BEAMFORMING_CTRL_TYPE {
	BEAMFORMING_CTRL_ENTER = 0,
	BEAMFORMING_CTRL_LEAVE = 1,
	BEAMFORMING_CTRL_START_PERIOD = 2,
	BEAMFORMING_CTRL_END_PERIOD = 3,
	BEAMFORMING_CTRL_SOUNDING_FAIL = 4,
	BEAMFORMING_CTRL_SOUNDING_CLK = 5,
};
u32	rtw_beamforming_get_report_frame(PADAPTER	 Adapter, union recv_frame *precv_frame);
void	rtw_beamforming_get_ndpa_frame(PADAPTER	 Adapter, union recv_frame *precv_frame);

void	beamforming_wk_hdl(_adapter *padapter, u8 type, u8 *pbuf);
u8	beamforming_wk_cmd(_adapter *padapter, s32 type, u8 *pbuf, s32 size, u8 enqueue);
void update_attrib_txbf_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);

#endif /* !RTW_BEAMFORMING_VERSION_2 */

#endif /*#ifdef CONFIG_BEAMFORMING */

#endif /*__RTW_BEAMFORMING_H_*/
                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8192e_spec.h                                                               0000644 0001750 0001750 00000031613 14214766567 016105  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_SPEC_H__
#define __RTL8192E_SPEC_H__

#include <drv_conf.h>

#define HAL_NAV_UPPER_UNIT_8192E		128		/* micro-second */

/* ************************************************************
 * 8192E Regsiter offset definition
 * ************************************************************ */

/* ************************************************************
 *
 * ************************************************************ */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_SYS_SWR_CTRL1_8192E		0x0010	/* 1 Byte        */
#define REG_SYS_SWR_CTRL2_8192E		0x0014	/* 1 Byte      */
#define REG_AFE_CTRL1_8192E			0x0024
#define REG_AFE_CTRL2_8192E			0x0028
#define REG_AFE_CTRL3_8192E			0x002c

#define REG_PAD_CTRL1_8192E			0x0064
#define REG_SDIO_CTRL_8192E			0x0070
#define REG_OPT_CTRL_8192E				0x0074
#define REG_RF_B_CTRL_8192E			0x0076
#define REG_AFE_CTRL4_8192E			0x0078
#define REG_LDO_SWR_CTRL				0x007C
#define REG_FW_DRV_MSG_8192E			0x0088
#define REG_HMEBOX_E2_E3_8192E		0x008C
#define REG_HIMR0_8192E				0x00B0
#define REG_HISR0_8192E					0x00B4
#define REG_HIMR1_8192E					0x00B8
#define REG_HISR1_8192E					0x00BC

#define REG_SYS_CFG1_8192E				0x00F0
#define REG_SYS_CFG2_8192E				0x00FC
/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_PKTBUF_DBG_ADDR			(REG_PKTBUF_DBG_CTRL)
#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
#define REG_WOWLAN_WAKE_REASON		REG_MCUTST_WOWLAN

#define REG_RSVD3_8192E					0x0168
#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
#define REG_C2HEVT_CMD_LEN_88XX		0x01AE

#define REG_HMEBOX_EXT0_8192E			0x01F0
#define REG_HMEBOX_EXT1_8192E			0x01F4
#define REG_HMEBOX_EXT2_8192E			0x01F8
#define REG_HMEBOX_EXT3_8192E			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_DWBCN0_CTRL             0x0208
#define REG_DWBCN1_CTRL             0x0228

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_8192E					0x0290
#define REG_EARLY_MODE_CONTROL_8192E		0x02BC

#define REG_RSVD5_8192E					0x02F0
#define REG_RSVD6_8192E					0x02F4
#define REG_RSVD7_8192E					0x02F8
#define REG_RSVD8_8192E					0x02FC

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8192E			0x0300
#define	REG_INT_MIG_8192E					0x0304	/* Interrupt Migration */
#define	REG_BCNQ_TXBD_DESA_8192E		0x0308	/* TX Beacon Descriptor Address */
#define	REG_MGQ_TXBD_DESA_8192E			0x0310	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_TXBD_DESA_8192E			0x0318	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_TXBD_DESA_8192E			0x0320	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_TXBD_DESA_8192E			0x0328	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_TXBD_DESA_8192E			0x0330	/* TX BK Queue Descriptor Address */
#define	REG_RXQ_RXBD_DESA_8192E			0x0338	/* RX Queue	Descriptor Address */
#define	REG_HI0Q_TXBD_DESA_8192E			0x0340
#define	REG_HI1Q_TXBD_DESA_8192E			0x0348
#define	REG_HI2Q_TXBD_DESA_8192E			0x0350
#define	REG_HI3Q_TXBD_DESA_8192E			0x0358
#define	REG_HI4Q_TXBD_DESA_8192E			0x0360
#define	REG_HI5Q_TXBD_DESA_8192E			0x0368
#define	REG_HI6Q_TXBD_DESA_8192E			0x0370
#define	REG_HI7Q_TXBD_DESA_8192E			0x0378
#define	REG_MGQ_TXBD_NUM_8192E			0x0380
#define	REG_RX_RXBD_NUM_8192E			0x0382
#define	REG_VOQ_TXBD_NUM_8192E			0x0384
#define	REG_VIQ_TXBD_NUM_8192E			0x0386
#define	REG_BEQ_TXBD_NUM_8192E			0x0388
#define	REG_BKQ_TXBD_NUM_8192E			0x038A
#define	REG_HI0Q_TXBD_NUM_8192E			0x038C
#define	REG_HI1Q_TXBD_NUM_8192E			0x038E
#define	REG_HI2Q_TXBD_NUM_8192E			0x0390
#define	REG_HI3Q_TXBD_NUM_8192E			0x0392
#define	REG_HI4Q_TXBD_NUM_8192E			0x0394
#define	REG_HI5Q_TXBD_NUM_8192E			0x0396
#define	REG_HI6Q_TXBD_NUM_8192E			0x0398
#define	REG_HI7Q_TXBD_NUM_8192E			0x039A
#define	REG_TSFTIMER_HCI_8192E			0x039C

/* Read Write Point */
#define	REG_VOQ_TXBD_IDX_8192E			0x03A0
#define	REG_VIQ_TXBD_IDX_8192E			0x03A4
#define	REG_BEQ_TXBD_IDX_8192E			0x03A8
#define	REG_BKQ_TXBD_IDX_8192E			0x03AC
#define	REG_MGQ_TXBD_IDX_8192E			0x03B0
#define	REG_RXQ_TXBD_IDX_8192E			0x03B4
#define	REG_HI0Q_TXBD_IDX_8192E			0x03B8
#define	REG_HI1Q_TXBD_IDX_8192E			0x03BC
#define	REG_HI2Q_TXBD_IDX_8192E			0x03C0
#define	REG_HI3Q_TXBD_IDX_8192E			0x03C4
#define	REG_HI4Q_TXBD_IDX_8192E			0x03C8
#define	REG_HI5Q_TXBD_IDX_8192E			0x03CC
#define	REG_HI6Q_TXBD_IDX_8192E			0x03D0
#define	REG_HI7Q_TXBD_IDX_8192E			0x03D4

#define	REG_PCIE_HCPWM_8192EE			0x03D8 /* ?????? */
#define	REG_PCIE_HRPWM_8192EE			0x03DC	/* PCIe RPWM */ /* ?????? */
#define	REG_DBI_WDATA_V1_8192E			0x03E8
#define	REG_DBI_RDATA_V1_8192E			0x03EC
#define	REG_DBI_FLAG_V1_8192E				0x03F0
#define	REG_MDIO_V1_8192E					0x3F4
#define	REG_PCIE_MIX_CFG_8192E				0x3F8

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_TXBF_CTRL_8192E				0x042C
#define REG_ARFR0_8192E					0x0444
#define REG_ARFR1_8192E					0x044C
#define REG_CCK_CHECK_8192E				0x0454
#define REG_AMPDU_MAX_TIME_8192E			0x0456
#define REG_BCNQ1_BDNY_8192E				0x0457

#define REG_AMPDU_MAX_LENGTH_8192E	0x0458
#define REG_WMAC_LBK_BUF_HD_8192E			0x045D
#define REG_NDPA_OPT_CTRL_8192E		0x045F
#define REG_DATA_SC_8192E				0x0483
#ifdef CONFIG_WOWLAN
	#define REG_TXPKTBUF_IV_LOW             0x0484
	#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_ARFR2_8192E					0x048C
#define REG_ARFR3_8192E					0x0494
#define REG_TXRPT_START_OFFSET			0x04AC
#define REG_AMPDU_BURST_MODE_8192E	0x04BC
#define REG_HT_SINGLE_AMPDU_8192E		0x04C7
#define REG_MACID_PKT_DROP0_8192E		0x04D0

/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_CTWND_8192E					0x0572
#define REG_SECONDARY_CCA_CTRL_8192E	0x0577
#define REG_SCH_TXCMD_8192E			0x05F8

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#define REG_MAC_CR_8192E				0x0600

#define REG_MAC_TX_SM_STATE_8192E		0x06B4

/* Power */
#define REG_BFMER0_INFO_8192E			0x06E4
#define REG_BFMER1_INFO_8192E			0x06EC
#define REG_CSI_RPT_PARAM_BW20_8192E	0x06F4
#define REG_CSI_RPT_PARAM_BW40_8192E	0x06F8
#define REG_CSI_RPT_PARAM_BW80_8192E	0x06FC

/* Hardware Port 2 */
#define REG_BFMEE_SEL_8192E				0x0714
#define REG_SND_PTCL_CTRL_8192E		0x0718


/* -----------------------------------------------------
 *
 *	Redifine register definition for compatibility
 *
 * ----------------------------------------------------- */

/* TODO: use these definition when using REG_xxx naming rule.
 * NOTE: DO NOT Remove these definition. Use later. */
#define	ISR_8192E							REG_HISR0_8192E

/* ----------------------------------------------------------------------------
 * 8192E IMR/ISR bits						(offset 0xB0,  8bits)
 * ---------------------------------------------------------------------------- */
#define	IMR_DISABLED_8192E					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define	IMR_TIMER2_8192E					BIT(31)		/* Timeout interrupt 2 */
#define	IMR_TIMER1_8192E					BIT(30)		/* Timeout interrupt 1	 */
#define	IMR_PSTIMEOUT_8192E				BIT(29)		/* Power Save Time Out Interrupt */
#define	IMR_GTINT4_8192E					BIT(28)		/* When GTIMER4 expires, this bit is set to 1	 */
#define	IMR_GTINT3_8192E					BIT(27)		/* When GTIMER3 expires, this bit is set to 1	 */
#define	IMR_TXBCN0ERR_8192E				BIT(26)		/* Transmit Beacon0 Error			 */
#define	IMR_TXBCN0OK_8192E					BIT(25)		/* Transmit Beacon0 OK			 */
#define	IMR_TSF_BIT32_TOGGLE_8192E		BIT(24)		/* TSF Timer BIT(32) toggle indication interrupt			 */
#define	IMR_BCNDMAINT0_8192E				BIT(20)		/* Beacon DMA Interrupt 0			 */
#define	IMR_BCNDERR0_8192E					BIT(16)		/* Beacon Queue DMA OK0			 */
#define	IMR_HSISR_IND_ON_INT_8192E		BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define	IMR_BCNDMAINT_E_8192E				BIT(14)		/* Beacon DMA Interrupt Extension for Win7			 */
#define	IMR_ATIMEND_8192E					BIT(12)		/* CTWidnow End or ATIM Window End */
#define	IMR_C2HCMD_8192E					BIT(10)		/* CPU to Host Command INT Status, Write 1 clear	 */
#define	IMR_CPWM2_8192E					BIT(9)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_CPWM_8192E						BIT(8)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_HIGHDOK_8192E					BIT(7)			/* High Queue DMA OK	 */
#define	IMR_MGNTDOK_8192E					BIT(6)			/* Management Queue DMA OK	 */
#define	IMR_BKDOK_8192E					BIT(5)			/* AC_BK DMA OK		 */
#define	IMR_BEDOK_8192E					BIT(4)			/* AC_BE DMA OK	 */
#define	IMR_VIDOK_8192E					BIT(3)			/* AC_VI DMA OK		 */
#define	IMR_VODOK_8192E					BIT(2)			/* AC_VO DMA OK	 */
#define	IMR_RDU_8192E						BIT(1)			/* Rx Descriptor Unavailable	 */
#define	IMR_ROK_8192E						BIT(0)			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define	IMR_BCNDMAINT7_8192E				BIT(27)		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT6_8192E				BIT(26)		/* Beacon DMA Interrupt 6 */
#define	IMR_BCNDMAINT5_8192E				BIT(25)		/* Beacon DMA Interrupt 5 */
#define	IMR_BCNDMAINT4_8192E				BIT(24)		/* Beacon DMA Interrupt 4 */
#define	IMR_BCNDMAINT3_8192E				BIT(23)		/* Beacon DMA Interrupt 3 */
#define	IMR_BCNDMAINT2_8192E				BIT(22)		/* Beacon DMA Interrupt 2 */
#define	IMR_BCNDMAINT1_8192E				BIT(21)		/* Beacon DMA Interrupt 1 */
#define	IMR_BCNDOK7_8192E					BIT(20)		/* Beacon Queue DMA OK Interrupt 7 */
#define	IMR_BCNDOK6_8192E					BIT(19)		/* Beacon Queue DMA OK Interrupt 6 */
#define	IMR_BCNDOK5_8192E					BIT(18)		/* Beacon Queue DMA OK Interrupt 5 */
#define	IMR_BCNDOK4_8192E					BIT(17)		/* Beacon Queue DMA OK Interrupt 4 */
#define	IMR_BCNDOK3_8192E					BIT(16)		/* Beacon Queue DMA OK Interrupt 3 */
#define	IMR_BCNDOK2_8192E					BIT(15)		/* Beacon Queue DMA OK Interrupt 2 */
#define	IMR_BCNDOK1_8192E					BIT(14)		/* Beacon Queue DMA OK Interrupt 1 */
#define	IMR_ATIMEND_E_8192E				BIT(13)		/* ATIM Window End Extension for Win7 */
#define	IMR_TXERR_8192E					BIT(11)		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define	IMR_RXERR_8192E					BIT(10)		/* Rx Error Flag INT Status, Write 1 clear */
#define	IMR_TXFOVW_8192E					BIT(9)			/* Transmit FIFO Overflow */
#define	IMR_RXFOVW_8192E					BIT(8)			/* Receive FIFO Overflow */

/* ----------------------------------------------------------------------------
 * 8192E Auto LLT bits						(offset 0x224,  8bits)
 * ----------------------------------------------------------------------------
 * 224 REG_AUTO_LLT
 * move to hal_com_reg.h */

/* ----------------------------------------------------------------------------
 * 8192E Auto LLT bits						(offset 0x290,  32bits)
 * ---------------------------------------------------------------------------- */
#define BIT_DMA_MODE			BIT(1)
#define BIT_USB_RXDMA_AGG_EN	BIT(31)

/* ----------------------------------------------------------------------------
 * 8192E REG_SYS_CFG1						(offset 0xF0,  32bits)
 * ---------------------------------------------------------------------------- */
#define BIT_SPSLDO_SEL			BIT(24)


/* ----------------------------------------------------------------------------
 * 8192E REG_CCK_CHECK						(offset 0x454,  8bits)
 * ---------------------------------------------------------------------------- */
#define BIT_BCN_PORT_SEL		BIT(5)

/* ****************************************************************************
 * Regsiter Bit and Content definition
 * **************************************************************************** */

/* 2 ACMHWCTRL 0x05C0 */
#define	AcmHw_HwEn_8192E				BIT(0)
#define	AcmHw_VoqEn_8192E				BIT(1)
#define	AcmHw_ViqEn_8192E				BIT(2)
#define	AcmHw_BeqEn_8192E				BIT(3)
#define	AcmHw_VoqStatus_8192E			BIT(5)
#define	AcmHw_ViqStatus_8192E			BIT(6)
#define	AcmHw_BeqStatus_8192E			BIT(7)

#endif /* __RTL8192E_SPEC_H__ */
                                                                                                                     rtl8822bu/src/include/custom_gpio.h                                                                 0000644 0001750 0001750 00000002025 14214766567 016124  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __CUSTOM_GPIO_H__
#define __CUSTOM_GPIO_H___

#include <drv_conf.h>
#include <osdep_service.h>

typedef enum cust_gpio_modes {
	WLAN_PWDN_ON,
	WLAN_PWDN_OFF,
	WLAN_POWER_ON,
	WLAN_POWER_OFF,
	WLAN_BT_PWDN_ON,
	WLAN_BT_PWDN_OFF
} cust_gpio_modes_t;

extern int rtw_wifi_gpio_init(void);
extern int rtw_wifi_gpio_deinit(void);
extern void rtw_wifi_gpio_wlan_ctrl(int onoff);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/rtw_mp.h                                                                      0000644 0001750 0001750 00000062510 14214766567 015111  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_MP_H_
#define _RTW_MP_H_

#define RTWPRIV_VER_INFO	1

#define MAX_MP_XMITBUF_SZ	2048
#define NR_MP_XMITFRAME		8
#define MP_READ_REG_MAX_OFFSET 0x4FFF

struct mp_xmit_frame {
	_list	list;

	struct pkt_attrib attrib;

	_pkt *pkt;

	int frame_tag;

	_adapter *padapter;

#ifdef CONFIG_USB_HCI

	/* insert urb, irp, and irpcnt info below... */
	/* max frag_cnt = 8 */
	u8 *mem_addr;
	u32 sz[8];
	u8 bpending[8];
	sint ac_tag[8];
	sint last[8];
	uint irpcnt;
	uint fragcnt;
#endif /* CONFIG_USB_HCI */

	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
};

struct mp_wiparam {
	u32 bcompleted;
	u32 act_type;
	u32 io_offset;
	u32 io_value;
};

typedef void(*wi_act_func)(void *padapter);

struct mp_tx {
	u8 stop;
	u32 count, sended;
	u8 payload;
	struct pkt_attrib attrib;
	/* struct tx_desc desc; */
	/* u8 resvdtx[7]; */
	u8 desc[TXDESC_SIZE];
	u8 *pallocated_buf;
	u8 *buf;
	u32 buf_size, write_size;
	_thread_hdl_ PktTxThread;
};

#define MP_MAX_LINES		1000
#define MP_MAX_LINES_BYTES	256


typedef struct _RT_PMAC_PKT_INFO {
	u8			MCS;
	u8			Nss;
	u8			Nsts;
	u32			N_sym;
	u8			SIGA2B3;
} RT_PMAC_PKT_INFO, *PRT_PMAC_PKT_INFO;

typedef struct _RT_PMAC_TX_INFO {
	u8			bEnPMacTx:1;		/* 0: Disable PMac 1: Enable PMac */
	u8			Mode:3;				/* 0: Packet TX 3:Continuous TX */
	u8			Ntx:4;				/* 0-7 */
	u8			TX_RATE;			/* MPT_RATE_E */
	u8			TX_RATE_HEX;
	u8			TX_SC;
	u8			bSGI:1;
	u8			bSPreamble:1;
	u8			bSTBC:1;
	u8			bLDPC:1;
	u8			NDP_sound:1;
	u8			BandWidth:3;		/* 0: 20 1:40 2:80Mhz */
	u8			m_STBC;			/* bSTBC + 1 */
	u16			PacketPeriod;
	u32		PacketCount;
	u32		PacketLength;
	u8			PacketPattern;
	u16			SFD;
	u8			SignalField;
	u8			ServiceField;
	u16			LENGTH;
	u8			CRC16[2];
	u8			LSIG[3];
	u8			HT_SIG[6];
	u8			VHT_SIG_A[6];
	u8			VHT_SIG_B[4];
	u8			VHT_SIG_B_CRC;
	u8			VHT_Delimiter[4];
	u8			MacAddress[6];
} RT_PMAC_TX_INFO, *PRT_PMAC_TX_INFO;


typedef void (*MPT_WORK_ITEM_HANDLER)(void *Adapter);
typedef struct _MPT_CONTEXT {
	/* Indicate if we have started Mass Production Test. */
	BOOLEAN			bMassProdTest;

	/* Indicate if the driver is unloading or unloaded. */
	BOOLEAN			bMptDrvUnload;

	_sema			MPh2c_Sema;
	_timer			MPh2c_timeout_timer;
	/* Event used to sync H2c for BT control */

	BOOLEAN		MptH2cRspEvent;
	BOOLEAN		MptBtC2hEvent;
	BOOLEAN		bMPh2c_timeout;

	/* 8190 PCI does not support NDIS_WORK_ITEM. */
	/* Work Item for Mass Production Test. */
	/* NDIS_WORK_ITEM	MptWorkItem;
	*	RT_WORK_ITEM		MptWorkItem; */
	/* Event used to sync the case unloading driver and MptWorkItem is still in progress.
	*	NDIS_EVENT		MptWorkItemEvent; */
	/* To protect the following variables.
	*	NDIS_SPIN_LOCK		MptWorkItemSpinLock; */
	/* Indicate a MptWorkItem is scheduled and not yet finished. */
	BOOLEAN			bMptWorkItemInProgress;
	/* An instance which implements function and context of MptWorkItem. */
	MPT_WORK_ITEM_HANDLER	CurrMptAct;

	/* 1=Start, 0=Stop from UI. */
	u32			MptTestStart;
	/* _TEST_MODE, defined in MPT_Req2.h */
	u32			MptTestItem;
	/* Variable needed in each implementation of CurrMptAct. */
	u32			MptActType;	/* Type of action performed in CurrMptAct. */
	/* The Offset of IO operation is depend of MptActType. */
	u32			MptIoOffset;
	/* The Value of IO operation is depend of MptActType. */
	u32			MptIoValue;
	/* The RfPath of IO operation is depend of MptActType. */

	u32			mpt_rf_path;


	WIRELESS_MODE		MptWirelessModeToSw;	/* Wireless mode to switch. */
	u8			MptChannelToSw;	/* Channel to switch. */
	u8			MptInitGainToSet;	/* Initial gain to set. */
	/* u32			bMptAntennaA;		 */ /* TRUE if we want to use antenna A. */
	u32			MptBandWidth;		/* bandwidth to switch. */

	u32			mpt_rate_index;/* rate index. */

	/* Register value kept for Single Carrier Tx test. */
	u8			btMpCckTxPower;
	/* Register value kept for Single Carrier Tx test. */
	u8			btMpOfdmTxPower;
	/* For MP Tx Power index */
	u8			TxPwrLevel[4];	/* rf-A, rf-B*/
	u32			RegTxPwrLimit;
	/* Content of RCR Regsiter for Mass Production Test. */
	u32			MptRCR;
	/* TRUE if we only receive packets with specific pattern. */
	BOOLEAN			bMptFilterPattern;
	/* Rx OK count, statistics used in Mass Production Test. */
	u32			MptRxOkCnt;
	/* Rx CRC32 error count, statistics used in Mass Production Test. */
	u32			MptRxCrcErrCnt;

	BOOLEAN			bCckContTx;	/* TRUE if we are in CCK Continuous Tx test. */
	BOOLEAN			bOfdmContTx;	/* TRUE if we are in OFDM Continuous Tx test. */
		/* TRUE if we have start Continuous Tx test. */
	BOOLEAN			is_start_cont_tx;

	/* TRUE if we are in Single Carrier Tx test. */
	BOOLEAN			bSingleCarrier;
	/* TRUE if we are in Carrier Suppression Tx Test. */

	BOOLEAN			is_carrier_suppression;

	/* TRUE if we are in Single Tone Tx test. */

	BOOLEAN			is_single_tone;


	/* ACK counter asked by K.Y.. */
	BOOLEAN			bMptEnableAckCounter;
	u32			MptAckCounter;

	/* SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~! */
	/* s8		BufOfLines[2][MAX_LINES_HWCONFIG_TXT][MAX_BYTES_LINE_HWCONFIG_TXT]; */
	/* s8			BufOfLines[2][MP_MAX_LINES][MP_MAX_LINES_BYTES]; */
	/* s32			RfReadLine[2]; */

	u8		APK_bound[2];	/* for APK	path A/path B */
	BOOLEAN		bMptIndexEven;

	u8		backup0xc50;
	u8		backup0xc58;
	u8		backup0xc30;
	u8		backup0x52_RF_A;
	u8		backup0x52_RF_B;

	u32			backup0x58_RF_A;
	u32			backup0x58_RF_B;

	u8			h2cReqNum;
	u8			c2hBuf[32];

	u8          btInBuf[100];
	u32			mptOutLen;
	u8          mptOutBuf[100];
	RT_PMAC_TX_INFO	PMacTxInfo;
	RT_PMAC_PKT_INFO	PMacPktInfo;
	u8 HWTxmode;

	BOOLEAN			bldpc;
	BOOLEAN			bstbc;
} MPT_CONTEXT, *PMPT_CONTEXT;
/* #endif */


/* #define RTPRIV_IOCTL_MP					( SIOCIWFIRSTPRIV + 0x17) */
enum {
	WRITE_REG = 1,
	READ_REG,
	WRITE_RF,
	READ_RF,
	MP_START,
	MP_STOP,
	MP_RATE,
	MP_CHANNEL,
	MP_CHL_OFFSET,
	MP_BANDWIDTH,
	MP_TXPOWER,
	MP_ANT_TX,
	MP_ANT_RX,
	MP_CTX,
	MP_QUERY,
	MP_ARX,
	MP_PSD,
	MP_PWRTRK,
	MP_THER,
	MP_IOCTL,
	EFUSE_GET,
	EFUSE_SET,
	MP_RESET_STATS,
	MP_DUMP,
	MP_PHYPARA,
	MP_SetRFPathSwh,
	MP_QueryDrvStats,
	CTA_TEST,
	MP_DISABLE_BT_COEXIST,
	MP_PwrCtlDM,
	MP_GETVER,
	MP_MON,
	EFUSE_BT_MASK,
	EFUSE_MASK,
	EFUSE_FILE,
	MP_TX,
	MP_RX,
	MP_IQK,
	MP_LCK,
	MP_HW_TX_MODE,
	MP_GET_TXPOWER_INX,
	MP_CUSTOMER_STR,
	MP_PWRLMT,
	MP_PWRBYRATE,
	BT_EFUSE_FILE,
	MP_SetBT,
	MP_SWRFPath,
	MP_LINK,
	MP_DPK_TRK,
	MP_DPK,
	MP_NULL,
#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
	VENDOR_IE_SET ,
	VENDOR_IE_GET ,
#endif
#ifdef CONFIG_WOWLAN
	MP_WOW_ENABLE,
	MP_WOW_SET_PATTERN,
#endif
#ifdef CONFIG_AP_WOWLAN
	MP_AP_WOW_ENABLE,
#endif
	MP_SD_IREAD,
	MP_SD_IWRITE,
};

struct mp_priv {
	_adapter *papdater;

	/* Testing Flag */
	u32 mode;/* 0 for normal type packet, 1 for loopback packet (16bytes TXCMD) */

	u32 prev_fw_state;

	/* OID cmd handler */
	struct mp_wiparam workparam;
	/*	u8 act_in_progress; */

	/* Tx Section */
	u8 TID;
	u32 tx_pktcount;
	u32 pktInterval;
	u32 pktLength;
	struct mp_tx tx;

	/* Rx Section */
	u32 rx_bssidpktcount;
	u32 rx_pktcount;
	u32 rx_pktcount_filter_out;
	u32 rx_crcerrpktcount;
	u32 rx_pktloss;
	BOOLEAN  rx_bindicatePkt;
	struct recv_stat rxstat;
	BOOLEAN brx_filter_beacon;

	/* RF/BB relative */
	u8 channel;
	u8 bandwidth;
	u8 prime_channel_offset;
	u8 txpoweridx;
	u8 rateidx;
	u32 preamble;
	/*	u8 modem; */
	u32 CrystalCap;
	/*	u32 curr_crystalcap; */

	u16 antenna_tx;
	u16 antenna_rx;
	/*	u8 curr_rfpath; */

	u8 check_mp_pkt;

	u8 bSetTxPower;
	/*	uint ForcedDataRate; */
	u8 mp_dm;
	u8 mac_filter[ETH_ALEN];
	u8 bmac_filter;

	/* RF PATH Setting for WLG WLA BTG BT */
	u8 rf_path_cfg;

	struct wlan_network mp_network;
	NDIS_802_11_MAC_ADDRESS network_macaddr;

	u8 *pallocated_mp_xmitframe_buf;
	u8 *pmp_xmtframe_buf;
	_queue free_mp_xmitqueue;
	u32 free_mp_xmitframe_cnt;
	BOOLEAN bSetRxBssid;
	BOOLEAN bTxBufCkFail;
	BOOLEAN bRTWSmbCfg;
	BOOLEAN bloopback;
	BOOLEAN bloadefusemap;
	BOOLEAN bloadBTefusemap;
	BOOLEAN bprocess_mp_mode;

	MPT_CONTEXT	mpt_ctx;

	u8		*TXradomBuffer;
	u8		CureFuseBTCoex;
    u8		mplink_buf[2048];
    u32		mplink_rx_len;
	BOOLEAN mplink_brx;
	BOOLEAN mplink_btx;

	bool tssitrk_on;
};

typedef struct _IOCMD_STRUCT_ {
	u8	cmdclass;
	u16	value;
	u8	index;
} IOCMD_STRUCT;

struct rf_reg_param {
	u32 path;
	u32 offset;
	u32 value;
};

struct bb_reg_param {
	u32 offset;
	u32 value;
};

typedef struct _MP_FIRMWARE {
	FIRMWARE_SOURCE eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8		*szFwBuffer;
#else
	u8			szFwBuffer[0x8000];
#endif
	u32		ulFwLength;
} RT_MP_FIRMWARE, *PRT_MP_FIRMWARE;




/* *********************************************************************** */

#define LOWER	_TRUE
#define RAISE	_FALSE

/* Hardware Registers */
#if 0
#if 0
#define IOCMD_CTRL_REG			0x102502C0
#define IOCMD_DATA_REG			0x102502C4
#else
#define IOCMD_CTRL_REG			0x10250370
#define IOCMD_DATA_REG			0x10250374
#endif

#define IOCMD_GET_THERMAL_METER		0xFD000028

#define IOCMD_CLASS_BB_RF		0xF0
#define IOCMD_BB_READ_IDX		0x00
#define IOCMD_BB_WRITE_IDX		0x01
#define IOCMD_RF_READ_IDX		0x02
#define IOCMD_RF_WRIT_IDX		0x03
#endif
#define BB_REG_BASE_ADDR		0x800

/* MP variables */
#if 0
#define _2MAC_MODE_	0
#define _LOOPBOOK_MODE_	1
#endif
typedef enum _MP_MODE_ {
	MP_OFF,
	MP_ON,
	MP_ERR,
	MP_CONTINUOUS_TX,
	MP_SINGLE_CARRIER_TX,
	MP_CARRIER_SUPPRISSION_TX,
	MP_SINGLE_TONE_TX,
	MP_PACKET_TX,
	MP_PACKET_RX
} MP_MODE;

typedef enum _TEST_MODE {
	TEST_NONE                 ,
	PACKETS_TX                ,
	PACKETS_RX                ,
	CONTINUOUS_TX             ,
	OFDM_Single_Tone_TX       ,
	CCK_Carrier_Suppression_TX
} TEST_MODE;


typedef enum _MPT_BANDWIDTH {
	MPT_BW_20MHZ = 0,
	MPT_BW_40MHZ_DUPLICATE = 1,
	MPT_BW_40MHZ_ABOVE = 2,
	MPT_BW_40MHZ_BELOW = 3,
	MPT_BW_40MHZ = 4,
	MPT_BW_80MHZ = 5,
	MPT_BW_80MHZ_20_ABOVE = 6,
	MPT_BW_80MHZ_20_BELOW = 7,
	MPT_BW_80MHZ_20_BOTTOM = 8,
	MPT_BW_80MHZ_20_TOP = 9,
	MPT_BW_80MHZ_40_ABOVE = 10,
	MPT_BW_80MHZ_40_BELOW = 11,
} MPT_BANDWIDTHE, *PMPT_BANDWIDTH;

#define MAX_RF_PATH_NUMS	RF_PATH_MAX


extern u8 mpdatarate[NumRates];

/* MP set force data rate base on the definition. */
typedef enum _MPT_RATE_INDEX {
	/* CCK rate. */
	MPT_RATE_1M = 1 ,	/* 0 */
	MPT_RATE_2M,
	MPT_RATE_55M,
	MPT_RATE_11M,	/* 3 */

	/* OFDM rate. */
	MPT_RATE_6M,	/* 4 */
	MPT_RATE_9M,
	MPT_RATE_12M,
	MPT_RATE_18M,
	MPT_RATE_24M,
	MPT_RATE_36M,
	MPT_RATE_48M,
	MPT_RATE_54M,	/* 11 */

	/* HT rate. */
	MPT_RATE_MCS0,	/* 12 */
	MPT_RATE_MCS1,
	MPT_RATE_MCS2,
	MPT_RATE_MCS3,
	MPT_RATE_MCS4,
	MPT_RATE_MCS5,
	MPT_RATE_MCS6,
	MPT_RATE_MCS7,	/* 19 */
	MPT_RATE_MCS8,
	MPT_RATE_MCS9,
	MPT_RATE_MCS10,
	MPT_RATE_MCS11,
	MPT_RATE_MCS12,
	MPT_RATE_MCS13,
	MPT_RATE_MCS14,
	MPT_RATE_MCS15,	/* 27 */
	MPT_RATE_MCS16,
	MPT_RATE_MCS17, /*  #29 */
	MPT_RATE_MCS18,
	MPT_RATE_MCS19,
	MPT_RATE_MCS20,
	MPT_RATE_MCS21,
	MPT_RATE_MCS22, /*  #34 */
	MPT_RATE_MCS23,
	MPT_RATE_MCS24,
	MPT_RATE_MCS25,
	MPT_RATE_MCS26,
	MPT_RATE_MCS27, /*  #39 */
	MPT_RATE_MCS28, /*  #40 */
	MPT_RATE_MCS29, /*  #41 */
	MPT_RATE_MCS30, /*  #42 */
	MPT_RATE_MCS31, /*  #43 */
	/* VHT rate. Total: 20*/
	MPT_RATE_VHT1SS_MCS0 = 100,/*  #44*/
	MPT_RATE_VHT1SS_MCS1, /*  # */
	MPT_RATE_VHT1SS_MCS2,
	MPT_RATE_VHT1SS_MCS3,
	MPT_RATE_VHT1SS_MCS4,
	MPT_RATE_VHT1SS_MCS5,
	MPT_RATE_VHT1SS_MCS6, /*  # */
	MPT_RATE_VHT1SS_MCS7,
	MPT_RATE_VHT1SS_MCS8,
	MPT_RATE_VHT1SS_MCS9, /* #53 */
	MPT_RATE_VHT2SS_MCS0, /* #54 */
	MPT_RATE_VHT2SS_MCS1,
	MPT_RATE_VHT2SS_MCS2,
	MPT_RATE_VHT2SS_MCS3,
	MPT_RATE_VHT2SS_MCS4,
	MPT_RATE_VHT2SS_MCS5,
	MPT_RATE_VHT2SS_MCS6,
	MPT_RATE_VHT2SS_MCS7,
	MPT_RATE_VHT2SS_MCS8,
	MPT_RATE_VHT2SS_MCS9, /* #63 */
	MPT_RATE_VHT3SS_MCS0,
	MPT_RATE_VHT3SS_MCS1,
	MPT_RATE_VHT3SS_MCS2,
	MPT_RATE_VHT3SS_MCS3,
	MPT_RATE_VHT3SS_MCS4,
	MPT_RATE_VHT3SS_MCS5,
	MPT_RATE_VHT3SS_MCS6, /*  #126 */
	MPT_RATE_VHT3SS_MCS7,
	MPT_RATE_VHT3SS_MCS8,
	MPT_RATE_VHT3SS_MCS9,
	MPT_RATE_VHT4SS_MCS0,
	MPT_RATE_VHT4SS_MCS1, /*  #131 */
	MPT_RATE_VHT4SS_MCS2,
	MPT_RATE_VHT4SS_MCS3,
	MPT_RATE_VHT4SS_MCS4,
	MPT_RATE_VHT4SS_MCS5,
	MPT_RATE_VHT4SS_MCS6, /*  #136 */
	MPT_RATE_VHT4SS_MCS7,
	MPT_RATE_VHT4SS_MCS8,
	MPT_RATE_VHT4SS_MCS9,
	MPT_RATE_LAST
} MPT_RATE_E, *PMPT_RATE_E;

#define MAX_TX_PWR_INDEX_N_MODE 64	/* 0x3F */

#define MPT_IS_CCK_RATE(_value)		(MPT_RATE_1M <= _value && _value <= MPT_RATE_11M)
#define MPT_IS_OFDM_RATE(_value)	(MPT_RATE_6M <= _value && _value <= MPT_RATE_54M)
#define MPT_IS_HT_RATE(_value)		(MPT_RATE_MCS0 <= _value && _value <= MPT_RATE_MCS31)
#define MPT_IS_HT_1S_RATE(_value)	(MPT_RATE_MCS0 <= _value && _value <= MPT_RATE_MCS7)
#define MPT_IS_HT_2S_RATE(_value)	(MPT_RATE_MCS8 <= _value && _value <= MPT_RATE_MCS15)
#define MPT_IS_HT_3S_RATE(_value)	(MPT_RATE_MCS16 <= _value && _value <= MPT_RATE_MCS23)
#define MPT_IS_HT_4S_RATE(_value)	(MPT_RATE_MCS24 <= _value && _value <= MPT_RATE_MCS31)

#define MPT_IS_VHT_RATE(_value)		(MPT_RATE_VHT1SS_MCS0 <= _value && _value <= MPT_RATE_VHT4SS_MCS9)
#define MPT_IS_VHT_1S_RATE(_value)	(MPT_RATE_VHT1SS_MCS0 <= _value && _value <= MPT_RATE_VHT1SS_MCS9)
#define MPT_IS_VHT_2S_RATE(_value)	(MPT_RATE_VHT2SS_MCS0 <= _value && _value <= MPT_RATE_VHT2SS_MCS9)
#define MPT_IS_VHT_3S_RATE(_value)	(MPT_RATE_VHT3SS_MCS0 <= _value && _value <= MPT_RATE_VHT3SS_MCS9)
#define MPT_IS_VHT_4S_RATE(_value)	(MPT_RATE_VHT4SS_MCS0 <= _value && _value <= MPT_RATE_VHT4SS_MCS9)

#define MPT_IS_2SS_RATE(_rate) ((MPT_RATE_MCS8 <= _rate && _rate <= MPT_RATE_MCS15) || \
	(MPT_RATE_VHT2SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT2SS_MCS9))
#define MPT_IS_3SS_RATE(_rate) ((MPT_RATE_MCS16 <= _rate && _rate <= MPT_RATE_MCS23) || \
	(MPT_RATE_VHT3SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT3SS_MCS9))
#define MPT_IS_4SS_RATE(_rate) ((MPT_RATE_MCS24 <= _rate && _rate <= MPT_RATE_MCS31) || \
	(MPT_RATE_VHT4SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT4SS_MCS9))

typedef enum _POWER_MODE_ {
	POWER_LOW = 0,
	POWER_NORMAL
} POWER_MODE;

/* The following enumeration is used to define the value of Reg0xD00[30:28] or JaguarReg0x914[18:16]. */
typedef enum _OFDM_TX_MODE {
	OFDM_ALL_OFF		= 0,
	OFDM_ContinuousTx	= 1,
	OFDM_SingleCarrier	= 2,
	OFDM_SingleTone	= 4,
} OFDM_TX_MODE;


#define RX_PKT_BROADCAST	1
#define RX_PKT_DEST_ADDR	2
#define RX_PKT_PHY_MATCH	3

typedef enum _ENCRY_CTRL_STATE_ {
	HW_CONTROL,		/* hw encryption& decryption */
	SW_CONTROL,		/* sw encryption& decryption */
	HW_ENCRY_SW_DECRY,	/* hw encryption & sw decryption */
	SW_ENCRY_HW_DECRY	/* sw encryption & hw decryption */
} ENCRY_CTRL_STATE;

typedef enum	_MPT_TXPWR_DEF {
	MPT_CCK,
	MPT_OFDM, /* L and HT OFDM */
	MPT_OFDM_AND_HT,
	MPT_HT,
	MPT_VHT
} MPT_TXPWR_DEF;


#define IS_MPT_HT_RATE(_rate)			(_rate >= MPT_RATE_MCS0 && _rate <= MPT_RATE_MCS31)
#define IS_MPT_VHT_RATE(_rate)			(_rate >= MPT_RATE_VHT1SS_MCS0 && _rate <= MPT_RATE_VHT4SS_MCS9)
#define IS_MPT_CCK_RATE(_rate)			(_rate >= MPT_RATE_1M && _rate <= MPT_RATE_11M)
#define IS_MPT_OFDM_RATE(_rate)			(_rate >= MPT_RATE_6M && _rate <= MPT_RATE_54M)

typedef enum _mp_tx_pkt_payload{
	MP_TX_Payload_00 = 0,
	MP_TX_Payload_a5,
	MP_TX_Payload_5a,
	MP_TX_Payload_ff,
	MP_TX_Payload_prbs9,
	MP_TX_Payload_default_random
} mp_tx_pkt_payload;

/*************************************************************************/
#if 0
extern struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv);
extern int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe);
#endif

extern s32 init_mp_priv(PADAPTER padapter);
extern void free_mp_priv(struct mp_priv *pmp_priv);
extern s32 MPT_InitializeAdapter(PADAPTER padapter, u8 Channel);
extern void MPT_DeInitAdapter(PADAPTER padapter);
extern s32 mp_start_test(PADAPTER padapter);
extern void mp_stop_test(PADAPTER padapter);

extern u32 _read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask);
extern void _write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);

extern u32 read_macreg(_adapter *padapter, u32 addr, u32 sz);
extern void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz);
extern u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask);
extern void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
extern u32 read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr);
extern void write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 val);
#ifdef CONFIG_ANTENNA_DIVERSITY
u8 rtw_mp_set_antdiv(PADAPTER padapter, BOOLEAN bMain);
#endif
void	SetChannel(PADAPTER pAdapter);
void	SetBandwidth(PADAPTER pAdapter);
int	SetTxPower(PADAPTER pAdapter);
void	SetAntenna(PADAPTER pAdapter);
void	SetDataRate(PADAPTER pAdapter);
void	SetAntenna(PADAPTER pAdapter);
s32	SetThermalMeter(PADAPTER pAdapter, u8 target_ther);
void	GetThermalMeter(PADAPTER pAdapter, u8 rfpath ,u8 *value);
void	SetContinuousTx(PADAPTER pAdapter, u8 bStart);
void	SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
void	SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
void	SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
void	PhySetTxPowerLevel(PADAPTER pAdapter);
void	fill_txdesc_for_mp(PADAPTER padapter, u8 *ptxdesc);
void	SetPacketTx(PADAPTER padapter);
void	SetPacketRx(PADAPTER pAdapter, u8 bStartRx, u8 bAB);
void	ResetPhyRxPktCount(PADAPTER pAdapter);
u32	GetPhyRxPktReceived(PADAPTER pAdapter);
u32	GetPhyRxPktCRC32Error(PADAPTER pAdapter);
s32	SetPowerTracking(PADAPTER padapter, u8 enable);
void	GetPowerTracking(PADAPTER padapter, u8 *enable);
u32	mp_query_psd(PADAPTER pAdapter, u8 *data);
void	rtw_mp_trigger_iqk(PADAPTER padapter);
void	rtw_mp_trigger_lck(PADAPTER padapter);
void	rtw_mp_trigger_dpk(PADAPTER padapter);
u8 rtw_mp_mode_check(PADAPTER padapter);
bool rtw_is_mp_tssitrk_on(_adapter *adapter);

void hal_mpt_SwitchRfSetting(PADAPTER pAdapter);
s32 hal_mpt_SetPowerTracking(PADAPTER padapter, u8 enable);
void hal_mpt_GetPowerTracking(PADAPTER padapter, u8 *enable);
void hal_mpt_CCKTxPowerAdjust(PADAPTER Adapter, BOOLEAN bInCH14);
void hal_mpt_SetChannel(PADAPTER pAdapter);
void hal_mpt_SetBandwidth(PADAPTER pAdapter);
void hal_mpt_SetTxPower(PADAPTER pAdapter);
void hal_mpt_SetDataRate(PADAPTER pAdapter);
void hal_mpt_SetAntenna(PADAPTER pAdapter);
s32 hal_mpt_SetThermalMeter(PADAPTER pAdapter, u8 target_ther);
void hal_mpt_TriggerRFThermalMeter(PADAPTER pAdapter);
u8 hal_mpt_ReadRFThermalMeter(PADAPTER pAdapter, u8 rf_path);
void hal_mpt_GetThermalMeter(PADAPTER pAdapter, u8 rfpath, u8 *value);
void hal_mpt_SetContinuousTx(PADAPTER pAdapter, u8 bStart);
void hal_mpt_SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
void hal_mpt_SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
void hal_mpt_SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
void mpt_ProSetPMacTx(PADAPTER	Adapter);
void MP_PHY_SetRFPathSwitch(PADAPTER pAdapter , BOOLEAN bMain);
void mp_phy_switch_rf_path_set(PADAPTER pAdapter , u8 *pstate);
u8 MP_PHY_QueryRFPathSwitch(PADAPTER pAdapter);
u32 mpt_ProQueryCalTxPower(PADAPTER	pAdapter, u8 RfPath);
void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart);
u8 mpt_to_mgnt_rate(u32	MptRateIdx);
u8 rtw_mpRateParseFunc(PADAPTER pAdapter, u8 *targetStr);
u32 mp_join(PADAPTER padapter, u8 mode);
u32 hal_mpt_query_phytxok(PADAPTER	pAdapter);
u32 mpt_get_tx_power_finalabs_val(PADAPTER	padapter, u8 rf_path);

void
PMAC_Get_Pkt_Param(
	PRT_PMAC_TX_INFO	pPMacTxInfo,
	PRT_PMAC_PKT_INFO	pPMacPktInfo
);
void
CCK_generator(
	PRT_PMAC_TX_INFO	pPMacTxInfo,
	PRT_PMAC_PKT_INFO	pPMacPktInfo
);
void
PMAC_Nsym_generator(
	PRT_PMAC_TX_INFO	pPMacTxInfo,
	PRT_PMAC_PKT_INFO	pPMacPktInfo
);
void
L_SIG_generator(
	u32	N_SYM,		/* Max: 750*/
	PRT_PMAC_TX_INFO	pPMacTxInfo,
	PRT_PMAC_PKT_INFO	pPMacPktInfo
);

void HT_SIG_generator(
	PRT_PMAC_TX_INFO	pPMacTxInfo,
	PRT_PMAC_PKT_INFO	pPMacPktInfo);

void VHT_SIG_A_generator(
	PRT_PMAC_TX_INFO	pPMacTxInfo,
	PRT_PMAC_PKT_INFO	pPMacPktInfo);

void VHT_SIG_B_generator(
	PRT_PMAC_TX_INFO	pPMacTxInfo);

void VHT_Delimiter_generator(
	PRT_PMAC_TX_INFO	pPMacTxInfo);


int rtw_mp_write_reg(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_read_reg(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_write_rf(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_read_rf(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_start(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_stop(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_rate(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_channel(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_ch_offset(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_bandwidth(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_txpower_index(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_txpower(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_txpower(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_ant_tx(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_ant_rx(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_set_ctx_destAddr(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_ctx(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_disable_bt_coexist(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_disable_bt_coexist(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_arx(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_trx_query(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_pwrtrk(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_psd(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_thermal(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_reset_stats(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_dump(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_phypara(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_SetRFPath(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_switch_rf_path(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_point *wrqu, char *extra);
int rtw_mp_link(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_QueryDrv(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_PwrCtlDM(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
int rtw_mp_getver(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_mon(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_pwrlmt(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_pwrbyrate(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_dpk_track(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wrqu, char *extra);
int rtw_mp_dpk(struct net_device *dev,
			struct iw_request_info *info,
			union iwreq_data *wrqu, char *extra);
int rtw_efuse_mask_file(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_bt_efuse_mask_file(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_efuse_file_map(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_bt_efuse_file_map(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_SetBT(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_pretx_proc(PADAPTER padapter, u8 bStartTest, char *extra);
int rtw_mp_tx(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_rx(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
int rtw_mp_hwtx(struct net_device *dev,
		struct iw_request_info *info,
		union iwreq_data *wrqu, char *extra);
u8 HwRateToMPTRate(u8 rate);
int rtw_mp_iqk(struct net_device *dev,
		 struct iw_request_info *info,
		 struct iw_point *wrqu, char *extra);
int rtw_mp_lck(struct net_device *dev,
		struct iw_request_info *info,
		struct iw_point *wrqu, char *extra);
#endif /* _RTW_MP_H_ */
                                                                                                                                                                                        rtl8822bu/src/include/rtw_btcoex_wifionly.h                                                         0000644 0001750 0001750 00000002073 14214766567 017677  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_BTCOEX_WIFIONLY_H__
#define __RTW_BTCOEX_WIFIONLY_H__

void rtw_btcoex_wifionly_switchband_notify(PADAPTER padapter);
void rtw_btcoex_wifionly_scan_notify(PADAPTER padapter);
void rtw_btcoex_wifionly_connect_notify(PADAPTER padapter);
void rtw_btcoex_wifionly_hw_config(PADAPTER padapter);
void rtw_btcoex_wifionly_initialize(PADAPTER padapter);
void rtw_btcoex_wifionly_AntInfoSetting(PADAPTER padapter);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/rtl8812a_spec.h                                                               0000644 0001750 0001750 00000024644 14214766567 016106  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_SPEC_H__
#define __RTL8812A_SPEC_H__

#include <drv_conf.h>


/* ************************************************************
* 8812 Regsiter offset definition
* ************************************************************ */

/* ************************************************************
*
* ************************************************************ */

/* -----------------------------------------------------
*
*	0x0000h ~ 0x00FFh	System Configuration
*
* ----------------------------------------------------- */
#define REG_SYS_CLKR_8812A				0x0008
#define REG_AFE_PLL_CTRL_8812A		0x0028
#define REG_HSIMR_8812					0x0058
#define REG_HSISR_8812					0x005c
#define REG_GPIO_EXT_CTRL				0x0060
#define REG_GPIO_STATUS_8812			0x006C
#define REG_SDIO_CTRL_8812				0x0070
#define REG_OPT_CTRL_8812				0x0074
#define REG_RF_B_CTRL_8812				0x0076
#define REG_FW_DRV_MSG_8812			0x0088
#define REG_HMEBOX_E2_E3_8812			0x008C
#define REG_HIMR0_8812					0x00B0
#define REG_HISR0_8812					0x00B4
#define REG_HIMR1_8812					0x00B8
#define REG_HISR1_8812					0x00BC
#define REG_EFUSE_BURN_GNT_8812		0x00CF
#define REG_SYS_CFG1_8812				0x00FC

/* -----------------------------------------------------
*
*	0x0100h ~ 0x01FFh	MACTOP General Configuration
*
* ----------------------------------------------------- */
#define REG_CR_8812A					0x100
#define REG_PKTBUF_DBG_ADDR			(REG_PKTBUF_DBG_CTRL)
#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
#define REG_WOWLAN_WAKE_REASON			REG_MCUTST_WOWLAN

#define REG_RSVD3_8812					0x0168
#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
#define REG_C2HEVT_CMD_LEN_88XX		0x01AE

#define REG_HMEBOX_EXT0_8812			0x01F0
#define REG_HMEBOX_EXT1_8812			0x01F4
#define REG_HMEBOX_EXT2_8812			0x01F8
#define REG_HMEBOX_EXT3_8812			0x01FC

/* -----------------------------------------------------
*
*	0x0200h ~ 0x027Fh	TXDMA Configuration
*
* ----------------------------------------------------- */
#define REG_DWBCN0_CTRL_8812				REG_TDECTRL
#define REG_DWBCN1_CTRL_8812				0x0228

/* -----------------------------------------------------
*
*	0x0280h ~ 0x02FFh	RXDMA Configuration
*
* ----------------------------------------------------- */
#define REG_TDECTRL_8812A				0x0208
#define REG_RXDMA_CONTROL_8812A		0x0286		/*Control the RX DMA.*/
#define REG_RXDMA_PRO_8812			0x0290
#define REG_EARLY_MODE_CONTROL_8812	0x02BC
#define REG_RSVD5_8812					0x02F0
#define REG_RSVD6_8812					0x02F4
#define REG_RSVD7_8812					0x02F8
#define REG_RSVD8_8812					0x02FC


/* -----------------------------------------------------
*
*	0x0300h ~ 0x03FFh	PCIe
*
* ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8812A			0x0300
#define	REG_DBI_WDATA_8812			0x0348	/* DBI Write Data */
#define	REG_DBI_RDATA_8812			0x034C	/* DBI Read Data */
#define	REG_DBI_ADDR_8812			0x0350	/* DBI Address */
#define	REG_DBI_FLAG_8812			0x0352	/* DBI Read/Write Flag */
#define	REG_MDIO_WDATA_8812			0x0354	/* MDIO for Write PCIE PHY */
#define	REG_MDIO_RDATA_8812			0x0356	/* MDIO for Reads PCIE PHY */
#define	REG_MDIO_CTL_8812			0x0358	/* MDIO for Control */
#define REG_PCIE_HRPWM_8812A			0x0361  /* PCIe RPWM */
#define REG_PCIE_HCPWM_8812A			0x0363  /* PCIe CPWM */

#define	REG_PCIE_MULTIFET_CTRL_8812	0x036A	/* PCIE Multi-Fethc Control */

/* -----------------------------------------------------
*
*	0x0400h ~ 0x047Fh	Protocol Configuration
*
* ----------------------------------------------------- */
#define REG_TXPKT_EMPTY_8812A			0x041A
#define REG_FWHW_TXQ_CTRL_8812A		0x0420
#define REG_TXBF_CTRL_8812A			0x042C
#define REG_ARFR0_8812					0x0444
#define REG_ARFR1_8812					0x044C
#define REG_CCK_CHECK_8812				0x0454
#define REG_AMPDU_MAX_TIME_8812		0x0456
#define REG_TXPKTBUF_BCNQ_BDNY1_8812	0x0457

#define REG_AMPDU_MAX_LENGTH_8812	0x0458
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8812	0x045D
#define REG_NDPA_OPT_CTRL_8812A		0x045F
#define REG_DATA_SC_8812				0x0483
#ifdef CONFIG_WOWLAN
#define REG_TXPKTBUF_IV_LOW             0x0484
#define REG_TXPKTBUF_IV_HIGH            0x0488
#endif
#define REG_ARFR2_8812					0x048C
#define REG_ARFR3_8812					0x0494
#define REG_TXRPT_START_OFFSET		0x04AC
#define REG_AMPDU_BURST_MODE_8812	0x04BC
#define REG_HT_SINGLE_AMPDU_8812		0x04C7
#define REG_MACID_PKT_DROP0_8812		0x04D0

/* -----------------------------------------------------
*
*	0x0500h ~ 0x05FFh	EDCA Configuration
*
* ----------------------------------------------------- */
#define REG_TXPAUSE_8812A				0x0522
#define REG_CTWND_8812					0x0572
#define REG_SECONDARY_CCA_CTRL_8812	0x0577
#define REG_SCH_TXCMD_8812A			0x05F8

/* -----------------------------------------------------
*
*	0x0600h ~ 0x07FFh	WMAC Configuration
*
* ----------------------------------------------------- */
#define REG_MAC_CR_8812				0x0600

#define REG_MAC_TX_SM_STATE_8812		0x06B4

/* Power */
#define REG_BFMER0_INFO_8812A			0x06E4
#define REG_BFMER1_INFO_8812A			0x06EC
#define REG_CSI_RPT_PARAM_BW20_8812A	0x06F4
#define REG_CSI_RPT_PARAM_BW40_8812A	0x06F8
#define REG_CSI_RPT_PARAM_BW80_8812A	0x06FC

/* Hardware Port 2 */
#define REG_BFMEE_SEL_8812A			0x0714
#define REG_SND_PTCL_CTRL_8812A		0x0718


/* -----------------------------------------------------
*
*	Redifine register definition for compatibility
*
* ----------------------------------------------------- */

/* TODO: use these definition when using REG_xxx naming rule.
* NOTE: DO NOT Remove these definition. Use later. */
#define	ISR_8812							REG_HISR0_8812

/* ----------------------------------------------------------------------------
* 8195 IMR/ISR bits						(offset 0xB0,  8bits)
* ---------------------------------------------------------------------------- */
#define	IMR_DISABLED_8812					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define	IMR_TIMER2_8812					BIT31		/* Timeout interrupt 2 */
#define	IMR_TIMER1_8812					BIT30		/* Timeout interrupt 1	 */
#define	IMR_PSTIMEOUT_8812				BIT29		/* Power Save Time Out Interrupt */
#define	IMR_GTINT4_8812					BIT28		/* When GTIMER4 expires, this bit is set to 1	 */
#define	IMR_GTINT3_8812					BIT27		/* When GTIMER3 expires, this bit is set to 1	 */
#define	IMR_TXBCN0ERR_8812				BIT26		/* Transmit Beacon0 Error			 */
#define	IMR_TXBCN0OK_8812					BIT25		/* Transmit Beacon0 OK			 */
#define	IMR_TSF_BIT32_TOGGLE_8812		BIT24		/* TSF Timer BIT32 toggle indication interrupt			 */
#define	IMR_BCNDMAINT0_8812				BIT20		/* Beacon DMA Interrupt 0			 */
#define	IMR_BCNDERR0_8812					BIT16		/* Beacon Queue DMA OK0			 */
#define	IMR_HSISR_IND_ON_INT_8812		BIT15		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define	IMR_BCNDMAINT_E_8812				BIT14		/* Beacon DMA Interrupt Extension for Win7			 */
#define	IMR_ATIMEND_8812					BIT12		/* CTWidnow End or ATIM Window End */
#define	IMR_C2HCMD_8812					BIT10		/* CPU to Host Command INT Status, Write 1 clear	 */
#define	IMR_CPWM2_8812					BIT9			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_CPWM_8812						BIT8			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define	IMR_HIGHDOK_8812					BIT7			/* High Queue DMA OK	 */
#define	IMR_MGNTDOK_8812					BIT6			/* Management Queue DMA OK	 */
#define	IMR_BKDOK_8812					BIT5			/* AC_BK DMA OK		 */
#define	IMR_BEDOK_8812					BIT4			/* AC_BE DMA OK	 */
#define	IMR_VIDOK_8812					BIT3			/* AC_VI DMA OK		 */
#define	IMR_VODOK_8812					BIT2			/* AC_VO DMA OK	 */
#define	IMR_RDU_8812						BIT1			/* Rx Descriptor Unavailable	 */
#define	IMR_ROK_8812						BIT0			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define	IMR_BCNDMAINT7_8812				BIT27		/* Beacon DMA Interrupt 7 */
#define	IMR_BCNDMAINT6_8812				BIT26		/* Beacon DMA Interrupt 6 */
#define	IMR_BCNDMAINT5_8812				BIT25		/* Beacon DMA Interrupt 5 */
#define	IMR_BCNDMAINT4_8812				BIT24		/* Beacon DMA Interrupt 4 */
#define	IMR_BCNDMAINT3_8812				BIT23		/* Beacon DMA Interrupt 3 */
#define	IMR_BCNDMAINT2_8812				BIT22		/* Beacon DMA Interrupt 2 */
#define	IMR_BCNDMAINT1_8812				BIT21		/* Beacon DMA Interrupt 1 */
#define	IMR_BCNDOK7_8812					BIT20		/* Beacon Queue DMA OK Interrup 7 */
#define	IMR_BCNDOK6_8812					BIT19		/* Beacon Queue DMA OK Interrup 6 */
#define	IMR_BCNDOK5_8812					BIT18		/* Beacon Queue DMA OK Interrup 5 */
#define	IMR_BCNDOK4_8812					BIT17		/* Beacon Queue DMA OK Interrup 4 */
#define	IMR_BCNDOK3_8812					BIT16		/* Beacon Queue DMA OK Interrup 3 */
#define	IMR_BCNDOK2_8812					BIT15		/* Beacon Queue DMA OK Interrup 2 */
#define	IMR_BCNDOK1_8812					BIT14		/* Beacon Queue DMA OK Interrup 1 */
#define	IMR_ATIMEND_E_8812				BIT13		/* ATIM Window End Extension for Win7 */
#define	IMR_TXERR_8812					BIT11		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define	IMR_RXERR_8812					BIT10		/* Rx Error Flag INT Status, Write 1 clear */
#define	IMR_TXFOVW_8812					BIT9			/* Transmit FIFO Overflow */
#define	IMR_RXFOVW_8812					BIT8			/* Receive FIFO Overflow */


#ifdef CONFIG_PCI_HCI
/* #define IMR_RX_MASK		(IMR_ROK_8812|IMR_RDU_8812|IMR_RXFOVW_8812) */
#define IMR_TX_MASK			(IMR_VODOK_8812 | IMR_VIDOK_8812 | IMR_BEDOK_8812 | IMR_BKDOK_8812 | IMR_MGNTDOK_8812 | IMR_HIGHDOK_8812)

#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8812 | IMR_TXBCN0OK_8812 | IMR_TXBCN0ERR_8812 | IMR_BCNDERR0_8812)

#define RT_AC_INT_MASKS	(IMR_VIDOK_8812 | IMR_VODOK_8812 | IMR_BEDOK_8812 | IMR_BKDOK_8812)
#endif


/* ****************************************************************************
* Regsiter Bit and Content definition
* **************************************************************************** */

/* 2 ACMHWCTRL 0x05C0 */
#define	AcmHw_HwEn_8812				BIT(0)
#define	AcmHw_VoqEn_8812				BIT(1)
#define	AcmHw_ViqEn_8812				BIT(2)
#define	AcmHw_BeqEn_8812				BIT(3)
#define	AcmHw_VoqStatus_8812			BIT(5)
#define	AcmHw_ViqStatus_8812			BIT(6)
#define	AcmHw_BeqStatus_8812			BIT(7)

#endif /* __RTL8812A_SPEC_H__ */

#ifdef CONFIG_RTL8821A
#include "rtl8821a_spec.h"
#endif /* CONFIG_RTL8821A */
                                                                                            rtl8822bu/src/include/Hal8703BPhyReg.h                                                              0000644 0001750 0001750 00000106207 14214766567 016052  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8703BPHYREG_H__
#define __INC_HAL8703BPHYREG_H__

#define		rSYM_WLBT_PAPE_SEL		0x64
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rTxAGC_B_Rate18_06				0x830
#define		rTxAGC_B_Rate54_24				0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00			0x83c

#define		rTxAGC_B_Mcs07_Mcs04			0x848
#define		rTxAGC_B_Mcs11_Mcs08			0x84c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rTxAGC_B_Mcs15_Mcs12			0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define	rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */
#define	rFPGA1_TxBlock				0x904	/* Useless now */
#define	rFPGA1_DebugSelect			0x908	/* Useless now */
#define	rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
#define	rDPDT_control				0x92c
#define	rfe_ctrl_anta_src				0x930
#define	rS0S1_PathSwitch			0x948
#define	rBBrx_DFIR					0x954

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport            		0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower      	0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper      	0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA						0xb00
#define rPdp_AntA_4						0xb04
#define rPdp_AntA_8						0xb08
#define rPdp_AntA_C						0xb0c
#define rPdp_AntA_10					0xb10
#define rPdp_AntA_14					0xb14
#define rPdp_AntA_18					0xb18
#define rPdp_AntA_1C					0xb1c
#define rPdp_AntA_20					0xb20
#define rPdp_AntA_24					0xb24

#define rConfig_Pmpd_AntA				0xb28
#define rConfig_ram64x16				0xb2c

#define rBndA							0xb30
#define rHssiPar						0xb34

#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c

#define rPdp_AntB						0xb70
#define rPdp_AntB_4						0xb74
#define rPdp_AntB_8						0xb78
#define rPdp_AntB_C						0xb7c
#define rPdp_AntB_10					0xb80
#define rPdp_AntB_14					0xb84
#define rPdp_AntB_18					0xb88
#define rPdp_AntB_1C					0xb8c
#define rPdp_AntB_20					0xb90
#define rPdp_AntB_24					0xb94

#define rConfig_Pmpd_AntB				0xb98

#define rBndB							0xba0

#define rAPK							0xbd8
#define rPm_Rx0_AntA					0xbdc
#define rPm_Rx1_AntA					0xbe0
#define rPm_Rx2_AntA					0xbe4
#define rPm_Rx3_AntA					0xbe8
#define rPm_Rx0_AntB					0xbec
#define rPm_Rx1_AntB					0xbf0
#define rPm_Rx2_AntB					0xbf4
#define rPm_Rx3_AntB					0xbf8
/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00			0xe10
#define		rTxAGC_A_Mcs07_Mcs04			0xe14
#define		rTxAGC_A_Mcs11_Mcs08			0xe18
#define		rTxAGC_A_Mcs15_Mcs12			0xe1c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/*  */

#define		RF_IQADJ_G1				0x01	/*  */
#define		RF_IQADJ_G2				0x02	/*  */
#define		RF_BS_PA_APSET_G1_G4		0x03
#define		RF_BS_PA_APSET_G5_G8		0x04
#define		RF_POW_TRSW				0x05	/*  */

#define		RF_GAIN_RX					0x06	/*  */
#define		RF_GAIN_TX					0x07	/*  */

#define		RF_TXM_IDAC				0x08	/*  */
#define		RF_IPA_G					0x09	/*  */
#define		RF_TXBIAS_G				0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A					0x0C	/*  */
#define		RF_TXBIAS_A				0x0D
#define		RF_BS_PA_APSET_G9_G11	0x0E
#define		RF_BS_IQGEN				0x0F	/*  */

#define		RF_MODE1					0x10	/*  */
#define		RF_MODE2					0x11	/*  */

#define		RF_RX_AGC_HP				0x12	/*  */
#define		RF_TX_AGC					0x13	/*  */
#define		RF_BIAS						0x14	/*  */
#define		RF_IPA						0x15	/*  */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/*  */
#define		RF_MODE_AG				0x18	/*  */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/*  */

#define		RF_RX_G1					0x1A	/*  */
#define		RF_RX_G2					0x1B	/*  */

#define		RF_RX_BB2					0x1C	/*  */
#define		RF_RX_BB1					0x1D	/*  */

#define		RF_RCK1					0x1E	/*  */
#define		RF_RCK2					0x1F	/*  */

#define		RF_TX_G1					0x20	/*  */
#define		RF_TX_G2					0x21	/*  */
#define		RF_TX_G3					0x22	/*  */

#define		RF_TX_BB1					0x23	/*  */

#define		RF_T_METER					0x24	/*  */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define	RF_TX_BIAS_A				0x35
#define	RF_TX_BIAS_D				0x36
#define	RF_LOBF_9					0x38
#define 	RF_RXRF_A3					0x3C	/*	 */
#define	RF_TRSW					0x3F

#define	RF_TXRF_A2					0x41
#define	RF_TXPA_G4					0x46
#define	RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define	RF_WE_LUT					0xEF
#define	RF_S0S1					0xB0

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
#define	RF_TX_GAIN_OFFSET_8703B(_val) (abs((_val)) | (((_val) > 0) ? BIT5 : 0))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bAntennaSelect		0x0300

#define		bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                  			0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    			0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  			0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI               		0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength          		0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         		0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW                		0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         		0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              		0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          		0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 		0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                		0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode				0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble			0x8	/* Useless */
#define		bCCKAntDiversity		0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate				0x3000
#define		bCCKDCCancel			0x0800
#define		bCCKISICancel			0x0400
#define		bCCKMatchFilter			0x0200
#define		bCCKEqualizer			0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart			0x300000
#define		bCCKCCACount			0x080000
#define		bCCKcs_lim				0x070000
#define		bCCKBistMode			0x80000000
#define		bCCKCCAMask			0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset			0xf0
#define		bCCKRxDCOffset			0xf
#define		bCCKCCAMode			0xc000
#define		bCCKFalseCS_lim			0x3f00
#define		bCCKCS_ratio			0xc00000
#define		bCCKCorgBit_sel			0x300000
#define		bCCKPD_lim				0x0f0000
#define		bCCKNewCCA			0x80000000
#define		bCCKRxHPofIG			0x8000
#define		bCCKRxIG				0x7f00
#define		bCCKLNAPolarity			0x800000
#define		bCCKRx1stGain			0x7f0000
#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC			0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType	0x0300
#define		bCCKRxDAGCEn			0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0				0x3f0000
#define		bCCKTxC1				0x3f000000
#define		bCCKTxC2				0x3f
#define		bCCKTxC3				0x3f00
#define		bCCKTxC4				0x3f0000
#define		bCCKTxC5				0x3f000000
#define		bCCKTxC6				0x3f
#define		bCCKTxC7				0x3f00
#define		bCCKDebugPort			0xff0000
#define		bCCKDACDebug			0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI				0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel			0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF				0x3	/* Useless */
#define		bShift_L					0xc0
#define		bGI_TH					0xc
#define		bRxPathA				0x1
#define		bRxPathB				0x2
#define		bRxPathC				0x4
#define		bRxPathD				0x8
#define		bTxPathA				0x1
#define		bTxPathB				0x2
#define		bTxPathC				0x4
#define		bTxPathD				0x8
#define		bTRSSIFreq				0x200
#define		bADCBackoff				0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode			0x1800000
#define		bRxDCNFType			0xe000000
#define		bRXIQImb_A				0x3ff
#define		bRXIQImb_B				0xfc00
#define		bRXIQImb_C				0x3f0000
#define		bRXIQImb_D				0xffc00000
#define		bDC_dc_Notch			0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH					0xf
#define		bPD_TH_Opt2			0xc000
#define		bPWED_TH				0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option				0x1000
#define		bMF_Win_L				0xe000
#define		bBW_Search_L			0x30000
#define		bwin_enh_L				0xc0000
#define		bBW_TH					0x700000
#define		bED_TH2				0x3800000
#define		bBW_option				0x4000000
#define		bRatio_TH				0x18000000
#define		bWindow_L				0xe0000000
#define		bSBD_Option				0x1
#define		bFrame_TH				0x1c
#define		bFS_Option				0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune				0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2			0x7
#define		bFrame_GI2_TH			0x38
#define		bGI2_Sync_en			0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum				0x1
#define		bCFOAcc				0x2
#define		bCFOStartOffset			0xc
#define		bCFOLookBack			0x70
#define		bCFOSumWeight			0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A				0x3ff
#define		bTXIQImb_B				0xfc00
#define		bTXIQImb_C				0x3f0000
#define		bTXIQImb_D				0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode			0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption			0x20000
#define		bCCADropThres			0xfff00000
#define		bEDCCA_H				0xf
#define		bEDCCA_L				0xf0
#define		bLambda_ED			0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn				0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En			0x10000000
#define		bRxQuickAGCEn			0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift				0x7f
#define		bTRSW_Tri_Only			0x80
#define		bPowerThres			0x300
#define		bRxAGCEn				0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin				0x4
#define		bRxHP_Ini				0x7
#define		bRxHP_TRLNA			0x70
#define		bRxHP_RSSI				0x700
#define		bRxHP_BBP1				0x7000
#define		bRxHP_BBP2				0x70000
#define		bRxHP_BBP3				0x700000
#define		bRSSI_H					0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW			0x7
#define		bRxSettle_LNA			0x38
#define		bRxSettle_RSSI			0x1c0
#define		bRxSettle_BBP			0xe00
#define		bRxSettle_RxHP			0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI			0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final				0x7000000
#define		bRxHTSettle_BBP			0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn			0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin			0x80000
#define		bRxHTAGCEn				0x100000
#define		bRxHTDAGCEn			0x200000
#define		bRxHTRxHP_BBP			0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH			0x3
#define		bRxPWRatioEn			0x4
#define		bRxMFHold				0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH			0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L			0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH				0xc0000000
#define		bDFSCnt0				0xff
#define		bDFSCnt1				0xff00
#define		bDFSFlag				0xf0000
#define		bMFWeightSum			0x300000
#define		bMinIdxTH				0x7f000000
#define		bDAFormat				0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain				0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn				0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss					0x20
#define		bCFOAntSumD			0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet			0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn				0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re		0x3f
#define		bSigTone_Im		0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail	0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail	0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync	0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength	12   /* total */
#define		bShortCFOFLength	11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength	11
#define		bLongCFOFLength	11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW			0x1
#define		bRxSC				0x6
#define		bRx_HT				0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg	0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain				0x3f
#define		bTableSel			0x40
#define		bTRSW				0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st				0xff
#define		bCSI2nd				0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd			0xff000000
#define		bSIGEVM			0xff
#define		bPWDB				0xff00
#define		bSGIEN				0x10000

#define		bSFactorQAM1		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode			0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType		0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO			0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC					0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF		0x20000
#define		bComChCFO			0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz			0x100000
#define		bUChCfg				0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C	0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW		0x18
#define		bRTL8256_RxLPFBW		0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW		0xc	/* Useless */
#define		bRTL8258_RxLPFBW		0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0				0x1	/* Useless */
#define		bByte1				0x2
#define		bByte2				0x4
#define		bByte3				0x8
#define		bWord0				0x3
#define		bWord1				0xc
#define		bDWord				0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1			0xff00
#define		bMaskByte2			0xff0000
#define		bMaskByte3			0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord			0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes		0xffffff00
#define		bMask12Bits			0xfff
#define		bMaskH4Bits			0xf0000000
#define		bMaskOFDM_D		0xffc00000
#define		bMaskCCK			0x3f3f3f3f


#define		bEnable			0x1	/* Useless */
#define		bDisable		0x0

#define		LeftAntenna		0x0	/* Useless */
#define		RightAntenna	0x1

#define		tCheckTxStatus		500   /* 500ms */ /* Useless */
#define		tUpdateRxCounter	100   /* 100ms */

#define		rateCCK		0	/* Useless */
#define		rateOFDM	1
#define		rateHT		2

/* define Register-End */
#define		bPMAC_End			0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

#endif
                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/sdio_ops_ce.h                                                                 0000644 0001750 0001750 00000003440 14214766567 016064  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _SDIO_OPS_WINCE_H_
#define _SDIO_OPS_WINCE_H_

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>
#include <osdep_intf.h>


#ifdef PLATFORM_OS_CE


extern u8 sdbus_cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);


extern void sdbus_cmd52w_ce(struct intf_priv *pintfpriv, u32 addr, u8 val8);


uint sdbus_read_blocks_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);

extern uint sdbus_read_bytes_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);


extern uint sdbus_write_blocks_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf, u8 async);

extern uint sdbus_write_bytes_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
extern u8 sdbus_func1cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
extern void sdbus_func1cmd52w_ce(struct intf_priv *pintfpriv, u32 addr, u8 val8);
extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt, void *pdata);
extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt, void *pdata);
extern void sdio_read_int(_adapter *padapter, u32 addr, u8 sz, void *pdata);

#endif

#endif
                                                                                                                                                                                                                                rtl8822bu/src/include/hal_phy.h                                                                     0000644 0001750 0001750 00000012562 14214766567 015227  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_PHY_H__
#define __HAL_PHY_H__


#if DISABLE_BB_RF
	#define	HAL_FW_ENABLE				0
	#define	HAL_MAC_ENABLE			0
	#define	HAL_BB_ENABLE				0
	#define	HAL_RF_ENABLE				0
#else /* FPGA_PHY and ASIC */
	#define	HAL_FW_ENABLE				1
	#define	HAL_MAC_ENABLE			1
	#define	HAL_BB_ENABLE				1
	#define	HAL_RF_ENABLE				1
#endif

#define	RF6052_MAX_TX_PWR			0x3F
#define	RF6052_MAX_REG_88E			0xFF
#define	RF6052_MAX_REG_92C			0x7F

#define	RF6052_MAX_REG	\
	((RF6052_MAX_REG_88E > RF6052_MAX_REG_92C) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C)

#define GET_RF6052_REAL_MAX_REG(_Adapter)	\
	(IS_HARDWARE_TYPE_8188E(_Adapter) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C)

#define	RF6052_MAX_PATH				2

/*
 * Antenna detection method, i.e., using single tone detection or RSSI reported from each antenna detected.
 * Added by Roger, 2013.05.22.
 *   */
#define ANT_DETECT_BY_SINGLE_TONE	BIT0
#define ANT_DETECT_BY_RSSI				BIT1
#define IS_ANT_DETECT_SUPPORT_SINGLE_TONE(__Adapter)		((GET_HAL_DATA(__Adapter)->AntDetection) & ANT_DETECT_BY_SINGLE_TONE)
#define IS_ANT_DETECT_SUPPORT_RSSI(__Adapter)		((GET_HAL_DATA(__Adapter)->AntDetection) & ANT_DETECT_BY_RSSI)


/*--------------------------Define Parameters-------------------------------*/
typedef	enum _RF_CHIP {
	RF_CHIP_MIN = 0,	/* 0 */
	RF_8225 = 1,			/* 1 11b/g RF for verification only */
	RF_8256 = 2,			/* 2 11b/g/n */
	RF_8258 = 3,			/* 3 11a/b/g/n RF */
	RF_6052 = 4,			/* 4 11b/g/n RF */
	RF_PSEUDO_11N = 5,	/* 5, It is a temporality RF. */
	RF_CHIP_MAX
} RF_CHIP_E, *PRF_CHIP_E;

typedef enum _ANTENNA_PATH {
	ANTENNA_NONE	= 0,
	ANTENNA_D		= 1,
	ANTENNA_C		= 2,
	ANTENNA_CD	= 3,
	ANTENNA_B		= 4,
	ANTENNA_BD	= 5,
	ANTENNA_BC	= 6,
	ANTENNA_BCD	= 7,
	ANTENNA_A		= 8,
	ANTENNA_AD	= 9,
	ANTENNA_AC	= 10,
	ANTENNA_ACD	= 11,
	ANTENNA_AB	= 12,
	ANTENNA_ABD	= 13,
	ANTENNA_ABC	= 14,
	ANTENNA_ABCD	= 15
} ANTENNA_PATH;

typedef enum _RF_CONTENT {
	radioa_txt = 0x1000,
	radiob_txt = 0x1001,
	radioc_txt = 0x1002,
	radiod_txt = 0x1003
} RF_CONTENT;

typedef enum _BaseBand_Config_Type {
	BaseBand_Config_PHY_REG = 0,			/* Radio Path A */
	BaseBand_Config_AGC_TAB = 1,			/* Radio Path B */
	BaseBand_Config_AGC_TAB_2G = 2,
	BaseBand_Config_AGC_TAB_5G = 3,
	BaseBand_Config_PHY_REG_PG
} BaseBand_Config_Type, *PBaseBand_Config_Type;

typedef enum _HW_BLOCK {
	HW_BLOCK_MAC = 0,
	HW_BLOCK_PHY0 = 1,
	HW_BLOCK_PHY1 = 2,
	HW_BLOCK_RF = 3,
	HW_BLOCK_MAXIMUM = 4, /* Never use this */
} HW_BLOCK_E, *PHW_BLOCK_E;

typedef enum _WIRELESS_MODE {
	WIRELESS_MODE_UNKNOWN = 0x00,
	WIRELESS_MODE_A = 0x01,
	WIRELESS_MODE_B = 0x02,
	WIRELESS_MODE_G = 0x04,
	WIRELESS_MODE_AUTO = 0x08,
	WIRELESS_MODE_N_24G = 0x10,
	WIRELESS_MODE_N_5G = 0x20,
	WIRELESS_MODE_AC_5G = 0x40,
	WIRELESS_MODE_AC_24G  = 0x80,
	WIRELESS_MODE_AC_ONLY  = 0x100,
} WIRELESS_MODE;

typedef enum _SwChnlCmdID {
	CmdID_End,
	CmdID_SetTxPowerLevel,
	CmdID_BBRegWrite10,
	CmdID_WritePortUlong,
	CmdID_WritePortUshort,
	CmdID_WritePortUchar,
	CmdID_RF_WriteReg,
} SwChnlCmdID;

typedef struct _SwChnlCmd {
	SwChnlCmdID	CmdID;
	u32				Para1;
	u32				Para2;
	u32				msDelay;
} SwChnlCmd;

typedef struct _R_ANTENNA_SELECT_OFDM {
	u32			r_tx_antenna:4;
	u32			r_ant_l:4;
	u32			r_ant_non_ht:4;
	u32			r_ant_ht1:4;
	u32			r_ant_ht2:4;
	u32			r_ant_ht_s1:4;
	u32			r_ant_non_ht_s1:4;
	u32			OFDM_TXSC:2;
	u32			Reserved:2;
} R_ANTENNA_SELECT_OFDM;

typedef struct _R_ANTENNA_SELECT_CCK {
	u8			r_cckrx_enable_2:2;
	u8			r_cckrx_enable:2;
	u8			r_ccktx_enable:4;
} R_ANTENNA_SELECT_CCK;


/*--------------------------Exported Function prototype---------------------*/
u32
PHY_CalculateBitShift(
	u32 BitMask
);

#ifdef CONFIG_RF_SHADOW_RW
typedef struct RF_Shadow_Compare_Map {
	/* Shadow register value */
	u32		Value;
	/* Compare or not flag */
	u8		Compare;
	/* Record If it had ever modified unpredicted */
	u8		ErrorOrNot;
	/* Recorver Flag */
	u8		Recorver;
	/*  */
	u8		Driver_Write;
} RF_SHADOW_T;

u32
PHY_RFShadowRead(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				Offset);

void
PHY_RFShadowWrite(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				Offset,
		u32				Data);

BOOLEAN
PHY_RFShadowCompare(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				Offset);

void
PHY_RFShadowRecorver(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				Offset);

void
PHY_RFShadowCompareAll(
		PADAPTER		Adapter);

void
PHY_RFShadowRecorverAll(
		PADAPTER		Adapter);

void
PHY_RFShadowCompareFlagSet(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				Offset,
		u8				Type);

void
PHY_RFShadowRecorverFlagSet(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				Offset,
		u8				Type);

void
PHY_RFShadowCompareFlagSetAll(
		PADAPTER		Adapter);

void
PHY_RFShadowRecorverFlagSetAll(
		PADAPTER		Adapter);

void
PHY_RFShadowRefresh(
		PADAPTER		Adapter);
#endif /*#CONFIG_RF_SHADOW_RW*/
#endif /* __HAL_COMMON_H__ */
                                                                                                                                              rtl8822bu/src/include/rtl8710b_sreset.h                                                             0000644 0001750 0001750 00000001631 14214766567 016446  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8710B_SRESET_H_
#define _RTL8710B_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8710b_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8710b_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                       rtl8822bu/src/include/rtl8814a_xmit.h                                                               0000755 0001750 0001750 00000046755 14214766567 016151  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_XMIT_H__
#define __RTL8814A_XMIT_H__

typedef struct txdescriptor_8814 {
	/* Offset 0 */
	u32 pktlen:16;
	u32 offset:8;
	u32 bmc:1;
	u32 htc:1;
	u32 ls:1;
} TXDESC_8814, *PTXDESC_8814;


#define OFFSET_SZ	0
#define OFFSET_SHT	16



#ifdef CONFIG_SDIO_HCI
	#define SET_TX_DESC_SDIO_TXSEQ_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
#endif /* CONFIG_SDIO_HCI */

/* -----------------------------------------------------------------
 *	RTL8814A TX BUFFER DESC
 * -----------------------------------------------------------------
 *
- Each TXBD has 4 segment.
 -- For 32 bit, each segment is 8 bytes.
 -- For 64 bit, each segment is 16 bytes.
*/
#if 0
	#if 1 /* 32 bit */
		#define SET_TX_EXTBUFF_DESC_LEN_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*8), 0, 16, __Value)
		#define SET_TX_EXTBUFF_DESC_ADDR_LOW_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*8)+4, 0, 32, __Value)
	#else /* 64 bit */
		#define SET_TX_EXTBUFF_DESC_LEN_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*16), 0, 16, __Value)
		#define SET_TX_EXTBUFF_DESC_ADDR_LOW_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*16)+4, 0, 32, __Value)
	#endif
	#define SET_TX_EXTBUFF_DESC_ADDR_HIGH_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*16)+8, 0, 32, __Value)
#endif
/*c2h-DWORD 2*/
#define GET_RX_STATUS_DESC_RPT_SEL_8814A(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+8, 28, 1)

/* *********************************************************
 * for Txfilldescroptor8814Ae, fill the desc content. */
#if 1 /* 32 bit */
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*8), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*8), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*8)+4, 0, 32, __Valeu)
#else /* 64 bit */
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+4, 0, 32, __Valeu)
#endif
#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+8, 0, 32, __Valeu)

/* ********************************************************* */

/* TX buffer
 * *************
 * Dword 0 */
#define SET_TX_BUFF_DESC_LEN_0_8814A(__pTxDesc, __Valeu)			SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Valeu)
#define SET_TX_BUFF_DESC_PSB_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
#define SET_TX_BUFF_DESC_OWN_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
#define GET_TX_BUFF_DESC_OWN_8814A(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

/* Dword 1 */
#define SET_TX_BUFF_DESC_ADDR_LOW_0_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
#define GET_TX_BUFF_DESC_ADDR_LOW_0_8814A(__pTxDesc)			LE_BITS_TO_4BYTE(__pTxDesc+4, 0, 32)
/* Dword 2 */
#define SET_TX_BUFF_DESC_ADDR_HIGH_0_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8814A(__pTxDesc)			LE_BITS_TO_4BYTE(__pTxDesc+8, 0, 32)
/* Dword 3 */ /* RESERVED 0 */

#if 0 /* 64 bit */
	/* Dword 4 */
	#define SET_TX_BUFF_DESC_LEN_1_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 16, __Value)
	#define SET_TX_BUFF_DESC_AMSDU_1_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 31, 1, __Value)
	/* Dword 5 */
	#define SET_TX_BUFF_DESC_ADDR_LOW_1_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 32, __Value)
	/* Dword 6 */
	#define SET_TX_BUFF_DESC_ADDR_HIGH_1_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 32, __Value)
	/* Dword 7 */ /* RESERVED 0 */
	/* Dword 8 */
	#define SET_TX_BUFF_DESC_LEN_2_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 16, __Value)
	#define SET_TX_BUFF_DESC_AMSDU_2_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 31, 1, __Value)
	/* Dword 9 */
	#define SET_TX_BUFF_DESC_ADDR_LOW_2_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 32, __Value)
	/* Dword 10 */
	#define SET_TX_BUFF_DESC_ADDR_HIGH_2_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
	/* Dword 11 */ /* RESERVED 0 */
	/* Dword 12 */
	#define SET_TX_BUFF_DESC_LEN_3_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 16, __Value)
	#define SET_TX_BUFF_DESC_AMSDU_3_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 31, 1, __Value)
	/* Dword 13 */
	#define SET_TX_BUFF_DESC_ADDR_LOW_3_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+52, 0, 32, __Value)
	/* Dword 14 */
	#define SET_TX_BUFF_DESC_ADDR_HIGH_3_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+56, 0, 32, __Value)
	/* Dword 15 */ /* RESERVED 0 */
#endif

/* *****Desc content
 * TX Info
 * *************
 * Dword 0 */
#define SET_TX_DESC_PKT_SIZE_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define GET_TX_DESC_PKT_SIZE_8814A(__pTxDesc)									LE_BITS_TO_4BYTE(__pTxDesc, 0, 16)
#define SET_TX_DESC_OFFSET_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define GET_TX_DESC_OFFSET_8814A(__pTxDesc)									LE_BITS_TO_4BYTE(__pTxDesc, 16, 8)
#define SET_TX_DESC_BMC_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_8814A(__pTxDesc, __Value)								SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_LAST_SEG_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
#define SET_TX_DESC_LINIP_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
#define SET_TX_DESC_AMSDU_PAD_EN_8814A(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_NO_ACM_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_8814A(__pTxDesc, __Value)								SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
#define SET_TX_DESC_DISQSELSEQ_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

/* Dword 1 */
#define SET_TX_DESC_MACID_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_8814A(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_8814A(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_8814A(__pTxDesc, __Value)							SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
#define SET_TX_DESC_MORE_DATA_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)
#define SET_TX_DESC_TXOP_PS_CAP_8814A(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 30, 1, __Value)
#define SET_TX_DESC_TXOP_PS_MODE_8814A(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 31, 1, __Value)


/* Dword 2 */
#define SET_TX_DESC_PAID_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
#define SET_TX_DESC_CCA_RTS_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_NULL_0_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
#define SET_TX_DESC_NULL_1_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
#define SET_TX_DESC_BK_8814A(__pTxDesc, __Value)				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define GET_TX_DESC_MORE_FRAG_8814A(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc+8, 17, 1)
#define SET_TX_DESC_RAW_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define SET_TX_DESC_SPE_RPT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_NULL_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_GID_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
#define SET_TX_DESC_HW_AES_IV_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 31, 1, __Value)


/* Dword 3 */
#define SET_TX_DESC_WHEADER_LEN_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 5, __Value)
#define SET_TX_DESC_EARLY_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
#define SET_TX_DESC_HW_SSN_SEL_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_CHECK_EN_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 1, __Value)
#define SET_TX_DESC_NAV_USE_HDR_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
#define SET_TX_DESC_USE_MAX_LEN_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_NDPA_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_TRY_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
#define SET_TX_DESC_PCTS_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
#define SET_TX_DESC_PCTS_MASK_IDX_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)


/* Dword 5 */
#define SET_TX_DESC_DATA_SC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_8814A(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_LDPC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
#define SET_TX_DESC_DATA_STBC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_CTROL_STBC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
#define SET_TX_DESC_SIGNALING_TA_PKT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 17, 1, __Value)
#define SET_TX_DESC_PORT_ID_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 21, 3, __Value)/* 20130415 KaiYuan add for 8814 */
#define SET_TX_DESC_TX_ANT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 4, __Value)
#define SET_TX_DESC_TX_POWER_OFFSET_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)

/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_MBSSID_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
#define SET_TX_DESC_ANTSEL_A_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
#define SET_TX_DESC_ANTSEL_B_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
#define SET_TX_DESC_ANT_MAPA_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 2, __Value)
#define SET_TX_DESC_ANT_MAPB_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 24, 2, __Value)
#define SET_TX_DESC_ANT_MAPC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 26, 2, __Value)
#define SET_TX_DESC_ANT_MAPD_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 28, 2, __Value)


/* Dword 7 */
#ifdef CONFIG_PCI_HCI
	#define SET_TX_DESC_TX_BUFFER_SIZE_8814A(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif
#if defined(CONFIG_SDIO_HCI)|| defined(CONFIG_USB_HCI)
	#define SET_TX_DESC_TX_DESC_CHECKSUM_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif
#define SET_TX_DESC_NTX_MAP_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 20, 4, __Value)
#define SET_TX_DESC_USB_TXAGG_NUM_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)


/* Dword 8 */
#define SET_TX_DESC_RTS_RC_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
#define SET_TX_DESC_BAR_RTY_TH_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
#define SET_TX_DESC_DATA_RC_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
#define SET_TX_DESC_EN_HWEXSEQ_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 14, 1, __Value)
#define SET_TX_DESC_HWSEQ_EN_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
#if defined(CONFIG_PCI_HCI)|| defined(CONFIG_USB_HCI)
	#define SET_TX_DESC_NEXT_HEAD_PAGE_L_8814A(__pTxDesc, __Value)(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
#endif
#ifdef CONFIG_SDIO_HCI
	#define SET_TX_DESC_SDIO_SEQ_8814A(__pTxDesc, __Value)(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value) /* 20130415 KaiYuan add for 8814AS */
#endif
#define SET_TX_DESC_TAIL_PAGE_L_8814A(__pTxDesc, __Value)(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)

/* Dword 9 */
#define SET_TX_DESC_PADDING_LENGTH_8814A(__pTxDesc, __Value)						SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
#define SET_TX_DESC_TXBF_PATH_8814A(__pTxDesc, __Value)								SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 11, 1, __Value)
#define SET_TX_DESC_SEQ_8814A(__pTxDesc, __Value)										SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
#define SET_TX_DESC_NEXT_HEAD_PAGE_H_8814A(__pTxDesc, __Value)(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 4, __Value)
#define SET_TX_DESC_TAIL_PAGE_H_8814A(__pTxDesc, __Value)(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 28, 4, __Value)



#define SET_EARLYMODE_PKTNUM_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
#define SET_EARLYMODE_LEN3_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)


void rtl8814a_cal_txdesc_chksum(u8 *ptxdesc);
void rtl8814a_fill_fake_txdesc(PADAPTER	padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8	IsBTQosNull, u8 bDataFrame);
void rtl8814a_fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
void rtl8814a_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
void rtl8814a_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#ifdef CONFIG_USB_HCI
	s32 rtl8814au_init_xmit_priv(PADAPTER padapter);
	void rtl8814au_free_xmit_priv(PADAPTER padapter);
	s32 rtl8814au_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8814au_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	 rtl8814au_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8814au_xmit_buf_handler(PADAPTER padapter);
	void rtl8814au_xmit_tasklet(void *priv);
	s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif /* CONFIG_USB_HCI */

#ifdef CONFIG_PCI_HCI
	s32 rtl8814ae_init_xmit_priv(PADAPTER padapter);
	void rtl8814ae_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8814ae_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	void rtl8814ae_xmitframe_resume(_adapter *padapter);
	s32 rtl8814ae_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8814ae_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8814ae_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8814ae_xmit_tasklet(void *priv);
#ifdef CONFIG_XMIT_THREAD_MODE
	s32 rtl8814ae_xmit_buf_handler(_adapter *padapter);
#endif
#endif

void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, u8 *ptxdesc);
u8
SCMapping_8814(
		PADAPTER		Adapter,
		struct pkt_attrib	*pattrib
);

u8
BWMapping_8814(
		PADAPTER		Adapter,
		struct pkt_attrib	*pattrib
);


#endif /* __RTL8814_XMIT_H__ */
                   rtl8822bu/src/include/rtw_mlme.h                                                                    0000644 0001750 0001750 00000136113 14214766567 015430  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_MLME_H_
#define __RTW_MLME_H_


#define	MAX_BSS_CNT	128
/* #define   MAX_JOIN_TIMEOUT	2000 */
/* #define   MAX_JOIN_TIMEOUT	2500 */
#define   MAX_JOIN_TIMEOUT	6500

/*	Commented by Albert 20101105
 *	Increase the scanning timeout because of increasing the SURVEY_TO value. */


#ifdef PALTFORM_OS_WINCE
#define	SCANQUEUE_LIFETIME 12000000 /* unit:us */
#else
#define	SCANQUEUE_LIFETIME 20000 /* 20sec, unit:msec */
#endif

#define WIFI_NULL_STATE					0x00000000
#define WIFI_ASOC_STATE					0x00000001 /* Linked */
#define WIFI_REASOC_STATE				0x00000002
#define WIFI_SLEEP_STATE				0x00000004
#define WIFI_STATION_STATE				0x00000008
#define WIFI_AP_STATE					0x00000010
#define WIFI_ADHOC_STATE				0x00000020
#define WIFI_ADHOC_MASTER_STATE			0x00000040
#define WIFI_UNDER_LINKING				0x00000080
#define WIFI_UNDER_WPS					0x00000100
#define WIFI_MESH_STATE					0x00000200
#define WIFI_STA_ALIVE_CHK_STATE		0x00000400
#define WIFI_SITE_MONITOR				0x00000800 /* under site surveying */
#define WIFI_WDS						0x00001000
#define WIFI_WDS_RX_BEACON				0x00002000 /* already rx WDS AP beacon */
#define WIFI_AUTOCONF					0x00004000
#define WIFI_AUTOCONF_IND				0x00008000
#define WIFI_MP_STATE					0x00010000
#define WIFI_MP_CTX_BACKGROUND			0x00020000 /* in continuous tx background */
#define WIFI_MP_CTX_ST					0x00040000 /* in continuous tx with single-tone */
#define WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in continuous tx background due to out of skb */
#define WIFI_MP_CTX_CCK_HW				0x00100000 /* in continuous tx */
#define WIFI_MP_CTX_CCK_CS				0x00200000 /* in continuous tx with carrier suppression */
#define WIFI_MP_LPBK_STATE				0x00400000
#define WIFI_OP_CH_SWITCHING			0x00800000
#define WIFI_UNDER_KEY_HANDSHAKE	0x01000000
/*#define WIFI_UNDEFINED_STATE			0x02000000*/
/*#define WIFI_UNDEFINED_STATE			0x04000000*/
/*#define WIFI_UNDEFINED_STATE			0x08000000*/
/*#define WIFI_UNDEFINED_STATE			0x10000000*/
/*#define WIFI_UNDEFINED_STATE			0x20000000*/
/*#define WIFI_UNDEFINED_STATE			0x40000000*/
#define WIFI_MONITOR_STATE				0x80000000

#define MIRACAST_DISABLED	0
#define MIRACAST_SOURCE		BIT0
#define MIRACAST_SINK		BIT1

#define MIRACAST_MODE_REVERSE(mode) \
	((((mode) & MIRACAST_SOURCE) ? MIRACAST_SINK : 0) | (((mode) & MIRACAST_SINK) ? MIRACAST_SOURCE : 0))

bool is_miracast_enabled(_adapter *adapter);
bool rtw_chk_miracast_mode(_adapter *adapter, u8 mode);
const char *get_miracast_mode_str(int mode);
void rtw_wfd_st_switch(struct sta_info *sta, bool on);

#define MLME_STATE(adapter) get_fwstate(&((adapter)->mlmepriv))
#define CHK_MLME_STATE(adapter, state) check_fwstate(&((adapter)->mlmepriv), (state))

#define MLME_IS_NULL(adapter) CHK_MLME_STATE(adapter, WIFI_NULL_STATE)
#define MLME_IS_STA(adapter) CHK_MLME_STATE(adapter, WIFI_STATION_STATE)
#define MLME_IS_AP(adapter) CHK_MLME_STATE(adapter, WIFI_AP_STATE)
#define MLME_IS_ADHOC(adapter) CHK_MLME_STATE(adapter, WIFI_ADHOC_STATE)
#define MLME_IS_ADHOC_MASTER(adapter) CHK_MLME_STATE(adapter, WIFI_ADHOC_MASTER_STATE)
#define MLME_IS_MESH(adapter) CHK_MLME_STATE(adapter, WIFI_MESH_STATE)
#define MLME_IS_MONITOR(adapter) CHK_MLME_STATE(adapter, WIFI_MONITOR_STATE)
#define MLME_IS_MP(adapter) CHK_MLME_STATE(adapter, WIFI_MP_STATE)
#ifdef CONFIG_P2P
	#define MLME_IS_PD(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_DEVICE)
	#define MLME_IS_GC(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_CLIENT)
	#define MLME_IS_GO(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_GO)
#else /* !CONFIG_P2P */
	#define MLME_IS_PD(adapter) 0
	#define MLME_IS_GC(adapter) 0
	#define MLME_IS_GO(adapter) 0
#endif /* !CONFIG_P2P */

#define MLME_IS_MSRC(adapter) rtw_chk_miracast_mode((adapter), MIRACAST_SOURCE)
#define MLME_IS_MSINK(adapter) rtw_chk_miracast_mode((adapter), MIRACAST_SINK)

#define MLME_IS_SCAN(adapter) CHK_MLME_STATE(adapter, WIFI_SITE_MONITOR)
#define MLME_IS_LINKING(adapter) CHK_MLME_STATE(adapter, WIFI_UNDER_LINKING)
#define MLME_IS_ASOC(adapter) CHK_MLME_STATE(adapter, WIFI_ASOC_STATE)
#define MLME_IS_OPCH_SW(adapter) CHK_MLME_STATE(adapter, WIFI_OP_CH_SWITCHING)
#define MLME_IS_WPS(adapter) CHK_MLME_STATE(adapter, WIFI_UNDER_WPS)

#if defined(CONFIG_IOCTL_CFG80211) && defined(CONFIG_P2P)
#define MLME_IS_ROCH(adapter) (rtw_cfg80211_get_is_roch(adapter) == _TRUE)
#else
#define MLME_IS_ROCH(adapter) 0
#endif

#ifdef CONFIG_IOCTL_CFG80211
#define MLME_IS_MGMT_TX(adapter) rtw_cfg80211_get_is_mgmt_tx(adapter)
#else
#define MLME_IS_MGMT_TX(adapter) 0
#endif

#define MLME_STATE_FMT "%s%s%s%s%s%s%s%s%s%s%s%s"
#define MLME_STATE_ARG(adapter) \
	MLME_IS_STA((adapter)) ? (MLME_IS_GC((adapter)) ? " GC" : " STA") : \
	MLME_IS_AP((adapter)) ? (MLME_IS_GO((adapter)) ? " GO" : " AP") : \
	MLME_IS_ADHOC((adapter)) ? " ADHOC" : \
	MLME_IS_ADHOC_MASTER((adapter)) ? " ADHOC_M" : \
	MLME_IS_MESH((adapter)) ? " MESH" : \
	MLME_IS_MONITOR((adapter)) ? " MONITOR" : \
	MLME_IS_MP((adapter)) ? " MP" : "", \
	MLME_IS_PD((adapter)) ? " PD" : "", \
	MLME_IS_MSRC((adapter)) ? " MSRC" : "", \
	MLME_IS_MSINK((adapter)) ? " MSINK" : "", \
	MLME_IS_SCAN((adapter)) ? " SCAN" : "", \
	MLME_IS_LINKING((adapter)) ? " LINKING" : "", \
	MLME_IS_ASOC((adapter)) ? " ASOC" : "", \
	MLME_IS_OPCH_SW((adapter)) ? " OPCH_SW" : "", \
	MLME_IS_WPS((adapter)) ? " WPS" : "", \
	MLME_IS_ROCH((adapter)) ? " ROCH" : "", \
	MLME_IS_MGMT_TX((adapter)) ? " MGMT_TX" : "", \
	(MLME_STATE((adapter)) & WIFI_SLEEP_STATE) ? " SLEEP" : ""

enum {
	MLME_ACTION_UNKNOWN,
	MLME_ACTION_NONE,
	MLME_SCAN_ENABLE, /* WIFI_SITE_MONITOR */
	MLME_SCAN_ENTER, /* WIFI_SITE_MONITOR && !SCAN_DISABLE && !SCAN_BACK_OP */
	MLME_SCAN_DONE, /*  WIFI_SITE_MONITOR && (SCAN_DISABLE || SCAN_BACK_OP) */
	MLME_SCAN_DISABLE, /* WIFI_SITE_MONITOR is going to be cleared */
	MLME_STA_CONNECTING,
	MLME_STA_CONNECTED,
	MLME_STA_DISCONNECTED,
	MLME_TDLS_LINKED,
	MLME_TDLS_NOLINK,
	MLME_AP_STARTED,
	MLME_AP_STOPPED,
	MLME_ADHOC_STARTED,
	MLME_ADHOC_STOPPED,
	MLME_MESH_STARTED,
	MLME_MESH_STOPPED,
	MLME_OPCH_SWITCH,
};

#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
#define _FW_LINKED			WIFI_ASOC_STATE
#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR


enum dot11AuthAlgrthmNum {
	dot11AuthAlgrthm_Open = 0,
	dot11AuthAlgrthm_Shared,
	dot11AuthAlgrthm_8021X,
	dot11AuthAlgrthm_Auto,
	dot11AuthAlgrthm_WAPI,
	dot11AuthAlgrthm_MaxNum
};

/* Scan type including active and passive scan. */
typedef enum _RT_SCAN_TYPE {
	SCAN_PASSIVE,
	SCAN_ACTIVE,
	SCAN_MIX,
} RT_SCAN_TYPE, *PRT_SCAN_TYPE;

#define WIFI_FREQUENCY_BAND_AUTO 0
#define WIFI_FREQUENCY_BAND_5GHZ 1
#define WIFI_FREQUENCY_BAND_2GHZ 2

#define rtw_band_valid(band) ((band) <= WIFI_FREQUENCY_BAND_2GHZ)

enum DriverInterface {
	DRIVER_WEXT =  1,
	DRIVER_CFG80211 = 2
};

enum SCAN_RESULT_TYPE {
	SCAN_RESULT_P2P_ONLY = 0,		/*	Will return all the P2P devices. */
	SCAN_RESULT_ALL = 1,			/*	Will return all the scanned device, include AP. */
	SCAN_RESULT_WFD_TYPE = 2		/*	Will just return the correct WFD device. */
									/*	If this device is Miracast sink device, it will just return all the Miracast source devices. */
};

/*

there are several "locks" in mlme_priv,
since mlme_priv is a shared resource between many threads,
like ISR/Call-Back functions, the OID handlers, and even timer functions.


Each _queue has its own locks, already.
Other items are protected by mlme_priv.lock.

To avoid possible dead lock, any thread trying to modifiying mlme_priv
SHALL not lock up more than one locks at a time!

*/


#define traffic_threshold	10
#define	traffic_scan_period	500

typedef struct _RT_LINK_DETECT_T {
	u32				NumTxOkInPeriod;
	u32				NumRxOkInPeriod;
	u32				NumRxUnicastOkInPeriod;
	BOOLEAN			bBusyTraffic;
	BOOLEAN			bTxBusyTraffic;
	BOOLEAN			bRxBusyTraffic;
	BOOLEAN			bHigherBusyTraffic; /* For interrupt migration purpose. */
	BOOLEAN			bHigherBusyRxTraffic; /* We may disable Tx interrupt according as Rx traffic. */
	BOOLEAN			bHigherBusyTxTraffic; /* We may disable Tx interrupt according as Tx traffic. */
	/* u8 TrafficBusyState; */
	u8 TrafficTransitionCount;
	u32 LowPowerTransitionCount;
} RT_LINK_DETECT_T, *PRT_LINK_DETECT_T;

struct profile_info {
	u8	ssidlen;
	u8	ssid[WLAN_SSID_MAXLEN];
	u8	peermac[ETH_ALEN];
};

struct tx_invite_req_info {
	u8					token;
	u8					benable;
	u8					go_ssid[WLAN_SSID_MAXLEN];
	u8					ssidlen;
	u8					go_bssid[ETH_ALEN];
	u8					peer_macaddr[ETH_ALEN];
	u8					operating_ch;	/*	This information will be set by using the p2p_set op_ch=x */
	u8					peer_ch;		/*	The listen channel for peer P2P device */

};

struct tx_invite_resp_info {
	u8					token;	/*	Used to record the dialog token of p2p invitation request frame. */
};

#ifdef CONFIG_WFD

struct wifi_display_info {
	u16							wfd_enable;			/*	Eanble/Disable the WFD function. */
	u16							init_rtsp_ctrlport;	/* init value of rtsp_ctrlport when WFD enable */
	u16							rtsp_ctrlport;		/* TCP port number at which the this WFD device listens for RTSP messages, 0 when WFD disable */
	u16							tdls_rtsp_ctrlport;	/* rtsp_ctrlport used by tdls, will sync when rtsp_ctrlport is changed by user */
	u16							peer_rtsp_ctrlport;	/*	TCP port number at which the peer WFD device listens for RTSP messages */
													/*	This filed should be filled when receiving the gropu negotiation request */

	u8							peer_session_avail;	/*	WFD session is available or not for the peer wfd device. */
													/*	This variable will be set when sending the provisioning discovery request to peer WFD device. */
													/*	And this variable will be reset when it is read by using the iwpriv p2p_get wfd_sa command. */
	u8							ip_address[4];
	u8							peer_ip_address[4];
	u8							wfd_pc;				/*	WFD preferred connection */
													/*	0 -> Prefer to use the P2P for WFD connection on peer side. */
													/*	1 -> Prefer to use the TDLS for WFD connection on peer side. */

	u8							wfd_device_type;	/*	WFD Device Type */
													/*	0 -> WFD Source Device */
													/*	1 -> WFD Primary Sink Device */
	enum	SCAN_RESULT_TYPE	scan_result_type;	/*	Used when P2P is enable. This parameter will impact the scan result. */
	u8 op_wfd_mode;
	u8 stack_wfd_mode;
};
#endif /* CONFIG_WFD */

struct tx_provdisc_req_info {
	u16					wps_config_method_request;	/*	Used when sending the provisioning request frame */
	u16					peer_channel_num[2];		/*	The channel number which the receiver stands. */
	NDIS_802_11_SSID	ssid;
	u8					peerDevAddr[ETH_ALEN];		/*	Peer device address */
	u8					peerIFAddr[ETH_ALEN];		/*	Peer interface address */
	u8					benable;					/*	This provision discovery request frame is trigger to send or not */
};

struct rx_provdisc_req_info {	/* When peer device issue prov_disc_req first, we should store the following informations */
	u8					peerDevAddr[ETH_ALEN];		/*	Peer device address */
	u8					strconfig_method_desc_of_prov_disc_req[4];	/*	description for the config method located in the provisioning discovery request frame.	 */
																	/*	The UI must know this information to know which config method the remote p2p device is requiring. */
};

struct tx_nego_req_info {
	u16					peer_channel_num[2];		/*	The channel number which the receiver stands. */
	u8					peerDevAddr[ETH_ALEN];		/*	Peer device address */
	u8					benable;					/*	This negoitation request frame is trigger to send or not */
	u8					peer_ch;					/*	The listen channel for peer P2P device */
};

struct group_id_info {
	u8					go_device_addr[ETH_ALEN];	/*	The GO's device address of this P2P group */
	u8					ssid[WLAN_SSID_MAXLEN];		/*	The SSID of this P2P group */
};

struct scan_limit_info {
	u8					scan_op_ch_only;			/*	When this flag is set, the driver should just scan the operation channel */
#ifndef CONFIG_P2P_OP_CHK_SOCIAL_CH
	u8					operation_ch[2];				/*	Store the operation channel of invitation request frame */
#else
	u8					operation_ch[5];				/*	Store additional channel 1,6,11  for Android 4.2 IOT & Nexus 4 */
#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
};

#ifdef CONFIG_IOCTL_CFG80211
struct cfg80211_wifidirect_info {
	_timer					remain_on_ch_timer;
	u8						restore_channel;
	struct ieee80211_channel	remain_on_ch_channel;
	enum nl80211_channel_type	remain_on_ch_type;
	ATOMIC_T ro_ch_cookie_gen;
	u64 remain_on_ch_cookie;
	bool is_ro_ch;
	struct wireless_dev *ro_ch_wdev;
	systime last_ro_ch_time; /* this will be updated at the beginning and end of ro_ch */
};
#endif /* CONFIG_IOCTL_CFG80211 */

#ifdef CONFIG_P2P_WOWLAN

enum P2P_WOWLAN_RECV_FRAME_TYPE {
	P2P_WOWLAN_RECV_NEGO_REQ = 0,
	P2P_WOWLAN_RECV_INVITE_REQ = 1,
	P2P_WOWLAN_RECV_PROVISION_REQ = 2,
};

struct p2p_wowlan_info {

	u8						is_trigger;
	enum P2P_WOWLAN_RECV_FRAME_TYPE	wowlan_recv_frame_type;
	u8						wowlan_peer_addr[ETH_ALEN];
	u16						wowlan_peer_wpsconfig;
	u8						wowlan_peer_is_persistent;
	u8						wowlan_peer_invitation_type;
};

#endif /* CONFIG_P2P_WOWLAN */

struct wifidirect_info {
	_adapter				*padapter;
	_timer					find_phase_timer;
	_timer					restore_p2p_state_timer;

	/*	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer. */
	_timer					pre_tx_scan_timer;
	_timer					reset_ch_sitesurvey;
	_timer					reset_ch_sitesurvey2;	/*	Just for resetting the scan limit function by using p2p nego */
#ifdef CONFIG_CONCURRENT_MODE
	/*	Used to switch the channel between legacy AP and listen state. */
	_timer					ap_p2p_switch_timer;
#endif
	struct tx_provdisc_req_info	tx_prov_disc_info;
	struct rx_provdisc_req_info rx_prov_disc_info;
	struct tx_invite_req_info	invitereq_info;
	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	/*	Store the profile information of persistent group */
	struct tx_invite_resp_info	inviteresp_info;
	struct tx_nego_req_info	nego_req_info;
	struct group_id_info		groupid_info;	/*	Store the group id information when doing the group negotiation handshake. */
	struct scan_limit_info		rx_invitereq_info;	/*	Used for get the limit scan channel from the Invitation procedure */
	struct scan_limit_info		p2p_info;		/*	Used for get the limit scan channel from the P2P negotiation handshake */
#ifdef CONFIG_WFD
	struct wifi_display_info		*wfd_info;
#endif

#ifdef CONFIG_P2P_WOWLAN
	struct p2p_wowlan_info		p2p_wow_info;
#endif /* CONFIG_P2P_WOWLAN */

	enum P2P_ROLE			role;
	enum P2P_STATE			pre_p2p_state;
	enum P2P_STATE			p2p_state;
	u8						device_addr[ETH_ALEN];	/*	The device address should be the mac address of this device. */
	u8						interface_addr[ETH_ALEN];
	u8						social_chan[4];
	u8						listen_channel;
	u8						operating_channel;
	u8						listen_dwell;		/*	This value should be between 1 and 3 */
	u8						support_rate[8];
	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
	u8						intent;		/*	should only include the intent value. */
	u8						p2p_peer_interface_addr[ETH_ALEN];
	u8						p2p_peer_device_addr[ETH_ALEN];
	u8						peer_intent;	/*	Included the intent value and tie breaker value. */
	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	/*	Device name for displaying on searching device screen */
	u16						device_name_len;
	u8						profileindex;	/*	Used to point to the index of profileinfo array */
	u8						peer_operating_ch;
	u8						find_phase_state_exchange_cnt;
	u16						device_password_id_for_nego;	/*	The device password ID for group negotation */
	u8						negotiation_dialog_token;
	u8						nego_ssid[WLAN_SSID_MAXLEN];	/*	SSID information for group negotitation */
	u8						nego_ssidlen;
	u8						p2p_group_ssid[WLAN_SSID_MAXLEN];
	u8						p2p_group_ssid_len;
	u8						persistent_supported;		/*	Flag to know the persistent function should be supported or not. */
														/*	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI. */
														/*	0: disable */
														/*	1: enable */
	u8						session_available;			/*	Flag to set the WFD session available to enable or disable "by Sigma" */
														/*	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI. */
														/*	0: disable */
														/*	1: enable */

	u8						wfd_tdls_enable;			/*	Flag to enable or disable the TDLS by WFD Sigma */
														/*	0: disable */
														/*	1: enable */
	u8						wfd_tdls_weaksec;			/*	Flag to enable or disable the weak security function for TDLS by WFD Sigma */
														/*	0: disable */
														/*	In this case, the driver can't issue the tdsl setup request frame. */
														/*	1: enable */
														/*	In this case, the driver can issue the tdls setup request frame */
														/*	even the current security is weak security. */

	enum	P2P_WPSINFO		ui_got_wps_info;			/*	This field will store the WPS value (PIN value or PBC) that UI had got from the user. */
	u16						supported_wps_cm;			/*	This field describes the WPS config method which this driver supported. */
														/*	The value should be the combination of config method defined in page104 of WPS v2.0 spec.	 */
	u8						external_uuid;				/* UUID flag */
	u8						uuid[16];					/* UUID */
	uint						channel_list_attr_len;	/*	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
	u8						channel_list_attr[100];		/*	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
														/*	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame. */
	u8						driver_interface;			/*	Indicate DRIVER_WEXT or DRIVER_CFG80211 */

#ifdef CONFIG_CONCURRENT_MODE
	u16						ext_listen_interval;	/*	The interval to be available with legacy AP (ms) */
	u16						ext_listen_period;	/*	The time period to be available for P2P listen state (ms) */
#endif
#ifdef CONFIG_P2P_PS
	enum P2P_PS_MODE		p2p_ps_mode; /* indicate p2p ps mode */
	enum P2P_PS_STATE		p2p_ps_state; /* indicate p2p ps state */
	u8						noa_index; /* Identifies and instance of Notice of Absence timing. */
	u8						ctwindow; /* Client traffic window. A period of time in TU after TBTT. */
	u8						opp_ps; /* opportunistic power save. */
	u8						noa_num; /* number of NoA descriptor in P2P IE. */
	u8						noa_count[P2P_MAX_NOA_NUM]; /* Count for owner, Type of client. */
	u32						noa_duration[P2P_MAX_NOA_NUM]; /* Max duration for owner, preferred or min acceptable duration for client. */
	u32						noa_interval[P2P_MAX_NOA_NUM]; /* Length of interval for owner, preferred or max acceptable interval of client. */
	u32						noa_start_time[P2P_MAX_NOA_NUM]; /* schedule expressed in terms of the lower 4 bytes of the TSF timer. */
#endif /* CONFIG_P2P_PS */
};

struct tdls_ss_record {	/* signal strength record */
	u8		macaddr[ETH_ALEN];
	u8		RxPWDBAll;
	u8		is_tdls_sta;	/* _TRUE: direct link sta, _FALSE: else */
};

struct tdls_temp_mgmt {
	u8	initiator;	/* 0: None, 1: we initiate, 2: peer initiate */
	u8	peer_addr[ETH_ALEN];
};

#ifdef CONFIG_TDLS_CH_SW
struct tdls_ch_switch {
	u32	ch_sw_state;
	ATOMIC_T	chsw_on;
	u8	addr[ETH_ALEN];
	u8	off_ch_num;
	u8	ch_offset;
	u32	cur_time;
	u8	delay_switch_back;
	u8	dump_stack;
	struct submit_ctx	chsw_sctx;
};
#endif

struct tdls_info {
	u8					ap_prohibited;
	u8					ch_switch_prohibited;
	u8					link_established;
	u8					sta_cnt;
	u8					sta_maximum;	/* 1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else; */
	struct tdls_ss_record	ss_record;
#ifdef CONFIG_TDLS_CH_SW
	struct tdls_ch_switch	chsw_info;
#endif

	u8					ch_sensing;
	u8					cur_channel;
	u8					collect_pkt_num[MAX_CHANNEL_NUM];
	_lock				cmd_lock;
	_lock				hdl_lock;
	u8					watchdog_count;
	u8					dev_discovered;		/* WFD_TDLS: for sigma test */

	/* Let wpa_supplicant to setup*/
	u8					driver_setup;
#ifdef CONFIG_WFD
	struct wifi_display_info		*wfd_info;
#endif

	struct submit_ctx	*tdls_sctx;
};

struct tdls_txmgmt {
	u8 peer[ETH_ALEN];
	u8 action_code;
	u8 dialog_token;
	u16 status_code;
	u8 *buf;
	size_t len;
};

/* used for mlme_priv.roam_flags */
enum {
	RTW_ROAM_ON_EXPIRED = BIT0,
	RTW_ROAM_ON_RESUME = BIT1,
	RTW_ROAM_ACTIVE = BIT2,
};

#ifdef CONFIG_RTW_80211R
#define RTW_FT_ACTION_REQ_LMT	4
#define RTW_FT_MAX_IE_SZ	256

enum _rtw_ft_sta_status {
	RTW_FT_UNASSOCIATED_STA = 0,
	RTW_FT_AUTHENTICATING_STA,
	RTW_FT_AUTHENTICATED_STA,
	RTW_FT_ASSOCIATING_STA,
	RTW_FT_ASSOCIATED_STA,
	RTW_FT_REQUESTING_STA,
	RTW_FT_REQUESTED_STA,
	RTW_FT_CONFIRMED_STA,
	RTW_FT_UNSPECIFIED_STA
};

#define rtw_ft_chk_status(a, s) \
	((a)->mlmepriv.ft_roam.ft_status == (s))

#define rtw_ft_roam_status(a, s)	\
	((rtw_to_roam(a) > 0) && rtw_ft_chk_status(a, s))

#define rtw_ft_authed_sta(a)	\
	((rtw_ft_chk_status(a, RTW_FT_AUTHENTICATED_STA)) ||	\
	(rtw_ft_chk_status(a, RTW_FT_ASSOCIATING_STA)) ||	\
	(rtw_ft_chk_status(a, RTW_FT_ASSOCIATED_STA)))

#define rtw_ft_set_status(a, s) \
	do { \
		((a)->mlmepriv.ft_roam.ft_status = (s)); \
	} while (0)

#define rtw_ft_lock_set_status(a, s, irq) \
	do { \
		_enter_critical_bh(&(a)->mlmepriv.lock, ((_irqL *)(irq)));	\
		((a)->mlmepriv.ft_roam.ft_status = (s));	\
		_exit_critical_bh(&(a)->mlmepriv.lock, ((_irqL *)(irq)));	\
	} while (0)

#define rtw_ft_reset_status(a) \
	do { \
		((a)->mlmepriv.ft_roam.ft_status = RTW_FT_UNASSOCIATED_STA); \
	} while (0)

enum rtw_ft_capability {
	RTW_FT_EN = BIT0,
	RTW_FT_OTD_EN = BIT1,
	RTW_FT_PEER_EN = BIT2,
	RTW_FT_PEER_OTD_EN = BIT3,
	RTW_FT_BTM_ROAM = BIT4,
};

#define rtw_ft_chk_flags(a, f) \
	((a)->mlmepriv.ft_roam.ft_flags & (f))

#define rtw_ft_set_flags(a, f) \
	do { \
		((a)->mlmepriv.ft_roam.ft_flags |= (f)); \
	} while (0)

#define rtw_ft_clr_flags(a, f) \
	do { \
		((a)->mlmepriv.ft_roam.ft_flags &= ~(f)); \
	} while (0)

#define rtw_ft_roam(a)	\
	((rtw_to_roam(a) > 0) && rtw_ft_chk_flags(a, RTW_FT_PEER_EN))
	
#define rtw_ft_valid_akm(a, t)	\
	((rtw_ft_chk_flags(a, RTW_FT_EN)) && \
	(((t) == 3) || ((t) == 4)))

#define rtw_ft_roam_expired(a, r)	\
	((rtw_chk_roam_flags(a, RTW_ROAM_ON_EXPIRED)) \
	&& (r == WLAN_REASON_ACTIVE_ROAM))

#define rtw_ft_otd_roam_en(a)	\
	((rtw_ft_chk_flags(a, RTW_FT_OTD_EN))	\
	&& ((a)->mlmepriv.ft_roam.ft_roam_on_expired == _FALSE)	\
	&& ((a)->mlmepriv.ft_roam.ft_cap & 0x01))
	
#define rtw_ft_otd_roam(a) \
	rtw_ft_chk_flags(a, RTW_FT_PEER_OTD_EN)

#define rtw_ft_valid_otd_candidate(a, p)	\
	((rtw_ft_chk_flags(a, RTW_FT_OTD_EN)) 	\
	&& ((rtw_ft_chk_flags(a, RTW_FT_PEER_OTD_EN)	\
	&& ((*((p)+4) & 0x01) == 0))	\
	|| ((rtw_ft_chk_flags(a, RTW_FT_PEER_OTD_EN) == 0)	\
	&& (*((p)+4) & 0x01))))

struct ft_roam_info {
	u16	mdid;
	u8	ft_cap;	
	/*b0: FT over DS, b1: Resource Req Protocol Cap, b2~b7: Reserved*/
	u8	updated_ft_ies[RTW_FT_MAX_IE_SZ];
	u16	updated_ft_ies_len;
	u8	ft_action[RTW_FT_MAX_IE_SZ];
	u16	ft_action_len;
	struct cfg80211_ft_event_params ft_event;
	u8	ft_roam_on_expired;
	u8	ft_flags;
	u32 ft_status;
	u32 ft_req_retry_cnt;
	bool ft_updated_bcn;	
};
#endif

#ifdef CONFIG_LAYER2_ROAMING
#if defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K)
#define RTW_RRM_NB_RPT_EN		BIT(1)
#define RTW_MAX_NB_RPT_NUM	8

#define rtw_roam_busy_scan(a, nb)	\
	(((a)->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE) && \
	(((a)->mlmepriv.ch_cnt) < ((nb)->nb_rpt_ch_list_num)))

#define rtw_wnm_btm_preference_cap(a) \
	((a)->mlmepriv.nb_info.preference_en == _TRUE)

#define rtw_wnm_btm_diff_bss(a) \
	((rtw_wnm_btm_preference_cap(a)) && \
	(is_zero_mac_addr((a)->mlmepriv.nb_info.roam_target_addr) == _FALSE) && \
	(_rtw_memcmp((a)->mlmepriv.nb_info.roam_target_addr,\
		(a)->mlmepriv.cur_network.network.MacAddress, ETH_ALEN) == _FALSE))

#define rtw_wnm_btm_roam_candidate(a, c) \
	((rtw_wnm_btm_preference_cap(a)) && \
	(is_zero_mac_addr((a)->mlmepriv.nb_info.roam_target_addr) == _FALSE) && \
	(_rtw_memcmp((a)->mlmepriv.nb_info.roam_target_addr,\
		(c)->network.MacAddress, ETH_ALEN)))

#define rtw_wnm_set_ext_cap_btm(_pEleStart, _val) \
	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+2, 3, 1, _val)

#define wnm_btm_bss_term_inc(p) (*((u8 *)((p)+3)) & BSS_TERMINATION_INCLUDED)

#define wnm_btm_ess_disassoc_im(p) (*((u8 *)((p)+3)) & ESS_DISASSOC_IMMINENT)

#define wnm_btm_req_mode(p) (*((u8 *)((p)+3)))

#define wnm_btm_disassoc_timer(p) (*((u16 *)((p)+4)))

#define wnm_btm_valid_interval(p) (*((u8 *)((p)+6)))

#define wnm_btm_term_duration_offset(p) ((p)+7)

/*IEEE Std 80211k Figure 7-95b Neighbor Report element format*/
struct nb_rpt_hdr {
	u8 id; /*0x34: Neighbor Report Element ID*/
	u8 len;
	u8 bssid[ETH_ALEN];
	u32 bss_info;
	u8 reg_class;
	u8 ch_num;
	u8 phy_type;	
};

/*IEEE Std 80211v, Figure 7-95e2XBSS Termination Duration subelement field format */
struct btm_term_duration {
	u8 id;
	u8 len;
	u64 tsf;
	u16 duration;
};

/*IEEE Std 80211v, Figure 7-101n8XBSS Transition Management Request frame body format */
struct btm_req_hdr {
	u8 req_mode;
	u16 disassoc_timer;
	u8 validity_interval;
	struct btm_term_duration term_duration;
};

/*IEEE Std 80211v,  Table 7-43b Optional Subelement IDs for Neighbor Report*/
/* BSS Transition Candidate Preference */
#define WNM_BTM_CAND_PREF_SUBEID 0x03

/* BSS Termination Duration */
#define WNM_BTM_TERM_DUR_SUBEID		0x04

struct wnm_btm_cant {
	struct nb_rpt_hdr nb_rpt;
	u8 preference;	/* BSS Transition Candidate Preference */
};

enum rtw_btm_req_mod {
	PREFERRED_CANDIDATE_LIST_INCLUDED = BIT0,
	ABRIDGED = BIT1,
	DISASSOC_IMMINENT = BIT2,
	BSS_TERMINATION_INCLUDED = BIT3,
	ESS_DISASSOC_IMMINENT = BIT4,
};

struct roam_nb_info {
	struct nb_rpt_hdr nb_rpt[RTW_MAX_NB_RPT_NUM];
	struct rtw_ieee80211_channel nb_rpt_ch_list[RTW_MAX_NB_RPT_NUM];
	bool	nb_rpt_valid;
	u8	nb_rpt_ch_list_num;
	u8 preference_en;
	u8 roam_target_addr[ETH_ALEN];
	u32	last_nb_rpt_entries;
	bool	nb_rpt_is_same;
	_timer roam_scan_timer;
};
#endif	/* defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K) */
#endif

struct mlme_priv {

	_lock	lock;
	sint	fw_state;	/* shall we protect this variable? maybe not necessarily... */
	u8	to_join; /* flag */
	u16 join_status;
#ifdef CONFIG_LAYER2_ROAMING
	u8 to_roam; /* roaming trying times */
	struct wlan_network *roam_network; /* the target of active roam */
	u8 roam_flags;
	u8 roam_rssi_diff_th; /* rssi difference threshold for active scan candidate selection */
	u32 roam_scan_int; 		/* scan interval for active roam (Unit:2 second)*/
	u32 roam_scanr_exp_ms; /* scan result expire time in ms  for roam */
	u8 roam_tgt_addr[ETH_ALEN]; /* request to roam to speicific target without other consideration */
	u8 roam_rssi_threshold;
	systime last_roaming;
	bool need_to_roam;
#endif

	u8	*nic_hdl;
	u32	max_bss_cnt;		/*	The size of scan queue	*/
	_list		*pscanned;
	_queue	free_bss_pool;
	_queue	scanned_queue;
	u8		*free_bss_buf;
	u32	num_of_scanned;

	NDIS_802_11_SSID	assoc_ssid;
	u8	assoc_bssid[6];
	u16	assoc_ch;		/* 0 reserved for no specific channel */

	struct wlan_network	cur_network;
	struct wlan_network *cur_network_scanned;

	/* bcn check info */
	struct beacon_keys cur_beacon_keys; /* save current beacon keys */
#ifdef CONFIG_BCN_CNT_CONFIRM_HDL
	struct beacon_keys new_beacon_keys; /* save new beacon keys */
	u8 new_beacon_cnts; /* if new_beacon_cnts >= threshold, ap beacon is changed */
#endif

#ifdef CONFIG_ARP_KEEP_ALIVE
	/* for arp offload keep alive */
	u8 bGetGateway;
	u8	GetGatewayTryCnt;
	u8	gw_mac_addr[ETH_ALEN];
	u8	gw_ip[4];
#endif

	/* uint wireless_mode; no used, remove it */

	u32	auto_scan_int_ms;

	_timer assoc_timer;

	uint assoc_by_bssid;
	uint assoc_by_rssi;

	_timer scan_to_timer; /* driver itself handles scan_timeout status. */
	systime scan_start_time; /* used to evaluate the time spent in scanning */

#ifdef CONFIG_SET_SCAN_DENY_TIMER
	_timer set_scan_deny_timer;
	ATOMIC_T set_scan_deny; /* 0: allowed, 1: deny */
#endif
	u8 wpa_phase;/*wpa_phase after wps finished*/

	struct qos_priv qospriv;

#ifdef CONFIG_80211N_HT

	/* Number of non-HT AP/stations */
	int num_sta_no_ht;

	/* Number of HT AP/stations 20 MHz */
	/* int num_sta_ht_20mhz; */


	int num_FortyMHzIntolerant;

	struct ht_priv	htpriv;

#endif

#ifdef CONFIG_80211AC_VHT
	struct vht_priv	vhtpriv;
#ifdef ROKU_PRIVATE
	/*infra mode, used to store AP's info*/
	struct vht_priv_infra_ap vhtpriv_infra_ap;
#endif /* ROKU_PRIVATE */
#endif

#ifdef ROKU_PRIVATE
	struct ht_priv_infra_ap htpriv_infra_ap;
#endif /* ROKU_PRIVATE */

#ifdef CONFIG_RTW_80211R
	struct ft_roam_info ft_roam;
#endif
#if defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K)
	struct roam_nb_info nb_info;
	u8 ch_cnt;
#endif

	RT_LINK_DETECT_T	LinkDetectInfo;

	u8	acm_mask; /* for wmm acm mask */
	RT_SCAN_TYPE	scan_mode; /* active: 1, passive: 0 */

	u8 *wps_probe_req_ie;
	u32 wps_probe_req_ie_len;

	u8 ext_capab_ie_data[8];/*currently for ap mode only*/
	u8 ext_capab_ie_len;

#if defined(CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
	 * in 802.11g BSS) */
	int num_sta_non_erp;

	/* Number of associated stations that do not support Short Slot Time */
	int num_sta_no_short_slot_time;

	/* Number of associated stations that do not support Short Preamble */
	int num_sta_no_short_preamble;

	ATOMIC_T olbc; /* Overlapping Legacy BSS Condition (Legacy b/g)*/

	/* Number of HT associated stations that do not support greenfield */
	int num_sta_ht_no_gf;

	/* Number of associated non-HT stations */
	/* int num_sta_no_ht; */

	/* Number of HT associated stations 20 MHz */
	int num_sta_ht_20mhz;

	/* number of associated stations 40MHz intolerant */
	int num_sta_40mhz_intolerant;

	/* Overlapping BSS information */
	ATOMIC_T olbc_ht;

#ifdef CONFIG_80211N_HT
	int ht_20mhz_width_req;
	int ht_intolerant_ch_reported;
	u16 ht_op_mode;
	u8 sw_to_20mhz; /*switch to 20Mhz BW*/
#endif /* CONFIG_80211N_HT */

#ifdef CONFIG_RTW_80211R
	u8 *auth_rsp;
	u32 auth_rsp_len;
#endif
	u8 *assoc_req;
	u32 assoc_req_len;

	u8 *assoc_rsp;
	u32 assoc_rsp_len;

	/* u8 *wps_probe_req_ie; */
	/* u32 wps_probe_req_ie_len; */

	u8 *wps_beacon_ie;
	u32 wps_beacon_ie_len;

	u8 *wps_probe_resp_ie;
	u32 wps_probe_resp_ie_len;

	u8 *wps_assoc_resp_ie;
	u32 wps_assoc_resp_ie_len;

	u8 *p2p_beacon_ie;
	u32 p2p_beacon_ie_len;

	u8 *p2p_probe_req_ie;
	u32 p2p_probe_req_ie_len;

	u8 *p2p_probe_resp_ie;
	u32 p2p_probe_resp_ie_len;

	u8 *p2p_go_probe_resp_ie;		/* for GO */
	u32 p2p_go_probe_resp_ie_len;	/* for GO */

	u8 *p2p_assoc_req_ie;
	u32 p2p_assoc_req_ie_len;

	u8 *p2p_assoc_resp_ie;
	u32 p2p_assoc_resp_ie_len;

	_lock	bcn_update_lock;
	u8		update_bcn;

	u8 ori_ch;
	u8 ori_bw;
	u8 ori_offset;
	#ifdef CONFIG_80211AC_VHT
	u8 ori_vht_en;
	#endif

	u8 ap_isolate;
#endif /* #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */

#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
	u8 *wfd_beacon_ie;
	u32 wfd_beacon_ie_len;

	u8 *wfd_probe_req_ie;
	u32 wfd_probe_req_ie_len;

	u8 *wfd_probe_resp_ie;
	u32 wfd_probe_resp_ie_len;

	u8 *wfd_go_probe_resp_ie;		/* for GO */
	u32 wfd_go_probe_resp_ie_len;	/* for GO */

	u8 *wfd_assoc_req_ie;
	u32 wfd_assoc_req_ie_len;

	u8 *wfd_assoc_resp_ie;
	u32 wfd_assoc_resp_ie_len;
#endif

#ifdef RTK_DMP_PLATFORM
	/* DMP kobject_hotplug function  signal need in passive level */
	_workitem	Linkup_workitem;
	_workitem	Linkdown_workitem;
#endif
	systime lastscantime;
#ifdef CONFIG_CONCURRENT_MODE
	u8	scanning_via_buddy_intf;
#endif

#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
	u32 vendor_ie_mask[WLAN_MAX_VENDOR_IE_NUM];
	u8 vendor_ie[WLAN_MAX_VENDOR_IE_NUM][WLAN_MAX_VENDOR_IE_LEN];
	u32 vendor_ielen[WLAN_MAX_VENDOR_IE_NUM];
#endif
};

#define mlme_set_scan_to_timer(mlme, ms) \
	do { \
		/* RTW_INFO("%s set_scan_to_timer(%p, %d)\n", __FUNCTION__, (mlme), (ms)); */ \
		_set_timer(&(mlme)->scan_to_timer, (ms)); \
	} while (0)

#define rtw_mlme_set_auto_scan_int(adapter, ms) \
	do { \
		adapter->mlmepriv.auto_scan_int_ms = ms; \
	} while (0)

#define RTW_AUTO_SCAN_REASON_UNSPECIFIED		0
#define RTW_AUTO_SCAN_REASON_2040_BSS			BIT0
#define RTW_AUTO_SCAN_REASON_ACS				BIT1
#define RTW_AUTO_SCAN_REASON_ROAM				BIT2
#define RTW_AUTO_SCAN_REASON_MESH_OFFCH_CAND	BIT3

void rtw_mlme_reset_auto_scan_int(_adapter *adapter, u8 *reason);

#ifdef CONFIG_AP_MODE

struct hostapd_priv {
	_adapter *padapter;

#ifdef CONFIG_HOSTAPD_MLME
	struct net_device *pmgnt_netdev;
	struct usb_anchor anchored;
#endif

};

extern int hostapd_mode_init(_adapter *padapter);
extern void hostapd_mode_unload(_adapter *padapter);
#endif


extern int rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf, u16 status);
extern void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf);
extern void rtw_surveydone_event_callback(_adapter *adapter, u8 *pbuf);
extern void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf);
extern void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf);
extern void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf);
void rtw_sta_mstatus_disc_rpt(_adapter *adapter, u8 mac_id);
void rtw_sta_mstatus_report(_adapter *adapter);
extern void rtw_atimdone_event_callback(_adapter *adapter, u8 *pbuf);
extern void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf);
extern void rtw_wmm_event_callback(PADAPTER padapter, u8 *pbuf);
#ifdef CONFIG_IEEE80211W
void rtw_sta_timeout_event_callback(_adapter *adapter, u8 *pbuf);
#endif /* CONFIG_IEEE80211W */
#ifdef CONFIG_RTW_80211R
void rtw_ft_info_init(struct ft_roam_info *pft);
u8 rtw_ft_chk_roaming_candidate(_adapter *padapter, 
	struct wlan_network *competitor);
void rtw_ft_update_stainfo(_adapter *padapter, WLAN_BSSID_EX *pnetwork);
void rtw_ft_reassoc_event_callback(_adapter *padapter, u8 *pbuf);
#endif
#if defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K)
void rtw_roam_nb_info_init(_adapter *padapter);
#endif

thread_return event_thread(thread_context context);

extern void rtw_free_network_queue(_adapter *adapter, u8 isfreeall);
extern int rtw_init_mlme_priv(_adapter *adapter);/* (struct mlme_priv *pmlmepriv); */

extern void rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);


extern sint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
extern sint rtw_set_key(_adapter *adapter, struct security_priv *psecuritypriv, sint keyid, u8 set_tx, bool enqueue);
extern sint rtw_set_auth(_adapter *adapter, struct security_priv *psecuritypriv);

__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv)
{
	/* if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid */
	/* if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address */
	return pmlmepriv->cur_network.network.MacAddress;
}

__inline static sint check_fwstate(struct mlme_priv *pmlmepriv, sint state)
{
	if ((state == WIFI_NULL_STATE) &&
		(pmlmepriv->fw_state == WIFI_NULL_STATE))
		return _TRUE;

	if (pmlmepriv->fw_state & state)
		return _TRUE;

	return _FALSE;
}

__inline static sint get_fwstate(struct mlme_priv *pmlmepriv)
{
	return pmlmepriv->fw_state;
}

/*
 * No Limit on the calling context,
 * therefore set it to be the critical section...
 *
 * ### NOTE:#### (!!!!)
 * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
 */
extern void rtw_mi_update_iface_status(struct mlme_priv *pmlmepriv, sint state);

static inline void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
{
	pmlmepriv->fw_state |= state;
	rtw_mi_update_iface_status(pmlmepriv, state);
}
static inline void init_fwstate(struct mlme_priv *pmlmepriv, sint state)
{
	pmlmepriv->fw_state = state;
	rtw_mi_update_iface_status(pmlmepriv, state);
}

static inline void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
{
	pmlmepriv->fw_state &= ~state;
	rtw_mi_update_iface_status(pmlmepriv, state);
}

/*
 * No Limit on the calling context,
 * therefore set it to be the critical section...
 */
static inline void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
{
	_irqL irqL;

	_enter_critical_bh(&pmlmepriv->lock, &irqL);
	_clr_fwstate_(pmlmepriv, state);
	_exit_critical_bh(&pmlmepriv->lock, &irqL);
}

static inline void up_scanned_network(struct mlme_priv *pmlmepriv)
{
	_irqL irqL;

	_enter_critical_bh(&pmlmepriv->lock, &irqL);
	pmlmepriv->num_of_scanned++;
	_exit_critical_bh(&pmlmepriv->lock, &irqL);
}
u8 rtw_is_adapter_up(_adapter *padapter);

__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
{
	_irqL irqL;

	_enter_critical_bh(&pmlmepriv->lock, &irqL);
	pmlmepriv->num_of_scanned--;
	_exit_critical_bh(&pmlmepriv->lock, &irqL);
}

__inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint val)
{
	_irqL irqL;

	_enter_critical_bh(&pmlmepriv->lock, &irqL);
	pmlmepriv->num_of_scanned = val;
	_exit_critical_bh(&pmlmepriv->lock, &irqL);
}

extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
extern bool rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target);
extern void rtw_disconnect_hdl_under_linked(_adapter *adapter, struct sta_info *psta, u8 free_assoc);
extern void rtw_generate_random_ibss(u8 *pibss);
struct wlan_network *_rtw_find_network(_queue *scanned_queue, const u8 *addr);
struct wlan_network *rtw_find_network(_queue *scanned_queue, const u8 *addr);
extern struct wlan_network *rtw_get_oldest_wlan_network(_queue *scanned_queue);
struct wlan_network *_rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);

extern void rtw_free_assoc_resources(_adapter *adapter, u8 lock_scanned_queue);
extern void rtw_indicate_disconnect(_adapter *adapter, u16 reason, u8 locally_generated);
extern int rtw_indicate_connect(_adapter *adapter);
void rtw_indicate_scan_done(_adapter *padapter, bool aborted);

void rtw_drv_scan_by_self(_adapter *padapter, u8 reason);
void rtw_scan_wait_completed(_adapter *adapter);
u32 rtw_scan_abort_timeout(_adapter *adapter, u32 timeout_ms);
void rtw_scan_abort_no_wait(_adapter *adapter);
void rtw_scan_abort(_adapter *adapter);
u32 rtw_join_abort_timeout(_adapter *adapter, u32 timeout_ms);

int rtw_cached_pmkid(_adapter *Adapter, u8 *bssid);
int rtw_rsn_sync_pmkid(_adapter *adapter, u8 *ie, uint ie_len, int i_ent);

extern int rtw_restruct_sec_ie(_adapter *adapter, u8 *out_ie);
#ifdef CONFIG_WMMPS_STA
void rtw_uapsd_use_default_setting(_adapter *padapter);
bool rtw_is_wmmps_mode(_adapter *padapter);
#endif /* CONFIG_WMMPS_STA */
extern int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
extern void rtw_init_registrypriv_dev_network(_adapter *adapter);

extern void rtw_update_registrypriv_dev_network(_adapter *adapter);

extern void rtw_get_encrypt_decrypt_from_registrypriv(_adapter *adapter);

extern void rtw_join_timeout_handler(void *ctx);
extern void rtw_scan_timeout_handler(void *ctx);

extern void rtw_dynamic_check_timer_handlder(void *ctx);
extern void rtw_iface_dynamic_check_timer_handlder(_adapter *adapter);

enum {
	SS_DENY_MP_MODE,
	SS_DENY_RSON_SCANING,
	SS_DENY_BLOCK_SCAN,
	SS_DENY_BY_DRV,
	SS_DENY_SELF_AP_UNDER_WPS,
	SS_DENY_SELF_AP_UNDER_LINKING,
	SS_DENY_SELF_AP_UNDER_SURVEY,
	/*SS_DENY_SELF_STA_UNDER_WPS,*/
	SS_DENY_SELF_STA_UNDER_LINKING,
	SS_DENY_SELF_STA_UNDER_SURVEY,
	SS_DENY_BUDDY_UNDER_LINK_WPS,
	SS_DENY_BUDDY_UNDER_SURVEY,
	SS_DENY_BUSY_TRAFFIC,
	SS_ALLOW,
#ifdef DBG_LA_MODE
	SS_DENY_LA_MODE,
#endif
	SS_DENY_ADAPTIVITY,
};

u8 _rtw_sitesurvey_condition_check(const char *caller, _adapter *adapter, bool check_sc_interval);
#define rtw_sitesurvey_condition_check(adapter, check_sc_interval) _rtw_sitesurvey_condition_check(__func__, adapter, check_sc_interval)

#ifdef CONFIG_SET_SCAN_DENY_TIMER
bool rtw_is_scan_deny(_adapter *adapter);
void rtw_clear_scan_deny(_adapter *adapter);
void rtw_set_scan_deny_timer_hdl(void *ctx);
void rtw_set_scan_deny(_adapter *adapter, u32 ms);
#else
#define rtw_is_scan_deny(adapter) _FALSE
#define rtw_clear_scan_deny(adapter) do {} while (0)
#define rtw_set_scan_deny(adapter, ms) do {} while (0)
#endif

void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv);

#define MLME_BEACON_IE			0
#define MLME_PROBE_REQ_IE		1
#define MLME_PROBE_RESP_IE		2
#define MLME_GO_PROBE_RESP_IE	3
#define MLME_ASSOC_REQ_IE		4
#define MLME_ASSOC_RESP_IE		5

#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
int rtw_mlme_update_wfd_ie_data(struct mlme_priv *mlme, u8 type, u8 *ie, u32 ie_len);
#endif


/* extern struct wlan_network* _rtw_dequeue_network(_queue *queue); */

extern struct wlan_network *_rtw_alloc_network(struct mlme_priv *pmlmepriv);


extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall);
extern void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);

extern void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall);

extern sint rtw_if_up(_adapter *padapter);

sint rtw_linked_check(_adapter *padapter);

u8 *rtw_get_capability_from_ie(u8 *ie);
u8 *rtw_get_timestampe_from_ie(u8 *ie);
u8 *rtw_get_beacon_interval_from_ie(u8 *ie);


void rtw_joinbss_reset(_adapter *padapter);

#ifdef CONFIG_80211N_HT
void	rtw_ht_use_default_setting(_adapter *padapter);
void rtw_build_wmm_ie_ht(_adapter *padapter, u8 *out_ie, uint *pout_len);
unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel);
void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel);
void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
void rtw_append_exented_cap(_adapter *padapter, u8 *out_ie, uint *pout_len);
#endif

int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst, u8 feature);

#ifdef CONFIG_LAYER2_ROAMING
#define rtw_roam_flags(adapter) ((adapter)->mlmepriv.roam_flags)
#define rtw_chk_roam_flags(adapter, flags) ((adapter)->mlmepriv.roam_flags & flags)
#define rtw_clr_roam_flags(adapter, flags) \
	do { \
		((adapter)->mlmepriv.roam_flags &= ~flags); \
	} while (0)

#define rtw_set_roam_flags(adapter, flags) \
	do { \
		((adapter)->mlmepriv.roam_flags |= flags); \
	} while (0)

#define rtw_assign_roam_flags(adapter, flags) \
	do { \
		((adapter)->mlmepriv.roam_flags = flags); \
	} while (0)

void _rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
void rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
void rtw_set_to_roam(_adapter *adapter, u8 to_roam);
u8 rtw_dec_to_roam(_adapter *adapter);
u8 rtw_to_roam(_adapter *adapter);
int rtw_select_roaming_candidate(struct mlme_priv *pmlmepriv);
#else
#define rtw_roam_flags(adapter) 0
#define rtw_chk_roam_flags(adapter, flags) 0
#define rtw_clr_roam_flags(adapter, flags) do {} while (0)
#define rtw_set_roam_flags(adapter, flags) do {} while (0)
#define rtw_assign_roam_flags(adapter, flags) do {} while (0)
#define _rtw_roaming(adapter, tgt_network) do {} while (0)
#define rtw_roaming(adapter, tgt_network) do {} while (0)
#define rtw_set_to_roam(adapter, to_roam) do {} while (0)
#define rtw_dec_to_roam(adapter) 0
#define rtw_to_roam(adapter) 0
#define rtw_select_roaming_candidate(mlme) _FAIL
#endif /* CONFIG_LAYER2_ROAMING */

bool rtw_adjust_chbw(_adapter *adapter, u8 req_ch, u8 *req_bw, u8 *req_offset);

struct sta_media_status_rpt_cmd_parm {
	struct sta_info *sta;
	bool connected;
};

void rtw_sta_media_status_rpt(_adapter *adapter, struct sta_info *sta, bool connected);
u8 rtw_sta_media_status_rpt_cmd(_adapter *adapter, struct sta_info *sta, bool connected);
void rtw_sta_media_status_rpt_cmd_hdl(_adapter *adapter, struct sta_media_status_rpt_cmd_parm *parm);
void rtw_sta_traffic_info(void *sel, _adapter *adapter);

#define GET_ARP_HTYPE(_arp)	BE_BITS_TO_2BYTE(((u8 *)(_arp)) + 0, 0, 16)
#define GET_ARP_PTYPE(_arp)	BE_BITS_TO_2BYTE(((u8 *)(_arp)) + 2, 0, 16)
#define GET_ARP_HLEN(_arp)	BE_BITS_TO_1BYTE(((u8 *)(_arp)) + 4, 0, 8)
#define GET_ARP_PLEN(_arp)	BE_BITS_TO_1BYTE(((u8 *)(_arp)) + 5, 0, 8)
#define GET_ARP_OPER(_arp)	BE_BITS_TO_2BYTE(((u8 *)(_arp)) + 6, 0, 16)

#define SET_ARP_HTYPE(_arp, _val)	SET_BITS_TO_BE_2BYTE(((u8 *)(_arp)) + 0, 0, 16, _val)
#define SET_ARP_PTYPE(_arp, _val)	SET_BITS_TO_BE_2BYTE(((u8 *)(_arp)) + 2, 0, 16, _val)
#define SET_ARP_HLEN(_arp, _val)	SET_BITS_TO_BE_1BYTE(((u8 *)(_arp)) + 4, 0, 8, _val)
#define SET_ARP_PLEN(_arp, _val)	SET_BITS_TO_BE_1BYTE(((u8 *)(_arp)) + 5, 0, 8, _val)
#define SET_ARP_OPER(_arp, _val)	SET_BITS_TO_BE_2BYTE(((u8 *)(_arp)) + 6, 0, 16, _val)

#define ARP_SHA(_arp, _hlen, _plen)	(((u8 *)(_arp)) + 8)
#define ARP_SPA(_arp, _hlen, _plen)	(((u8 *)(_arp)) + 8 + (_hlen))
#define ARP_THA(_arp, _hlen, _plen)	(((u8 *)(_arp)) + 8 + (_hlen) + (_plen))
#define ARP_TPA(_arp, _hlen, _plen)	(((u8 *)(_arp)) + 8 + 2 * (_hlen) + (_plen))

#define ARP_SENDER_MAC_ADDR(_arp)	ARP_SHA(_arp, ETH_ALEN, RTW_IP_ADDR_LEN)
#define ARP_SENDER_IP_ADDR(_arp)	ARP_SPA(_arp, ETH_ALEN, RTW_IP_ADDR_LEN)
#define ARP_TARGET_MAC_ADDR(_arp)	ARP_THA(_arp, ETH_ALEN, RTW_IP_ADDR_LEN)
#define ARP_TARGET_IP_ADDR(_arp)	ARP_TPA(_arp, ETH_ALEN, RTW_IP_ADDR_LEN)

#define GET_ARP_SENDER_MAC_ADDR(_arp, _val)	_rtw_memcpy(_val, ARP_SENDER_MAC_ADDR(_arp), ETH_ALEN)
#define GET_ARP_SENDER_IP_ADDR(_arp, _val)	_rtw_memcpy(_val, ARP_SENDER_IP_ADDR(_arp), RTW_IP_ADDR_LEN)
#define GET_ARP_TARGET_MAC_ADDR(_arp, _val)	_rtw_memcpy(_val, ARP_TARGET_MAC_ADDR(_arp), ETH_ALEN)
#define GET_ARP_TARGET_IP_ADDR(_arp, _val)	_rtw_memcpy(_val, ARP_TARGET_IP_ADDR(_arp), RTW_IP_ADDR_LEN)

#define SET_ARP_SENDER_MAC_ADDR(_arp, _val)	_rtw_memcpy(ARP_SENDER_MAC_ADDR(_arp), _val, ETH_ALEN)
#define SET_ARP_SENDER_IP_ADDR(_arp, _val)	_rtw_memcpy(ARP_SENDER_IP_ADDR(_arp), _val, RTW_IP_ADDR_LEN)
#define SET_ARP_TARGET_MAC_ADDR(_arp, _val)	_rtw_memcpy(ARP_TARGET_MAC_ADDR(_arp), _val, ETH_ALEN)
#define SET_ARP_TARGET_IP_ADDR(_arp, _val)	_rtw_memcpy(ARP_TARGET_IP_ADDR(_arp), _val, RTW_IP_ADDR_LEN)

void dump_arp_pkt(void *sel, u8 *da, u8 *sa, u8 *arp, bool tx);

#define IPV4_SRC(_iphdr)			(((u8 *)(_iphdr)) + 12)
#define IPV4_DST(_iphdr)			(((u8 *)(_iphdr)) + 16)
#define GET_IPV4_IHL(_iphdr)		BE_BITS_TO_1BYTE(((u8 *)(_iphdr)) + 0, 0, 4)
#define GET_IPV4_PROTOCOL(_iphdr)	BE_BITS_TO_1BYTE(((u8 *)(_iphdr)) + 9, 0, 8)
#define GET_IPV4_SRC(_iphdr)		BE_BITS_TO_4BYTE(((u8 *)(_iphdr)) + 12, 0, 32)
#define GET_IPV4_DST(_iphdr)		BE_BITS_TO_4BYTE(((u8 *)(_iphdr)) + 16, 0, 32)

#define GET_UDP_SRC(_udphdr)			BE_BITS_TO_2BYTE(((u8 *)(_udphdr)) + 0, 0, 16)
#define GET_UDP_DST(_udphdr)			BE_BITS_TO_2BYTE(((u8 *)(_udphdr)) + 2, 0, 16)
#define GET_UDP_SIG1(_udphdr)			BE_BITS_TO_1BYTE(((u8 *)(_udphdr)) + 8, 0, 8)
#define GET_UDP_SIG2(_udphdr)			BE_BITS_TO_1BYTE(((u8 *)(_udphdr)) + 23, 0, 8)

#define TCP_SRC(_tcphdr)				(((u8 *)(_tcphdr)) + 0)
#define TCP_DST(_tcphdr)				(((u8 *)(_tcphdr)) + 2)
#define GET_TCP_SRC(_tcphdr)			BE_BITS_TO_2BYTE(((u8 *)(_tcphdr)) + 0, 0, 16)
#define GET_TCP_DST(_tcphdr)			BE_BITS_TO_2BYTE(((u8 *)(_tcphdr)) + 2, 0, 16)
#define GET_TCP_SEQ(_tcphdr)			BE_BITS_TO_4BYTE(((u8 *)(_tcphdr)) + 4, 0, 32)
#define GET_TCP_ACK_SEQ(_tcphdr)		BE_BITS_TO_4BYTE(((u8 *)(_tcphdr)) + 8, 0, 32)
#define GET_TCP_DOFF(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 12, 4, 4)
#define GET_TCP_FIN(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 0, 1)
#define GET_TCP_SYN(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 1, 1)
#define GET_TCP_RST(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 2, 1)
#define GET_TCP_PSH(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 3, 1)
#define GET_TCP_ACK(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 4, 1)
#define GET_TCP_URG(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 5, 1)
#define GET_TCP_ECE(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 6, 1)
#define GET_TCP_CWR(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 7, 1)

#endif /* __RTL871X_MLME_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/rtw_mlme_ext.h                                                                0000644 0001750 0001750 00000141211 14214766567 016303  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_MLME_EXT_H_
#define __RTW_MLME_EXT_H_


/*	Commented by Albert 20101105
 *	Increase the SURVEY_TO value from 100 to 150  ( 100ms to 150ms )
 *	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
 *	So, this driver tried to extend the dwell time for each scanning channel.
 *	This will increase the chance to receive the probe response from SoftAP. */
#define SURVEY_TO		(100)

#define REAUTH_TO		(300) /* (50) */
#define REASSOC_TO		(300) /* (50) */
/* #define DISCONNECT_TO	(3000) */
#define ADDBA_TO			(2000)

#ifndef SURVEY_TO_ACTIVE
#define SURVEY_TO_ACTIVE	SURVEY_TO
#endif

#define LINKED_TO (1) /* unit:2 sec, 1x2 = 2 sec */

#define REAUTH_LIMIT	(4)
#define REASSOC_LIMIT	(4)
#define READDBA_LIMIT	(2)

#define DEAUTH_DENY_TO		500 /* unit: ms */

#ifdef CONFIG_GSPI_HCI
	#define ROAMING_LIMIT	5
#else
	#define ROAMING_LIMIT	8
#endif
/* #define	IOCMD_REG0		0x10250370 */
/* #define	IOCMD_REG1		0x10250374 */
/* #define	IOCMD_REG2		0x10250378 */

/* #define	FW_DYNAMIC_FUN_SWITCH	0x10250364 */

/* #define	WRITE_BB_CMD		0xF0000001 */
/* #define	SET_CHANNEL_CMD	0xF3000000 */
/* #define	UPDATE_RA_CMD	0xFD0000A2 */

#define _HW_STATE_NOLINK_		0x00
#define _HW_STATE_ADHOC_		0x01
#define _HW_STATE_STATION_	0x02
#define _HW_STATE_AP_			0x03
#define _HW_STATE_MONITOR_ 0x04


#define		_1M_RATE_	0
#define		_2M_RATE_	1
#define		_5M_RATE_	2
#define		_11M_RATE_	3
#define		_6M_RATE_	4
#define		_9M_RATE_	5
#define		_12M_RATE_	6
#define		_18M_RATE_	7
#define		_24M_RATE_	8
#define		_36M_RATE_	9
#define		_48M_RATE_	10
#define		_54M_RATE_	11

/********************************************************
MCS rate definitions
*********************************************************/
#define MCS_RATE_1R	(0x000000ff)
#define MCS_RATE_2R	(0x0000ffff)
#define MCS_RATE_3R	(0x00ffffff)
#define MCS_RATE_4R	(0xffffffff)
#define MCS_RATE_2R_13TO15_OFF	(0x00001fff)


extern unsigned char RTW_WPA_OUI[];
extern unsigned char WMM_OUI[];
extern unsigned char WPS_OUI[];
extern unsigned char WFD_OUI[];
extern unsigned char P2P_OUI[];

extern unsigned char WMM_INFO_OUI[];
extern unsigned char WMM_PARA_OUI[];

typedef struct _RT_CHANNEL_PLAN {
	unsigned char	Channel[MAX_CHANNEL_NUM];
	unsigned char	Len;
} RT_CHANNEL_PLAN, *PRT_CHANNEL_PLAN;

enum Associated_AP {
	atherosAP	= 0,
	broadcomAP	= 1,
	ciscoAP		= 2,
	marvellAP	= 3,
	ralinkAP	= 4,
	realtekAP	= 5,
	airgocapAP	= 6,
	unknownAP	= 7,
	maxAP,
};

typedef enum _HT_IOT_PEER {
	HT_IOT_PEER_UNKNOWN			= 0,
	HT_IOT_PEER_REALTEK			= 1,
	HT_IOT_PEER_REALTEK_92SE		= 2,
	HT_IOT_PEER_BROADCOM		= 3,
	HT_IOT_PEER_RALINK			= 4,
	HT_IOT_PEER_ATHEROS			= 5,
	HT_IOT_PEER_CISCO				= 6,
	HT_IOT_PEER_MERU				= 7,
	HT_IOT_PEER_MARVELL			= 8,
	HT_IOT_PEER_REALTEK_SOFTAP 	= 9,/* peer is RealTek SOFT_AP, by Bohn, 2009.12.17 */
	HT_IOT_PEER_SELF_SOFTAP 		= 10, /* Self is SoftAP */
	HT_IOT_PEER_AIRGO				= 11,
	HT_IOT_PEER_INTEL				= 12,
	HT_IOT_PEER_RTK_APCLIENT		= 13,
	HT_IOT_PEER_REALTEK_81XX		= 14,
	HT_IOT_PEER_REALTEK_WOW		= 15,
	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
	HT_IOT_PEER_MAX				= 18
} HT_IOT_PEER_E, *PHTIOT_PEER_E;


typedef enum _RT_HT_INF0_CAP {
	RT_HT_CAP_USE_TURBO_AGGR = 0x01,
	RT_HT_CAP_USE_LONG_PREAMBLE = 0x02,
	RT_HT_CAP_USE_AMPDU = 0x04,
	RT_HT_CAP_USE_WOW = 0x8,
	RT_HT_CAP_USE_SOFTAP = 0x10,
	RT_HT_CAP_USE_92SE = 0x20,
	RT_HT_CAP_USE_88C_92C = 0x40,
	RT_HT_CAP_USE_AP_CLIENT_MODE = 0x80,	/* AP team request to reserve this bit, by Emily */
} RT_HT_INF0_CAPBILITY, *PRT_HT_INF0_CAPBILITY;

typedef enum _RT_HT_INF1_CAP {
	RT_HT_CAP_USE_VIDEO_CLIENT = 0x01,
	RT_HT_CAP_USE_JAGUAR_BCUT = 0x02,
	RT_HT_CAP_USE_JAGUAR_CCUT = 0x04,
} RT_HT_INF1_CAPBILITY, *PRT_HT_INF1_CAPBILITY;

struct mlme_handler {
	unsigned int   num;
	char *str;
	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
};

struct action_handler {
	unsigned int   num;
	char *str;
	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
};

enum SCAN_STATE {
	SCAN_DISABLE = 0,
	SCAN_START = 1,
	SCAN_PS_ANNC_WAIT = 2,
	SCAN_ENTER = 3,
	SCAN_PROCESS = 4,

	/* backop */
	SCAN_BACKING_OP = 5,
	SCAN_BACK_OP = 6,
	SCAN_LEAVING_OP = 7,
	SCAN_LEAVE_OP = 8,

	/* SW antenna diversity (before linked) */
	SCAN_SW_ANTDIV_BL = 9,

	/* legacy p2p */
	SCAN_TO_P2P_LISTEN = 10,
	SCAN_P2P_LISTEN = 11,

	SCAN_COMPLETE = 12,
	SCAN_STATE_MAX,
};

const char *scan_state_str(u8 state);

enum ss_backop_flag {
	SS_BACKOP_EN = BIT0, /* backop when linked */
	SS_BACKOP_EN_NL = BIT1, /* backop even when no linked */

	SS_BACKOP_PS_ANNC = BIT4,
	SS_BACKOP_TX_RESUME = BIT5,
};

struct ss_res {
	u8 state;
	u8 next_state; /* will set to state on next cmd hdl */
	int	bss_cnt;
	int	channel_idx;
	u8 force_ssid_scan;
	int	scan_mode;
	u16 scan_ch_ms;
	u32 scan_timeout_ms;
	u8 rx_ampdu_accept;
	u8 rx_ampdu_size;
	u8 igi_scan;
	u8 igi_before_scan; /* used for restoring IGI value without enable DIG & FA_CNT */
#ifdef CONFIG_SCAN_BACKOP
	u8 backop_flags_sta; /* policy for station mode*/
	#ifdef CONFIG_AP_MODE
	u8 backop_flags_ap; /* policy for ap mode */
	#endif
	#ifdef CONFIG_RTW_MESH
	u8 backop_flags_mesh; /* policy for mesh mode */
	#endif
	u8 backop_flags; /* per backop runtime decision */
	u8 scan_cnt;
	u8 scan_cnt_max;
	systime backop_time; /* the start time of backop */
	u16 backop_ms;
#endif
#if defined(CONFIG_ANTENNA_DIVERSITY) || defined(DBG_SCAN_SW_ANTDIV_BL)
	u8 is_sw_antdiv_bl_scan;
#endif
	u8 ssid_num;
	u8 ch_num;
	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];

	u32 token; 	/* 0: use to identify caller */
	u16 duration;	/* 0: use default */
	u8 igi;		/* 0: use defalut */
	u8 bw;		/* 0: use default */

	bool acs; /* aim to trigger channel selection when scan done */
};

/* #define AP_MODE				0x0C */
/* #define STATION_MODE	0x08 */
/* #define AD_HOC_MODE		0x04 */
/* #define NO_LINK_MODE	0x00 */

#define	WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
#define	WIFI_FW_AP_STATE				_HW_STATE_AP_
#define	WIFI_FW_ADHOC_STATE			_HW_STATE_ADHOC_

#define WIFI_FW_PRE_LINK			0x00000800
#define	WIFI_FW_AUTH_NULL			0x00000100
#define	WIFI_FW_AUTH_STATE			0x00000200
#define	WIFI_FW_AUTH_SUCCESS			0x00000400

#define	WIFI_FW_ASSOC_STATE			0x00002000
#define	WIFI_FW_ASSOC_SUCCESS		0x00004000

#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)

#ifdef CONFIG_TDLS
enum TDLS_option {
	TDLS_ESTABLISHED = 1,
	TDLS_ISSUE_PTI,
	TDLS_CH_SW_RESP,
	TDLS_CH_SW_PREPARE,
	TDLS_CH_SW_START,
	TDLS_CH_SW_TO_OFF_CHNL,
	TDLS_CH_SW_TO_BASE_CHNL_UNSOLICITED,
	TDLS_CH_SW_TO_BASE_CHNL,
	TDLS_CH_SW_END_TO_BASE_CHNL,
	TDLS_CH_SW_END,
	TDLS_RS_RCR,
	TDLS_TEARDOWN_STA,
	TDLS_TEARDOWN_STA_NO_WAIT,
	TDLS_TEARDOWN_STA_LOCALLY,
	TDLS_TEARDOWN_STA_LOCALLY_POST,
	maxTDLS,
};

#endif /* CONFIG_TDLS */

#if (KERNEL_VERSION(3, 8, 0) > LINUX_VERSION_CODE)
#define NL80211_AUTHTYPE_SAE (__NL80211_AUTHTYPE_NUM + 1)
#endif

/*
 * Usage:
 * When one iface acted as AP mode and the other iface is STA mode and scanning,
 * it should switch back to AP's operating channel periodically.
 * Parameters info:
 * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
 * RTW_BACK_OP_CH_MS milliseconds.
 * Example:
 * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
 * RTW_SCAN_NUM_OF_CH is 8, RTW_BACK_OP_CH_MS is 300
 * When it's STA mode gets set_scan command,
 * it would
 * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
 * 2. Back to channel 1 for 300 milliseconds
 * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
 * 4. Back to channel 1 for 300 milliseconds
 * 5. ... and so on, till survey done.
 */
#if defined(CONFIG_ATMEL_RC_PATCH)
	#define RTW_SCAN_NUM_OF_CH 2
	#define RTW_BACK_OP_CH_MS 200
#else
	#define RTW_SCAN_NUM_OF_CH 3
	#define RTW_BACK_OP_CH_MS 400
#endif

#define RTW_IP_ADDR_LEN 4
#define RTW_IPv6_ADDR_LEN 16

struct mlme_ext_info {
	u32	state;
#ifdef CONFIG_MI_WITH_MBSSID_CAM
	u8	hw_media_state;
#endif
	u32	reauth_count;
	u32	reassoc_count;
	u32	link_count;
	u32	auth_seq;
	u32	auth_algo;	/* 802.11 auth, could be open, shared, auto */
	u16 auth_status;
	u32	authModeToggle;
	u32	enc_algo;/* encrypt algorithm; */
	u32	key_index;	/* this is only valid for legendary wep, 0~3 for key id. */
	u32	iv;
	u8	chg_txt[128];
	u16	aid;
	u16	bcn_interval;
	u16	capability;
	u8	assoc_AP_vendor;
	u8	slotTime;
	u8	preamble_mode;
	u8	WMM_enable;
	u8	ERP_enable;
	u8	ERP_IE;
	u8	HT_enable;
	u8	HT_caps_enable;
	u8	HT_info_enable;
	u8	HT_protection;
	u8	turboMode_cts2self;
	u8	turboMode_rtsen;
	u8	SM_PS;
	u8	agg_enable_bitmap;
	u8	ADDBA_retry_count;
	u8	candidate_tid_bitmap;
	u8	dialogToken;
	/* Accept ADDBA Request */
	BOOLEAN bAcceptAddbaReq;
	u8	bwmode_updated;
	u8	hidden_ssid_mode;
	u8	VHT_enable;

	u8 ip_addr[RTW_IP_ADDR_LEN];
	u8 ip6_addr[RTW_IPv6_ADDR_LEN];

	struct ADDBA_request		ADDBA_req;
	struct WMM_para_element	WMM_param;
	struct HT_caps_element	HT_caps;
	struct HT_info_element		HT_info;
	WLAN_BSSID_EX			network;/* join network or bss_network, if in ap mode, it is the same to cur_network.network */
#ifdef ROKU_PRIVATE
	/*infra mode, store supported rates from AssocRsp*/
	NDIS_802_11_RATES_EX	SupportedRates_infra_ap;
	u8 ht_vht_received;/*ht_vht_received used to show debug msg BIT(0):HT BIT(1):VHT */
#endif /* ROKU_PRIVATE */
};

/* The channel information about this channel including joining, scanning, and power constraints. */
typedef struct _RT_CHANNEL_INFO {
	u8				ChannelNum;		/* The channel number. */
	RT_SCAN_TYPE	ScanType;		/* Scan type such as passive or active scan. */
	bool dfs;
	/* u16				ScanPeriod;		 */ /* Listen time in millisecond in this channel. */
	/* s32				MaxTxPwrDbm;	 */ /* Max allowed tx power. */
	/* u32				ExInfo;			 */ /* Extended Information for this channel. */
#ifdef CONFIG_FIND_BEST_CHANNEL
	u32				rx_count;
#endif
#if CONFIG_IEEE80211_BAND_5GHZ && CONFIG_DFS
	#ifdef CONFIG_DFS_MASTER
	systime non_ocp_end_time;
	#endif
#endif
	u8 hidden_bss_cnt; /* per scan count */
} RT_CHANNEL_INFO, *PRT_CHANNEL_INFO;

#define CAC_TIME_MS (60*1000)
#define CAC_TIME_CE_MS (10*60*1000)
#define NON_OCP_TIME_MS (30*60*1000)

#if CONFIG_TXPWR_LIMIT
void rtw_txpwr_init_regd(struct rf_ctl_t *rfctl);
#endif
void rtw_rfctl_init(_adapter *adapter);
void rtw_rfctl_deinit(_adapter *adapter);

u8 rtw_rfctl_get_dfs_domain(struct rf_ctl_t *rfctl);
u8 rtw_rfctl_dfs_domain_unknown(struct rf_ctl_t *rfctl);

#ifdef CONFIG_DFS_MASTER
struct rf_ctl_t;
#define CH_IS_NON_OCP(rt_ch_info) (rtw_time_after((rt_ch_info)->non_ocp_end_time, rtw_get_current_time()))
bool rtw_is_cac_reset_needed(struct rf_ctl_t *rfctl, u8 ch, u8 bw, u8 offset);
bool _rtw_rfctl_overlap_radar_detect_ch(struct rf_ctl_t *rfctl, u8 ch, u8 bw, u8 offset);
bool rtw_rfctl_overlap_radar_detect_ch(struct rf_ctl_t *rfctl);
bool rtw_rfctl_is_tx_blocked_by_ch_waiting(struct rf_ctl_t *rfctl);
bool rtw_chset_is_chbw_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
bool rtw_chset_is_ch_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch);
void rtw_chset_update_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
void rtw_chset_update_non_ocp_ms(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset, int ms);
u32 rtw_get_ch_waiting_ms(struct rf_ctl_t *rfctl, u8 ch, u8 bw, u8 offset, u32 *r_non_ocp_ms, u32 *r_cac_ms);
void rtw_reset_cac(struct rf_ctl_t *rfctl, u8 ch, u8 bw, u8 offset);
u32 rtw_force_stop_cac(struct rf_ctl_t *rfctl, u32 timeout_ms);
#else
#define CH_IS_NON_OCP(rt_ch_info) 0
#define rtw_chset_is_chbw_non_ocp(ch_set, ch, bw, offset) _FALSE
#define rtw_chset_is_ch_non_ocp(ch_set, ch) _FALSE
#define rtw_rfctl_is_tx_blocked_by_ch_waiting(rfctl) _FALSE
#endif

enum {
	RTW_CHF_2G = BIT0,
	RTW_CHF_5G = BIT1,
	RTW_CHF_DFS = BIT2,
	RTW_CHF_LONG_CAC = BIT3,
	RTW_CHF_NON_DFS = BIT4,
	RTW_CHF_NON_LONG_CAC = BIT5,
	RTW_CHF_NON_OCP = BIT6,
};

bool rtw_choose_shortest_waiting_ch(struct rf_ctl_t *rfctl, u8 sel_ch, u8 max_bw
	, u8 *dec_ch, u8 *dec_bw, u8 *dec_offset
	, u8 d_flags, u8 cur_ch, bool by_int_info, u8 mesh_only);

void dump_chset(void *sel, RT_CHANNEL_INFO *ch_set);
void dump_cur_chset(void *sel, struct rf_ctl_t *rfctl);

int rtw_chset_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch);
u8 rtw_chset_is_chbw_valid(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset
	, bool allow_primary_passive, bool allow_passive);
void rtw_chset_sync_chbw(RT_CHANNEL_INFO *ch_set, u8 *req_ch, u8 *req_bw, u8 *req_offset
	, u8 *g_ch, u8 *g_bw, u8 *g_offset, bool allow_primary_passive, bool allow_passive);

bool rtw_mlme_band_check(_adapter *adapter, const u32 ch);


enum {
	BAND_24G = BIT0,
	BAND_5G = BIT1,
};
void RTW_SET_SCAN_BAND_SKIP(_adapter *padapter, int skip_band);
void RTW_CLR_SCAN_BAND_SKIP(_adapter *padapter, int skip_band);
int RTW_GET_SCAN_BAND_SKIP(_adapter *padapter);

bool rtw_mlme_ignore_chan(_adapter *adapter, const u32 ch);

/* P2P_MAX_REG_CLASSES - Maximum number of regulatory classes */
#define P2P_MAX_REG_CLASSES 10

/* P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class */
#define P2P_MAX_REG_CLASS_CHANNELS 20

/* struct p2p_channels - List of supported channels */
struct p2p_channels {
	/* struct p2p_reg_class - Supported regulatory class */
	struct p2p_reg_class {
		/* reg_class - Regulatory class (IEEE 802.11-2007, Annex J) */
		u8 reg_class;

		/* channel - Supported channels */
		u8 channel[P2P_MAX_REG_CLASS_CHANNELS];

		/* channels - Number of channel entries in use */
		size_t channels;
	} reg_class[P2P_MAX_REG_CLASSES];

	/* reg_classes - Number of reg_class entries in use */
	size_t reg_classes;
};

struct p2p_oper_class_map {
	enum hw_mode {IEEE80211G, IEEE80211A} mode;
	u8 op_class;
	u8 min_chan;
	u8 max_chan;
	u8 inc;
	enum { BW20, BW40PLUS, BW40MINUS } bw;
};

struct mlme_ext_priv {
	_adapter	*padapter;
	u8	mlmeext_init;
	ATOMIC_T		event_seq;
	u16	mgnt_seq;
#ifdef CONFIG_IEEE80211W
	u16	sa_query_seq;
#endif
	/* struct fw_priv 	fwpriv; */

	unsigned char	cur_channel;
	unsigned char	cur_bwmode;
	unsigned char	cur_ch_offset;/* PRIME_CHNL_OFFSET */
	unsigned char	cur_wireless_mode;	/* NETWORK_TYPE */

	unsigned char	basicrate[NumRates];
	unsigned char	datarate[NumRates];
#ifdef CONFIG_80211N_HT
	unsigned char default_supported_mcs_set[16];
#endif

	struct ss_res		sitesurvey_res;
	struct mlme_ext_info	mlmext_info;/* for sta/adhoc mode, including current scanning/connecting/connected related info.
                                                      * for ap mode, network includes ap's cap_info */
	_timer		survey_timer;
	_timer		link_timer;

#ifdef CONFIG_RTW_REPEATER_SON
	_timer		rson_scan_timer;
#endif
#ifdef CONFIG_RTW_80211R
	_timer		ft_link_timer;
	_timer		ft_roam_timer;
#endif

	systime last_scan_time;
	u8	scan_abort;
	u8 join_abort;
	u8	tx_rate; /* TXRATE when USERATE is set. */

	u32	retry; /* retry for issue probereq */

	/* Don't handle deauth in DEAUTH_DENY_TO ms after sending deauth */
	/* value 0 means always handle deauth packet */
	systime last_deauth_time;

	u64 TSFValue;
	u32 bcn_cnt;
	u32 last_bcn_cnt;
	u8 cur_bcn_cnt;/*2s*/
	u8 dtim;/*DTIM Period*/
#ifdef DBG_RX_BCN
	u8 tim[4];
#endif
#ifdef CONFIG_BCN_RECV_TIME
	u16 bcn_rx_time;
#endif
#ifdef CONFIG_AP_MODE
	unsigned char bstart_bss;
#endif

#ifdef CONFIG_80211D
	u8 update_channel_plan_by_ap_done;
#endif
	/* recv_decache check for Action_public frame */
	u8 action_public_dialog_token;
	u16	 action_public_rxseq;

	/* #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK */
	u8 active_keep_alive_check;
	/* #endif */
#ifdef DBG_FIXED_CHAN
	u8 fixed_chan;
#endif

	u8 tsf_update_required:1;
	u8 en_hw_update_tsf:1; /* set hw sync bcn tsf register or not */
	systime tsf_update_pause_stime;
	u8 tsf_update_pause_factor; /* num of bcn intervals to stay TSF update pause status */
	u8 tsf_update_restore_factor; /* num of bcn interval to stay TSF update restore status */
#ifdef CONFIG_SUPPORT_STATIC_SMPS
	u8 ssmps_en;
	u16 ssmps_tx_tp_th;/*Mbps*/
	u16 ssmps_rx_tp_th;/*Mbps*/
	#ifdef DBG_STATIC_SMPS
	u8 ssmps_test;
	u8 ssmps_test_en;
	#endif
#endif
#ifdef CONFIG_CTRL_TXSS_BY_TP
	u8 txss_ctrl_en;
	u16 txss_tp_th;/*Mbps*/
	u8 txss_tp_chk_cnt;/*unit 2s*/
	bool txss_1ss;
	u8 txss_momi_type_bk;
#endif
};

struct support_rate_handler {
	u8 rate;
	bool basic;
	bool existence;
};

static inline u8 check_mlmeinfo_state(struct mlme_ext_priv *plmeext, sint state)
{
	if ((plmeext->mlmext_info.state & 0x03) == state)
		return _TRUE;

	return _FALSE;
}

void sitesurvey_set_offch_state(_adapter *adapter, u8 scan_state);

#define mlmeext_msr(mlmeext) ((mlmeext)->mlmext_info.state & 0x03)
#define mlmeext_scan_state(mlmeext) ((mlmeext)->sitesurvey_res.state)
#define mlmeext_scan_state_str(mlmeext) scan_state_str((mlmeext)->sitesurvey_res.state)
#define mlmeext_chk_scan_state(mlmeext, _state) ((mlmeext)->sitesurvey_res.state == (_state))
#define mlmeext_set_scan_state(mlmeext, _state) \
	do { \
		((mlmeext)->sitesurvey_res.state = (_state)); \
		((mlmeext)->sitesurvey_res.next_state = (_state)); \
		rtw_mi_update_iface_status(&((container_of(mlmeext, _adapter, mlmeextpriv)->mlmepriv)), 0); \
		/* RTW_INFO("set_scan_state:%s\n", scan_state_str(_state)); */ \
		sitesurvey_set_offch_state(container_of(mlmeext, _adapter, mlmeextpriv), _state); \
	} while (0)

#define mlmeext_scan_next_state(mlmeext) ((mlmeext)->sitesurvey_res.next_state)
#define mlmeext_set_scan_next_state(mlmeext, _state) \
	do { \
		((mlmeext)->sitesurvey_res.next_state = (_state)); \
		/* RTW_INFO("set_scan_next_state:%s\n", scan_state_str(_state)); */ \
	} while (0)

#ifdef CONFIG_SCAN_BACKOP
#define mlmeext_scan_backop_flags(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags)
#define mlmeext_chk_scan_backop_flags(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags & (flags))
#define mlmeext_assign_scan_backop_flags(mlmeext, flags) \
	do { \
		((mlmeext)->sitesurvey_res.backop_flags = (flags)); \
		RTW_INFO("assign_scan_backop_flags:0x%02x\n", (mlmeext)->sitesurvey_res.backop_flags); \
	} while (0)

#define mlmeext_scan_backop_flags_sta(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_sta)
#define mlmeext_chk_scan_backop_flags_sta(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_sta & (flags))
#define mlmeext_assign_scan_backop_flags_sta(mlmeext, flags) \
	do { \
		((mlmeext)->sitesurvey_res.backop_flags_sta = (flags)); \
	} while (0)
#else
#define mlmeext_scan_backop_flags(mlmeext) (0)
#define mlmeext_chk_scan_backop_flags(mlmeext, flags) (0)
#define mlmeext_assign_scan_backop_flags(mlmeext, flags) do {} while (0)

#define mlmeext_scan_backop_flags_sta(mlmeext) (0)
#define mlmeext_chk_scan_backop_flags_sta(mlmeext, flags) (0)
#define mlmeext_assign_scan_backop_flags_sta(mlmeext, flags) do {} while (0)
#endif /* CONFIG_SCAN_BACKOP */

#if defined(CONFIG_SCAN_BACKOP) && defined(CONFIG_AP_MODE)
#define mlmeext_scan_backop_flags_ap(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_ap)
#define mlmeext_chk_scan_backop_flags_ap(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_ap & (flags))
#define mlmeext_assign_scan_backop_flags_ap(mlmeext, flags) \
	do { \
		((mlmeext)->sitesurvey_res.backop_flags_ap = (flags)); \
	} while (0)
#else
#define mlmeext_scan_backop_flags_ap(mlmeext) (0)
#define mlmeext_chk_scan_backop_flags_ap(mlmeext, flags) (0)
#define mlmeext_assign_scan_backop_flags_ap(mlmeext, flags) do {} while (0)
#endif /* defined(CONFIG_SCAN_BACKOP) && defined(CONFIG_AP_MODE) */

#if defined(CONFIG_SCAN_BACKOP) && defined(CONFIG_RTW_MESH)
#define mlmeext_scan_backop_flags_mesh(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_mesh)
#define mlmeext_chk_scan_backop_flags_mesh(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_mesh & (flags))
#define mlmeext_assign_scan_backop_flags_mesh(mlmeext, flags) \
	do { \
		((mlmeext)->sitesurvey_res.backop_flags_mesh = (flags)); \
	} while (0)
#else
#define mlmeext_scan_backop_flags_mesh(mlmeext) (0)
#define mlmeext_chk_scan_backop_flags_mesh(mlmeext, flags) (0)
#define mlmeext_assign_scan_backop_flags_mesh(mlmeext, flags) do {} while (0)
#endif /* defined(CONFIG_SCAN_BACKOP) && defined(CONFIG_RTW_MESH) */

u32 rtw_scan_timeout_decision(_adapter *padapter);

void init_mlme_default_rate_set(_adapter *padapter);
int init_mlme_ext_priv(_adapter *padapter);
int init_hw_mlme_ext(_adapter *padapter);
void free_mlme_ext_priv(struct mlme_ext_priv *pmlmeext);
extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv);

/* void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv); */
u8 judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen);
void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
void set_mcs_rate_by_mask(u8 *mcs_set, u32 mask);
void UpdateBrateTbl(_adapter *padapter, u8 *mBratesOS);
void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen);
void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 ch);

void Set_MSR(_adapter *padapter, u8 type);

void rtw_set_external_auth_status(_adapter *padapter, const void *data, int len);

u8 rtw_get_oper_ch(_adapter *adapter);
void rtw_set_oper_ch(_adapter *adapter, u8 ch);
u8 rtw_get_oper_bw(_adapter *adapter);
void rtw_set_oper_bw(_adapter *adapter, u8 bw);
u8 rtw_get_oper_choffset(_adapter *adapter);
void rtw_set_oper_choffset(_adapter *adapter, u8 offset);
u8	rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset);
systime rtw_get_on_oper_ch_time(_adapter *adapter);
systime rtw_get_on_cur_ch_time(_adapter *adapter);

u8 rtw_get_offset_by_chbw(u8 ch, u8 bw, u8 *r_offset);

void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);

unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);

void _clear_cam_entry(_adapter *padapter, u8 entry);
void write_cam_from_cache(_adapter *adapter, u8 id);
void rtw_sec_cam_swap(_adapter *adapter, u8 cam_id_a, u8 cam_id_b);
void rtw_clean_dk_section(_adapter *adapter);
void rtw_clean_hw_dk_cam(_adapter *adapter);

/* modify both HW and cache */
void write_cam(_adapter *padapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
void clear_cam_entry(_adapter *padapter, u8 id);

/* modify cache only */
void write_cam_cache(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
void clear_cam_cache(_adapter *adapter, u8 id);

void invalidate_cam_all(_adapter *padapter);

void flush_all_cam_entry(_adapter *padapter);

BOOLEAN IsLegal5GChannel(PADAPTER Adapter, u8 channel);

void site_survey(_adapter *padapter, u8 survey_channel, RT_SCAN_TYPE ScanType);
u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, _adapter *padapter, bool update_ie);

u8 *get_my_bssid(WLAN_BSSID_EX *pnetwork);
u16 get_beacon_interval(WLAN_BSSID_EX *bss);

int is_client_associated_to_ap(_adapter *padapter);
int is_client_associated_to_ibss(_adapter *padapter);
int is_IBSS_empty(_adapter *padapter);

unsigned char check_assoc_AP(u8 *pframe, uint len);
void get_assoc_AP_Vendor(char *vendor, u8 assoc_AP_vendor);
#ifdef CONFIG_RTS_FULL_BW
void rtw_parse_sta_vendor_ie_8812(_adapter *adapter, struct sta_info *sta, u8 *tlv_ies, u16 tlv_ies_len);
#endif/*CONFIG_RTS_FULL_BW*/
#ifdef CONFIG_80211AC_VHT
void get_vht_bf_cap(u8 *pframe, uint len, struct vht_bf_cap *bf_cap);
#endif

int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE);
#ifdef CONFIG_WFD
void rtw_process_wfd_ie(_adapter *adapter, u8 *ie, u8 ie_len, const char *tag);
void rtw_process_wfd_ies(_adapter *adapter, u8 *ies, u8 ies_len, const char *tag);
#endif
void WMMOnAssocRsp(_adapter *padapter);

void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
#ifdef ROKU_PRIVATE
void HT_caps_handler_infra_ap(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
#endif
void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
void HTOnAssocRsp(_adapter *padapter);

#ifdef ROKU_PRIVATE
void Supported_rate_infra_ap(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
void Extended_Supported_rate_infra_ap(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
#endif

void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
void VCS_update(_adapter *padapter, struct sta_info *psta);
void	update_ldpc_stbc_cap(struct sta_info *psta);

bool rtw_validate_value(u16 EID, u8 *p, u16 len);
bool is_hidden_ssid(char *ssid, int len);
bool hidden_ssid_ap(WLAN_BSSID_EX *snetwork);
void rtw_absorb_ssid_ifneed(_adapter *padapter, WLAN_BSSID_EX *bssid, u8 *pframe);

int rtw_get_bcn_keys(_adapter *adapter, u8 *whdr, u32 flen, struct beacon_keys *bcn_keys);
int rtw_get_bcn_keys_from_bss(WLAN_BSSID_EX *bss, struct beacon_keys *bcn_keys);
int rtw_update_bcn_keys_of_network(struct wlan_network *network);

int validate_beacon_len(u8 *pframe, uint len);
void rtw_dump_bcn_keys(void *sel, struct beacon_keys *recv_beacon);
bool rtw_bcn_key_compare(struct beacon_keys *cur, struct beacon_keys *recv);
int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len);
void update_beacon_info(_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
#if CONFIG_DFS
void process_csa_ie(_adapter *padapter, u8 *ies, uint ies_len);
#endif
void update_capinfo(PADAPTER Adapter, u16 updateCap);
void update_wireless_mode(_adapter *padapter);
void update_tx_basic_rate(_adapter *padapter, u8 modulation);
void update_sta_basic_rate(struct sta_info *psta, u8 wireless_mode);
int rtw_ies_get_supported_rate(u8 *ies, uint ies_len, u8 *rate_set, u8 *rate_num);

/* for sta/adhoc mode */
void update_sta_info(_adapter *padapter, struct sta_info *psta);
unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
void Update_RA_Entry(_adapter *padapter, struct sta_info *psta);
void set_sta_rate(_adapter *padapter, struct sta_info *psta);

unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr, unsigned short reason, u8 locally_generated);

unsigned char get_highest_rate_idx(u64 mask);
unsigned char get_lowest_rate_idx_ex(u64 mask, int start_bit);
#define get_lowest_rate_idx(mask) get_lowest_rate_idx_ex(mask, 0)

int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode);
unsigned int is_ap_in_tkip(_adapter *padapter);
unsigned int is_ap_in_wep(_adapter *padapter);
unsigned int should_forbid_n_rate(_adapter *padapter);

void parsing_eapol_packet(_adapter *padapter, u8 *key_payload, struct sta_info *psta, u8 trx_type);

bool _rtw_camctl_chk_cap(_adapter *adapter, u8 cap);
void _rtw_camctl_set_flags(_adapter *adapter, u32 flags);
void rtw_camctl_set_flags(_adapter *adapter, u32 flags);
void _rtw_camctl_clr_flags(_adapter *adapter, u32 flags);
void rtw_camctl_clr_flags(_adapter *adapter, u32 flags);
bool _rtw_camctl_chk_flags(_adapter *adapter, u32 flags);

struct sec_cam_bmp;
void dump_sec_cam_map(void *sel, struct sec_cam_bmp *map, u8 max_num);
void rtw_sec_cam_map_clr_all(struct sec_cam_bmp *map);

bool _rtw_camid_is_gk(_adapter *adapter, u8 cam_id);
bool rtw_camid_is_gk(_adapter *adapter, u8 cam_id);
s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid, s8 gk);
s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid, u8 gk, bool *used);
void rtw_camid_free(_adapter *adapter, u8 cam_id);
u8 rtw_get_sec_camid(_adapter *adapter, u8 max_bk_key_num, u8 *sec_key_id);

struct macid_bmp;
struct macid_ctl_t;
void dump_macid_map(void *sel, struct macid_bmp *map, u8 max_num);
bool rtw_macid_is_set(struct macid_bmp *map, u8 id);
void rtw_macid_map_clr(struct macid_bmp *map, u8 id);
bool rtw_macid_is_used(struct macid_ctl_t *macid_ctl, u8 id);
bool rtw_macid_is_bmc(struct macid_ctl_t *macid_ctl, u8 id);
u8 rtw_macid_get_iface_bmp(struct macid_ctl_t *macid_ctl, u8 id);
bool rtw_macid_is_iface_shared(struct macid_ctl_t *macid_ctl, u8 id);
bool rtw_macid_is_iface_specific(struct macid_ctl_t *macid_ctl, u8 id, _adapter *adapter);
s8 rtw_macid_get_ch_g(struct macid_ctl_t *macid_ctl, u8 id);
void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta);
void rtw_release_macid(_adapter *padapter, struct sta_info *psta);
u8 rtw_search_max_mac_id(_adapter *padapter);
u8 rtw_macid_ctl_set_h2c_msr(struct macid_ctl_t *macid_ctl, u8 id, u8 h2c_msr);
void rtw_macid_ctl_set_bw(struct macid_ctl_t *macid_ctl, u8 id, u8 bw);
void rtw_macid_ctl_set_vht_en(struct macid_ctl_t *macid_ctl, u8 id, u8 en);
void rtw_macid_ctl_set_rate_bmp0(struct macid_ctl_t *macid_ctl, u8 id, u32 bmp);
void rtw_macid_ctl_set_rate_bmp1(struct macid_ctl_t *macid_ctl, u8 id, u32 bmp);
#ifdef CONFIG_PROTSEL_MACSLEEP
void rtw_macid_ctl_init_sleep_reg(struct macid_ctl_t *macid_ctl, u16 reg_ctrl, u16 reg_info);
#else
void rtw_macid_ctl_init_sleep_reg(struct macid_ctl_t *macid_ctl, u16 m0, u16 m1, u16 m2, u16 m3);
#endif
void rtw_macid_ctl_init(struct macid_ctl_t *macid_ctl);
void rtw_macid_ctl_deinit(struct macid_ctl_t *macid_ctl);
u8 rtw_iface_bcmc_id_get(_adapter *padapter);
void rtw_iface_bcmc_id_set(_adapter *padapter, u8 mac_id);
#if defined(DBG_CONFIG_ERROR_RESET) && defined(CONFIG_CONCURRENT_MODE)
void rtw_iface_bcmc_sec_cam_map_restore(_adapter *adapter);
#endif
bool rtw_bmp_is_set(const u8 *bmp, u8 bmp_len, u8 id);
void rtw_bmp_set(u8 *bmp, u8 bmp_len, u8 id);
void rtw_bmp_clear(u8 *bmp, u8 bmp_len, u8 id);
bool rtw_bmp_not_empty(const u8 *bmp, u8 bmp_len);
bool rtw_bmp_not_empty_exclude_bit0(const u8 *bmp, u8 bmp_len);

#ifdef CONFIG_AP_MODE
bool rtw_tim_map_is_set(_adapter *padapter, const u8 *map, u8 id);
void rtw_tim_map_set(_adapter *padapter, u8 *map, u8 id);
void rtw_tim_map_clear(_adapter *padapter, u8 *map, u8 id);
bool rtw_tim_map_anyone_be_set(_adapter *padapter, const u8 *map);
bool rtw_tim_map_anyone_be_set_exclude_aid0(_adapter *padapter, const u8 *map);
#endif /* CONFIG_AP_MODE */

u32 report_join_res(_adapter *padapter, int aid_res, u16 status);
void report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
void report_surveydone_event(_adapter *padapter, bool acs);
u32 report_del_sta_event(_adapter *padapter, unsigned char *MacAddr, unsigned short reason, bool enqueue, u8 locally_generated);
void report_add_sta_event(_adapter *padapter, unsigned char *MacAddr);
bool rtw_port_switch_chk(_adapter *adapter);
void report_wmm_edca_update(_adapter *padapter);

void beacon_timing_control(_adapter *padapter);
u8 chk_bmc_sleepq_cmd(_adapter *padapter);
extern u8 set_tx_beacon_cmd(_adapter *padapter, u8 flags);
unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame);
void update_mgnt_tx_rate(_adapter *padapter, u8 rate);
void update_monitor_frame_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
void update_mgntframe_attrib_addr(_adapter *padapter, struct xmit_frame *pmgntframe);
void dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
s32 dump_mgntframe_and_wait(_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);
s32 dump_mgntframe_and_wait_ack(_adapter *padapter, struct xmit_frame *pmgntframe);
s32 dump_mgntframe_and_wait_ack_timeout(_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);

#ifdef CONFIG_P2P
int get_reg_classes_full_count(struct p2p_channels *channel_list);
void issue_probersp_p2p(_adapter *padapter, unsigned char *da);
void issue_p2p_provision_request(_adapter *padapter, u8 *pssid, u8 ussidlen, u8 *pdev_raddr);
void issue_p2p_GO_request(_adapter *padapter, u8 *raddr);
void issue_probereq_p2p(_adapter *padapter, u8 *da);
int issue_probereq_p2p_ex(_adapter *adapter, u8 *da, int try_cnt, int wait_ms);
void issue_p2p_invitation_response(_adapter *padapter, u8 *raddr, u8 dialogToken, u8 success);
void issue_p2p_invitation_request(_adapter *padapter, u8 *raddr);
#endif /* CONFIG_P2P */
void issue_beacon(_adapter *padapter, int timeout_ms);
void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
void _issue_assocreq(_adapter *padapter, u8 is_assoc);
void issue_assocreq(_adapter *padapter);
void issue_reassocreq(_adapter *padapter);
void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
void issue_probereq(_adapter *padapter, const NDIS_802_11_SSID *pssid, const u8 *da);
s32 issue_probereq_ex(_adapter *padapter, const NDIS_802_11_SSID *pssid, const u8 *da, u8 ch, bool append_wps, int try_cnt, int wait_ms);
int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, u8 ps, int try_cnt, int wait_ms);
int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset);
void issue_addba_req(_adapter *adapter, unsigned char *ra, u8 tid);
void issue_addba_rsp(_adapter *adapter, unsigned char *ra, u8 tid, u16 status, u8 size);
u8 issue_addba_rsp_wait_ack(_adapter *adapter, unsigned char *ra, u8 tid, u16 status, u8 size, int try_cnt, int wait_ms);
void issue_del_ba(_adapter *adapter, unsigned char *ra, u8 tid, u16 reason, u8 initiator);
int issue_del_ba_ex(_adapter *adapter, unsigned char *ra, u8 tid, u16 reason, u8 initiator, int try_cnt, int wait_ms);
void issue_action_BSSCoexistPacket(_adapter *padapter);

#ifdef CONFIG_IEEE80211W
void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid, u8 key_type);
int issue_deauth_11w(_adapter *padapter, unsigned char *da, unsigned short reason, u8 key_type);
#endif /* CONFIG_IEEE80211W */
int issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode);
int issue_action_SM_PS_wait_ack(_adapter *padapter, unsigned char *raddr, u8 NewMimoPsMode, int try_cnt, int wait_ms);

unsigned int send_delba_sta_tid(_adapter *adapter, u8 initiator, struct sta_info *sta, u8 tid, u8 force);
unsigned int send_delba_sta_tid_wait_ack(_adapter *adapter, u8 initiator, struct sta_info *sta, u8 tid, u8 force);

unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
unsigned int send_beacon(_adapter *padapter);

void start_clnt_assoc(_adapter *padapter);
void start_clnt_auth(_adapter *padapter);
void start_clnt_join(_adapter *padapter);
void start_create_ibss(_adapter *padapter);

unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame);
unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame);

unsigned int on_action_spct(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_qos(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_dls(_adapter *padapter, union recv_frame *precv_frame);
#ifdef CONFIG_RTW_WNM
unsigned int on_action_wnm(_adapter *adapter, union recv_frame *rframe);
#endif

#define RX_AMPDU_ACCEPT_INVALID 0xFF
#define RX_AMPDU_SIZE_INVALID 0xFF

enum rx_ampdu_reason {
	RX_AMPDU_DRV_FIXED = 1,
	RX_AMPDU_BTCOEX = 2, /* not used, because BTCOEX has its own variable management */
	RX_AMPDU_DRV_SCAN = 3,
};
u8 rtw_rx_ampdu_size(_adapter *adapter);
bool rtw_rx_ampdu_is_accept(_adapter *adapter);
bool rtw_rx_ampdu_set_size(_adapter *adapter, u8 size, u8 reason);
bool rtw_rx_ampdu_set_accept(_adapter *adapter, u8 accept, u8 reason);
u8 rx_ampdu_apply_sta_tid(_adapter *adapter, struct sta_info *sta, u8 tid, u8 accept, u8 size);
u8 rx_ampdu_size_sta_limit(_adapter *adapter, struct sta_info *sta);
u8 rx_ampdu_apply_sta(_adapter *adapter, struct sta_info *sta, u8 accept, u8 size);
u16 rtw_rx_ampdu_apply(_adapter *adapter);

unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame);
unsigned int on_action_public(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_ft(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame);
#ifdef CONFIG_IEEE80211W
unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame);
#endif /* CONFIG_IEEE80211W */
unsigned int on_action_rm(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_wmm(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_vht(_adapter *padapter, union recv_frame *precv_frame);
unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame);

#ifdef CONFIG_RTW_80211R
void rtw_ft_update_bcn(_adapter *padapter, union recv_frame *precv_frame);
void rtw_ft_start_clnt_join(_adapter *padapter);
u8 rtw_ft_update_rsnie(_adapter *padapter, u8 bwrite, 
	struct pkt_attrib *pattrib, u8 **pframe);
void rtw_ft_build_auth_req_ies(_adapter *padapter, 
	struct pkt_attrib *pattrib, u8 **pframe);
void rtw_ft_build_assoc_req_ies(_adapter *padapter, 
	u8 is_reassoc, struct pkt_attrib *pattrib, u8 **pframe);
u8 rtw_ft_update_auth_rsp_ies(_adapter *padapter, u8 *pframe, u32 len);
void rtw_ft_start_roam(_adapter *padapter, u8 *pTargetAddr);
void rtw_ft_issue_action_req(_adapter *padapter, u8 *pTargetAddr);
void rtw_ft_report_evt(_adapter *padapter);
void rtw_ft_report_reassoc_evt(_adapter *padapter, u8 *pMacAddr);
void rtw_ft_link_timer_hdl(void *ctx);
void rtw_ft_roam_timer_hdl(void *ctx);
void rtw_ft_roam_status_reset(_adapter *padapter);
#endif
#ifdef CONFIG_RTW_WNM
void rtw_wnm_roam_scan_hdl(void *ctx);
void rtw_wnm_process_btm_req(_adapter *padapter,  u8* pframe, u32 frame_len);
void rtw_wnm_reset_btm_candidate(struct roam_nb_info *pnb);
void rtw_wnm_reset_btm_state(_adapter *padapter);
void rtw_wnm_issue_action(_adapter *padapter, u8 action, u8 reason);
#endif
#if defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K)
u32 rtw_wnm_btm_candidates_survey(_adapter *padapter, u8* pframe, u32 elem_len, u8 is_preference);
#endif
void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res);
void mlmeext_sta_del_event_callback(_adapter *padapter);
void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta);

int rtw_get_rx_chk_limit(_adapter *adapter);
void rtw_set_rx_chk_limit(_adapter *adapter, int limit);
void linked_status_chk(_adapter *padapter, u8 from_timer);

#define rtw_get_bcn_cnt(adapter)	(adapter->mlmeextpriv.cur_bcn_cnt)
#define rtw_get_bcn_dtim_period(adapter)	(adapter->mlmeextpriv.dtim)
void rtw_collect_bcn_info(_adapter *adapter);

void _linked_info_dump(_adapter *padapter);

void survey_timer_hdl(void *ctx);
#ifdef CONFIG_RTW_REPEATER_SON
void rson_timer_hdl(void *ctx);
#endif
void link_timer_hdl(void *ctx);
void addba_timer_hdl(void *ctx);
#ifdef CONFIG_IEEE80211W
void sa_query_timer_hdl(void *ctx);
#endif /* CONFIG_IEEE80211W */
#if 0
void reauth_timer_hdl(_adapter *padapter);
void reassoc_timer_hdl(_adapter *padapter);
#endif

#define set_survey_timer(mlmeext, ms) \
	do { \
		/*RTW_INFO("%s set_survey_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
		_set_timer(&(mlmeext)->survey_timer, (ms)); \
	} while (0)

#define set_link_timer(mlmeext, ms) \
	do { \
		/*RTW_INFO("%s set_link_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
		_set_timer(&(mlmeext)->link_timer, (ms)); \
	} while (0)

bool rtw_is_cck_rate(u8 rate);
bool rtw_is_ofdm_rate(u8 rate);
bool rtw_is_basic_rate_cck(u8 rate);
bool rtw_is_basic_rate_ofdm(u8 rate);
bool rtw_is_basic_rate_mix(u8 rate);

extern int cckrates_included(unsigned char *rate, int ratelen);
extern int cckratesonly_included(unsigned char *rate, int ratelen);

extern void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr);

extern void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
extern void correct_TSF(_adapter *padapter, u8 mlme_state);
#ifdef CONFIG_BCN_RECV_TIME
void rtw_rx_bcn_time_update(_adapter *adapter, uint bcn_len, u8 data_rate);
#endif
extern u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer);

void rtw_process_bar_frame(_adapter *padapter, union recv_frame *precv_frame);
void rtw_join_done_chk_ch(_adapter *padapter, int join_res);

int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset);

#ifdef CONFIG_PLATFORM_ARM_SUN8I
	#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	8000
#else
	#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	12000
#endif

struct cmd_hdl {
	uint	parmsize;
	u8(*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);
};

void rtw_leave_opch(_adapter *adapter);
void rtw_back_opch(_adapter *adapter);

u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf);
u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf);
u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf);
u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf);
u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf);
u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf);


u8 NULL_hdl(_adapter *padapter, u8 *pbuf);
u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf);
u8 disconnect_hdl(_adapter *padapter, u8 *pbuf);
u8 createbss_hdl(_adapter *padapter, u8 *pbuf);
#ifdef CONFIG_AP_MODE
u8 stop_ap_hdl(_adapter *adapter);
#endif
u8 setopmode_hdl(_adapter *padapter, u8 *pbuf);
u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf);
u8 setauth_hdl(_adapter *padapter, u8 *pbuf);
u8 setkey_hdl(_adapter *padapter, u8 *pbuf);
u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf);
u8 set_assocsta_hdl(_adapter *padapter, u8 *pbuf);
u8 del_assocsta_hdl(_adapter *padapter, u8 *pbuf);
u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf);
u8 add_ba_rsp_hdl(_adapter *padapter, unsigned char *pbuf);

void rtw_ap_wep_pk_setting(_adapter *adapter, struct sta_info *psta);

u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf);
u8 h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf);
u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf);
u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf);
u8 rtw_set_chbw_hdl(_adapter *padapter, u8 *pbuf);
u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf);
u8 led_blink_hdl(_adapter *padapter, unsigned char *pbuf);
u8 set_csa_hdl(_adapter *padapter, unsigned char *pbuf);	/* Kurt: Handling DFS channel switch announcement ie. */
u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf);
u8 run_in_thread_hdl(_adapter *padapter, u8 *pbuf);
u8 rtw_getmacreg_hdl(_adapter *padapter, u8 *pbuf);

int rtw_sae_preprocess(_adapter *adapter, const u8 *buf, u32 len, u8 tx);

#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, cmd},

#ifdef _RTW_CMD_C_

struct cmd_hdl wlancmds[] = {
	GEN_DRV_CMD_HANDLER(sizeof(struct readMAC_parm), rtw_getmacreg) /*0*/
	GEN_DRV_CMD_HANDLER(0, NULL)
	GEN_DRV_CMD_HANDLER(0, NULL)
	GEN_DRV_CMD_HANDLER(0, NULL)
	GEN_DRV_CMD_HANDLER(0, NULL)
	GEN_DRV_CMD_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL) /*10*/
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct joinbss_parm), join_cmd_hdl)  /*14*/
	GEN_MLME_EXT_HANDLER(sizeof(struct disconnect_parm), disconnect_hdl)
	GEN_MLME_EXT_HANDLER(sizeof(struct createbss_parm), createbss_hdl)
	GEN_MLME_EXT_HANDLER(sizeof(struct setopmode_parm), setopmode_hdl)
	GEN_MLME_EXT_HANDLER(sizeof(struct sitesurvey_parm), sitesurvey_cmd_hdl)  /*18*/
	GEN_MLME_EXT_HANDLER(sizeof(struct setauth_parm), setauth_hdl)
	GEN_MLME_EXT_HANDLER(sizeof(struct setkey_parm), setkey_hdl)  /*20*/
	GEN_MLME_EXT_HANDLER(sizeof(struct set_stakey_parm), set_stakey_hdl)
	GEN_MLME_EXT_HANDLER(sizeof(struct set_assocsta_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct del_assocsta_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct setstapwrstate_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct setbasicrate_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct getbasicrate_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct setdatarate_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct getdatarate_parm), NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)   /*30*/
	GEN_MLME_EXT_HANDLER(sizeof(struct setphy_parm), NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct getphy_parm), NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)	/*40*/
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)
	GEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), rtw_set_chbw_hdl) /* 46 */
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL) /*50*/
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(0, NULL)
	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl) /*55*/

	GEN_MLME_EXT_HANDLER(0, mlme_evt_hdl) /*56*/
	GEN_MLME_EXT_HANDLER(0, rtw_drvextra_cmd_hdl) /*57*/

	GEN_MLME_EXT_HANDLER(0, h2c_msg_hdl) /*58*/
	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelPlan_param), set_chplan_hdl) /*59*/
	GEN_MLME_EXT_HANDLER(sizeof(struct LedBlink_param), led_blink_hdl) /*60*/

	GEN_MLME_EXT_HANDLER(0, set_csa_hdl) /*61*/
	GEN_MLME_EXT_HANDLER(sizeof(struct TDLSoption_param), tdls_hdl) /*62*/
	GEN_MLME_EXT_HANDLER(0, chk_bmc_sleepq_hdl) /*63*/
	GEN_MLME_EXT_HANDLER(sizeof(struct RunInThread_param), run_in_thread_hdl) /*64*/
	GEN_MLME_EXT_HANDLER(sizeof(struct addBaRsp_parm), add_ba_rsp_hdl) /* 65 */
	GEN_MLME_EXT_HANDLER(sizeof(struct rm_event), rm_post_event_hdl) /* 66 */
};

#endif

struct C2HEvent_Header {

#ifdef CONFIG_LITTLE_ENDIAN

	unsigned int len:16;
	unsigned int ID:8;
	unsigned int seq:8;

#elif defined(CONFIG_BIG_ENDIAN)

	unsigned int seq:8;
	unsigned int ID:8;
	unsigned int len:16;

#else

#  error "Must be LITTLE or BIG Endian"

#endif

	unsigned int rsvd;

};

void rtw_dummy_event_callback(_adapter *adapter , u8 *pbuf);
void rtw_fwdbg_event_callback(_adapter *adapter , u8 *pbuf);

enum rtw_c2h_event {
	GEN_EVT_CODE(_Read_MACREG) = 0, /*0*/
	GEN_EVT_CODE(_Read_BBREG),
	GEN_EVT_CODE(_Read_RFREG),
	GEN_EVT_CODE(_Read_EEPROM),
	GEN_EVT_CODE(_Read_EFUSE),
	GEN_EVT_CODE(_Read_CAM),			/*5*/
	GEN_EVT_CODE(_Get_BasicRate),
	GEN_EVT_CODE(_Get_DataRate),
	GEN_EVT_CODE(_Survey),	 /*8*/
	GEN_EVT_CODE(_SurveyDone),	 /*9*/

	GEN_EVT_CODE(_JoinBss) , /*10*/
	GEN_EVT_CODE(_AddSTA),
	GEN_EVT_CODE(_DelSTA),
	GEN_EVT_CODE(_AtimDone) ,
	GEN_EVT_CODE(_TX_Report),
	GEN_EVT_CODE(_CCX_Report),			/*15*/
	GEN_EVT_CODE(_DTM_Report),
	GEN_EVT_CODE(_TX_Rate_Statistics),
	GEN_EVT_CODE(_C2HLBK),
	GEN_EVT_CODE(_FWDBG),
	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
	GEN_EVT_CODE(_ADDBA),
	GEN_EVT_CODE(_C2HBCN),
	GEN_EVT_CODE(_ReportPwrState),		/* filen: only for PCIE, USB	 */
	GEN_EVT_CODE(_CloseRF),				/* filen: only for PCIE, work around ASPM */
	GEN_EVT_CODE(_WMM),					/*25*/
#ifdef CONFIG_IEEE80211W
	GEN_EVT_CODE(_TimeoutSTA),
#endif /* CONFIG_IEEE80211W */
#ifdef CONFIG_RTW_80211R
	GEN_EVT_CODE(_FT_REASSOC),
#endif
	MAX_C2HEVT
};


#ifdef _RTW_MLME_EXT_C_

static struct fwevent wlanevents[] = {
	{0, rtw_dummy_event_callback},	/*0*/
	{0, NULL},
	{0, NULL},
	{0, NULL},
	{0, NULL},
	{0, NULL},
	{0, NULL},
	{0, NULL},
	{0, &rtw_survey_event_callback},		/*8*/
	{sizeof(struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/

	{0, &rtw_joinbss_event_callback},		/*10*/
	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
	{sizeof(struct stadel_event), &rtw_stadel_event_callback},
	{0, &rtw_atimdone_event_callback},
	{0, rtw_dummy_event_callback},
	{0, NULL},	/*15*/
	{0, NULL},
	{0, NULL},
	{0, NULL},
	{0, rtw_fwdbg_event_callback},
	{0, NULL},	 /*20*/
	{0, NULL},
	{0, NULL},
	{0, &rtw_cpwm_event_callback},
	{0, NULL},
	{0, &rtw_wmm_event_callback}, /*25*/
#ifdef CONFIG_IEEE80211W
	{sizeof(struct stadel_event), &rtw_sta_timeout_event_callback},
#endif /* CONFIG_IEEE80211W */
#ifdef CONFIG_RTW_80211R
	{sizeof(struct stassoc_event), &rtw_ft_reassoc_event_callback},
#endif
};

#endif/* _RTW_MLME_EXT_C_ */

#endif
                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtw_mp_phy_regdef.h                                                           0000644 0001750 0001750 00000112317 14214766567 017306  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
/*****************************************************************************
 *
 * Module:	__RTW_MP_PHY_REGDEF_H_
 *
 *
 * Note:	1. Define PMAC/BB register map
 *			2. Define RF register map
 *			3. PMAC/BB register bit mask.
 *			4. RF reg bit mask.
 *			5. Other BB/RF relative definition.
 *
 *
 * Export:	Constants, macro, functions(API), global variables(None).
 *
 * Abbrev:
 *
 * History:
 *	Data			Who		Remark
 *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
 *						2. Reorganize code architecture.
 *	09/25/2008	MH		1. Add RL6052 register definition
 *
 *****************************************************************************/
#ifndef __RTW_MP_PHY_REGDEF_H_
#define __RTW_MP_PHY_REGDEF_H_


/*--------------------------Define Parameters-------------------------------*/

/* ************************************************************
 * 8192S Regsiter offset definition
 * ************************************************************ */

/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other defintion for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface.
 * #define		RF_BB_CMD_ADDR				0x02c0 */	/* RF/BB read/write command address.
 * #define		RF_BB_CMD_DATA				0x02c4 */	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814
/* #define rFPGA0_XC_RFTiming		0x818 */
/* #define rFPGA0_XD_RFTiming		0x81c */

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rFPGA0_XC_HSSIParameter1		0x830
#define		rFPGA0_XC_HSSIParameter2		0x834
#define		rFPGA0_XD_HSSIParameter1		0x838
#define		rFPGA0_XD_HSSIParameter2		0x83c
#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844
#define		rFPGA0_XC_LSSIParameter		0x848
#define		rFPGA0_XD_LSSIParameter		0x84c

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864
#define		rFPGA0_XC_RFInterfaceOE		0x868
#define		rFPGA0_XD_RFInterfaceOE		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */

#define		rFPGA1_TxBlock				0x904	/* Useless now */
#define		rFPGA1_DebugSelect			0x908	/* Useless now */
#define		rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
#define	rS0S1_PathSwitch			0x948

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport            		0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower      	0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper      	0xa58  /* 0xa5c */

/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG  */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c
#define		rOFDM0_RxIQExtAnta			0xca0

#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8


/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_Rate18_06				0xe00
#define		rTxAGC_Rate54_24				0xe04
#define		rTxAGC_CCK_Mcs32				0xe08
#define		rTxAGC_Mcs03_Mcs00			0xe10
#define		rTxAGC_Mcs07_Mcs04			0xe14
#define		rTxAGC_Mcs11_Mcs08			0xe18
#define		rTxAGC_Mcs15_Mcs12			0xe1c

/* Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register] */
#define		rRx_Wait_CCCA					0xe70
#define		rAnapar_Ctrl_BB					0xee0

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define RTL92SE_FPGA_VERIFY 0
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
/* #if (RTL92SE_FPGA_VERIFY == 1) */
#define		rZebra1_Channel				0x7	/* RF channel switch
 * #else */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/*  */

#define		RF_IQADJ_G1				0x01	/*  */
#define		RF_IQADJ_G2				0x02	/*  */
#define		RF_POW_TRSW				0x05	/*  */

#define		RF_GAIN_RX					0x06	/*  */
#define		RF_GAIN_TX					0x07	/*  */

#define		RF_TXM_IDAC				0x08	/*  */
#define		RF_BS_IQGEN				0x0F	/*  */

#define		RF_MODE1					0x10	/*  */
#define		RF_MODE2					0x11	/*  */

#define		RF_RX_AGC_HP				0x12	/*  */
#define		RF_TX_AGC					0x13	/*  */
#define		RF_BIAS						0x14	/*  */
#define		RF_IPA						0x15	/*  */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/*  */
#define		RF_MODE_AG				0x18	/*  */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/*  */

#define		RF_RX_G1					0x1A	/*  */
#define		RF_RX_G2					0x1B	/*  */

#define		RF_RX_BB2					0x1C	/*  */
#define		RF_RX_BB1					0x1D	/*  */

#define		RF_RCK1					0x1E	/*  */
#define		RF_RCK2					0x1F	/*  */

#define		RF_TX_G1					0x20	/*  */
#define		RF_TX_G2					0x21	/*  */
#define		RF_TX_G3					0x22	/*  */

#define		RF_TX_BB1					0x23	/*  */

#define		RF_T_METER					0x24	/*  */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                  			0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    			0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  			0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI               		0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength          		0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         		0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW                		0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4
#if (RTL92SE_FPGA_VERIFY == 1)
	#define		bLSSIReadAddress          		0x3f000000   /* LSSI "Read" Address	 */ /* Reg 0x824 rFPGA0_XA_HSSIParameter2 */
#else
	#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */
#endif
#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */
#if (RTL92SE_FPGA_VERIFY == 1)
	#define		bLSSIReadBackData         		0xfff		/* Reg 0x8a0 rFPGA0_XA_LSSIReadBack */
#else
	#define		bLSSIReadBackData         		0xfffff		/* T65 RF */
#endif
#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              		0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          		0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 		0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                		0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode                		0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble              		0x8	/* Useless */
#define		bCCKAntDiversity			0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate			0x3000
#define		bCCKDCCancel		0x0800
#define		bCCKISICancel		0x0400
#define		bCCKMatchFilter		0x0200
#define		bCCKEqualizer		0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart		0x300000
#define		bCCKCCACount		0x080000
#define		bCCKcs_lim			0x070000
#define		bCCKBistMode		0x80000000
#define		bCCKCCAMask		0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset		0xf0
#define		bCCKRxDCOffset		0xf
#define		bCCKCCAMode		0xc000
#define		bCCKFalseCS_lim		0x3f00
#define		bCCKCS_ratio		0xc00000
#define		bCCKCorgBit_sel		0x300000
#define		bCCKPD_lim			0x0f0000
#define		bCCKNewCCA		0x80000000
#define		bCCKRxHPofIG		0x8000
#define		bCCKRxIG			0x7f00
#define		bCCKLNAPolarity		0x800000
#define		bCCKRx1stGain		0x7f0000
#define		bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC		0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType		0x0300
#define		bCCKRxDAGCEn		0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0			0x3f0000
#define		bCCKTxC1			0x3f000000
#define		bCCKTxC2			0x3f
#define		bCCKTxC3			0x3f00
#define		bCCKTxC4			0x3f0000
#define		bCCKTxC5			0x3f000000
#define		bCCKTxC6			0x3f
#define		bCCKTxC7			0x3f00
#define		bCCKDebugPort		0xff0000
#define		bCCKDACDebug		0x0f000000
#define		bCCKFalseAlarmEnable		0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI			0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel		0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss		0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate		0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze		0x4000
#define		bCCKTxPathSel		0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF                			0x3	/* Useless */
#define		bShift_L			0xc0
#define		bGI_TH			0xc
#define		bRxPathA			0x1
#define		bRxPathB			0x2
#define		bRxPathC			0x4
#define		bRxPathD			0x8
#define		bTxPathA			0x1
#define		bTxPathB			0x2
#define		bTxPathC			0x4
#define		bTxPathD			0x8
#define		bTRSSIFreq			0x200
#define		bADCBackoff			0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode		0x1800000
#define		bRxDCNFType		0xe000000
#define		bRXIQImb_A			0x3ff
#define		bRXIQImb_B			0xfc00
#define		bRXIQImb_C			0x3f0000
#define		bRXIQImb_D			0xffc00000
#define		bDC_dc_Notch		0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH			0xf
#define		bPD_TH_Opt2		0xc000
#define		bPWED_TH			0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option			0x1000
#define		bMF_Win_L			0xe000
#define		bBW_Search_L		0x30000
#define		bwin_enh_L			0xc0000
#define		bBW_TH			0x700000
#define		bED_TH2			0x3800000
#define		bBW_option			0x4000000
#define		bRatio_TH			0x18000000
#define		bWindow_L			0xe0000000
#define		bSBD_Option			0x1
#define		bFrame_TH			0x1c
#define		bFS_Option			0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L		0xe00
#define		bFrame_Weight_Short		0x7000
#define		bSub_Tune			0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2		0x7
#define		bFrame_GI2_TH		0x38
#define		bGI2_Sync_en		0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum		0x1
#define		bCFOAcc			0x2
#define		bCFOStartOffset		0xc
#define		bCFOLookBack		0x70
#define		bCFOSumWeight		0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A			0x3ff
#define		bTXIQImb_B			0xfc00
#define		bTXIQImb_C			0x3f0000
#define		bTXIQImb_D			0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode		0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption		0x20000
#define		bCCADropThres		0xfff00000
#define		bEDCCA_H			0xf
#define		bEDCCA_L			0xf0
#define		bLambda_ED               0x300
#define		bRxInitialGain           0x7f
#define		bRxAntDivEn              0x80
#define		bRxAGCAddressForLNA      0x7f00
#define		bRxHighPowerFlow         0x8000
#define		bRxAGCFreezeThres        0xc0000
#define		bRxFreezeStep_AGC1       0x300000
#define		bRxFreezeStep_AGC2       0xc00000
#define		bRxFreezeStep_AGC3       0x3000000
#define		bRxFreezeStep_AGC0       0xc000000
#define		bRxRssi_Cmp_En           0x10000000
#define		bRxQuickAGCEn            0x20000000
#define		bRxAGCFreezeThresMode    0x40000000
#define		bRxOverFlowCheckType     0x80000000
#define		bRxAGCShift              0x7f
#define		bTRSW_Tri_Only           0x80
#define		bPowerThres              0x300
#define		bRxAGCEn                 0x1
#define		bRxAGCTogetherEn         0x2
#define		bRxAGCMin                0x4
#define		bRxHP_Ini                0x7
#define		bRxHP_TRLNA              0x70
#define		bRxHP_RSSI               0x700
#define		bRxHP_BBP1               0x7000
#define		bRxHP_BBP2               0x70000
#define		bRxHP_BBP3               0x700000
#define		bRSSI_H                  0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen                0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW           0x7
#define		bRxSettle_LNA            0x38
#define		bRxSettle_RSSI           0x1c0
#define		bRxSettle_BBP            0xe00
#define		bRxSettle_RxHP           0x7000
#define		bRxSettle_AntSW_RSSI     0x38000
#define		bRxSettle_AntSW          0xc0000
#define		bRxProcessTime_DAGC      0x300000
#define		bRxSettle_HSSI           0x400000
#define		bRxProcessTime_BBPPW     0x800000
#define		bRxAntennaPowerShift     0x3000000
#define		bRSSITableSelect         0xc000000
#define		bRxHP_Final              0x7000000
#define		bRxHTSettle_BBP          0x7
#define		bRxHTSettle_HSSI         0x8
#define		bRxHTSettle_RxHP         0x70
#define		bRxHTSettle_BBPPW        0x80
#define		bRxHTSettle_Idle         0x300
#define		bRxHTSettle_Reserved     0x1c00
#define		bRxHTRxHPEn              0x8000
#define		bRxHTAGCFreezeThres      0x30000
#define		bRxHTAGCTogetherEn       0x40000
#define		bRxHTAGCMin              0x80000
#define		bRxHTAGCEn               0x100000
#define		bRxHTDAGCEn              0x200000
#define		bRxHTRxHP_BBP            0x1c00000
#define		bRxHTRxHP_Final          0xe0000000
#define		bRxPWRatioTH             0x3
#define		bRxPWRatioEn             0x4
#define		bRxMFHold                0x3800
#define		bRxPD_Delay_TH1          0x38
#define		bRxPD_Delay_TH2          0x1c0
#define		bRxPD_DC_COUNT_MAX       0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH           0x8000
#define		bRxProcess_Delay         0xf0000
#define		bRxSearchrange_GI2_Early 0x700000
#define		bRxFrame_Guard_Counter_L 0x3800000
#define		bRxSGI_Guard_L           0xc000000
#define		bRxSGI_Search_L          0x30000000
#define		bRxSGI_TH                0xc0000000
#define		bDFSCnt0                 0xff
#define		bDFSCnt1                 0xff00
#define		bDFSFlag                 0xf0000
#define		bMFWeightSum             0x300000
#define		bMinIdxTH                0x7f000000
#define		bDAFormat                0x40000
#define		bTxChEmuEnable           0x01000000
#define		bTRSWIsolation_A         0x7f
#define		bTRSWIsolation_B         0x7f00
#define		bTRSWIsolation_C         0x7f0000
#define		bTRSWIsolation_D         0x7f000000
#define		bExtLNAGain              0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn                  0x4	/* Useless */
#define		bAntennaMapping          0x10
#define		bNss                     0x20
#define		bCFOAntSumD              0x200
#define		bPHYCounterReset         0x8000000
#define		bCFOReportGet            0x4000000
#define		bOFDMContinueTx          0x10000000
#define		bOFDMSingleCarrier       0x20000000
#define		bOFDMSingleTone          0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect                0x100
#define		bCFOEn                   0x10000
#define		bCFOValue                0xfff00000
#define		bSigTone_Re              0x3f
#define		bSigTone_Im              0x7f00
#define		bCounter_CCA             0xffff
#define		bCounter_ParityFail      0xffff0000
#define		bCounter_RateIllegal     0xffff
#define		bCounter_CRC8Fail        0xffff0000
#define		bCounter_MCSNoSupport    0xffff
#define		bCounter_FastSync        0xffff
#define		bShortCFO                0xfff
#define		bShortCFOTLength         12   /* total */
#define		bShortCFOFLength         11   /* fraction */
#define		bLongCFO                 0x7ff
#define		bLongCFOTLength          11
#define		bLongCFOFLength          11
#define		bTailCFO                 0x1fff
#define		bTailCFOTLength          13
#define		bTailCFOFLength          12
#define		bmax_en_pwdB             0xffff
#define		bCC_power_dB             0xffff0000
#define		bnoise_pwdB              0xffff
#define		bPowerMeasTLength        10
#define		bPowerMeasFLength        3
#define		bRx_HT_BW                0x1
#define		bRxSC                    0x6
#define		bRx_HT                   0x8
#define		bNB_intf_det_on          0x1
#define		bIntf_win_len_cfg        0x30
#define		bNB_Intf_TH_cfg          0x1c0
#define		bRFGain                  0x3f
#define		bTableSel                0x40
#define		bTRSW                    0x80
#define		bRxSNR_A                 0xff
#define		bRxSNR_B                 0xff00
#define		bRxSNR_C                 0xff0000
#define		bRxSNR_D                 0xff000000
#define		bSNREVMTLength           8
#define		bSNREVMFLength           1
#define		bCSI1st                  0xff
#define		bCSI2nd                  0xff00
#define		bRxEVM1st                0xff0000
#define		bRxEVM2nd                0xff000000
#define		bSIGEVM                  0xff
#define		bPWDB                    0xff00
#define		bSGIEN                   0x10000

#define		bSFactorQAM1             0xf	/* Useless */
#define		bSFactorQAM2             0xf0
#define		bSFactorQAM3             0xf00
#define		bSFactorQAM4             0xf000
#define		bSFactorQAM5             0xf0000
#define		bSFactorQAM6             0xf0000
#define		bSFactorQAM7             0xf00000
#define		bSFactorQAM8             0xf000000
#define		bSFactorQAM9             0xf0000000
#define		bCSIScheme               0x100000

#define		bNoiseLvlTopSet          0x3	/* Useless */
#define		bChSmooth                0x4
#define		bChSmoothCfg1            0x38
#define		bChSmoothCfg2            0x1c0
#define		bChSmoothCfg3            0xe00
#define		bChSmoothCfg4            0x7000
#define		bMRCMode                 0x800000
#define		bTHEVMCfg                0x7000000

#define		bLoopFitType             0x1	/* Useless */
#define		bUpdCFO                  0x40
#define		bUpdCFOOffData           0x80
#define		bAdvUpdCFO               0x100
#define		bAdvTimeCtrl             0x800
#define		bUpdClko                 0x1000
#define		bFC                      0x6000
#define		bTrackingMode            0x8000
#define		bPhCmpEnable             0x10000
#define		bUpdClkoLTF              0x20000
#define		bComChCFO                0x40000
#define		bCSIEstiMode             0x80000
#define		bAdvUpdEqz               0x100000
#define		bUChCfg                  0x7000000
#define		bUpdEqz                  0x8000000

#define		bTxAGCRate18_06			0x7f7f7f7f	/* Useless */
#define		bTxAGCRate54_24			0x7f7f7f7f
#define		bTxAGCRateMCS32			0x7f
#define		bTxAGCRateCCK			0x7f00
#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
#define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn         0x20000000	/* Useless */
#define		bRxPesudoNoise_A         0xff
#define		bRxPesudoNoise_B         0xff00
#define		bRxPesudoNoise_C         0xff0000
#define		bRxPesudoNoise_D         0xff000000
#define		bPesudoNoiseState_A      0xffff
#define		bPesudoNoiseState_B      0xffff0000
#define		bPesudoNoiseState_C      0xffff
#define		bPesudoNoiseState_D      0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable        0x8		/* Useless */
#define		bZebra1_TRxControl        0xc00
#define		bZebra1_TRxGainSetting    0x07f
#define		bZebra1_RxCorner          0xc00
#define		bZebra1_TxChargePump      0x38
#define		bZebra1_RxChargePump      0x7
#define		bZebra1_ChannelNum        0xf80
#define		bZebra1_TxLPFBW           0x400
#define		bZebra1_RxLPFBW           0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1      0x100	/* Useless */
#define		bRTL8256RegModeCtrl0      0x40
#define		bRTL8256_TxLPFBW          0x18
#define		bRTL8256_RxLPFBW          0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW          0xc	/* Useless */
#define		bRTL8258_RxLPFBW          0xc00
#define		bRTL8258_RSSILPFBW        0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0                    0x1	/* Useless */
#define		bByte1                    0x2
#define		bByte2                    0x4
#define		bByte3                    0x8
#define		bWord0                    0x3
#define		bWord1                    0xc
#define		bDWord                    0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1		0xff00
#define		bMaskByte2		0xff0000
#define		bMaskByte3		0xff000000
#define		bMaskHWord	0xffff0000
#define		bMaskLWord		0x0000ffff
#define		bMaskDWord	0xffffffff
#define		bMaskH4Bits		0xf0000000
#define		bMaskH3Bytes	0xffffff00
#define		bMaskOFDM_D	0xffc00000
#define		bMaskCCK		0x3f3f3f3f
#define		bMask12Bits		0xfff

/* for PutRFRegsetting & GetRFRegSetting BitMask */
#if (RTL92SE_FPGA_VERIFY == 1)
/* #define		bMask12Bits               0xfff */	/* RF Reg mask bits */
/* #define		bMask20Bits               0xfff */	/* RF Reg mask bits T65 RF */
#define		bRFRegOffsetMask	0xfff
#else
/* #define		bMask12Bits               0xfffff */	/* RF Reg mask bits */
/* #define		bMask20Bits               0xfffff */	/* RF Reg mask bits T65 RF */
#define		bRFRegOffsetMask	0xfffff
#endif
#define		bEnable                   0x1	/* Useless */
#define		bDisable                  0x0

#define		LeftAntenna               0x0	/* Useless */
#define		RightAntenna              0x1

#define		tCheckTxStatus            500   /* 500ms */ /* Useless */
#define		tUpdateRxCounter          100   /* 100ms */

#define		rateCCK     0	/* Useless */
#define		rateOFDM    1
#define		rateHT      2

/* define Register-End */
#define		bPMAC_End                 0x1ff	/* Useless */
#define		bFPGAPHY0_End             0x8ff
#define		bFPGAPHY1_End             0x9ff
#define		bCCKPHY0_End              0xaff
#define		bOFDMPHY0_End             0xcff
#define		bOFDMPHY1_End             0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl	0x0		/* Useless */
#define		bWMACControl	0x1
#define		bWNICControl	0x2

#if 0
#define		ANTENNA_A	0x1	/* Useless */
#define		ANTENNA_B	0x2
#define		ANTENNA_AB	0x3	/* ANTENNA_A | ANTENNA_B */

#define		ANTENNA_C	0x4
#define		ANTENNA_D	0x8
#endif

#define RCR_AAP			BIT(0)				/* accept all physical address */
#define RCR_APM			BIT(1)				/* accept physical match */
#define RCR_AM			BIT(2)				/* accept multicast */
#define RCR_AB			BIT(3)				/* accept broadcast */
#define RCR_ACRC32		BIT(5)				/* accept error packet */
#define RCR_9356SEL		BIT(6)
#define RCR_AICV		BIT(9)				/* Accept ICV error packet */
#define RCR_RXFTH0		(BIT(13) | BIT(14) | BIT(15))	/* Rx FIFO threshold */
#define RCR_ADF			BIT(18)				/* Accept Data(frame type) frame */
#define RCR_ACF			BIT(19)				/* Accept control frame */
#define RCR_AMF			BIT(20)				/* Accept management frame */
#define RCR_ADD3		BIT(21)
#define RCR_APWRMGT		BIT(22)				/* Accept power management packet */
#define RCR_CBSSID		BIT(23)				/* Accept BSSID match packet */
#define RCR_ENMARP		BIT(28)				/* enable mac auto reset phy */
#define RCR_EnCS1		BIT(29)				/* enable carrier sense method 1 */
#define RCR_EnCS2		BIT(30)				/* enable carrier sense method 2 */
#define RCR_OnlyErlPkt		BIT(31)				/* Rx Early mode is performed for packet size greater than 1536 */

/*--------------------------Define Parameters-------------------------------*/


#endif /* __INC_HAL8192SPHYREG_H */
                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/rtw_ioctl_set.h                                                               0000644 0001750 0001750 00000003414 14214766567 016460  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_IOCTL_SET_H_
#define __RTW_IOCTL_SET_H_

u8 rtw_set_802_11_authentication_mode(_adapter *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
u8 rtw_set_802_11_bssid(_adapter *padapter, u8 *bssid);
u8 rtw_set_802_11_add_wep(_adapter *padapter, NDIS_802_11_WEP *wep);
u8 rtw_set_802_11_disassociate(_adapter *padapter);
u8 rtw_set_802_11_bssid_list_scan(_adapter *padapter, struct sitesurvey_parm *pparm);
#ifdef CONFIG_RTW_ACS
u8 rtw_set_acs_sitesurvey(_adapter *adapter);
#endif
u8 rtw_set_802_11_infrastructure_mode(_adapter *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype, u8 flags);
u8 rtw_set_802_11_ssid(_adapter *padapter, NDIS_802_11_SSID *ssid);
u8 rtw_set_802_11_connect(_adapter *padapter,
			  u8 *bssid, NDIS_802_11_SSID *ssid, u16 ch);

u8 rtw_validate_bssid(u8 *bssid);
u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);

u16 rtw_get_cur_max_rate(_adapter *adapter);
int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode);
int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan);
int rtw_set_country(_adapter *adapter, const char *country_code);
int rtw_set_band(_adapter *adapter, u8 band);

#endif
                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtw_xmit.h                                                                    0000644 0001750 0001750 00000072236 14214766567 015464  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_XMIT_H_
#define _RTW_XMIT_H_


#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	#ifdef CONFIG_TX_AGGREGATION
		#ifdef CONFIG_RTL8822C
			#ifdef CONFIG_SDIO_TX_FORMAT_DUMMY_AUTO
				#define MAX_XMITBUF_SZ	(51200)
			#else
				#define MAX_XMITBUF_SZ	(32764)
			#endif
		#elif defined(CONFIG_RTL8822B)
			#define MAX_XMITBUF_SZ	(31744)	/* ~32k */
		#else
			#define MAX_XMITBUF_SZ	(20480)	/* 20k */
		#endif
		/* #define SDIO_TX_AGG_MAX	5 */
	#else
		#define MAX_XMITBUF_SZ (1664)
		#define SDIO_TX_AGG_MAX	1
	#endif

	#if defined CONFIG_SDIO_HCI
		#define NR_XMITBUFF	(16)
		#define SDIO_TX_DIV_NUM (2)
	#endif
	#if defined(CONFIG_GSPI_HCI)
		#define NR_XMITBUFF	(128)
	#endif

#elif defined (CONFIG_USB_HCI)

	#ifdef CONFIG_USB_TX_AGGREGATION
		#if defined(CONFIG_PLATFORM_ARM_SUNxI) || defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I) || defined(CONFIG_PLATFORM_ARM_SUN8I) || defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
			#define MAX_XMITBUF_SZ (12288)  /* 12k 1536*8 */
		#elif defined (CONFIG_PLATFORM_MSTAR)
			#define MAX_XMITBUF_SZ	7680	/* 7.5k */
		#else
			#define MAX_XMITBUF_SZ	(20480)	/* 20k */
		#endif
	#else
		#define MAX_XMITBUF_SZ	(2048)
	#endif

	#ifdef CONFIG_SINGLE_XMIT_BUF
		#define NR_XMITBUFF	(1)
	#else
		#define NR_XMITBUFF	(4)
	#endif /* CONFIG_SINGLE_XMIT_BUF */
#elif defined (CONFIG_PCI_HCI)
#ifdef CONFIG_TX_AMSDU
	#define MAX_XMITBUF_SZ	(3500)
#else
	#define MAX_XMITBUF_SZ	(1664)
#endif
#ifdef CONFIG_PCI_TX_POLLING
	#define NR_XMITBUFF	(256)
#else
	#define NR_XMITBUFF	(128)
#endif
#endif


#ifdef CONFIG_PCI_HCI
	#define XMITBUF_ALIGN_SZ 4
#else
	#ifdef USB_XMITBUF_ALIGN_SZ
		#define XMITBUF_ALIGN_SZ (USB_XMITBUF_ALIGN_SZ)
	#else
		#define XMITBUF_ALIGN_SZ 512
	#endif
#endif


/* xmit extension buff defination */
#define MAX_XMIT_EXTBUF_SZ	(1536)

#ifdef CONFIG_SINGLE_XMIT_BUF
	#define NR_XMIT_EXTBUFF	(1)
#else
	#define NR_XMIT_EXTBUFF	(32)
#endif

#ifdef CONFIG_RTL8812A
	#define MAX_CMDBUF_SZ	(512 * 18)
#elif defined(CONFIG_RTL8723D) && defined(CONFIG_LPS_POFF)
	#define MAX_CMDBUF_SZ	(128*70) /*(8960)*/
#else
	#define MAX_CMDBUF_SZ	(5120)	/* (4096) */
#endif

#define MAX_BEACON_LEN	512

#define MAX_NUMBLKS		(1)

#define XMIT_VO_QUEUE (0)
#define XMIT_VI_QUEUE (1)
#define XMIT_BE_QUEUE (2)
#define XMIT_BK_QUEUE (3)

#define VO_QUEUE_INX		0
#define VI_QUEUE_INX		1
#define BE_QUEUE_INX		2
#define BK_QUEUE_INX		3
#define BCN_QUEUE_INX		4
#define MGT_QUEUE_INX		5
#define HIGH_QUEUE_INX		6
#define TXCMD_QUEUE_INX	7

#define HW_QUEUE_ENTRY	8

#ifdef CONFIG_PCI_HCI
	#ifdef CONFIG_TRX_BD_ARCH
		#define TX_BD_NUM			(128+1)	/* +1 result from ring buffer */
	#else
		#define TXDESC_NUM			128
	#endif
#endif

#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
	do {\
		dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0 : (dot11txpn.val + 1);\
		pattrib_iv[0] = dot11txpn._byte_.TSC0;\
		pattrib_iv[1] = dot11txpn._byte_.TSC1;\
		pattrib_iv[2] = dot11txpn._byte_.TSC2;\
		pattrib_iv[3] = ((keyidx & 0x3)<<6);\
	} while (0)


#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
	do {\
		dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0 : (dot11txpn.val + 1);\
		pattrib_iv[0] = dot11txpn._byte_.TSC1;\
		pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
		pattrib_iv[2] = dot11txpn._byte_.TSC0;\
		pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
		pattrib_iv[4] = dot11txpn._byte_.TSC2;\
		pattrib_iv[5] = dot11txpn._byte_.TSC3;\
		pattrib_iv[6] = dot11txpn._byte_.TSC4;\
		pattrib_iv[7] = dot11txpn._byte_.TSC5;\
	} while (0)

#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
	do {\
		dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0 : (dot11txpn.val + 1);\
		pattrib_iv[0] = dot11txpn._byte_.TSC0;\
		pattrib_iv[1] = dot11txpn._byte_.TSC1;\
		pattrib_iv[2] = 0;\
		pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
		pattrib_iv[4] = dot11txpn._byte_.TSC2;\
		pattrib_iv[5] = dot11txpn._byte_.TSC3;\
		pattrib_iv[6] = dot11txpn._byte_.TSC4;\
		pattrib_iv[7] = dot11txpn._byte_.TSC5;\
	} while (0)

/* Check if AMPDU Tx is supported or not. If it is supported,
* it need to check "amsdu in ampdu" is supported or not.
* (ampdu_en, amsdu_ampdu_en) =
* (0, x) : AMPDU is not enable, but AMSDU is valid to send.
* (1, 0) : AMPDU is enable, AMSDU in AMPDU is not enable. So, AMSDU is not valid to send.
* (1, 1) : AMPDU and AMSDU in AMPDU are enable. So, AMSDU is valid to send.
*/
#define IS_AMSDU_AMPDU_NOT_VALID(pattrib)\
	 ((pattrib->ampdu_en == _TRUE) && (pattrib->amsdu_ampdu_en == _FALSE))

#define IS_AMSDU_AMPDU_VALID(pattrib)\
	 !((pattrib->ampdu_en == _TRUE) && (pattrib->amsdu_ampdu_en == _FALSE))

#define HWXMIT_ENTRY	4

/* For Buffer Descriptor ring architecture */
#if defined(BUF_DESC_ARCH) || defined(CONFIG_TRX_BD_ARCH)
	#if defined(CONFIG_RTL8192E)
		#define TX_BUFFER_SEG_NUM	1 /* 0:2 seg, 1: 4 seg, 2: 8 seg. */
	#elif defined(CONFIG_RTL8814A)
		#define TX_BUFFER_SEG_NUM	1 /* 0:2 seg, 1: 4 seg, 2: 8 seg. */
	#else
		#define TX_BUFFER_SEG_NUM	1 /* 0:2 seg, 1: 4 seg, 2: 8 seg. */
	#endif
#endif

#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) ||\
	defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8192E) ||\
	defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8703B) ||\
	defined(CONFIG_RTL8188F) || defined(CONFIG_RTL8188GTV) || defined(CONFIG_RTL8723D) ||\
	defined(CONFIG_RTL8710B) || defined(CONFIG_RTL8192F)
	#define TXDESC_SIZE 40
#elif defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8822C)
	#define TXDESC_SIZE 48		/* HALMAC_TX_DESC_SIZE_8822B */
#elif defined(CONFIG_RTL8821C)
	#define TXDESC_SIZE 48		/* HALMAC_TX_DESC_SIZE_8821C */
#elif defined(CONFIG_RTL8814B)
	#define TXDESC_SIZE (16 + 32)
#else
	#define TXDESC_SIZE 32 /* old IC (ex: 8188E) */
#endif

#ifdef CONFIG_TX_EARLY_MODE
	#define EARLY_MODE_INFO_SIZE	8
#endif


#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	#define TXDESC_OFFSET TXDESC_SIZE
#endif

#ifdef CONFIG_USB_HCI
	#ifdef USB_PACKET_OFFSET_SZ
		#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
	#else
		#define PACKET_OFFSET_SZ (8)
	#endif
	#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
#endif

#ifdef CONFIG_PCI_HCI
	#if defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8822C) || defined(CONFIG_TRX_BD_ARCH)
		/* this section is defined for buffer descriptor ring architecture */
		#define TX_WIFI_INFO_SIZE (TXDESC_SIZE) /* it may add 802.11 hdr or others... */
		/* tx desc and payload are in the same buf */
		#define TXDESC_OFFSET (TX_WIFI_INFO_SIZE)
	#else
		/* tx desc and payload are NOT in the same buf */
		#define TXDESC_OFFSET (0)
		/* 8188ee/8723be/8812ae/8821ae has extra PCI DMA info in tx desc */
		#define TX_DESC_NEXT_DESC_OFFSET	(TXDESC_SIZE + 8)
	#endif
#endif /* CONFIG_PCI_HCI */

enum TXDESC_SC {
	SC_DONT_CARE = 0x00,
	SC_UPPER = 0x01,
	SC_LOWER = 0x02,
	SC_DUPLICATE = 0x03
};

#ifdef CONFIG_PCI_HCI
	#ifndef CONFIG_TRX_BD_ARCH	/* CONFIG_TRX_BD_ARCH doesn't need this */
		#define TXDESC_64_BYTES
	#endif
#elif defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8723B) \
	|| defined(CONFIG_RTL8188F) || defined(CONFIG_RTL8188GTV) || defined(CONFIG_RTL8723D) \
	|| defined(CONFIG_RTL8192F)
	#define TXDESC_40_BYTES
#endif

#ifdef CONFIG_TRX_BD_ARCH
struct tx_buf_desc {
#ifdef CONFIG_64BIT_DMA
#define TX_BUFFER_SEG_SIZE	4	/* in unit of DWORD */
#else
#define TX_BUFFER_SEG_SIZE	2	/* in unit of DWORD */
#endif
	unsigned int dword[TX_BUFFER_SEG_SIZE * (2 << TX_BUFFER_SEG_NUM)];
} __packed;
#elif (defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8822C)) && defined(CONFIG_PCI_HCI) /* 8192ee or 8814ae */
/* 8192EE_TODO */
struct tx_desc {
	unsigned int txdw0;
	unsigned int txdw1;
	unsigned int txdw2;
	unsigned int txdw3;
	unsigned int txdw4;
	unsigned int txdw5;
	unsigned int txdw6;
	unsigned int txdw7;
};
#else
struct tx_desc {
	unsigned int txdw0;
	unsigned int txdw1;
	unsigned int txdw2;
	unsigned int txdw3;
	unsigned int txdw4;
	unsigned int txdw5;
	unsigned int txdw6;
	unsigned int txdw7;

#if defined(TXDESC_40_BYTES) || defined(TXDESC_64_BYTES)
	unsigned int txdw8;
	unsigned int txdw9;
#endif /* TXDESC_40_BYTES */

#ifdef TXDESC_64_BYTES
	unsigned int txdw10;
	unsigned int txdw11;

	/* 2008/05/15 MH Because PCIE HW memory R/W 4K limit. And now,  our descriptor */
	/* size is 40 bytes. If you use more than 102 descriptor( 103*40>4096), HW will execute */
	/* memoryR/W CRC error. And then all DMA fetch will fail. We must decrease descriptor */
	/* number or enlarge descriptor size as 64 bytes. */
	unsigned int txdw12;
	unsigned int txdw13;
	unsigned int txdw14;
	unsigned int txdw15;
#endif
};
#endif

#ifndef CONFIG_TRX_BD_ARCH
union txdesc {
	struct tx_desc txdesc;
	unsigned int value[TXDESC_SIZE >> 2];
};
#endif

#ifdef CONFIG_PCI_HCI
#define PCI_MAX_TX_QUEUE_COUNT	8	/* == HW_QUEUE_ENTRY */

struct rtw_tx_ring {
	unsigned char	qid;
#ifdef CONFIG_TRX_BD_ARCH
	struct tx_buf_desc	*buf_desc;
#else
	struct tx_desc	*desc;
#endif
	dma_addr_t	dma;
	unsigned int	idx;
	unsigned int	entries;
	_queue		queue;
	u32		qlen;
#ifdef CONFIG_TRX_BD_ARCH
	u16		hw_rp_cache;
#endif
};

#ifdef DBG_TXBD_DESC_DUMP

#define TX_BAK_FRMAE_CNT	10
#define TX_BAK_DESC_LEN	48	/* byte */
#define TX_BAK_DATA_LEN		30	/* byte */

struct rtw_tx_desc_backup {
	int tx_bak_rp;
	int tx_bak_wp;
	u8 tx_bak_desc[TX_BAK_DESC_LEN];
	u8 tx_bak_data_hdr[TX_BAK_DATA_LEN];
	u8 tx_desc_size;
};
#endif
#endif

struct	hw_xmit	{
	/* _lock xmit_lock; */
	/* _list	pending; */
	_queue *sta_queue;
	/* struct hw_txqueue *phwtxqueue; */
	/* sint	txcmdcnt; */
	int	accnt;
};

#if 0
struct pkt_attrib {
	u8	type;
	u8	subtype;
	u8	bswenc;
	u8	dhcp_pkt;
	u16	ether_type;
	int	pktlen;		/* the original 802.3 pkt raw_data len (not include ether_hdr data) */
	int	pkt_hdrlen;	/* the original 802.3 pkt header len */
	int	hdrlen;		/* the WLAN Header Len */
	int	nr_frags;
	int	last_txcmdsz;
	int	encrypt;	/* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
	u8	iv[8];
	int	iv_len;
	u8	icv[8];
	int	icv_len;
	int	priority;
	int	ack_policy;
	int	mac_id;
	int	vcs_mode;	/* virtual carrier sense method */

	u8	dst[ETH_ALEN];
	u8	src[ETH_ALEN];
	u8	ta[ETH_ALEN];
	u8	ra[ETH_ALEN];

	u8	key_idx;

	u8	qos_en;
	u8	ht_en;
	u8	raid;/* rate adpative id */
	u8	bwmode;
	u8	ch_offset;/* PRIME_CHNL_OFFSET */
	u8	sgi;/* short GI */
	u8	ampdu_en;/* tx ampdu enable */
	u8	mdata;/* more data bit */
	u8	eosp;

	u8	triggered;/* for ap mode handling Power Saving sta */

	u32	qsel;
	u16	seqnum;

	struct sta_info *psta;
};
#else
/* reduce size */
struct pkt_attrib {
	u8	type;
	u8	subtype;
	u8	bswenc;
	u8	dhcp_pkt;
	u16	ether_type;
	u16	seqnum;
	u8	hw_ssn_sel;	/* for HW_SEQ0,1,2,3 */
	u16	pkt_hdrlen;	/* the original 802.3 pkt header len */
	u16	hdrlen;		/* the WLAN Header Len */
	u32	pktlen;		/* the original 802.3 pkt raw_data len (not include ether_hdr data) */
	u32	last_txcmdsz;
	u8	nr_frags;
	u8	encrypt;	/* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
#if defined(CONFIG_CONCURRENT_MODE)
	u8	bmc_camid;
#endif
	u8	iv_len;
	u8	icv_len;
	u8	iv[18];
	u8	icv[16];
	u8	priority;
	u8	ack_policy;
	u8	mac_id;
	u8	vcs_mode;	/* virtual carrier sense method */
	u8	dst[ETH_ALEN];
	u8	src[ETH_ALEN];
	u8	ta[ETH_ALEN];
	u8	ra[ETH_ALEN];
#ifdef CONFIG_RTW_MESH
	u8	mda[ETH_ALEN];	/* mesh da */
	u8	msa[ETH_ALEN];	/* mesh sa */
	u8	meshctrl_len;	/* Length of Mesh Control field */
	u8	mesh_frame_mode;
	#if CONFIG_RTW_MESH_DATA_BMC_TO_UC
	u8 mb2u;
	#endif
	u8 mfwd_ttl;
	u32 mseq;
#endif
#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
	u8	hw_csum;
#endif
	u8	key_idx;
	u8	qos_en;
	u8	ht_en;
	u8	raid;/* rate adpative id */
	u8	bwmode;
	u8	ch_offset;/* PRIME_CHNL_OFFSET */
	u8	sgi;/* short GI */
	u8	ampdu_en;/* tx ampdu enable */
	u8	ampdu_spacing; /* ampdu_min_spacing for peer sta's rx */
	u8	amsdu;
	u8	amsdu_ampdu_en;/* tx amsdu in ampdu enable */
	u8	mdata;/* more data bit */
	u8	pctrl;/* per packet txdesc control enable */
	u8	triggered;/* for ap mode handling Power Saving sta */
	u8	qsel;
	u8	order;/* order bit */
	u8	eosp;
	u8	rate;
	u8	intel_proxim;
	u8	retry_ctrl;
	u8   mbssid;
	u8	ldpc;
	u8	stbc;
#ifdef CONFIG_WMMPS_STA
	u8	trigger_frame;
#endif /* CONFIG_WMMPS_STA */
	
	struct sta_info *psta;

	u8 rtsen;
	u8 cts2self;
	union Keytype	dot11tkiptxmickey;
	/* union Keytype	dot11tkiprxmickey; */
	union Keytype	dot118021x_UncstKey;

#ifdef CONFIG_TDLS
	u8 direct_link;
	struct sta_info *ptdls_sta;
#endif /* CONFIG_TDLS */
	u8 key_type;

	u8 icmp_pkt;
	u8 hipriority_pkt; /* high priority packet */

#ifdef CONFIG_BEAMFORMING
	u16 txbf_p_aid;/*beamforming Partial_AID*/
	u16 txbf_g_id;/*beamforming Group ID*/

	/*
	 * 2'b00: Unicast NDPA
	 * 2'b01: Broadcast NDPA
	 * 2'b10: Beamforming Report Poll
	 * 2'b11: Final Beamforming Report Poll
	 */
	u8 bf_pkt_type;
#endif

};
#endif

#ifdef CONFIG_RTW_MESH
#define XATTRIB_GET_MCTRL_LEN(xattrib) ((xattrib)->meshctrl_len)
#else
#define XATTRIB_GET_MCTRL_LEN(xattrib) 0
#endif

#ifdef CONFIG_TX_AMSDU
enum {
	RTW_AMSDU_TIMER_UNSET = 0,
	RTW_AMSDU_TIMER_SETTING,
	RTW_AMSDU_TIMER_TIMEOUT,
};
#endif

#define WLANHDR_OFFSET	64

#define NULL_FRAMETAG		(0x0)
#define DATA_FRAMETAG		0x01
#define L2_FRAMETAG		0x02
#define MGNT_FRAMETAG		0x03
#define AMSDU_FRAMETAG	0x04

#define EII_FRAMETAG		0x05
#define IEEE8023_FRAMETAG  0x06

#define MP_FRAMETAG		0x07

#define TXAGG_FRAMETAG	0x08

enum {
	XMITBUF_DATA = 0,
	XMITBUF_MGNT = 1,
	XMITBUF_CMD = 2,
};

bool rtw_xmit_ac_blocked(_adapter *adapter);

struct  submit_ctx {
	systime submit_time; /* */
	u32 timeout_ms; /* <0: not synchronous, 0: wait forever, >0: up to ms waiting */
	int status; /* status for operation */
#ifdef PLATFORM_LINUX
	struct completion done;
#endif
};

enum {
	RTW_SCTX_SUBMITTED = -1,
	RTW_SCTX_DONE_SUCCESS = 0,
	RTW_SCTX_DONE_UNKNOWN,
	RTW_SCTX_DONE_TIMEOUT,
	RTW_SCTX_DONE_BUF_ALLOC,
	RTW_SCTX_DONE_BUF_FREE,
	RTW_SCTX_DONE_WRITE_PORT_ERR,
	RTW_SCTX_DONE_TX_DESC_NA,
	RTW_SCTX_DONE_TX_DENY,
	RTW_SCTX_DONE_CCX_PKT_FAIL,
	RTW_SCTX_DONE_DRV_STOP,
	RTW_SCTX_DONE_DEV_REMOVE,
	RTW_SCTX_DONE_CMD_ERROR,
	RTW_SCTX_DONE_CMD_DROP,
	RTX_SCTX_CSTR_WAIT_RPT2,
};


void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms);
int rtw_sctx_wait(struct submit_ctx *sctx, const char *msg);
void rtw_sctx_done_err(struct submit_ctx **sctx, int status);
void rtw_sctx_done(struct submit_ctx **sctx);

struct xmit_buf {
	_list	list;

	_adapter *padapter;

	u8 *pallocated_buf;

	u8 *pbuf;

	void *priv_data;

	u16 buf_tag; /* 0: Normal xmitbuf, 1: extension xmitbuf, 2:cmd xmitbuf */
	u16 flags;
	u32 alloc_sz;

	u32  len;

	struct submit_ctx *sctx;

#ifdef CONFIG_USB_HCI

	/* u32 sz[8]; */
	u32	ff_hwaddr;
#ifdef RTW_HALMAC
	u8 bulkout_id; /* for halmac */
#endif /* RTW_HALMAC */

	PURB	pxmit_urb[8];
	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */

	u8 bpending[8];

	sint last[8];

#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	u8 *phead;
	u8 *pdata;
	u8 *ptail;
	u8 *pend;
	u32 ff_hwaddr;
	u8	pg_num;
	u8	agg_num;
#endif

#ifdef CONFIG_PCI_HCI
#ifdef CONFIG_TRX_BD_ARCH
	/*struct tx_buf_desc *buf_desc;*/
#else
	struct tx_desc *desc;
#endif
#endif

#if defined(DBG_XMIT_BUF) || defined(DBG_XMIT_BUF_EXT)
	u8 no;
#endif

};


struct xmit_frame {
	_list	list;

	struct pkt_attrib attrib;

	_pkt *pkt;

	int	frame_tag;

	_adapter *padapter;

	u8	*buf_addr;

	struct xmit_buf *pxmitbuf;

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	u8	pg_num;
	u8	agg_num;
#endif

#ifdef CONFIG_USB_HCI
#ifdef CONFIG_USB_TX_AGGREGATION
	u8	agg_num;
#endif
	s8	pkt_offset;
#endif

#ifdef CONFIG_XMIT_ACK
	u8 ack_report;
#endif

	u8 *alloc_addr; /* the actual address this xmitframe allocated */
	u8 ext_tag; /* 0:data, 1:mgmt */

};

struct tx_servq {
	_list	tx_pending;
	_queue	sta_pending;
	int qcnt;
};


struct sta_xmit_priv {
	_lock	lock;
	sint	option;
	sint	apsd_setting;	/* When bit mask is on, the associated edca queue supports APSD. */


	/* struct tx_servq blk_q[MAX_NUMBLKS]; */
	struct tx_servq	be_q;			/* priority == 0,3 */
	struct tx_servq	bk_q;			/* priority == 1,2 */
	struct tx_servq	vi_q;			/* priority == 4,5 */
	struct tx_servq	vo_q;			/* priority == 6,7 */
	_list	legacy_dz;
	_list  apsd;

	u16 txseq_tid[16];

	/* uint	sta_tx_bytes; */
	/* u64	sta_tx_pkts; */
	/* uint	sta_tx_fail; */


};


struct	hw_txqueue	{
	volatile sint	head;
	volatile sint	tail;
	volatile sint 	free_sz;	/* in units of 64 bytes */
	volatile sint      free_cmdsz;
	volatile sint	 txsz[8];
	uint	ff_hwaddr;
	uint	cmd_hwaddr;
	sint	ac_tag;
};

struct agg_pkt_info {
	u16 offset;
	u16 pkt_len;
};

enum cmdbuf_type {
	CMDBUF_BEACON = 0x00,
	CMDBUF_RSVD,
	CMDBUF_MAX
};

u8 rtw_get_hwseq_no(_adapter *padapter);

struct	xmit_priv	{

	_lock	lock;

	_sema	xmit_sema;

	/* _queue	blk_strms[MAX_NUMBLKS]; */
	_queue	be_pending;
	_queue	bk_pending;
	_queue	vi_pending;
	_queue	vo_pending;
	_queue	bm_pending;

	/* _queue	legacy_dz_queue; */
	/* _queue	apsd_queue; */

	u8 *pallocated_frame_buf;
	u8 *pxmit_frame_buf;
	uint free_xmitframe_cnt;
	_queue	free_xmit_queue;

	/* uint mapping_addr; */
	/* uint pkt_sz; */

	u8 *xframe_ext_alloc_addr;
	u8 *xframe_ext;
	uint free_xframe_ext_cnt;
	_queue free_xframe_ext_queue;

	/* struct	hw_txqueue	be_txqueue; */
	/* struct	hw_txqueue	bk_txqueue; */
	/* struct	hw_txqueue	vi_txqueue; */
	/* struct	hw_txqueue	vo_txqueue; */
	/* struct	hw_txqueue	bmc_txqueue; */

	uint	frag_len;

	_adapter	*adapter;

	u8   vcs_setting;
	u8	vcs;
	u8	vcs_type;
	/* u16  rts_thresh; */

	u64	tx_bytes;
	u64	tx_pkts;
	u64	tx_drop;
	u64	last_tx_pkts;

	struct hw_xmit *hwxmits;
	u8	hwxmit_entry;

	u8	wmm_para_seq[4];/* sequence for wmm ac parameter strength from large to small. it's value is 0->vo, 1->vi, 2->be, 3->bk. */

#ifdef CONFIG_USB_HCI
	_sema	tx_retevt;/* all tx return event; */
	u8		txirp_cnt;

	_tasklet xmit_tasklet;

	/* per AC pending irp */
	int beq_cnt;
	int bkq_cnt;
	int viq_cnt;
	int voq_cnt;

#endif

#ifdef CONFIG_PCI_HCI
	/* Tx */
	struct rtw_tx_ring	tx_ring[PCI_MAX_TX_QUEUE_COUNT];
	int	txringcount[PCI_MAX_TX_QUEUE_COUNT];
	u8 	beaconDMAing;		/* flag of indicating beacon is transmiting to HW by DMA */
	_tasklet xmit_tasklet;
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
#ifdef CONFIG_SDIO_TX_TASKLET
	_tasklet xmit_tasklet;
#else
	_thread_hdl_	SdioXmitThread;
	_sema		SdioXmitSema;
	#ifdef SDIO_FREE_XMIT_BUF_SEMA
	_sema		sdio_free_xmitbuf_sema;
	#endif
#endif /* CONFIG_SDIO_TX_TASKLET */
#endif /* CONFIG_SDIO_HCI */

	_queue free_xmitbuf_queue;
	_queue pending_xmitbuf_queue;
	u8 *pallocated_xmitbuf;
	u8 *pxmitbuf;
	uint free_xmitbuf_cnt;

	_queue free_xmit_extbuf_queue;
	u8 *pallocated_xmit_extbuf;
	u8 *pxmit_extbuf;
	uint free_xmit_extbuf_cnt;

	struct xmit_buf	pcmd_xmitbuf[CMDBUF_MAX];
	u8   hw_ssn_seq_no;/* mapping to REG_HW_SEQ 0,1,2,3 */
	u16	nqos_ssn;
#ifdef CONFIG_TX_EARLY_MODE

#ifdef CONFIG_SDIO_HCI
#define MAX_AGG_PKT_NUM 20
#else
#define MAX_AGG_PKT_NUM 256 /* Max tx ampdu coounts		 */
#endif

	struct agg_pkt_info agg_pkt[MAX_AGG_PKT_NUM];
#endif

#ifdef CONFIG_XMIT_ACK
	int	ack_tx;
	_mutex ack_tx_mutex;
	struct submit_ctx ack_tx_ops;
	u8 seq_no;
#endif

#ifdef CONFIG_TX_AMSDU
	_timer amsdu_vo_timer;
	u8 amsdu_vo_timeout;

	_timer amsdu_vi_timer;
	u8 amsdu_vi_timeout;

	_timer amsdu_be_timer;
	u8 amsdu_be_timeout;

	_timer amsdu_bk_timer;
	u8 amsdu_bk_timeout;

	u32 amsdu_debug_set_timer;
	u32 amsdu_debug_timeout;
	u32 amsdu_debug_coalesce_one;
	u32 amsdu_debug_coalesce_two;

#endif
#ifdef DBG_TXBD_DESC_DUMP
	BOOLEAN	 dump_txbd_desc;
#endif
#ifdef CONFIG_PCI_TX_POLLING
	_timer tx_poll_timer;
#endif
	_lock lock_sctx;

};

extern struct xmit_frame *__rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_cmdxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_RSVD)
#if defined(CONFIG_RTL8192E) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8192ee(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8192ee(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8822B) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8822be(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8822be(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8822C) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8822ce(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8822ce(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8821C) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8821ce(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8821ce(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8192F) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8192fe(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8192fe(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8812A) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8812ae(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8812ae(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8723D) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8723de(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8723de(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8723B) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8723be(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8723be(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8814A) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8814ae(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8814ae(p, CMDBUF_BEACON)
#elif defined(CONFIG_RTL8814B) && defined(CONFIG_PCI_HCI)
extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8814be(struct xmit_priv *pxmitpriv,
		enum cmdbuf_type buf_type);
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8814be(p, CMDBUF_BEACON)
#else
#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_BEACON)
#endif

extern struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv);
extern s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);

extern struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
extern s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);

void rtw_count_tx_stats(_adapter *padapter, struct xmit_frame *pxmitframe, int sz);
extern void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len);

extern s32 rtw_make_wlanhdr(_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
extern s32 rtw_put_snap(u8 *data, u16 h_proto);

extern struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
struct xmit_frame *rtw_alloc_xmitframe_ext(struct xmit_priv *pxmitpriv);
struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv);
extern s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue);
struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta, sint up, u8 *ac);
extern s32 rtw_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
extern struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, sint entry);

extern s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
extern u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
#define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
extern s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
#if defined(CONFIG_IEEE80211W) || defined(CONFIG_RTW_MESH)
extern s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
#endif
#ifdef CONFIG_TDLS
extern struct tdls_txmgmt *ptxmgmt;
s32 rtw_xmit_tdls_coalesce(_adapter *padapter, struct xmit_frame *pxmitframe, struct tdls_txmgmt *ptxmgmt);
s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
#endif
s32 _rtw_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag);
void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);


s32 rtw_txframes_pending(_adapter *padapter);
s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry);


s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv);


void rtw_alloc_hwxmits(_adapter *padapter);
void rtw_free_hwxmits(_adapter *padapter);
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev);
#endif
void rtw_xmit_dequeue_callback(_workitem *work);
void rtw_xmit_queue_set(struct sta_info *sta);
void rtw_xmit_queue_clear(struct sta_info *sta);
s32 rtw_xmit_posthandle(_adapter *padapter, struct xmit_frame *pxmitframe, _pkt *pkt);
s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
bool xmitframe_hiq_filter(struct xmit_frame *xmitframe);
#if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta);
#endif

u8 rtw_get_tx_bw_mode(_adapter *adapter, struct sta_info *sta);

void rtw_update_tx_rate_bmp(struct dvobj_priv *dvobj);
u8 rtw_get_tx_bw_bmp_of_ht_rate(struct dvobj_priv *dvobj, u8 rate, u8 max_bw);
u8 rtw_get_tx_bw_bmp_of_vht_rate(struct dvobj_priv *dvobj, u8 rate, u8 max_bw);
s16 rtw_adapter_get_oper_txpwr_max_mbm(_adapter *adapter);
s16 rtw_get_oper_txpwr_max_mbm(struct dvobj_priv *dvobj);

u8 query_ra_short_GI(struct sta_info *psta, u8 bw);

u8	qos_acm(u8 acm_mask, u8 priority);

#ifdef CONFIG_XMIT_THREAD_MODE
void	enqueue_pending_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
void enqueue_pending_xmitbuf_to_head(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
struct xmit_buf	*dequeue_pending_xmitbuf(struct xmit_priv *pxmitpriv);
struct xmit_buf	*select_and_dequeue_pending_xmitbuf(_adapter *padapter);
sint	check_pending_xmitbuf(struct xmit_priv *pxmitpriv);
thread_return	rtw_xmit_thread(thread_context context);
#endif

#ifdef CONFIG_TX_AMSDU
extern void rtw_amsdu_vo_timeout_handler(void *FunctionContext);
extern void rtw_amsdu_vi_timeout_handler(void *FunctionContext);
extern void rtw_amsdu_be_timeout_handler(void *FunctionContext);
extern void rtw_amsdu_bk_timeout_handler(void *FunctionContext);

extern u8 rtw_amsdu_get_timer_status(_adapter *padapter, u8 priority);
extern void rtw_amsdu_set_timer_status(_adapter *padapter, u8 priority, u8 status);
extern void rtw_amsdu_set_timer(_adapter *padapter, u8 priority);
extern void rtw_amsdu_cancel_timer(_adapter *padapter, u8 priority);

extern s32 rtw_xmitframe_coalesce_amsdu(_adapter *padapter, struct xmit_frame *pxmitframe, struct xmit_frame *pxmitframe_queue);	
extern s32 check_amsdu(struct xmit_frame *pxmitframe);
extern s32 check_amsdu_tx_support(_adapter *padapter);
extern struct xmit_frame *rtw_get_xframe(struct xmit_priv *pxmitpriv, int *num_frame);
#endif

#ifdef DBG_TXBD_DESC_DUMP
void rtw_tx_desc_backup(_adapter *padapter, struct xmit_frame *pxmitframe, u8 desc_size, u8 hwq);
void rtw_tx_desc_backup_reset(void);
u8 rtw_get_tx_desc_backup(_adapter *padapter, u8 hwq, struct rtw_tx_desc_backup **pbak);
#endif

#ifdef CONFIG_PCI_TX_POLLING
void rtw_tx_poll_init(_adapter *padapter);
void rtw_tx_poll_timeout_handler(void *FunctionContext);
void rtw_tx_poll_timer_set(_adapter *padapter, u32 delay);
void rtw_tx_poll_timer_cancel(_adapter *padapter);
#endif

u32	rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe);

#ifdef CONFIG_XMIT_ACK
int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms);
void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status);
#endif /* CONFIG_XMIT_ACK */

enum XMIT_BLOCK_REASON {
	XMIT_BLOCK_NONE = 0,
	XMIT_BLOCK_REDLMEM = BIT0, /*LPS-PG*/
	XMIT_BLOCK_SUSPEND = BIT1, /*WOW*/
	XMIT_BLOCK_MAX = 0xFF,
};
void rtw_init_xmit_block(_adapter *padapter);
void rtw_deinit_xmit_block(_adapter *padapter);

#ifdef DBG_XMIT_BLOCK
void dump_xmit_block(void *sel, _adapter *padapter);
#endif
void rtw_set_xmit_block(_adapter *padapter, enum XMIT_BLOCK_REASON reason);
void rtw_clr_xmit_block(_adapter *padapter, enum XMIT_BLOCK_REASON reason);
bool rtw_is_xmit_blocked(_adapter *padapter);

/* include after declaring struct xmit_buf, in order to avoid warning */
#include <xmit_osdep.h>

#endif /* _RTL871X_XMIT_H_ */
                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/include/rtl8814a_hal.h                                                                0000755 0001750 0001750 00000032536 14214766567 015724  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_HAL_H__
#define __RTL8814A_HAL_H__

/* #include "hal_com.h" */
#include "hal_data.h"

/* include HAL Related header after HAL Related compiling flags */
#include "rtl8814a_spec.h"
#include "rtl8814a_rf.h"
#include "rtl8814a_dm.h"
#include "rtl8814a_recv.h"
#include "rtl8814a_xmit.h"
#include "rtl8814a_cmd.h"
#include "rtl8814a_led.h"
#include "Hal8814PwrSeq.h"
#include "Hal8814PhyReg.h"
#include "Hal8814PhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8814a_sreset.h"
#endif /* DBG_CONFIG_ERROR_DETECT */

enum {
	VOLTAGE_V25						= 0x03,
	LDOE25_SHIFT					= 28 ,
};
/* max. iram is 64k , max dmen is 32k. Total = 96k = 0x18000*/
#define FW_SIZE							0x18000
#define FW_START_ADDRESS   0x1000
typedef struct _RT_FIRMWARE_8814 {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8814, *PRT_FIRMWARE_8814;

#define PAGE_SIZE_TX_8814	PAGE_SIZE_128
/* BCN rsvd_page_num = MAX_BEACON_LEN / PAGE_SIZE_TX_8814
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/

#define BCNQ_PAGE_NUM_8814		(MAX_BEACON_LEN / PAGE_SIZE_TX_8814 + 6) /*0x08*/

#define Rtl8814A_NIC_PWR_ON_FLOW				rtl8814A_power_on_flow
#define Rtl8814A_NIC_RF_OFF_FLOW				rtl8814A_radio_off_flow
#define Rtl8814A_NIC_DISABLE_FLOW				rtl8814A_card_disable_flow
#define Rtl8814A_NIC_ENABLE_FLOW				rtl8814A_card_enable_flow
#define Rtl8814A_NIC_SUSPEND_FLOW				rtl8814A_suspend_flow
#define Rtl8814A_NIC_RESUME_FLOW				rtl8814A_resume_flow
#define Rtl8814A_NIC_PDN_FLOW					rtl8814A_hwpdn_flow
#define Rtl8814A_NIC_LPS_ENTER_FLOW			rtl8814A_enter_lps_flow
#define Rtl8814A_NIC_LPS_LEAVE_FLOW			rtl8814A_leave_lps_flow

/* *****************************************************
 *				New	Firmware Header(8-byte alinment required)
 * *****************************************************
 * --- LONG WORD 0 ---- */
#define GET_FIRMWARE_HDR_SIGNATURE_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16)
#define GET_FIRMWARE_HDR_CATEGORY_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) /* AP/NIC and USB/PCI */
#define GET_FIRMWARE_HDR_FUNCTION_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr, 24, 8) /* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
#define GET_FIRMWARE_HDR_VERSION_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)/* FW Version */
#define GET_FIRMWARE_HDR_SUB_VER_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) /* FW Subversion, default 0x00 */
#define GET_FIRMWARE_HDR_SUB_IDX_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8) /* FW Subversion Index */

/* --- LONG WORD 1 ---- */
#define GET_FIRMWARE_HDR_SVN_IDX_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 32)/* The SVN entry index */
#define GET_FIRMWARE_HDR_RSVD1_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 0, 32)

/* --- LONG WORD 2 ---- */
#define GET_FIRMWARE_HDR_MONTH_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+16, 0, 8) /* Release time Month field */
#define GET_FIRMWARE_HDR_DATE_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+16, 8, 8) /* Release time Date field */
#define GET_FIRMWARE_HDR_HOUR_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+16, 16, 8)/* Release time Hour field */
#define GET_FIRMWARE_HDR_MINUTE_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+16, 24, 8)/* Release time Minute field */
#define GET_FIRMWARE_HDR_YEAR_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+20, 0, 16)/* Release time Year field */
#define GET_FIRMWARE_HDR_FOUNDRY_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 16, 8)/* Release time Foundry field */
#define GET_FIRMWARE_HDR_RSVD2_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 24, 8)

/* --- LONG WORD 3 ---- */
#define GET_FIRMWARE_HDR_MEM_UASGE_DL_FROM_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+24, 0, 1)
#define GET_FIRMWARE_HDR_MEM_UASGE_BOOT_FROM_3081(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+24, 1, 1)
#define GET_FIRMWARE_HDR_MEM_UASGE_BOOT_LOADER_3081(__FwHdr)LE_BITS_TO_4BYTE(__FwHdr+24, 2, 1)
#define GET_FIRMWARE_HDR_MEM_UASGE_IRAM_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 3, 1)
#define GET_FIRMWARE_HDR_MEM_UASGE_ERAM_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 4, 1)
#define GET_FIRMWARE_HDR_MEM_UASGE_RSVD4_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+24, 5, 3)
#define GET_FIRMWARE_HDR_RSVD3_3081(__FwHdr)					LE_BITS_TO_4BYTE(__FwHdr+24, 8, 8)
#define GET_FIRMWARE_HDR_BOOT_LOADER_SZ_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 16, 16)
#define GET_FIRMWARE_HDR_RSVD5_3081(__FwHdr)					LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)

/* --- LONG WORD 4 ---- */
#define GET_FIRMWARE_HDR_TOTAL_DMEM_SZ_3081(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+36, 0, 32)
#define GET_FIRMWARE_HDR_FW_CFG_SZ_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+36, 0, 16)
#define GET_FIRMWARE_HDR_FW_ATTR_SZ_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+36, 16, 16)

/* --- LONG WORD 5 ---- */
#define GET_FIRMWARE_HDR_IROM_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+40, 0, 32)
#define GET_FIRMWARE_HDR_EROM_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+44, 0, 32)

/* --- LONG WORD 6 ---- */
#define GET_FIRMWARE_HDR_IRAM_SZ_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+48, 0, 32)
#define GET_FIRMWARE_HDR_ERAM_SZ_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+52, 0, 32)

/* --- LONG WORD 7 ---- */
#define GET_FIRMWARE_HDR_RSVD6_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+56, 0, 32)
#define GET_FIRMWARE_HDR_RSVD7_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+60, 0, 32)



/*
 * 2013/08/16 MH MOve from SDIO.h for common use.
 *   */
#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
	#define TRX_SHARE_MODE_8814A				0	/* TRX Buffer Share Index */
	#define BASIC_RXFF_SIZE_8814A				24576/* Basic RXFF Size is 24K = 24*1024 Unit: Byte */
	#define TRX_SHARE_BUFF_UNIT_8814A			65536/* TRX Share Buffer unit Size 64K = 64*1024 Unit: Byte */
	#define TRX_SHARE_BUFF_UNIT_PAGE_8814A	(TRX_SHARE_BUFF_UNIT_8814A/PAGE_SIZE_8814A)/* 512 Pages */

	/* Origin: */
	#define  HPQ_PGNUM_8814A					0x20	/* High Queue */
	#define  LPQ_PGNUM_8814A					0x20	/* Low Queue */
	#define  NPQ_PGNUM_8814A					0x20	/* Normal Queue */
	#define  EPQ_PGNUM_8814A					0x20	/* Extra Queue */

#else	/*  #if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI) */

	#define  HPQ_PGNUM_8814A		20
	#define  NPQ_PGNUM_8814A		20
	#define  LPQ_PGNUM_8814A		20 /* 1972 */
	#define  EPQ_PGNUM_8814A		20
	#define  BCQ_PGNUM_8814A		32

#endif /* #if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI) */

#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8814	0x06
#else
	#define WOWLAN_PAGE_NUM_8814	0x00
#endif

#define PAGE_SIZE_8814A						128/* TXFF Page Size, Unit: Byte */
#define MAX_RX_DMA_BUFFER_SIZE_8814A		0x5C00	/* BASIC_RXFF_SIZE_8814A + TRX_SHARE_MODE_8814A * TRX_SHARE_BUFF_UNIT_8814A */ /* Basic RXFF Size + ShareBuffer Size */
#define TX_PAGE_BOUNDARY_8814A			TXPKT_PGNUM_8814A	/* Need to enlarge boundary, by KaiYuan */
#define TX_PAGE_BOUNDARY_WOWLAN_8814A	TXPKT_PGNUM_8814A	/* TODO: 20130415 KaiYuan Check this value later */

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8814A	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8814A	0x0	/* 0B */
#endif
#define RX_DMA_BOUNDARY_8814A		(MAX_RX_DMA_BUFFER_SIZE_8814A - RX_DMA_RESERVED_SIZE_8814A - 1)

#define  TOTAL_PGNUM_8814A		2048
#define  TXPKT_PGNUM_8814A		(2048 - BCNQ_PAGE_NUM_8814-WOWLAN_PAGE_NUM_8814)
#define  PUB_PGNUM_8814A		(TXPKT_PGNUM_8814A-HPQ_PGNUM_8814A-NPQ_PGNUM_8814A-LPQ_PGNUM_8814A-EPQ_PGNUM_8814A)

/* Note: For WMM Normal Chip Setting ,modify later */
#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8814A	TX_PAGE_BOUNDARY_8814A
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8814A		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8814A + 1)

#define DRIVER_EARLY_INT_TIME_8814		0x05
#define BCN_DMA_ATIME_INT_TIME_8814		0x02


#define MAX_PAGE_SIZE			4096	/* @ page : 4k bytes */

#define EFUSE_MAX_SECTION_JAGUAR				64

#define	HWSET_MAX_SIZE_8814A			512

#define	EFUSE_REAL_CONTENT_LEN_8814A	1024
#define	EFUSE_MAX_BANK_8814A		2

#define	EFUSE_MAP_LEN_8814A			512
#define	EFUSE_MAX_SECTION_8814A		64
#define	EFUSE_MAX_WORD_UNIT_8814A		4
#define	EFUSE_PROTECT_BYTES_BANK_8814A		16

#define	EFUSE_IC_ID_OFFSET_8814A		506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define AVAILABLE_EFUSE_ADDR_8814A(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8814A)

/*-------------------------------------------------------------------------
Chip specific
-------------------------------------------------------------------------*/

/* pic buffer descriptor */
#if 1 /* according to the define in the rtw_xmit.h, rtw_recv.h */
	#define RTL8814AE_SEG_NUM  TX_BUFFER_SEG_NUM /* 0:2 seg, 1: 4 seg, 2: 8 seg */
	#define TX_DESC_NUM_8814A  TX_BD_NUM   /* 128 */
	#define RX_DESC_NUM_8814A  PCI_MAX_RX_COUNT /* 128 */
	#ifdef CONFIG_CONCURRENT_MODE
		#define BE_QUEUE_TX_DESC_NUM_8814A  (TX_BD_NUM<<1)    /* 256 */
	#else
		#define BE_QUEUE_TX_DESC_NUM_8814A  (TX_BD_NUM+(TX_BD_NUM>>1)) /* 192 */
	#endif
#else
	#define RTL8814AE_SEG_NUM  TX_BUFFER_SEG_NUM /* 0:2 seg, 1: 4 seg, 2: 8 seg */
	#define TX_DESC_NUM_8814A  128 /* 1024//2048 change by ylb 20130624 */
	#define RX_DESC_NUM_8814A  128 /* 1024 //512 change by ylb 20130624 */
#endif

/* <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
 * 9bytes + 1byt + 5bytes and pre 1byte.
 * For worst case:
 * | 1byte|----8bytes----|1byte|--5bytes--|
 * |         |            Reserved(14bytes)	      |
 *   */
#define	EFUSE_OOB_PROTECT_BYTES		15	/* PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte. */

#ifdef CONFIG_FILE_FWIMG
extern char *rtw_fw_file_path;
#ifdef CONFIG_WOWLAN
extern char *rtw_fw_wow_file_path;
#endif
#ifdef CONFIG_MP_INCLUDED
extern char *rtw_fw_mp_bt_file_path;
#endif /* CONFIG_MP_INCLUDED */
#endif /* CONFIG_FILE_FWIMG */

/* rtl8814_hal_init.c */
s32 FirmwareDownload8814A(PADAPTER	Adapter, BOOLEAN bUsedWoWLANFw);
void	InitializeFirmwareVars8814(PADAPTER padapter);

void
Hal_InitEfuseVars_8814A(
		PADAPTER	Adapter
);

s32 InitLLTTable8814A(
		PADAPTER	Adapter
);


void InitRDGSetting8814A(PADAPTER padapter);

/* void CheckAutoloadState8812A(PADAPTER padapter); */

/* EFuse */
u8	GetEEPROMSize8814A(PADAPTER padapter);
void hal_InitPGData_8814A(
		PADAPTER padapter,
		u8 *PROMContent
);

void	hal_ReadPROMVersion8814A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	hal_ReadTxPowerInfo8814A(PADAPTER padapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);
void	hal_ReadBoardType8814A(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	hal_ReadThermalMeter_8814A(PADAPTER	Adapter, u8 *PROMContent, BOOLEAN	AutoloadFail);
void	hal_ReadChannelPlan8814A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	hal_EfuseParseXtal_8814A(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	hal_ReadAntennaDiversity8814A(PADAPTER pAdapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
void	hal_Read_TRX_antenna_8814A(PADAPTER	Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void hal_ReadAmplifierType_8814A(
		PADAPTER		Adapter
);
void hal_ReadPAType_8814A(
		PADAPTER	Adapter,
		u8			*PROMContent,
		BOOLEAN		AutoloadFail,
		u8		*pPAType,
		u8		*pLNAType
);

void hal_GetRxGainOffset_8814A(
	PADAPTER	Adapter,
	u8 			*PROMContent,
	BOOLEAN		AutoloadFail
);
void Hal_EfuseParseKFreeData_8814A(
			PADAPTER		Adapter,
			u8				*PROMContent,
			BOOLEAN			AutoloadFail);
void	hal_ReadRFEType_8814A(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	hal_EfuseParseBTCoexistInfo8814A(PADAPTER Adapter, u8 *hwinfo, BOOLEAN AutoLoadFail);

/* void	hal_ReadUsbType_8812AU(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
 * int	FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware); */
void	hal_ReadRemoteWakeup_8814A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
u8	MgntQuery_NssTxRate(u16 Rate);

/* BOOLEAN HalDetectPwrDownMode8812(PADAPTER Adapter); */

#ifdef CONFIG_WOWLAN
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void _InitBeaconParameters_8814A(PADAPTER padapter);
void SetBeaconRelatedRegisters8814A(PADAPTER padapter);

void ReadRFType8814A(PADAPTER padapter);
void InitDefaultValue8814A(PADAPTER padapter);

u8 SetHwReg8814A(PADAPTER padapter, u8 variable, u8 *pval);
void GetHwReg8814A(PADAPTER padapter, u8 variable, u8 *pval);
u8 SetHalDefVar8814A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8814A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
void rtl8814_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8814a(_adapter *adapter);

void rtl8814_start_thread(PADAPTER padapter);
void rtl8814_stop_thread(PADAPTER padapter);


#ifdef CONFIG_PCI_HCI
	BOOLEAN	InterruptRecognized8814AE(PADAPTER Adapter);
	void	UpdateInterruptMask8814AE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
	void	InitMAC_TRXBD_8814AE(PADAPTER Adapter);
	u16	get_txbd_rw_reg(u16 ff_hwaddr);
#endif

#ifdef CONFIG_BT_COEXIST
	void rtl8814a_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
#endif

#endif /* __RTL8188E_HAL_H__ */
                                                                                                                                                                  rtl8822bu/src/include/rtl8723d_dm.h                                                                 0000644 0001750 0001750 00000002615 14214766567 015552  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_DM_H__
#define __RTL8723D_DM_H__
/* ************************************************************
 * Description:
 *
 * This file is for 8723D dynamic mechanism only
 *
 *
 * ************************************************************ */

/* ************************************************************
 * structure and define
 * ************************************************************ */

/* ************************************************************
 * function prototype
 * ************************************************************ */

void rtl8723d_init_dm_priv(PADAPTER padapter);
void rtl8723d_deinit_dm_priv(PADAPTER padapter);

void rtl8723d_InitHalDm(PADAPTER padapter);
void rtl8723d_HalDmWatchDog(PADAPTER padapter);

#endif
                                                                                                                   rtl8822bu/src/include/rtl8710b_cmd.h                                                                0000644 0001750 0001750 00000023705 14214766567 015712  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_CMD_H__
#define __RTL8710B_CMD_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

enum h2c_cmd_8710B {
	/* Common Class: 000 */
	H2C_8710B_RSVD_PAGE = 0x00,
	H2C_8710B_MEDIA_STATUS_RPT = 0x01,
	H2C_8710B_SCAN_ENABLE = 0x02,
	H2C_8710B_KEEP_ALIVE = 0x03,
	H2C_8710B_DISCON_DECISION = 0x04,
	H2C_8710B_PSD_OFFLOAD = 0x05,
	H2C_8710B_AP_OFFLOAD = 0x08,
	H2C_8710B_BCN_RSVDPAGE = 0x09,
	H2C_8710B_PROBERSP_RSVDPAGE = 0x0A,
	H2C_8710B_FCS_RSVDPAGE = 0x10,
	H2C_8710B_FCS_INFO = 0x11,
	H2C_8710B_AP_WOW_GPIO_CTRL = 0x13,

	/* PoweSave Class: 001 */
	H2C_8710B_SET_PWR_MODE = 0x20,
	H2C_8710B_PS_TUNING_PARA = 0x21,
	H2C_8710B_PS_TUNING_PARA2 = 0x22,
	H2C_8710B_P2P_LPS_PARAM = 0x23,
	H2C_8710B_P2P_PS_OFFLOAD = 0x24,
	H2C_8710B_PS_SCAN_ENABLE = 0x25,
	H2C_8710B_SAP_PS_ = 0x26,
	H2C_8710B_INACTIVE_PS_ = 0x27, /* Inactive_PS */
	H2C_8710B_FWLPS_IN_IPS_ = 0x28,

	/* Dynamic Mechanism Class: 010 */
	H2C_8710B_MACID_CFG = 0x40,
	H2C_8710B_TXBF = 0x41,
	H2C_8710B_RSSI_SETTING = 0x42,
	H2C_8710B_AP_REQ_TXRPT = 0x43,
	H2C_8710B_INIT_RATE_COLLECT = 0x44,
	H2C_8710B_RA_PARA_ADJUST = 0x46,

	/* WOWLAN Class: 100 */
	H2C_8710B_WOWLAN = 0x80,
	H2C_8710B_REMOTE_WAKE_CTRL = 0x81,
	H2C_8710B_AOAC_GLOBAL_INFO = 0x82,
	H2C_8710B_AOAC_RSVD_PAGE = 0x83,
	H2C_8710B_AOAC_RSVD_PAGE2 = 0x84,
	H2C_8710B_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_8710B_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_8710B_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_8710B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
	H2C_8710B_P2P_OFFLOAD = 0x8B,

	H2C_8710B_RESET_TSF = 0xC0,
	H2C_8710B_MAXID,
};

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * _RSVDPAGE_LOC_CMD_0x00 */
#define SET_8710B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8710B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8710B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8710B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8710B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _PWR_MOD_CMD_0x20 */
#define SET_8710B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8710B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8710B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8710B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8710B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8710B_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8710B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8710B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _PS_TUNE_PARAM_CMD_0x21 */
#define SET_8710B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8710B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8710B_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
#define SET_8710B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
#define SET_8710B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _MACID_CFG_CMD_0x40 */
#define SET_8710B_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
#define SET_8710B_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)

/* _RSSI_SETTING_CMD_0x42 */
#define SET_8710B_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8710B_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
#define SET_8710B_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _AP_REQ_TXRPT_CMD_0x43 */
#define SET_8710B_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8710B_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _FORCE_BT_TXPWR_CMD_0x62 */
#define SET_8710B_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)

/* _FORCE_BT_MP_OPER_CMD_0x67 */
#define SET_8710B_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_8710B_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_8710B_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8710B_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_8710B_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8710B_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)

/* _BT_FW_PATCH_0x6A */
#define SET_8710B_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8710B_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8710B_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8710B_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_8710B_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)

/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    Function Statement     --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

/* host message to firmware cmd */
void rtl8710b_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8710b_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
/* s32 rtl8710b_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable); */
void rtl8710b_set_FwPsTuneParam_cmd(PADAPTER padapter);
void rtl8710b_download_rsvd_page(PADAPTER padapter, u8 mstatus);
#ifdef CONFIG_BT_COEXIST
	void rtl8710b_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P
	void rtl8710b_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
void rtl8710b_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
#endif
#endif

#ifdef CONFIG_P2P_WOWLAN
	void rtl8710b_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
#endif

s32 FillH2CCmd8710B(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8710B(_adapter *padapter, bool wowlan);
#endif
                                                           rtl8822bu/src/include/osdep_intf.h                                                                  0000644 0001750 0001750 00000010044 14214766567 015726  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef __OSDEP_INTF_H_
#define __OSDEP_INTF_H_


struct intf_priv {

	u8 *intf_dev;
	u32	max_iosz;	/* USB2.0: 128, USB1.1: 64, SDIO:64 */
	u32	max_xmitsz; /* USB2.0: unlimited, SDIO:512 */
	u32	max_recvsz; /* USB2.0: unlimited, SDIO:512 */

	volatile u8 *io_rwmem;
	volatile u8 *allocated_io_rwmem;
	u32	io_wsz; /* unit: 4bytes */
	u32	io_rsz;/* unit: 4bytes */
	u8 intf_status;

	void (*_bus_io)(u8 *priv);

	/*
	Under Sync. IRP (SDIO/USB)
	A protection mechanism is necessary for the io_rwmem(read/write protocol)

	Under Async. IRP (SDIO/USB)
	The protection mechanism is through the pending queue.
	*/

	_mutex ioctl_mutex;


#ifdef PLATFORM_LINUX
#ifdef CONFIG_USB_HCI
	/* when in USB, IO is through interrupt in/out endpoints */
	struct usb_device	*udev;
	PURB	piorw_urb;
	u8 io_irp_cnt;
	u8 bio_irp_pending;
	_sema io_retevt;
	_timer	io_timer;
	u8 bio_irp_timeout;
	u8 bio_timer_cancel;
#endif
#endif

};

struct dvobj_priv *devobj_init(void);
void devobj_deinit(struct dvobj_priv *pdvobj);

u8 rtw_init_drv_sw(_adapter *padapter);
u8 rtw_free_drv_sw(_adapter *padapter);
u8 rtw_reset_drv_sw(_adapter *padapter);
void rtw_dev_unload(PADAPTER padapter);

u32 rtw_start_drv_threads(_adapter *padapter);
void rtw_stop_drv_threads(_adapter *padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
void rtw_cancel_dynamic_chk_timer(_adapter *padapter);
#endif
void rtw_cancel_all_timer(_adapter *padapter);

uint loadparam(_adapter *adapter);

#ifdef PLATFORM_LINUX
int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);

int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname);
struct net_device *rtw_init_netdev(_adapter *padapter);

void rtw_os_ndev_free(_adapter *adapter);
int rtw_os_ndev_init(_adapter *adapter, const char *name);
void rtw_os_ndev_deinit(_adapter *adapter);
void rtw_os_ndev_unregister(_adapter *adapter);
void rtw_os_ndevs_unregister(struct dvobj_priv *dvobj);
int rtw_os_ndevs_init(struct dvobj_priv *dvobj);
void rtw_os_ndevs_deinit(struct dvobj_priv *dvobj);

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
u16 rtw_recv_select_queue(struct sk_buff *skb);
#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35) */

int rtw_ndev_notifier_register(void);
void rtw_ndev_notifier_unregister(void);
void rtw_inetaddr_notifier_register(void);
void rtw_inetaddr_notifier_unregister(void);

#include "../os_dep/linux/rtw_proc.h"

#ifdef CONFIG_IOCTL_CFG80211
	#include "../os_dep/linux/ioctl_cfg80211.h"
#endif /* CONFIG_IOCTL_CFG80211 */

u8 rtw_rtnl_lock_needed(struct dvobj_priv *dvobj);
void rtw_set_rtnl_lock_holder(struct dvobj_priv *dvobj, _thread_hdl_ thd_hdl);

#endif /* PLATFORM_LINUX */


#ifdef PLATFORM_FREEBSD
extern int rtw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
#endif

void rtw_ips_dev_unload(_adapter *padapter);

#ifdef CONFIG_IPS
int rtw_ips_pwr_up(_adapter *padapter);
void rtw_ips_pwr_down(_adapter *padapter);
#endif

#ifdef CONFIG_CONCURRENT_MODE
struct _io_ops;
struct dvobj_priv;
_adapter *rtw_drv_add_vir_if(_adapter *primary_padapter, void (*set_intf_ops)(_adapter *primary_padapter, struct _io_ops *pops));
void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj);
void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj);
#endif

void rtw_ndev_destructor(_nic_hdl ndev);
#ifdef CONFIG_ARP_KEEP_ALIVE
int rtw_gw_addr_query(_adapter *padapter);
#endif

int rtw_suspend_common(_adapter *padapter);
int rtw_resume_common(_adapter *padapter);

#endif /* _OSDEP_INTF_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/Hal8192EPwrSeq.h                                                              0000644 0001750 0001750 00000031667 14214766567 016111  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8192E
#define REALTEK_POWER_SEQUENCE_8192E

#include "HalPwrSeqCmd.h"
/*
	Check document WM-20110607-Paul-RTL8192E_Power_Architecture-R02.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8192E_TRANS_CARDEMU_TO_ACT_STEPS	18
#define	RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS	18
#define	RTL8192E_TRANS_CARDEMU_TO_SUS_STEPS	18
#define	RTL8192E_TRANS_SUS_TO_CARDEMU_STEPS	18
#define	RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS	18
#define	RTL8192E_TRANS_PDN_TO_CARDEMU_STEPS	18
#define	RTL8192E_TRANS_ACT_TO_LPS_STEPS	23
#define	RTL8192E_TRANS_LPS_TO_ACT_STEPS	23
#define	RTL8192E_TRANS_END_STEPS	1


#define RTL8192E_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3), 0},/* disable WL suspend*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	\


#define RTL8192E_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\


#define RTL8192E_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, (BIT4 | BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8192E_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8192E_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x00CC, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*Unlock small LDO Register*/	\
	{0x0011, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*Disable small LDO*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8192E_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0011, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*Enable small LDO*/	\
	{0x00CC, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0}, /*Lock small LDO Register*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\


#define RTL8192E_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8192E_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8192E_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8192E_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM, For Repeatly In and out, Taggle bit should be changed*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/\
	{0x013D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*Clear ISR*/

#define RTL8192E_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8192E_power_on_flow[RTL8192E_TRANS_CARDEMU_TO_ACT_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_radio_off_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_card_disable_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_card_enable_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_suspend_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8192E_TRANS_CARDEMU_TO_SUS_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_resume_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8192E_TRANS_CARDEMU_TO_SUS_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_hwpdn_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_enter_lps_flow[RTL8192E_TRANS_ACT_TO_LPS_STEPS + RTL8192E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8192E_leave_lps_flow[RTL8192E_TRANS_LPS_TO_ACT_STEPS + RTL8192E_TRANS_END_STEPS];

#endif
                                                                         rtl8822bu/src/include/rtl8821a_xmit.h                                                               0000644 0001750 0001750 00000010234 14214766567 016123  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8821A_XMIT_H__
#define __RTL8821A_XMIT_H__

#include <drv_types.h>

typedef struct txdescriptor_8821a {
	/* Offset 0 */
	u32 pktlen:16;
	u32 offset:8;
	u32 bmc:1;
	u32 htc:1;
	u32 rsvd0026:1;
	u32 rsvd0027:1;
	u32 linip:1;
	u32 noacm:1;
	u32 gf:1;
	u32 rsvd0031:1;

	/* Offset 4 */
	u32 macid:7;
	u32 rsvd0407:1;
	u32 qsel:5;
	u32 rdg_nav_ext:1;
	u32 lsig_txop_en:1;
	u32 pifs:1;
	u32 rate_id:5;
	u32 en_desc_id:1;
	u32 sectype:2;
	u32 pkt_offset:5; /* unit: 8 bytes */
	u32 moredata:1;
	u32 txop_ps_cap:1;
	u32 txop_ps_mode:1;

	/* Offset 8 */
	u32 p_aid:9;
	u32 rsvd0809:1;
	u32 cca_rts:2;
	u32 agg_en:1;
	u32 rdg_en:1;
	u32 null_0:1;
	u32 null_1:1;
	u32 bk:1;
	u32 morefrag:1;
	u32 raw:1;
	u32 spe_rpt:1;
	u32 ampdu_density:3;
	u32 bt_null:1;
	u32 g_id:6;
	u32 rsvd0830:2;

	/* Offset 12 */
	u32 wheader_len:4;
	u32 chk_en:1;
	u32 early_rate:1;
	u32 hw_ssn_sel:2;
	u32 userate:1;
	u32 disrtsfb:1;
	u32 disdatafb:1;
	u32 cts2self:1;
	u32 rtsen:1;
	u32 hw_rts_en:1;
	u32 port_id:1;
	u32 navusehdr:1;
	u32 use_max_len:1;
	u32 max_agg_num:5;
	u32 ndpa:2;
	u32 ampdu_max_time:8;

	/* Offset 16 */
	u32 datarate:7;
	u32 try_rate:1;
	u32 data_ratefb_lmt:5;
	u32 rts_ratefb_lmt:4;
	u32 rty_lmt_en:1;
	u32 data_rt_lmt:6;
	u32 rtsrate:5;
	u32 pcts_en:1;
	u32 pcts_mask_idx:2;

	/* Offset 20 */
	u32 data_sc:4;
	u32 data_short:1;
	u32 data_bw:2;
	u32 data_ldpc:1;
	u32 data_stbc:2;
	u32 vcs_stbc:2;
	u32 rts_short:1;
	u32 rts_sc:4;
	u32 rsvd2016:7;
	u32 tx_ant:4;
	u32 txpwr_offset:3;
	u32 rsvd2031:1;

	/* Offset 24 */
	u32 sw_define:12;
	u32 mbssid:4;
	u32 antsel_A:3;
	u32 antsel_B:3;
	u32 antsel_C:3;
	u32 antsel_D:3;
	u32 rsvd2428:4;

	/* Offset 28 */
	u32 checksum:16;
	u32 rsvd2816:8;
	u32 usb_txagg_num:8;

	/* Offset 32 */
	u32 rts_rc:6;
	u32 bar_rty_th:2;
	u32 data_rc:6;
	u32 rsvd3214:1;
	u32 en_hwseq:1;
	u32 nextneadpage:8;
	u32 tailpage:8;

	/* Offset 36 */
	u32 padding_len:11;
	u32 txbf_path:1;
	u32 seq:12;
	u32 final_data_rate:8;
} TXDESC_8821A, *PTXDESC_8821A;

#ifdef CONFIG_SDIO_HCI
s32 InitXmitPriv8821AS(PADAPTER padapter);
void FreeXmitPriv8821AS(PADAPTER padapter);
s32 XmitBufHandler8821AS(PADAPTER padapter);
s32 MgntXmit8821AS(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32	HalXmitNoLock8821AS(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 HalXmit8821AS(PADAPTER padapter, struct xmit_frame *pxmitframe);
#ifndef CONFIG_SDIO_TX_TASKLET
thread_return XmitThread8821AS(thread_context context);
#endif /* !CONFIG_SDIO_TX_TASKLET */
#endif /* CONFIG_SDIO_HCI */

#if 0
#ifdef CONFIG_USB_HCI
s32 rtl8821au_init_xmit_priv(PADAPTER padapter);
void rtl8821au_free_xmit_priv(PADAPTER padapter);
s32 rtl8821au_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8821au_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32 rtl8821au_hal_xmitframe_enqueue(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8821au_xmit_buf_handler(PADAPTER padapter);
void rtl8821au_xmit_tasklet(void *priv);
s32 rtl8821au_xmitframe_complete(PADAPTER padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif /* CONFIG_USB_HCI */

#ifdef CONFIG_PCI_HCI
s32 rtl8821e_init_xmit_priv(PADAPTER padapter);
void rtl8821e_free_xmit_priv(PADAPTER padapter);
struct xmit_buf *rtl8821e_dequeue_xmitbuf(struct rtw_tx_ring *ring);
void rtl8821e_xmitframe_resume(PADAPTER padapter);
s32 rtl8821e_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8821e_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
void rtl8821e_xmit_tasklet(void *priv);
#endif /* CONFIG_PCI_HCI */
#endif

#endif /* __RTL8821_XMIT_H__ */
                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtw_eeprom.h                                                                  0000644 0001750 0001750 00000007704 14214766567 015770  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_EEPROM_H__
#define __RTW_EEPROM_H__


#define	RTL8712_EEPROM_ID			0x8712
/* #define	EEPROM_MAX_SIZE			256 */

#define	HWSET_MAX_SIZE_128		128
#define	HWSET_MAX_SIZE_256		256
#define	HWSET_MAX_SIZE_512		512
#define HWSET_MAX_SIZE_1024		1024

#define	EEPROM_MAX_SIZE			HWSET_MAX_SIZE_1024

#define	CLOCK_RATE					50			/* 100us		 */

/* - EEPROM opcodes */
#define EEPROM_READ_OPCODE		06
#define EEPROM_WRITE_OPCODE		05
#define EEPROM_ERASE_OPCODE		07
#define EEPROM_EWEN_OPCODE		19      /* Erase/write enable */
#define EEPROM_EWDS_OPCODE		16      /* Erase/write disable */

/* Country codes */
#define USA							0x555320
#define EUROPE						0x1 /* temp, should be provided later	 */
#define JAPAN						0x2 /* temp, should be provided later */

/*
 * Customer ID, note that:
 * This variable is initiailzed through EEPROM or registry,
 * however, its definition may be different with that in EEPROM for
 * EEPROM size consideration. So, we have to perform proper translation between them.
 * Besides, CustomerID of registry has precedence of that of EEPROM.
 * defined below. 060703, by rcnjko.
 *   */
typedef enum _RT_CUSTOMER_ID {
	RT_CID_DEFAULT = 0,
	RT_CID_8187_ALPHA0 = 1,
	RT_CID_8187_SERCOMM_PS = 2,
	RT_CID_8187_HW_LED = 3,
	RT_CID_8187_NETGEAR = 4,
	RT_CID_WHQL = 5,
	RT_CID_819x_CAMEO  = 6,
	RT_CID_819x_RUNTOP = 7,
	RT_CID_819x_Senao = 8,
	RT_CID_TOSHIBA = 9,	/* Merge by Jacken, 2008/01/31. */
	RT_CID_819x_Netcore = 10,
	RT_CID_Nettronix = 11,
	RT_CID_DLINK = 12,
	RT_CID_PRONET = 13,
	RT_CID_COREGA = 14,
	RT_CID_CHINA_MOBILE = 15,
	RT_CID_819x_ALPHA = 16,
	RT_CID_819x_Sitecom = 17,
	RT_CID_CCX = 18, /* It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17. */
	RT_CID_819X_LENOVO = 19,
	RT_CID_819x_QMI = 20,
	RT_CID_819x_Edimax_Belkin = 21,
	RT_CID_819x_Sercomm_Belkin = 22,
	RT_CID_819x_CAMEO1 = 23,
	RT_CID_819x_MSI = 24,
	RT_CID_819X_ACER = 25,
	RT_CID_819x_AzWave_ASUS = 26,
	RT_CID_819x_AzWave = 27, /* For AzWave in PCIe, The ID is AzWave use and not only Asus */
	RT_CID_819x_HP = 28,
	RT_CID_819x_WNC_COREGA = 29,
	RT_CID_819x_Arcadyan_Belkin = 30,
	RT_CID_819x_SAMSUNG = 31,
	RT_CID_819x_CLEVO = 32,
	RT_CID_819x_DELL = 33,
	RT_CID_819x_PRONETS = 34,
	RT_CID_819x_Edimax_ASUS = 35,
	RT_CID_NETGEAR = 36,
	RT_CID_PLANEX = 37,
	RT_CID_CC_C = 38,
	RT_CID_819x_Xavi = 39,
	RT_CID_LENOVO_CHINA = 40,
	RT_CID_INTEL_CHINA = 41,
	RT_CID_TPLINK_HPWR = 42,
	RT_CID_819x_Sercomm_Netgear = 43,
	RT_CID_819x_ALPHA_Dlink = 44,/* add by ylb 20121012 for customer led for alpha */
	RT_CID_WNC_NEC = 45,/* add by page for NEC */
	RT_CID_DNI_BUFFALO = 46,/* add by page for NEC */
} RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;

extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
extern u16 eeprom_read16(_adapter *padapter, u16 reg);
extern void read_eeprom_content(_adapter *padapter);
extern void eeprom_read_sz(_adapter *padapter, u16 reg, u8 *data, u32 sz);

extern void read_eeprom_content_by_attrib(_adapter	*padapter);

#ifdef PLATFORM_LINUX
#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
extern int isAdaptorInfoFileValid(void);
extern int storeAdaptorInfoFile(char *path, u8 *efuse_data);
extern int retriveAdaptorInfoFile(char *path, u8 *efuse_data);
#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
#endif /* PLATFORM_LINUX */

#endif /* __RTL871X_EEPROM_H__ */
                                                            rtl8822bu/src/include/rtw_rm_util.h                                                                 0000644 0001750 0001750 00000003352 14214766567 016147  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef _RTW_RM_UTIL_H_
#define _RTW_RM_UTIL_H_
/*
 * define the following channels as the max channels in each channel plan.
 * 2G, total 14 chnls
 * {1,2,3,4,5,6,7,8,9,10,11,12,13,14}
 * 5G, total 25 chnls
 * {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,144,149,153,157,161,165}
 */
#ifndef MAX
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#endif

u8 rm_get_oper_class_via_ch(u8 ch);
u8 rm_get_ch_set( struct rtw_ieee80211_channel *pch_set, u8 op_class, u8 ch_num);
u8 rm_get_bcn_rsni(struct rm_obj *prm, struct wlan_network *pnetwork);
u8 rm_get_bcn_rcpi(struct rm_obj *prm, struct wlan_network *pnetwork);
u8 rm_get_frame_rsni(struct rm_obj *prm, union recv_frame *pframe);
u8 translate_percentage_to_rcpi(u32 SignalStrengthIndex);
u8 translate_dbm_to_rcpi(s8 SignalPower);
int is_wildcard_bssid(u8 *bssid);

int rm_get_path_a_max_tx_power(_adapter *adapter, s8 *path_a);
int rm_get_tx_power(PADAPTER adapter, enum rf_path path, enum MGN_RATE rate, s8 *pwr);
int rm_get_rx_sensitivity(PADAPTER adapter, enum channel_width bw, enum MGN_RATE rate, s8 *pwr);

#endif /* _RTW_RM_UTIL_H_ */
                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/Hal8192EPhyCfg.h                                                              0000644 0001750 0001750 00000006465 14214766567 016046  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8192EPHYCFG_H__
#define __INC_HAL8192EPHYCFG_H__


/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters-------------------------------*/

/*------------------------------Define structure----------------------------*/

/* BB/RF related */

/*------------------------------Define structure----------------------------*/


/*------------------------Export global variable----------------------------*/
/*------------------------Export global variable----------------------------*/


/*------------------------Export Marco Definition---------------------------*/
/*------------------------Export Marco Definition---------------------------*/


/*--------------------------Exported Function prototype---------------------*/
/*
 * BB and RF register read/write
 *   */
u32	PHY_QueryBBReg8192E(PADAPTER	Adapter,
				u32			RegAddr,
				u32			BitMask);
void	PHY_SetBBReg8192E(PADAPTER		Adapter,
				u32			RegAddr,
				u32			BitMask,
				u32			Data);
u32	PHY_QueryRFReg8192E(PADAPTER	Adapter,
				enum rf_path	eRFPath,
				u32			RegAddr,
				u32			BitMask);
void	PHY_SetRFReg8192E(PADAPTER		Adapter,
				enum rf_path	eRFPath,
				u32			RegAddr,
				u32			BitMask,
				u32			Data);

/*
 * Initialization related function
 *
 * MAC/BB/RF HAL config */
int	PHY_MACConfig8192E(PADAPTER	Adapter);
int	PHY_BBConfig8192E(PADAPTER	Adapter);
int	PHY_RFConfig8192E(PADAPTER	Adapter);

/* RF config */


/*
 * BB TX Power R/W
 *   */
void	PHY_SetTxPowerLevel8192E(PADAPTER	Adapter, u8	channel);

void
PHY_SetTxPowerIndex_8192E(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

/*
 * channel switch related funciton
 *   */
void
PHY_SetSwChnlBWMode8192E(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void
PHY_SetRFEReg_8192E(
		PADAPTER		Adapter
);

void
phy_SpurCalibration_8192E(
		PADAPTER			Adapter,
		enum spur_cal_method	method
);
void PHY_SpurCalibration_8192E( PADAPTER Adapter);

#ifdef CONFIG_SPUR_CAL_NBI
void
phy_SpurCalibration_8192E_NBI(
		PADAPTER			Adapter
);
#endif
/*
 * BB/MAC/RF other monitor API
 *   */

void
phy_set_rf_path_switch_8192e(
		struct dm_struct		*phydm,
		bool		bMain
);

/*--------------------------Exported Function prototype---------------------*/
#endif /* __INC_HAL8192CPHYCFG_H */
                                                                                                                                                                                                           rtl8822bu/src/include/rtw_version.h                                                                 0000644 0001750 0001750 00000000154 14214766567 016156  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 #define DRIVERVERSION	"v5.8.7.1_35809.20191129_COEX20191120-7777"
#define BTCOEXVERSION	"COEX20191120-7777"
                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/linux/                                                                        0000755 0001750 0001750 00000000000 14214766567 014563  5                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 rtl8822bu/src/include/linux/wireless.h                                                              0000644 0001750 0001750 00000005262 14214766567 016576  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef _LINUX_WIRELESS_H
#define _LINUX_WIRELESS_H

/***************************** INCLUDES *****************************/

#if 0
	#include <linux/types.h>		/* for __u* and __s* typedefs */
	#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
	#include <linux/if.h>			/* for IFNAMSIZ and co... */
#else
	#define __user
	/* typedef uint16_t	__u16; */
	#include <sys/socket.h>			/* for "struct sockaddr" et al	*/
	#include <net/if.h>			/* for IFNAMSIZ and co... */
#endif

/****************************** TYPES ******************************/
#ifdef CONFIG_COMPAT
struct compat_iw_point {
	compat_caddr_t pointer;
	__u16 length;
	__u16 flags;
};
#endif
/* --------------------------- SUBTYPES --------------------------- */
/*
 *	For all data larger than 16 octets, we need to use a
 *	pointer to memory allocated in user space.
 */
struct	iw_point {
	void __user	*pointer;	/* Pointer to the data  (in user space) */
	__u16		length;		/* number of fields or size in bytes */
	__u16		flags;		/* Optional params */
};


/* ------------------------ IOCTL REQUEST ------------------------ */
/*
 * This structure defines the payload of an ioctl, and is used
 * below.
 *
 * Note that this structure should fit on the memory footprint
 * of iwreq (which is the same as ifreq), which mean a max size of
 * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
 * You should check this when increasing the structures defined
 * above in this file...
 */
union	iwreq_data {
	/* Config - generic */
	char		name[IFNAMSIZ];
	/* Name : used to verify the presence of  wireless extensions.
	 * Name of the protocol/provider... */

	struct iw_point	data;		/* Other large parameters */
};

/*
 * The structure to exchange data for ioctl.
 * This structure is the same as 'struct ifreq', but (re)defined for
 * convenience...
 * Do I need to remind you about structure size (32 octets) ?
 */
struct	iwreq {
	union {
		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
	} ifr_ifrn;

	/* Data part (defined just above) */
	union	iwreq_data	u;
};

#endif	/* _LINUX_WIRELESS_H */
                                                                                                                                                                                                                                                                                                                                              rtl8822bu/src/include/if_ether.h                                                                    0000644 0001750 0001750 00000010742 14214766567 015366  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef _LINUX_IF_ETHER_H
#define _LINUX_IF_ETHER_H

/*
 *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
 *	and FCS/CRC (frame check sequence).
 */

#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
#define ETH_HLEN	14		/* Total octets in header.	 */
#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */

/*
 *	These are the defined Ethernet Protocol ID's.
 */

#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
#define ETH_P_X25	0x0805		/* CCITT X.25			*/
#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
#define ETH_P_DEC       0x6000          /* DEC Assigned proto          */
#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load           */
#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console      */
#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing             */
#define ETH_P_LAT       0x6004          /* DEC LAT                     */
#define ETH_P_DIAG      0x6005          /* DEC Diagnostics             */
#define ETH_P_CUST      0x6006          /* DEC Customer use            */
#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch      */
#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header */
#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages    */
#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
					 * over Ethernet
					 */

/*
 *	Non DIX types. Won't clash for 1500 types.
 */

#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames */
#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25 */
#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
#define ETH_P_SNAP	0x0005		/* Internal only		*/
#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only    */
#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/

/*
 *	This is an Ethernet frame header.
 */

struct ethhdr {
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
};

struct _vlan {
	unsigned short       h_vlan_TCI;                /* Encapsulates priority and VLAN ID */
	unsigned short       h_vlan_encapsulated_proto;
};



#define get_vlan_id(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI)) & 0xfff)
#define get_vlan_priority(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI))>>13)
#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short)pvlan->h_vlan_encapsulated_proto))


#endif	/* _LINUX_IF_ETHER_H */
                              rtl8822bu/src/include/rtl8710b_rf.h                                                                 0000644 0001750 0001750 00000001373 14214766567 015553  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_RF_H__
#define __RTL8710B_RF_H__

int PHY_RF6052_Config8710B(PADAPTER pdapter);

#endif
                                                                                                                                                                                                                                                                     rtl8822bu/src/include/rtl8188f_dm.h                                                                 0000644 0001750 0001750 00000002615 14214766567 015561  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_DM_H__
#define __RTL8188F_DM_H__
/* ************************************************************
 * Description:
 *
 * This file is for 8188F dynamic mechanism only
 *
 *
 * ************************************************************ */

/* ************************************************************
 * structure and define
 * ************************************************************ */

/* ************************************************************
 * function prototype
 * ************************************************************ */

void rtl8188f_init_dm_priv(PADAPTER padapter);
void rtl8188f_deinit_dm_priv(PADAPTER padapter);

void rtl8188f_InitHalDm(PADAPTER padapter);
void rtl8188f_HalDmWatchDog(PADAPTER padapter);

#endif
                                                                                                                   rtl8822bu/src/include/rtl8192f_dm.h                                                                 0000644 0001750 0001750 00000002016 14214766567 015547  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_DM_H__
#define __RTL8192F_DM_H__

void rtl8192f_init_dm_priv(PADAPTER Adapter);
void rtl8192f_deinit_dm_priv(PADAPTER Adapter);
void rtl8192f_InitHalDm(PADAPTER Adapter);
void rtl8192f_HalDmWatchDog(PADAPTER Adapter);

/* void rtl8192c_dm_CheckTXPowerTracking(PADAPTER Adapter); */

/* void rtl8192c_dm_RF_Saving(PADAPTER pAdapter, u8 bForceInNormal); */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/include/rtl8723d_cmd.h                                                                0000644 0001750 0001750 00000024535 14214766567 015722  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_CMD_H__
#define __RTL8723D_CMD_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

enum h2c_cmd_8723D {
	/* Common Class: 000 */
	H2C_8723D_RSVD_PAGE = 0x00,
	H2C_8723D_MEDIA_STATUS_RPT = 0x01,
	H2C_8723D_SCAN_ENABLE = 0x02,
	H2C_8723D_KEEP_ALIVE = 0x03,
	H2C_8723D_DISCON_DECISION = 0x04,
	H2C_8723D_PSD_OFFLOAD = 0x05,
	H2C_8723D_AP_OFFLOAD = 0x08,
	H2C_8723D_BCN_RSVDPAGE = 0x09,
	H2C_8723D_PROBERSP_RSVDPAGE = 0x0A,
	H2C_8723D_FCS_RSVDPAGE = 0x10,
	H2C_8723D_FCS_INFO = 0x11,
	H2C_8723D_AP_WOW_GPIO_CTRL = 0x13,

	/* PoweSave Class: 001 */
	H2C_8723D_SET_PWR_MODE = 0x20,
	H2C_8723D_PS_TUNING_PARA = 0x21,
	H2C_8723D_PS_TUNING_PARA2 = 0x22,
	H2C_8723D_P2P_LPS_PARAM = 0x23,
	H2C_8723D_P2P_PS_OFFLOAD = 0x24,
	H2C_8723D_PS_SCAN_ENABLE = 0x25,
	H2C_8723D_SAP_PS_ = 0x26,
	H2C_8723D_INACTIVE_PS_ = 0x27, /* Inactive_PS */
	H2C_8723D_FWLPS_IN_IPS_ = 0x28,

	/* Dynamic Mechanism Class: 010 */
	H2C_8723D_MACID_CFG = 0x40,
	H2C_8723D_TXBF = 0x41,
	H2C_8723D_RSSI_SETTING = 0x42,
	H2C_8723D_AP_REQ_TXRPT = 0x43,
	H2C_8723D_INIT_RATE_COLLECT = 0x44,
	H2C_8723D_RA_PARA_ADJUST = 0x46,

	/* BT Class: 011 */
	H2C_8723D_B_TYPE_TDMA = 0x60,
	H2C_8723D_BT_INFO = 0x61,
	H2C_8723D_FORCE_BT_TXPWR = 0x62,
	H2C_8723D_BT_IGNORE_WLANACT = 0x63,
	H2C_8723D_DAC_SWING_VALUE = 0x64,
	H2C_8723D_ANT_SEL_RSV = 0x65,
	H2C_8723D_WL_OPMODE = 0x66,
	H2C_8723D_BT_MP_OPER = 0x67,
	H2C_8723D_BT_CONTROL = 0x68,
	H2C_8723D_BT_WIFI_CTRL = 0x69,
	H2C_8723D_BT_FW_PATCH = 0x6A,
	H2C_8723D_BT_WLAN_CALIBRATION = 0x6D,

	/* WOWLAN Class: 100 */
	H2C_8723D_WOWLAN = 0x80,
	H2C_8723D_REMOTE_WAKE_CTRL = 0x81,
	H2C_8723D_AOAC_GLOBAL_INFO = 0x82,
	H2C_8723D_AOAC_RSVD_PAGE = 0x83,
	H2C_8723D_AOAC_RSVD_PAGE2 = 0x84,
	H2C_8723D_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_8723D_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_8723D_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_8723D_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
	H2C_8723D_P2P_OFFLOAD = 0x8B,

	H2C_8723D_RESET_TSF = 0xC0,
	H2C_8723D_MAXID,
};

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * _RSVDPAGE_LOC_CMD_0x00 */
#define SET_8723D_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723D_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8723D_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8723D_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8723D_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _PWR_MOD_CMD_0x20 */
#define SET_8723D_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723D_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8723D_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8723D_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8723D_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8723D_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8723D_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8723D_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _PS_TUNE_PARAM_CMD_0x21 */
#define SET_8723D_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723D_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8723D_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
#define SET_8723D_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
#define SET_8723D_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _MACID_CFG_CMD_0x40 */
#define SET_8723D_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
#define SET_8723D_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)

/* _RSSI_SETTING_CMD_0x42 */
#define SET_8723D_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723D_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
#define SET_8723D_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _AP_REQ_TXRPT_CMD_0x43 */
#define SET_8723D_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723D_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _FORCE_BT_TXPWR_CMD_0x62 */
#define SET_8723D_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)

/* _FORCE_BT_MP_OPER_CMD_0x67 */
#define SET_8723D_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_8723D_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_8723D_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8723D_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_8723D_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8723D_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)

/* _BT_FW_PATCH_0x6A */
#define SET_8723D_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8723D_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8723D_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8723D_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_8723D_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)

/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    Function Statement     --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

/* host message to firmware cmd */
void rtl8723d_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8723d_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
/* s32 rtl8723d_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable); */
void rtl8723d_set_FwPsTuneParam_cmd(PADAPTER padapter);
void rtl8723d_download_rsvd_page(PADAPTER padapter, u8 mstatus);
#ifdef CONFIG_BT_COEXIST
	void rtl8723d_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P
	void rtl8723d_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
#ifdef CONFIG_TDLS_CH_SW
void rtl8723d_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
#endif
#endif

#ifdef CONFIG_P2P_WOWLAN
	void rtl8723d_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
#endif

s32 FillH2CCmd8723D(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8723D(_adapter *padapter, bool wowlan);
#endif
                                                                                                                                                                   rtl8822bu/src/include/rtl8192f_sreset.h                                                             0000644 0001750 0001750 00000001720 14214766567 016455  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8192F_SRESET_H_
#define _RTL8192F_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8192f_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8192f_sreset_linked_status_check(_adapter *padapter);
#endif /* DBG_CONFIG_ERROR_DETECT */
#endif /* _RTL8192F_SRESET_H_ */                                                rtl8822bu/src/include/rtl8192e_sreset.h                                                             0000644 0001750 0001750 00000001632 14214766567 016456  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL88812A_SRESET_H_
#define _RTL8812A_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8192e_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8192e_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                      rtl8822bu/src/include/rtl8188e_led.h                                                                0000644 0001750 0001750 00000002563 14214766567 015726  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_LED_H__
#define __RTL8188E_LED_H__

#ifdef CONFIG_RTW_SW_LED

/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8188eu_InitSwLeds(PADAPTER padapter);
	void rtl8188eu_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
	void rtl8188ee_InitSwLeds(PADAPTER padapter);
	void rtl8188ee_DeInitSwLeds(PADAPTER padapter);
#endif
#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	void rtl8188es_InitSwLeds(PADAPTER padapter);
	void rtl8188es_DeInitSwLeds(PADAPTER padapter);
#endif

#endif
#endif /*CONFIG_RTW_SW_LED*/
                                                                                                                                             rtl8822bu/src/include/rtl8703b_led.h                                                                0000644 0001750 0001750 00000003055 14214766567 015711  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_LED_H__
#define __RTL8703B_LED_H__

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8703bu_InitSwLeds(PADAPTER padapter);
	void rtl8703bu_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
	void rtl8703bs_InitSwLeds(PADAPTER padapter);
	void rtl8703bs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_GSPI_HCI
	void rtl8703bs_InitSwLeds(PADAPTER padapter);
	void rtl8703bs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
	void rtl8703be_InitSwLeds(PADAPTER padapter);
	void rtl8703be_DeInitSwLeds(PADAPTER padapter);
#endif

#endif/*CONFIG_RTW_SW_LED*/
#endif /*__RTL8703B_LED_H__*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   rtl8822bu/src/include/Hal8814PhyCfg.h                                                               0000644 0001750 0001750 00000010747 14214766567 015740  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8814PHYCFG_H__
#define __INC_HAL8814PHYCFG_H__


/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3


#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters-------------------------------*/

/*------------------------------Define structure----------------------------*/


/* BB/RF related */

#define	SIC_ENABLE				0

/*------------------------------Define structure----------------------------*/


/*------------------------Export global variable----------------------------*/
/*------------------------Export global variable----------------------------*/


/*------------------------Export Marco Definition---------------------------*/
/*------------------------Export Marco Definition---------------------------*/


/*--------------------------Exported Function prototype---------------------*/
/* 1. BB register R/W API */

extern	u32
PHY_QueryBBReg8814A(PADAPTER	Adapter,
			u32		RegAddr,
			u32		BitMask);


void
PHY_SetBBReg8814A(PADAPTER	Adapter,
			u32		RegAddr,
			u32		BitMask,
			u32		Data);


extern	u32
PHY_QueryRFReg8814A(PADAPTER			Adapter,
			enum rf_path	eRFPath,
			u32			RegAddr,
			u32			BitMask);


void
PHY_SetRFReg8814A(PADAPTER			Adapter,
			enum rf_path		eRFPath,
			u32				RegAddr,
			u32				BitMask,
			u32				Data);

/* 1 3. Initial BB/RF config by reading MAC/BB/RF txt. */
s32
phy_BB8814A_Config_ParaFile(
		PADAPTER	Adapter
);

void
PHY_ConfigBB_8814A(
		PADAPTER	Adapter
);


void
phy_ADC_CLK_8814A(
		PADAPTER	Adapter
);

s32
PHY_RFConfig8814A(
		PADAPTER	Adapter
);

/*
 * RF Power setting
 *
 * BOOLEAN	PHY_SetRFPowerState8814A(PADAPTER Adapter, rt_rf_power_state	eRFPowerState); */

/* 1 5. Tx  Power setting API */

void
PHY_SetTxPowerLevel8814(
		PADAPTER		Adapter,
		u8			Channel
);

u8
phy_get_tx_power_index_8814a(
		PADAPTER		Adapter,
		enum rf_path		RFPath,
		u8				Rate,
		enum channel_width BandWidth,
		u8				Channel
);

void
PHY_SetTxPowerIndex_8814A(
		PADAPTER		Adapter,
		u32				PowerIndex,
		enum rf_path		RFPath,
		u8				Rate
);

u32
PHY_GetTxBBSwing_8814A(
		PADAPTER	Adapter,
		BAND_TYPE	Band,
		enum rf_path	RFPath
);



/* 1 6. Channel setting API */
#if 0
void
PHY_SwChnlTimerCallback8814A(
		struct timer_list		*p_timer
);
#endif
void
PHY_SwChnlWorkItemCallback8814A(
		void *pContext
);


void
HAL_HandleSwChnl8814A(
		PADAPTER	pAdapter,
		u8		channel
);

void
PHY_SwChnlSynchronously8814A(PADAPTER		pAdapter,
				u8			channel);

void
PHY_HandleSwChnlAndSetBW8814A(
		PADAPTER			Adapter,
		BOOLEAN				bSwitchChannel,
		BOOLEAN				bSetBandWidth,
		u8					ChannelNum,
		enum channel_width	ChnlWidth,
		u8					ChnlOffsetOf40MHz,
		u8					ChnlOffsetOf80MHz,
		u8					CenterFrequencyIndex1
);


BOOLEAN
PHY_QueryRFPathSwitch_8814A(PADAPTER	pAdapter);



#if (USE_WORKITEM)
void
RtCheckForHangWorkItemCallback8814A(
		void *pContext
);
#endif

BOOLEAN
SetAntennaConfig8814A(
		PADAPTER	Adapter,
		u8		DefaultAnt
);

void
PHY_SetRFEReg8814A(
		PADAPTER		Adapter,
		BOOLEAN		bInit,
		u8		Band
);


s32
PHY_SwitchWirelessBand8814A(
		PADAPTER		 Adapter,
		u8		Band
);

void
PHY_SetIO_8814A(
	PADAPTER		pAdapter
);

void
PHY_SetSwChnlBWMode8814(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

s32 PHY_MACConfig8814(PADAPTER Adapter);
int PHY_BBConfig8814(PADAPTER	Adapter);
void PHY_Set_SecCCATH_by_RXANT_8814A(PADAPTER	pAdapter, u32 ulAntennaRx);



/*--------------------------Exported Function prototype---------------------*/

/*--------------------------Exported Function prototype---------------------*/
#endif /* __INC_HAL8192CPHYCFG_H */
                         rtl8822bu/src/include/rtw_vht.h                                                                     0000644 0001750 0001750 00000024040 14214766567 015272  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_VHT_H_
#define _RTW_VHT_H_

#define VHT_CAP_IE_LEN 12
#define VHT_OP_IE_LEN 5

#define	LDPC_VHT_ENABLE_RX			BIT0
#define	LDPC_VHT_ENABLE_TX			BIT1
#define	LDPC_VHT_TEST_TX_ENABLE		BIT2
#define	LDPC_VHT_CAP_TX				BIT3

#define	STBC_VHT_ENABLE_RX			BIT0
#define	STBC_VHT_ENABLE_TX			BIT1
#define	STBC_VHT_TEST_TX_ENABLE		BIT2
#define	STBC_VHT_CAP_TX				BIT3

/* VHT capability info */
#define SET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
#define SET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 2, 2, _val)
#define SET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 1, _val)
#define SET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 5, 1, _val)
#define SET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 6, 1, _val)
#define SET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
#define SET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 0, 3, _val)
#define SET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 3, 1, _val)
#define SET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 4, 1, _val)
#define SET_VHT_CAPABILITY_ELE_BFER_ANT_SUPP(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 5, 3, _val)
#define SET_VHT_CAPABILITY_ELE_SOUNDING_DIMENSIONS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 0, 3, _val)

#define SET_VHT_CAPABILITY_ELE_MU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 3, 1, _val)
#define SET_VHT_CAPABILITY_ELE_MU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 4, 1, _val)
#define SET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 5, 1, _val)
#define SET_VHT_CAPABILITY_ELE_HTC_VHT(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 6, 1, _val)
#define SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart, _val)		SET_BITS_TO_LE_2BYTE((_pEleStart)+2, 7, 3, _val) /* B23~B25 */
#define SET_VHT_CAPABILITY_ELE_LINK_ADAPTION(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 2, 2, _val)
#define SET_VHT_CAPABILITY_ELE_MCS_RX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+4, 0, 16, _val)   /* B0~B15 indicate Rx MCS MAP, we write 0 to indicate MCS0~7. by page */
#define SET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+6, 0, 13, _val)
#define SET_VHT_CAPABILITY_ELE_MCS_TX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+8, 0, 16, _val)   /* B0~B15 indicate Tx MCS MAP, we write 0 to indicate MCS0~7. by page */
#define SET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+10, 0, 13, _val)


#define GET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
#define GET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 2, 2)
#define GET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 4, 1)
#define GET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 5, 1)
#define GET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 6, 1)
#define GET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
#define GET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 3)
#define GET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 3, 1)
#define GET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 4, 1)
/*phydm-beamforming*/
#define GET_VHT_CAPABILITY_ELE_SU_BFEE_STS_CAP(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+1, 5, 3)
#define GET_VHT_CAPABILITY_ELE_SU_BFER_SOUND_DIM_NUM(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 0, 3)
#define GET_VHT_CAPABILITY_ELE_MU_BFER(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 3, 1)
#define GET_VHT_CAPABILITY_ELE_MU_BFEE(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 4, 1)
#define GET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 5, 1)
#define GET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 7, 3)
#define GET_VHT_CAPABILITY_ELE_RX_MCS(_pEleStart)					       ((_pEleStart)+4)
#define GET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+6, 0, 13)
#define GET_VHT_CAPABILITY_ELE_TX_MCS(_pEleStart)					       ((_pEleStart)+8)
#define GET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+10, 0, 13)


/* VHT Operation Information Element */
#define SET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 8, _val)
#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ1(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart+1, 0, 8, _val)
#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ2(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart+2, 0, 8, _val)
#define SET_VHT_OPERATION_ELE_BASIC_MCS_SET(_pEleStart, _val)			SET_BITS_TO_LE_2BYTE((_pEleStart)+3, 0, 16, _val)

#define GET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart, 0, 8)
#define GET_VHT_OPERATION_ELE_CENTER_FREQ1(_pEleStart)	LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 8)
#define GET_VHT_OPERATION_ELE_CENTER_FREQ2(_pEleStart)     LE_BITS_TO_1BYTE((_pEleStart)+2, 0, 8)

/* VHT Operating Mode */
#define SET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 3, _val)
#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
#define GET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 4, 3)
#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart, 7, 1)

#define SET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart)+7, 6, 1, _val)
#define GET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+7, 6, 1)

#define VHT_MAX_MPDU_LEN_MAX 3
extern const u16 _vht_max_mpdu_len[];
#define vht_max_mpdu_len(val) (((val) >= VHT_MAX_MPDU_LEN_MAX) ? _vht_max_mpdu_len[VHT_MAX_MPDU_LEN_MAX] : _vht_max_mpdu_len[(val)])

#define VHT_SUP_CH_WIDTH_SET_MAX 3
extern const u8 _vht_sup_ch_width_set_to_bw_cap[];
#define vht_sup_ch_width_set_to_bw_cap(set) (((set) >= VHT_SUP_CH_WIDTH_SET_MAX) ? _vht_sup_ch_width_set_to_bw_cap[VHT_SUP_CH_WIDTH_SET_MAX] : _vht_sup_ch_width_set_to_bw_cap[(set)])
extern const char *const _vht_sup_ch_width_set_str[];
#define vht_sup_ch_width_set_str(set) (((set) >= VHT_SUP_CH_WIDTH_SET_MAX) ? _vht_sup_ch_width_set_str[VHT_SUP_CH_WIDTH_SET_MAX] : _vht_sup_ch_width_set_str[(set)])

#define VHT_MAX_AMPDU_LEN(f) ((1 << (13 + f)) - 1)
void dump_vht_cap_ie(void *sel, const u8 *ie, u32 ie_len);

#define VHT_OP_CH_WIDTH_MAX 4
extern const char *const _vht_op_ch_width_str[];
#define vht_op_ch_width_str(ch_width) (((ch_width) >= VHT_OP_CH_WIDTH_MAX) ? _vht_op_ch_width_str[VHT_OP_CH_WIDTH_MAX] : _vht_op_ch_width_str[(ch_width)])

void dump_vht_op_ie(void *sel, const u8 *ie, u32 ie_len);

struct vht_bf_cap {
	u8 is_mu_bfer;
	u8 su_sound_dim;
};

struct vht_priv {
	u8	vht_option;

	u8	ldpc_cap;
	u8	stbc_cap;
	u16	beamform_cap;
	struct	vht_bf_cap ap_bf_cap;

	u8	sgi_80m;/* short GI */
	u8	ampdu_len;

	u8	vht_highest_rate;
	u8	vht_mcs_map[2];

	u8 op_present:1; /* vht_op is present */
	u8 notify_present:1; /* vht_op_mode_notify is present */

	u8 vht_cap[32];
	u8 vht_op[VHT_OP_IE_LEN];
	u8 vht_op_mode_notify;
};

#ifdef ROKU_PRIVATE
struct vht_priv_infra_ap {

	/* Infra mode, only store for AP's info, not intersection of STA and AP*/
	u8	ldpc_cap_infra_ap;
	u8	stbc_cap_infra_ap;
	u16	beamform_cap_infra_ap;
	u8	vht_mcs_map_infra_ap[2];
	u8	vht_mcs_map_tx_infra_ap[2];
	u8	channel_width_infra_ap;
	u8	number_of_streams_infra_ap;
};
#endif /* ROKU_PRIVATE */

u8	rtw_get_vht_highest_rate(u8 *pvht_mcs_map);
u16	rtw_vht_mcs_to_data_rate(u8 bw, u8 short_GI, u8 vht_mcs_rate);
u64	rtw_vht_mcs_map_to_bitmap(u8 *mcs_map, u8 nss);
void	rtw_vht_use_default_setting(_adapter *padapter);
u32	rtw_build_vht_operation_ie(_adapter *padapter, u8 *pbuf, u8 channel);
u32	rtw_build_vht_op_mode_notify_ie(_adapter *padapter, u8 *pbuf, u8 bw);
u32	rtw_build_vht_cap_ie(_adapter *padapter, u8 *pbuf);
void	update_sta_vht_info_apmode(_adapter *padapter, void *psta);
void	update_hw_vht_param(_adapter *padapter);
void	VHT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
#ifdef ROKU_PRIVATE
void	VHT_caps_handler_infra_ap(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
#endif /* ROKU_PRIVATE */
void	VHT_operation_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
void	rtw_process_vht_op_mode_notify(_adapter *padapter, u8 *pframe, void *sta);
u32	rtw_restructure_vht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
void	VHTOnAssocRsp(_adapter *padapter);
u8	rtw_vht_mcsmap_to_nss(u8 *pvht_mcs_map);
void rtw_vht_nss_to_mcsmap(u8 nss, u8 *target_mcs_map, u8 *cur_mcs_map);
void rtw_vht_ies_attach(_adapter *padapter, WLAN_BSSID_EX *pcur_network);
void rtw_vht_ies_detach(_adapter *padapter, WLAN_BSSID_EX *pcur_network);
void rtw_check_for_vht20(_adapter *adapter, u8 *ies, int ies_len);
#endif /* _RTW_VHT_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                rtl8822bu/src/include/rtw_recv.h                                                                    0000644 0001750 0001750 00000045243 14214766567 015440  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_RECV_H_
#define _RTW_RECV_H_

#define RTW_RX_MSDU_ACT_NONE		0
#define RTW_RX_MSDU_ACT_INDICATE	BIT0
#define RTW_RX_MSDU_ACT_FORWARD		BIT1

#ifdef CONFIG_SINGLE_RECV_BUF
	#define NR_RECVBUFF (1)
#else
	#if defined(CONFIG_GSPI_HCI)
		#define NR_RECVBUFF (32)
	#elif defined(CONFIG_SDIO_HCI)
		#define NR_RECVBUFF (8)
	#else
		#define NR_RECVBUFF (8)
	#endif
#endif /* CONFIG_SINGLE_RECV_BUF */
#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
	#define NR_PREALLOC_RECV_SKB (rtw_rtkm_get_nr_recv_skb()>>1)
#else /*!CONFIG_PREALLOC_RX_SKB_BUFFER */
	#define NR_PREALLOC_RECV_SKB 8
#endif /* CONFIG_PREALLOC_RX_SKB_BUFFER */

#ifdef CONFIG_RTW_NAPI
	#define RTL_NAPI_WEIGHT (32)
#endif


#if defined(CONFIG_RTL8821C) && defined(CONFIG_SDIO_HCI) && defined(CONFIG_RECV_THREAD_MODE)
	#ifdef NR_RECVBUFF
	#undef NR_RECVBUFF
	#define NR_RECVBUFF (32)
	#endif
#endif

#define NR_RECVFRAME 256

#define RXFRAME_ALIGN	8
#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)

#define DRVINFO_SZ	4 /* unit is 8bytes */

#define MAX_RXFRAME_CNT	512
#define MAX_RX_NUMBLKS		(32)
#define RECVFRAME_HDR_ALIGN 128
#define MAX_CONTINUAL_NORXPACKET_COUNT 4    /*  In MAX_CONTINUAL_NORXPACKET_COUNT*2 sec  , no rx traffict would issue DELBA*/

#define PHY_RSSI_SLID_WIN_MAX				100
#define PHY_LINKQUALITY_SLID_WIN_MAX		20


#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)

#define RX_MPDU_QUEUE				0
#define RX_CMD_QUEUE				1
#define RX_MAX_QUEUE				2

#define MAX_SUBFRAME_COUNT	64
/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
extern u8 rtw_bridge_tunnel_header[];
extern u8 rtw_rfc1042_header[];

enum addba_rsp_ack_state {
	RTW_RECV_ACK_OR_TIMEOUT,
};

/* for Rx reordering buffer control */
struct recv_reorder_ctrl {
	_adapter	*padapter;
	u8 tid;
	u8 enable;
	u16 indicate_seq;/* =wstart_b, init_value=0xffff */
	u16 wend_b;
	u8 wsize_b;
	u8 ampdu_size;
	_queue pending_recvframe_queue;
	_timer reordering_ctrl_timer;
	u8 bReorderWaiting;
	unsigned long rec_abba_rsp_ack;
};

struct	stainfo_rxcache	{
	u16	tid_rxseq[16];
	u8 iv[16][8];
	u8 last_tid;
#if 0
	unsigned short	tid0_rxseq;
	unsigned short	tid1_rxseq;
	unsigned short	tid2_rxseq;
	unsigned short	tid3_rxseq;
	unsigned short	tid4_rxseq;
	unsigned short	tid5_rxseq;
	unsigned short	tid6_rxseq;
	unsigned short	tid7_rxseq;
	unsigned short	tid8_rxseq;
	unsigned short	tid9_rxseq;
	unsigned short	tid10_rxseq;
	unsigned short	tid11_rxseq;
	unsigned short	tid12_rxseq;
	unsigned short	tid13_rxseq;
	unsigned short	tid14_rxseq;
	unsigned short	tid15_rxseq;
#endif
};


struct smooth_rssi_data {
	u32	elements[100];	/* array to store values */
	u32	index;			/* index to current array to store */
	u32	total_num;		/* num of valid elements */
	u32	total_val;		/* sum of valid elements */
};

struct signal_stat {
	u8	update_req;		/* used to indicate */
	u8	avg_val;		/* avg of valid elements */
	u32	total_num;		/* num of valid elements */
	u32	total_val;		/* sum of valid elements	 */
};

struct rx_raw_rssi {
	u8 data_rate;
	u8 pwdball;
	s8 pwr_all;

	u8 mimo_signal_strength[4];/* in 0~100 index */
	u8 mimo_signal_quality[4];

	s8 ofdm_pwr[4];
	u8 ofdm_snr[4];
};


#include "cmn_info/rtw_sta_info.h"

struct rx_pkt_attrib	{
	u16	pkt_len;
	u8	physt;
	u8	drvinfo_sz;
	u8	shift_sz;
	u8	hdrlen; /* the WLAN Header Len */
	u8	to_fr_ds;
	u8	amsdu;
	u8	qos;
	u8	priority;
	u8	pw_save;
	u8	mdata;
	u16	seq_num;
	u8	frag_num;
	u8	mfrag;
	u8	order;
	u8	privacy; /* in frame_ctrl field */
	u8	bdecrypted;
	u8	encrypt; /* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
	u8	iv_len;
	u8	icv_len;
	u8	crc_err;
	u8	icv_err;

	u16	eth_type;

	u8	dst[ETH_ALEN];
	u8	src[ETH_ALEN];
	u8	ta[ETH_ALEN];
	u8	ra[ETH_ALEN];
	u8	bssid[ETH_ALEN];
#ifdef CONFIG_RTW_MESH
	u8	msa[ETH_ALEN]; /* mesh sa */
	u8	mda[ETH_ALEN]; /* mesh da */
	u8 mesh_ctrl_present;
	u8	mesh_ctrl_len; /* length of mesh control field */
#endif

	u8	ack_policy;

	u8	key_index;

	u8	data_rate;
	u8 ch; /* RX channel */
	u8	bw;
	u8	stbc;
	u8	ldpc;
	u8	sgi;
	u8	pkt_rpt_type;
	u32 tsfl;
	u32	MacIDValidEntry[2];	/* 64 bits present 64 entry. */
	u8	ppdu_cnt;
	u32 	free_cnt;		/* free run counter */
	struct phydm_phyinfo_struct phy_info;

#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
	/* checksum offload realted varaiables */
	u8 csum_valid;		/* Checksum valid, 0: not check, 1: checked */
	u8 csum_err;		/* Checksum Error occurs */
#endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
};

#ifdef CONFIG_RTW_MESH
#define RATTRIB_GET_MCTRL_LEN(rattrib) ((rattrib)->mesh_ctrl_len)
#else
#define RATTRIB_GET_MCTRL_LEN(rattrib) 0
#endif

/* These definition is used for Rx packet reordering. */
#define SN_LESS(a, b)		(((a-b) & 0x800) != 0)
#define SN_EQUAL(a, b)	(a == b)
/* #define REORDER_WIN_SIZE	128 */
/* #define REORDER_ENTRY_NUM	128 */
#define REORDER_WAIT_TIME	(50) /* (ms) */

#if defined(CONFIG_PLATFORM_RTK390X) && defined(CONFIG_USB_HCI)
	#define RECVBUFF_ALIGN_SZ 32
#else
	#define RECVBUFF_ALIGN_SZ 8
#endif

#ifdef CONFIG_TRX_BD_ARCH
	#define RX_WIFI_INFO_SIZE	24
#elif (defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822B)) && defined(CONFIG_PCI_HCI)
	#define RXBD_SIZE	sizeof(struct recv_stat)
#endif

#define RXDESC_SIZE	24
#define RXDESC_OFFSET RXDESC_SIZE

#ifdef CONFIG_TRX_BD_ARCH
struct rx_buf_desc {
	/* RX has exactly one segment */
#ifdef CONFIG_64BIT_DMA
	unsigned int dword[4];
#else
	unsigned int dword[2];
#endif
};

struct recv_stat {
	unsigned int rxdw[8];
};
#else
struct recv_stat {
	unsigned int rxdw0;

	unsigned int rxdw1;

#if !((defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8822C)) && defined(CONFIG_PCI_HCI))  /* exclude 8192ee, 8814ae, 8822be, 8821ce */
	unsigned int rxdw2;

	unsigned int rxdw3;
#endif

#ifndef BUF_DESC_ARCH
	unsigned int rxdw4;

	unsigned int rxdw5;

#ifdef CONFIG_PCI_HCI
	unsigned int rxdw6;

	unsigned int rxdw7;
#endif
#endif /* if BUF_DESC_ARCH is defined, rx_buf_desc occupy 4 double words */
};
#endif

#define EOR BIT(30)

#ifdef CONFIG_PCI_HCI
#define PCI_MAX_RX_QUEUE		1/* MSDU packet queue, Rx Command Queue */
#define PCI_MAX_RX_COUNT		128
#ifdef CONFIG_TRX_BD_ARCH
#define RX_BD_NUM				PCI_MAX_RX_COUNT	/* alias */
#endif

struct rtw_rx_ring {
#ifdef CONFIG_TRX_BD_ARCH
	struct rx_buf_desc	*buf_desc;
#else
	struct recv_stat	*desc;
#endif
	dma_addr_t		dma;
	unsigned int		idx;
	struct sk_buff	*rx_buf[PCI_MAX_RX_COUNT];
};
#endif



/*
accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
; halt(passive) ;

using enter_critical section to protect
*/

#ifndef DBG_RX_BH_TRACKING
#define DBG_RX_BH_TRACKING 0
#endif

struct recv_priv {
	_lock	lock;

#ifdef CONFIG_RECV_THREAD_MODE
	_sema	recv_sema;

#endif

	/* _queue	blk_strms[MAX_RX_NUMBLKS];    */ /* keeping the block ack frame until return ack */
	_queue	free_recv_queue;
	_queue	recv_pending_queue;
	_queue	uc_swdec_pending_queue;


	u8 *pallocated_frame_buf;
	u8 *precv_frame_buf;

	uint free_recvframe_cnt;

	#if DBG_RX_BH_TRACKING
	u32 rx_bh_stage;
	u32 rx_bh_buf_dq_cnt;
	void *rx_bh_lbuf;
	void *rx_bh_cbuf;
	void *rx_bh_cbuf_data;
	u32 rx_bh_cbuf_dlen;
	u32 rx_bh_cbuf_pos;
	void *rx_bh_cframe;
	#endif

	_adapter	*adapter;

	u32 is_any_non_be_pkts;

	u64	rx_bytes;
	u64	rx_pkts;
	u64	rx_drop;

	u64 dbg_rx_drop_count;
	u64 dbg_rx_ampdu_drop_count;
	u64 dbg_rx_ampdu_forced_indicate_count;
	u64 dbg_rx_ampdu_loss_count;
	u64 dbg_rx_dup_mgt_frame_drop_count;
	u64 dbg_rx_ampdu_window_shift_cnt;
	u64 dbg_rx_conflic_mac_addr_cnt;

	uint  rx_icv_err;
	uint  rx_largepacket_crcerr;
	uint  rx_smallpacket_crcerr;
	uint  rx_middlepacket_crcerr;

#ifdef CONFIG_USB_HCI
	/* u8 *pallocated_urb_buf; */
	_sema allrxreturnevt;
	uint	ff_hwaddr;
	ATOMIC_T	rx_pending_cnt;

#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
#ifdef PLATFORM_LINUX
	PURB	int_in_urb;
#endif

	u8	*int_in_buf;
#endif /* CONFIG_USB_INTERRUPT_IN_PIPE */

#endif
#if defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)
	_tasklet irq_prepare_beacon_tasklet;
	_tasklet recv_tasklet;

	struct sk_buff_head free_recv_skb_queue;
	struct sk_buff_head rx_skb_queue;
#ifdef CONFIG_RTW_NAPI
		struct sk_buff_head rx_napi_skb_queue;
#endif 
#ifdef CONFIG_RX_INDICATE_QUEUE
	_tasklet rx_indicate_tasklet;
	struct ifqueue rx_indicate_queue;
#endif /* CONFIG_RX_INDICATE_QUEUE */

#endif /* defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD) */

	u8 *pallocated_recv_buf;
	u8 *precv_buf;    /* 4 alignment */
	_queue	free_recv_buf_queue;
	u32	free_recv_buf_queue_cnt;

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI) || defined(CONFIG_USB_HCI)
	_queue	recv_buf_pending_queue;
#endif

#ifdef CONFIG_PCI_HCI
	/* Rx */
	struct rtw_rx_ring	rx_ring[PCI_MAX_RX_QUEUE];
	int rxringcount;	/* size should be PCI_MAX_RX_QUEUE */
	u32	rxbuffersize;
#endif

	/* For display the phy informatiom */
	u8 is_signal_dbg;	/* for debug */
	u8 signal_strength_dbg;	/* for debug */

	u8 signal_strength;
	u8 signal_qual;
	s8 rssi;	/* translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.SignalStrength); */
	struct rx_raw_rssi raw_rssi_info;
	/* s8 rxpwdb;	 */
	/* int RxSNRdB[2]; */
	/* s8 RxRssi[2]; */
	/* int FalseAlmCnt_all; */


#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
	_timer signal_stat_timer;
	u32 signal_stat_sampling_interval;
	/* u32 signal_stat_converging_constant; */
	struct signal_stat signal_qual_data;
	struct signal_stat signal_strength_data;
#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
	struct smooth_rssi_data signal_qual_data;
	struct smooth_rssi_data signal_strength_data;
#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
	u16 sink_udpport, pre_rtp_rxseq, cur_rtp_rxseq;

	BOOLEAN store_law_data_flag;
};

#define RX_BH_STG_UNKNOWN		0
#define RX_BH_STG_HDL_ENTER		1
#define RX_BH_STG_HDL_EXIT		2
#define RX_BH_STG_NEW_BUF		3
#define RX_BH_STG_NEW_FRAME		4
#define RX_BH_STG_NORMAL_RX		5
#define RX_BH_STG_NORMAL_RX_END	6
#define RX_BH_STG_C2H			7
#define RX_BH_STG_C2H_END		8

#if DBG_RX_BH_TRACKING
void rx_bh_tk_set_stage(struct recv_priv *recv, u32 s);
void rx_bh_tk_set_buf(struct recv_priv *recv, void *buf, void *data, u32 dlen);
void rx_bh_tk_set_buf_pos(struct recv_priv *recv, void *pos);
void rx_bh_tk_set_frame(struct recv_priv *recv, void *frame);
void dump_rx_bh_tk(void *sel, struct recv_priv *recv);
#else
#define rx_bh_tk_set_stage(recv, s) do {} while (0)
#define rx_bh_tk_set_buf(recv, buf, data, dlen) do {} while (0)
#define rx_bh_tk_set_buf_pos(recv, pos) do {} while (0)
#define rx_bh_tk_set_frame(recv, frame) do {} while (0)
#define dump_rx_bh_tk(sel, recv) do {} while (0)
#endif

#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
#define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */

struct sta_recv_priv {

	_lock	lock;
	sint	option;

	/* _queue	blk_strms[MAX_RX_NUMBLKS]; */
	_queue defrag_q;	 /* keeping the fragment frame until defrag */

	struct	stainfo_rxcache rxcache;
	u16	bmc_tid_rxseq[16];
	u16	nonqos_rxseq;
	u16	nonqos_bmc_rxseq;

	/* uint	sta_rx_bytes; */
	/* uint	sta_rx_pkts; */
	/* uint	sta_rx_fail; */

};


struct recv_buf {
	_list list;

	_lock recvbuf_lock;

	u32	ref_cnt;

	PADAPTER adapter;

	u8	*pbuf;
	u8	*pallocated_buf;

	u32	len;
	u8	*phead;
	u8	*pdata;
	u8	*ptail;
	u8	*pend;

#ifdef CONFIG_USB_HCI
	PURB	purb;
	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
	u32 alloc_sz;

	u8  irp_pending;
	int  transfer_len;
#endif

#if defined(PLATFORM_LINUX)
	_pkt *pskb;
#elif defined(PLATFORM_FREEBSD) /* skb solution */
	struct sk_buff *pskb;
#endif
};


/*
	head  ----->

		data  ----->

			payload

		tail  ----->


	end   ----->

	len = (unsigned int )(tail - data);

*/
struct recv_frame_hdr {
	_list	list;
	_pkt *pkt;

	_adapter  *adapter;

	u8 fragcnt;

	int frame_tag;

	struct rx_pkt_attrib attrib;

	uint  len;
	u8 *rx_head;
	u8 *rx_data;
	u8 *rx_tail;
	u8 *rx_end;

	void *precvbuf;


	/*  */
	struct sta_info *psta;

	/* for A-MPDU Rx reordering buffer control */
	struct recv_reorder_ctrl *preorder_ctrl;

#ifdef CONFIG_WAPI_SUPPORT
	u8 UserPriority;
	u8 WapiTempPN[16];
	u8 WapiSrcAddr[6];
	u8 bWapiCheckPNInDecrypt;
	u8 bIsWaiPacket;
#endif

};


union recv_frame {

	union {
		_list list;
		struct recv_frame_hdr hdr;
		uint mem[RECVFRAME_HDR_ALIGN >> 2];
	} u;

	/* uint mem[MAX_RXSZ>>2]; */

};

bool rtw_rframe_del_wfd_ie(union recv_frame *rframe, u8 ies_offset);

typedef enum _RX_PACKET_TYPE {
	NORMAL_RX,/* Normal rx packet */
	TX_REPORT1,/* CCX */
	TX_REPORT2,/* TX RPT */
	HIS_REPORT,/* USB HISR RPT */
	C2H_PACKET
} RX_PACKET_TYPE, *PRX_PACKET_TYPE;

extern union recv_frame *_rtw_alloc_recvframe(_queue *pfree_recv_queue);   /* get a free recv_frame from pfree_recv_queue */
extern union recv_frame *rtw_alloc_recvframe(_queue *pfree_recv_queue);   /* get a free recv_frame from pfree_recv_queue */
extern void rtw_init_recvframe(union recv_frame *precvframe , struct recv_priv *precvpriv);
extern int	 rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);

#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
extern int _rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
extern int rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);

extern void rtw_free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue);
u32 rtw_free_uc_swdec_pending_queue(_adapter *adapter);

sint rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, _queue *queue);
sint rtw_enqueue_recvbuf(struct recv_buf *precvbuf, _queue *queue);
struct recv_buf *rtw_dequeue_recvbuf(_queue *queue);

#if defined(CONFIG_80211N_HT) && defined(CONFIG_RECV_REORDERING_CTRL)
void rtw_reordering_ctrl_timeout_handler(void *pcontext);
#endif

void rx_query_phy_status(union recv_frame *rframe, u8 *phy_stat);
int rtw_inc_and_chk_continual_no_rx_packet(struct sta_info *sta, int tid_index);
void rtw_reset_continual_no_rx_packet(struct sta_info *sta, int tid_index);

#ifdef CONFIG_RECV_THREAD_MODE
thread_return rtw_recv_thread(thread_context context);
#endif

__inline static u8 *get_rxmem(union recv_frame *precvframe)
{
	/* always return rx_head... */
	if (precvframe == NULL)
		return NULL;

	return precvframe->u.hdr.rx_head;
}

__inline static u8 *get_rx_status(union recv_frame *precvframe)
{

	return get_rxmem(precvframe);

}

__inline static u8 *get_recvframe_data(union recv_frame *precvframe)
{

	/* alwasy return rx_data */
	if (precvframe == NULL)
		return NULL;

	return precvframe->u.hdr.rx_data;

}

__inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
{
	/* append data before rx_data */

	/* add data to the start of recv_frame
	*
	*      This function extends the used data area of the recv_frame at the buffer
	*      start. rx_data must be still larger than rx_head, after pushing.
	*/

	if (precvframe == NULL)
		return NULL;


	precvframe->u.hdr.rx_data -= sz ;
	if (precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head) {
		precvframe->u.hdr.rx_data += sz ;
		return NULL;
	}

	precvframe->u.hdr.len += sz;

	return precvframe->u.hdr.rx_data;

}


__inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
{
	/* rx_data += sz; move rx_data sz bytes  hereafter */

	/* used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller */


	if (precvframe == NULL)
		return NULL;


	precvframe->u.hdr.rx_data += sz;

	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {
		precvframe->u.hdr.rx_data -= sz;
		return NULL;
	}

	precvframe->u.hdr.len -= sz;

	return precvframe->u.hdr.rx_data;

}

__inline static u8 *recvframe_put(union recv_frame *precvframe, sint sz)
{
	/* rx_tai += sz; move rx_tail sz bytes  hereafter */

	/* used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller */
	/* after putting, rx_tail must be still larger than rx_end. */
	unsigned char *prev_rx_tail;

	/* RTW_INFO("recvframe_put: len=%d\n", sz); */

	if (precvframe == NULL)
		return NULL;

	prev_rx_tail = precvframe->u.hdr.rx_tail;

	precvframe->u.hdr.rx_tail += sz;

	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {
		precvframe->u.hdr.rx_tail -= sz;
		return NULL;
	}

	precvframe->u.hdr.len += sz;

	return precvframe->u.hdr.rx_tail;

}



__inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
{
	/* rmv data from rx_tail (by yitsen) */

	/* used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller */
	/* after pulling, rx_end must be still larger than rx_data. */

	if (precvframe == NULL)
		return NULL;

	precvframe->u.hdr.rx_tail -= sz;

	if (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data) {
		precvframe->u.hdr.rx_tail += sz;
		return NULL;
	}

	precvframe->u.hdr.len -= sz;

	return precvframe->u.hdr.rx_tail;

}

__inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
{
	/* due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame */
	/* from any given member of recv_frame. */
	/* rxmem indicates the any member/address in recv_frame */

	return (union recv_frame *)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);

}

__inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
{

	u8 *buf_star;
	union recv_frame *precv_frame;
	precv_frame = rxmem_to_recvframe((unsigned char *)buf_star);

	return precv_frame;
}

__inline static u8 *pkt_to_recvmem(_pkt *pkt)
{
	/* return the rx_head */

	union recv_frame *precv_frame = pkt_to_recvframe(pkt);

	return	precv_frame->u.hdr.rx_head;

}

__inline static u8 *pkt_to_recvdata(_pkt *pkt)
{
	/* return the rx_data */

	union recv_frame *precv_frame = pkt_to_recvframe(pkt);

	return	precv_frame->u.hdr.rx_data;

}


__inline static sint get_recvframe_len(union recv_frame *precvframe)
{
	return precvframe->u.hdr.len;
}


__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
{
	s32	SignalPower; /* in dBm. */

	/* Translate to dBm (x=y-100) */
	SignalPower = SignalStrengthIndex - 100;
	return SignalPower;
}

struct sta_info;

extern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);

extern void  mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame);

u8 adapter_allow_bmc_data_rx(_adapter *adapter);
s32 pre_recv_entry(union recv_frame *precvframe, u8 *pphy_status);
void count_rx_stats(_adapter *padapter, union recv_frame *prframe, struct sta_info *sta);

#endif
                                                                                                                                                                                                                                                                                                                                                             rtl8822bu/src/include/rtw_security.h                                                                0000644 0001750 0001750 00000035720 14214766567 016347  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_SECURITY_H_
#define __RTW_SECURITY_H_


#define _NO_PRIVACY_		0x0
#define _WEP40_				0x1
#define _TKIP_				0x2
#define _TKIP_WTMIC_		0x3
#define _AES_				0x4
#define _WEP104_			0x5
#define _SMS4_				0x06
#define _WEP_WPA_MIXED_		0x07 /* WEP + WPA */
#define _BIP_				0x8

/* 802.11W use wrong key */
#define IEEE80211W_RIGHT_KEY	0x0
#define IEEE80211W_WRONG_KEY	0x1
#define IEEE80211W_NO_KEY		0x2

#define CCMPH_2_PN(ch)	((ch) & 0x000000000000ffff) \
			| (((ch) & 0xffffffff00000000) >> 16)

#define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))

const char *security_type_str(u8 value);

#define _WPA_IE_ID_	0xdd
#define _WPA2_IE_ID_	0x30

#define SHA256_MAC_LEN 32
#define AES_BLOCK_SIZE 16
#define AES_PRIV_SIZE (4 * 44)

#define RTW_KEK_LEN 16
#define RTW_KCK_LEN 16
#define RTW_TKIP_MIC_LEN 8
#define RTW_REPLAY_CTR_LEN 8

#define INVALID_SEC_MAC_CAM_ID	0xFF

typedef enum {
	ENCRYP_PROTOCOL_OPENSYS,   /* open system */
	ENCRYP_PROTOCOL_WEP,       /* WEP */
	ENCRYP_PROTOCOL_WPA,       /* WPA */
	ENCRYP_PROTOCOL_WPA2,      /* WPA2 */
	ENCRYP_PROTOCOL_WAPI,      /* WAPI: Not support in this version */
	ENCRYP_PROTOCOL_MAX
} ENCRYP_PROTOCOL_E;


#ifndef Ndis802_11AuthModeWPA2
#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
#endif

#ifndef Ndis802_11AuthModeWPA2PSK
#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
#endif

union pn48	{

	u64	val;

#ifdef CONFIG_LITTLE_ENDIAN

struct {
	u8 TSC0;
	u8 TSC1;
	u8 TSC2;
	u8 TSC3;
	u8 TSC4;
	u8 TSC5;
	u8 TSC6;
	u8 TSC7;
} _byte_;

#elif defined(CONFIG_BIG_ENDIAN)

struct {
	u8 TSC7;
	u8 TSC6;
	u8 TSC5;
	u8 TSC4;
	u8 TSC3;
	u8 TSC2;
	u8 TSC1;
	u8 TSC0;
} _byte_;

#endif

};

union Keytype {
	u8   skey[16];
	u32    lkey[4];
};


typedef struct _RT_PMKID_LIST {
	u8						bUsed;
	u8						Bssid[6];
	u8						PMKID[16];
	u8						SsidBuf[33];
	u8						*ssid_octet;
	u16						ssid_length;
} RT_PMKID_LIST, *PRT_PMKID_LIST;


struct security_priv {
	u32	  dot11AuthAlgrthm;		/* 802.11 auth, could be open, shared, 8021x and authswitch */
	u32	  dot11PrivacyAlgrthm;	/* This specify the privacy for shared auth. algorithm. */

	/* WEP */
	u32	  dot11PrivacyKeyIndex;	/* this is only valid for legendary wep, 0~3 for key id. (tx key index) */
	union Keytype dot11DefKey[6];			/* this is only valid for def. key	 */
	u32	dot11DefKeylen[6];
	u8	dot11Def_camid[6];
	u8 	key_mask; /* use to restore wep key after hal_init */

	u32 dot118021XGrpPrivacy;	/* This specify the privacy algthm. used for Grp key */
	u32	dot118021XGrpKeyid;		/* key id used for Grp Key ( tx key index) */
	union Keytype	dot118021XGrpKey[6];	/* 802.1x Group Key, for inx0 and inx1	 */
	union Keytype	dot118021XGrptxmickey[6];
	union Keytype	dot118021XGrprxmickey[6];
	union pn48		dot11Grptxpn;			/* PN48 used for Grp Key xmit. */
	union pn48		dot11Grprxpn;			/* PN48 used for Grp Key recv. */
	u8				iv_seq[4][8];
#ifdef CONFIG_IEEE80211W
	u32	dot11wBIPKeyid;						/* key id used for BIP Key ( tx key index) */
	union Keytype	dot11wBIPKey[6];		/* BIP Key, for index4 and index5 */
	union pn48		dot11wBIPtxpn;			/* PN48 used for BIP xmit. */
	union pn48		dot11wBIPrxpn;			/* PN48 used for BIP recv. */
#endif /* CONFIG_IEEE80211W */
#ifdef CONFIG_AP_MODE
	/* extend security capabilities for AP_MODE */
	unsigned int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
	unsigned int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
	unsigned int wpa_group_cipher;
	unsigned int wpa2_group_cipher;
	unsigned int wpa_pairwise_cipher;
	unsigned int wpa2_pairwise_cipher;
	u8 mfp_opt;
#endif
#ifdef CONFIG_CONCURRENT_MODE
	u8	dot118021x_bmc_cam_id;
#endif
	/*IEEE802.11-2012 Std. Table 8-101 AKM Suite Selectors*/
	u32	rsn_akm_suite_type;

	u8 wps_ie[MAX_WPS_IE_LEN];/* added in assoc req */
	int wps_ie_len;

	u8 owe_ie[MAX_OWE_IE_LEN];/* added in assoc req */
	int owe_ie_len;

	u8	binstallGrpkey;
#ifdef CONFIG_GTK_OL
	u8	binstallKCK_KEK;
#endif /* CONFIG_GTK_OL */
#ifdef CONFIG_IEEE80211W
	u8	binstallBIPkey;
#endif /* CONFIG_IEEE80211W */
	u8	busetkipkey;
	u8	bcheck_grpkey;
	u8	bgrpkey_handshake;

	u8	auth_alg;
	u8	auth_type;
	u8	extauth_status;
	/* u8	packet_cnt; */ /* unused, removed */

	s32	sw_encrypt;/* from registry_priv */
	s32	sw_decrypt;/* from registry_priv */

	s32 	hw_decrypted;/* if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready. */


	/* keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc) */
	u32 ndisauthtype;	/* NDIS_802_11_AUTHENTICATION_MODE */
	u32 ndisencryptstatus;	/* NDIS_802_11_ENCRYPTION_STATUS */

	NDIS_802_11_WEP ndiswep;

	u8 assoc_info[600];
	u8 szofcapability[256]; /* for wpa2 usage */
	u8 oidassociation[512]; /* for wpa/wpa2 usage */
	u8 authenticator_ie[256];  /* store ap security information element */
	u8 supplicant_ie[256];  /* store sta security information element */


	/* for tkip countermeasure */
	systime last_mic_err_time;
	u8	btkip_countermeasure;
	u8	btkip_wait_report;
	systime btkip_countermeasure_time;

	/* --------------------------------------------------------------------------- */
	/* For WPA2 Pre-Authentication. */
	/* --------------------------------------------------------------------------- */
	/* u8				RegEnablePreAuth;				 */ /* Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01. */
	/* u8				EnablePreAuthentication;			 */ /* Current Value: Pre-Authentication enabled or not. */
	RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	/* Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13. */
	u8				PMKIDIndex;
	/* u32				PMKIDCount;						 */ /* Added by Annie, 2006-10-13. */
	/* u8				szCapability[256];				 */ /* For WPA2-PSK using zero-config, by Annie, 2005-09-20. */

	u8 bWepDefaultKeyIdxSet;

#define DBG_SW_SEC_CNT
#ifdef DBG_SW_SEC_CNT
	u64 wep_sw_enc_cnt_bc;
	u64 wep_sw_enc_cnt_mc;
	u64 wep_sw_enc_cnt_uc;
	u64 wep_sw_dec_cnt_bc;
	u64 wep_sw_dec_cnt_mc;
	u64 wep_sw_dec_cnt_uc;

	u64 tkip_sw_enc_cnt_bc;
	u64 tkip_sw_enc_cnt_mc;
	u64 tkip_sw_enc_cnt_uc;
	u64 tkip_sw_dec_cnt_bc;
	u64 tkip_sw_dec_cnt_mc;
	u64 tkip_sw_dec_cnt_uc;

	u64 aes_sw_enc_cnt_bc;
	u64 aes_sw_enc_cnt_mc;
	u64 aes_sw_enc_cnt_uc;
	u64 aes_sw_dec_cnt_bc;
	u64 aes_sw_dec_cnt_mc;
	u64 aes_sw_dec_cnt_uc;
#endif /* DBG_SW_SEC_CNT */
};

#ifdef CONFIG_IEEE80211W
#define SEC_IS_BIP_KEY_INSTALLED(sec) ((sec)->binstallBIPkey)
#else
#define SEC_IS_BIP_KEY_INSTALLED(sec) _FALSE
#endif

struct sha256_state {
	u64 length;
	u32 state[8], curlen;
	u8 buf[64];
};

#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
	do {\
		switch (psecuritypriv->dot11AuthAlgrthm) {\
		case dot11AuthAlgrthm_Open:\
		case dot11AuthAlgrthm_Shared:\
		case dot11AuthAlgrthm_Auto:\
			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
			break;\
		case dot11AuthAlgrthm_8021X:\
			if (bmcst)\
				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
			else\
				encry_algo = (u8) psta->dot118021XPrivacy;\
			break;\
		case dot11AuthAlgrthm_WAPI:\
			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
			break;\
		} \
	} while (0)

#define _AES_IV_LEN_ 8

#define SET_ICE_IV_LEN(iv_len, icv_len, encrypt)\
	do {\
		switch (encrypt) {\
		case _WEP40_:\
		case _WEP104_:\
			iv_len = 4;\
			icv_len = 4;\
			break;\
		case _TKIP_:\
			iv_len = 8;\
			icv_len = 4;\
			break;\
		case _AES_:\
			iv_len = 8;\
			icv_len = 8;\
			break;\
		case _SMS4_:\
			iv_len = 18;\
			icv_len = 16;\
			break;\
		default:\
			iv_len = 0;\
			icv_len = 0;\
			break;\
		} \
	} while (0)


#define GET_TKIP_PN(iv, dot11txpn)\
	do {\
		dot11txpn._byte_.TSC0 = iv[2];\
		dot11txpn._byte_.TSC1 = iv[0];\
		dot11txpn._byte_.TSC2 = iv[4];\
		dot11txpn._byte_.TSC3 = iv[5];\
		dot11txpn._byte_.TSC4 = iv[6];\
		dot11txpn._byte_.TSC5 = iv[7];\
	} while (0)


#define ROL32(A, n)	(((A) << (n)) | (((A)>>(32-(n)))  & ((1UL << (n)) - 1)))
#define ROR32(A, n)	ROL32((A), 32-(n))

struct mic_data {
	u32  K0, K1;         /* Key */
	u32  L, R;           /* Current state */
	u32  M;              /* Message accumulator (single word) */
	u32     nBytesInM;      /*  # bytes in M */
};

extern const u32 Te0[256];
extern const u32 Te1[256];
extern const u32 Te2[256];
extern const u32 Te3[256];
extern const u32 Te4[256];
extern const u32 Td0[256];
extern const u32 Td1[256];
extern const u32 Td2[256];
extern const u32 Td3[256];
extern const u32 Td4[256];
extern const u32 rcon[10];
extern const u8 Td4s[256];
extern const u8 rcons[10];

#define RCON(i) (rcons[(i)] << 24)

static inline u32 rotr(u32 val, int bits)
{
	return (val >> bits) | (val << (32 - bits));
}

#define TE0(i) Te0[((i) >> 24) & 0xff]
#define TE1(i) rotr(Te0[((i) >> 16) & 0xff], 8)
#define TE2(i) rotr(Te0[((i) >> 8) & 0xff], 16)
#define TE3(i) rotr(Te0[(i) & 0xff], 24)
#define TE41(i) ((Te0[((i) >> 24) & 0xff] << 8) & 0xff000000)
#define TE42(i) (Te0[((i) >> 16) & 0xff] & 0x00ff0000)
#define TE43(i) (Te0[((i) >> 8) & 0xff] & 0x0000ff00)
#define TE44(i) ((Te0[(i) & 0xff] >> 8) & 0x000000ff)
#define TE421(i) ((Te0[((i) >> 16) & 0xff] << 8) & 0xff000000)
#define TE432(i) (Te0[((i) >> 8) & 0xff] & 0x00ff0000)
#define TE443(i) (Te0[(i) & 0xff] & 0x0000ff00)
#define TE414(i) ((Te0[((i) >> 24) & 0xff] >> 8) & 0x000000ff)
#define TE4(i) ((Te0[(i)] >> 8) & 0x000000ff)

#define TD0(i) Td0[((i) >> 24) & 0xff]
#define TD1(i) rotr(Td0[((i) >> 16) & 0xff], 8)
#define TD2(i) rotr(Td0[((i) >> 8) & 0xff], 16)
#define TD3(i) rotr(Td0[(i) & 0xff], 24)
#define TD41(i) (Td4s[((i) >> 24) & 0xff] << 24)
#define TD42(i) (Td4s[((i) >> 16) & 0xff] << 16)
#define TD43(i) (Td4s[((i) >> 8) & 0xff] << 8)
#define TD44(i) (Td4s[(i) & 0xff])
#define TD0_(i) Td0[(i) & 0xff]
#define TD1_(i) rotr(Td0[(i) & 0xff], 8)
#define TD2_(i) rotr(Td0[(i) & 0xff], 16)
#define TD3_(i) rotr(Td0[(i) & 0xff], 24)

#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ \
			((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))

#define PUTU32(ct, st) { \
		(ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); \
		(ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }

#define WPA_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))

#define WPA_PUT_LE16(a, val)			\
	do {					\
		(a)[1] = ((u16) (val)) >> 8;	\
		(a)[0] = ((u16) (val)) & 0xff;	\
	} while (0)

#define WPA_PUT_BE32(a, val)					\
	do {							\
		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
	} while (0)

#define WPA_PUT_BE64(a, val)				\
	do {						\
		(a)[0] = (u8) (((u64) (val)) >> 56);	\
		(a)[1] = (u8) (((u64) (val)) >> 48);	\
		(a)[2] = (u8) (((u64) (val)) >> 40);	\
		(a)[3] = (u8) (((u64) (val)) >> 32);	\
		(a)[4] = (u8) (((u64) (val)) >> 24);	\
		(a)[5] = (u8) (((u64) (val)) >> 16);	\
		(a)[6] = (u8) (((u64) (val)) >> 8);	\
		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
	} while (0)

/* the K array */
static const unsigned long K[64] = {
	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
	0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
	0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
	0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
	0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
	0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
	0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
	0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
};


/* Various logical functions */
#define RORc(x, y) \
	(((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
	  ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
#define Ch(x, y, z)       (z ^ (x & (y ^ z)))
#define Maj(x, y, z)      (((x | y) & z) | (x & y))
#define S(x, n)         RORc((x), (n))
#define R(x, n)         (((x) & 0xFFFFFFFFUL)>>(n))
#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
#ifndef MIN
#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#endif
#ifdef CONFIG_IEEE80211W
int omac1_aes_128(const u8 *key, const u8 *data, size_t data_len, u8 *mac);
#endif /* CONFIG_IEEE80211W */
#ifdef CONFIG_RTW_MESH_AEK
int aes_siv_encrypt(const u8 *key, const u8 *pw, size_t pwlen
	, size_t num_elem, const u8 *addr[], const size_t *len, u8 *out);
int aes_siv_decrypt(const u8 *key, const u8 *iv_crypt, size_t iv_c_len
	, size_t num_elem, const u8 *addr[], const size_t *len, u8 *out);
#endif
void rtw_secmicsetkey(struct mic_data *pmicdata, u8 *key);
void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b);
void rtw_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nBytes);
void rtw_secgetmic(struct mic_data *pmicdata, u8 *dst);

void rtw_seccalctkipmic(
	u8 *key,
	u8 *header,
	u8 *data,
	u32 data_len,
	u8 *Miccode,
	u8   priority);

u32 rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe);
u32 rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe);
void rtw_wep_encrypt(_adapter *padapter, u8  *pxmitframe);

u32 rtw_aes_decrypt(_adapter *padapter, u8  *precvframe);
u32 rtw_tkip_decrypt(_adapter *padapter, u8  *precvframe);
void rtw_wep_decrypt(_adapter *padapter, u8  *precvframe);
#ifdef CONFIG_IEEE80211W
u32	rtw_BIP_verify(_adapter *padapter, u8 *whdr_pos, sint flen
	, const u8 *key, u16 id, u64* ipn);
#endif
#ifdef CONFIG_TDLS
void wpa_tdls_generate_tpk(_adapter *padapter, void *sta);
int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
			u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
			u8 *mic);
int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason,
			u8 dialog_token, u8 trans_seq, u8 *ftie, u8 *mic);
int tdls_verify_mic(u8 *kck, u8 trans_seq,
			u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
#endif /* CONFIG_TDLS */

void rtw_sec_restore_wep_key(_adapter *adapter);
u8 rtw_handle_tkip_countermeasure(_adapter *adapter, const char *caller);

#ifdef CONFIG_WOWLAN
u16 rtw_calc_crc(u8  *pdata, int length);
#endif /*CONFIG_WOWLAN*/

#define rtw_sec_chk_auth_alg(a, s) \
	((a)->securitypriv.auth_alg == (s))

#define rtw_sec_chk_auth_type(a, s) \
	((a)->securitypriv.auth_type == (s))

#endif /* __RTL871X_SECURITY_H_ */
                                                rtl8822bu/src/include/rtl8723d_xmit.h                                                               0000644 0001750 0001750 00000057317 14214766567 016144  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_XMIT_H__
#define __RTL8723D_XMIT_H__


#define MAX_TID (15)


#ifndef __INC_HAL8723DDESC_H
#define __INC_HAL8723DDESC_H

#define RX_STATUS_DESC_SIZE_8723D		24
#define RX_DRV_INFO_SIZE_UNIT_8723D 8


/* DWORD 0 */
#define SET_RX_STATUS_DESC_PKT_LEN_8723D(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_8723D(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_8723D(__pRxStatusDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

#define GET_RX_STATUS_DESC_PKT_LEN_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICV_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_EOR_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_OWN_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_TID_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_AMSDU_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_A1_FIT_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
#define GET_RX_STATUS_DESC_CHKERR_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_IPVER_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_IS_TCPUDP__8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_CHK_VLD_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_MC_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#define GET_RX_STATUS_DESC_RX_IS_QOS_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_RPT_SEL_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)
#define GET_RX_STATUS_DESC_FCS_OK_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 31, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_HTC_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#ifdef CONFIG_USB_RX_AGGREGATION
#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
#endif
#define GET_RX_STATUS_DESC_PATTERN_MATCH_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_MATCH_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_MATCH_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

/* DWORD 6 */
#define GET_RX_STATUS_DESC_MATCH_ID_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 7)

/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_8723D(__pRxStatusDesc) \
	LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

#define GET_RX_STATUS_DESC_BUFF_ADDR_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
#define GET_RX_STATUS_DESC_BUFF_ADDR64_8723D(__pRxDesc) \
	LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)

#define SET_RX_STATUS_DESC_BUFF_ADDR_8723D(__pRxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)


/* Dword 0, rsvd: bit26, bit28 */
#define GET_TX_DESC_OWN_8723D(__pTxDesc)\
	LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

#define SET_TX_DESC_PKT_SIZE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define SET_TX_DESC_OFFSET_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define SET_TX_DESC_BMC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_AMSDU_PAD_EN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_NO_ACM_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)

/* Dword 1 */
#define SET_TX_DESC_MACID_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
#define SET_TX_DESC_MORE_DATA_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)

/* Dword 2  remove P_AID, G_ID field*/
#define SET_TX_DESC_CCA_RTS_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_NULL0_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
#define SET_TX_DESC_NULL1_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
#define SET_TX_DESC_BK_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define SET_TX_DESC_RAW_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define SET_TX_DESC_CCX_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_INT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_FTM_EN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 30, 1, __Value)

/* Dword 3 */
#define SET_TX_DESC_HWSEQ_SEL_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_PORT_ID_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 2, __Value)
#define SET_TX_DESC_NAV_USE_HDR_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
#define SET_TX_DESC_USE_MAX_LEN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_TX_TRY_RATE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
#define SET_TX_DESC_PCTS_EN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
#define SET_TX_DESC_PCTS_MASK_IDX_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)

/* Dword 5 */
#define SET_TX_DESC_DATA_SC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_STBC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_RTS_STBC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
#define SET_TX_DESC_PATH_A_EN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 1, __Value)
#define SET_TX_DESC_TXPWR_OF_SET_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)

/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_MBSSID_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
#define SET_TX_DESC_RF_SEL_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)

/* Dword 7 */
#ifdef CONFIG_PCI_HCI
#define SET_TX_DESC_TX_BUFFER_SIZE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#ifdef CONFIG_USB_HCI
#define SET_TX_DESC_TX_DESC_CHECKSUM_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#ifdef CONFIG_SDIO_HCI
#define SET_TX_DESC_TX_TIMESTAMP_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 6, 18, __Value)
#endif

#define SET_TX_DESC_USB_TXAGG_NUM_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)

/* Dword 8 */
#define SET_TX_DESC_RTS_RC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
#define SET_TX_DESC_BAR_RC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
#define SET_TX_DESC_DATA_RC_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
#define SET_TX_DESC_HWSEQ_EN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
#define SET_TX_DESC_NEXTHEADPAGE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
#define SET_TX_DESC_TAILPAGE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)

/* Dword 9 */
#define SET_TX_DESC_PADDING_LEN_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
#define SET_TX_DESC_SEQ_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
#define SET_TX_DESC_FINAL_DATA_RATE_8723D(__pTxDesc, __Value) \
	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 8, __Value)


#define SET_EARLYMODE_PKTNUM_8723D(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_8723D(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_8723D(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_8723D(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_8723D(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
#define SET_EARLYMODE_LEN3_8723D(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)


/*-----------------------------------------------------------------*/
/*	RTL8723D TX BUFFER DESC                                      */
/*-----------------------------------------------------------------*/
#ifdef CONFIG_64BIT_DMA
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+4, 0, 32, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+8, 0, 32, __Valeu)
#else
	#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
	#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
	#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu)	/* 64 BIT mode only */
#endif
/* ********************************************************* */

/* 64 bits  -- 32 bits */
/* =======     ======= */
/* Dword 0     0 */
#define SET_TX_BUFF_DESC_LEN_0_8723D(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 14, __Valeu)
#define SET_TX_BUFF_DESC_PSB_8723D(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
#define SET_TX_BUFF_DESC_OWN_8723D(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

/* Dword 1     1 */
#define SET_TX_BUFF_DESC_ADDR_LOW_0_8723D(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
#define GET_TX_BUFF_DESC_ADDR_LOW_0_8723D(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0, 32)
/* Dword 2     NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_0_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 0, __Value)
#ifdef CONFIG_64BIT_DMA
	#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8723D(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+8, 0, 32)
#else
	#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8723D(__pTxDesc) 0
#endif
/* Dword 3     NA */
/* RESERVED 0 */
/* Dword 4     2 */
#define SET_TX_BUFF_DESC_LEN_1_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 1, __Value)
#define SET_TX_BUFF_DESC_AMSDU_1_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 5     3 */
#define SET_TX_BUFF_DESC_ADDR_LOW_1_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 6     NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_1_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 1, __Value)
/* Dword 7     NA */
/*RESERVED 0 */
/* Dword 8     4 */
#define SET_TX_BUFF_DESC_LEN_2_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 2, __Value)
#define SET_TX_BUFF_DESC_AMSDU_2_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 9     5 */
#define SET_TX_BUFF_DESC_ADDR_LOW_2_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 10    NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_2_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 2, __Value)
/* Dword 11    NA */
/*RESERVED 0 */
/* Dword 12    6 */
#define SET_TX_BUFF_DESC_LEN_3_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, 3, __Value)
#define SET_TX_BUFF_DESC_AMSDU_3_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 13    7 */
#define SET_TX_BUFF_DESC_ADDR_LOW_3_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 14    NA */
#define SET_TX_BUFF_DESC_ADDR_HIGH_3_8723D(__pTxDesc, __Value) SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, 3, __Value)
/* Dword 15    NA */
/*RESERVED 0 */


#endif
/* -----------------------------------------------------------
 *
 *	Rate
 *
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC8723D_RATE1M				0x00
#define DESC8723D_RATE2M				0x01
#define DESC8723D_RATE5_5M				0x02
#define DESC8723D_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC8723D_RATE6M				0x04
#define DESC8723D_RATE9M				0x05
#define DESC8723D_RATE12M				0x06
#define DESC8723D_RATE18M				0x07
#define DESC8723D_RATE24M				0x08
#define DESC8723D_RATE36M				0x09
#define DESC8723D_RATE48M				0x0a
#define DESC8723D_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC8723D_RATEMCS0				0x0c
#define DESC8723D_RATEMCS1				0x0d
#define DESC8723D_RATEMCS2				0x0e
#define DESC8723D_RATEMCS3				0x0f
#define DESC8723D_RATEMCS4				0x10
#define DESC8723D_RATEMCS5				0x11
#define DESC8723D_RATEMCS6				0x12
#define DESC8723D_RATEMCS7				0x13
#define DESC8723D_RATEMCS8				0x14
#define DESC8723D_RATEMCS9				0x15
#define DESC8723D_RATEMCS10		0x16
#define DESC8723D_RATEMCS11		0x17
#define DESC8723D_RATEMCS12		0x18
#define DESC8723D_RATEMCS13		0x19
#define DESC8723D_RATEMCS14		0x1a
#define DESC8723D_RATEMCS15		0x1b
#define DESC8723D_RATEVHTSS1MCS0		0x2c
#define DESC8723D_RATEVHTSS1MCS1		0x2d
#define DESC8723D_RATEVHTSS1MCS2		0x2e
#define DESC8723D_RATEVHTSS1MCS3		0x2f
#define DESC8723D_RATEVHTSS1MCS4		0x30
#define DESC8723D_RATEVHTSS1MCS5		0x31
#define DESC8723D_RATEVHTSS1MCS6		0x32
#define DESC8723D_RATEVHTSS1MCS7		0x33
#define DESC8723D_RATEVHTSS1MCS8		0x34
#define DESC8723D_RATEVHTSS1MCS9		0x35
#define DESC8723D_RATEVHTSS2MCS0		0x36
#define DESC8723D_RATEVHTSS2MCS1		0x37
#define DESC8723D_RATEVHTSS2MCS2		0x38
#define DESC8723D_RATEVHTSS2MCS3		0x39
#define DESC8723D_RATEVHTSS2MCS4		0x3a
#define DESC8723D_RATEVHTSS2MCS5		0x3b
#define DESC8723D_RATEVHTSS2MCS6		0x3c
#define DESC8723D_RATEVHTSS2MCS7		0x3d
#define DESC8723D_RATEVHTSS2MCS8		0x3e
#define DESC8723D_RATEVHTSS2MCS9		0x3f


#define	RX_HAL_IS_CCK_RATE_8723D(pDesc)\
	(GET_RX_STATUS_DESC_RX_RATE_8723D(pDesc) == DESC8723D_RATE1M || \
	 GET_RX_STATUS_DESC_RX_RATE_8723D(pDesc) == DESC8723D_RATE2M || \
	 GET_RX_STATUS_DESC_RX_RATE_8723D(pDesc) == DESC8723D_RATE5_5M || \
	 GET_RX_STATUS_DESC_RX_RATE_8723D(pDesc) == DESC8723D_RATE11M)

#ifdef CONFIG_TRX_BD_ARCH
	struct tx_desc;
#endif

void rtl8723d_cal_txdesc_chksum(struct tx_desc *ptxdesc);
void rtl8723d_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
void rtl8723d_fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8723d_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8723d_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
void rtl8723d_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);

#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8723ds_init_xmit_priv(PADAPTER padapter);
	void rtl8723ds_free_xmit_priv(PADAPTER padapter);
	s32 rtl8723ds_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723ds_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8723ds_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723ds_xmit_buf_handler(PADAPTER padapter);
	thread_return rtl8723ds_xmit_thread(thread_context context);
	#define hal_xmit_handler rtl8723ds_xmit_buf_handler
#endif

#ifdef CONFIG_USB_HCI
	s32 rtl8723du_xmit_buf_handler(PADAPTER padapter);
	#define hal_xmit_handler rtl8723du_xmit_buf_handler
	s32 rtl8723du_init_xmit_priv(PADAPTER padapter);
	void rtl8723du_free_xmit_priv(PADAPTER padapter);
	s32 rtl8723du_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723du_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	 rtl8723du_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8723du_xmit_tasklet(void *priv);
	s32 rtl8723du_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
	void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8723de_init_xmit_priv(PADAPTER padapter);
	void rtl8723de_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8723de_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	void	rtl8723de_xmitframe_resume(_adapter *padapter);
	s32 rtl8723de_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8723de_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8723de_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8723de_xmit_tasklet(void *priv);
#endif

u8	BWMapping_8723D(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_8723D(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif
                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/hal_sdio_coex.h                                                               0000644 0001750 0001750 00000002507 14214766567 016401  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2013 Realtek Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
 *
 *
 ******************************************************************************/
#ifndef __HAL_SDIO_COEX_H__
#define __HAL_SDIO_COEX_H__

#include <drv_types.h>

#ifdef CONFIG_SDIO_MULTI_FUNCTION_COEX

enum { /* for sdio multi-func. coex */
	SDIO_MULTI_WIFI = 0,
	SDIO_MULTI_BT,
	SDIO_MULTI_NUM
};

bool ex_hal_sdio_multi_if_bus_available(PADAPTER adapter);

#else

#define ex_hal_sdio_multi_if_bus_available(adapter) TRUE

#endif  /* CONFIG_SDIO_MULTI_FUNCTION_COEX */
#endif  /* !__HAL_SDIO_COEX_H__ */

                                                                                                                                                                                         rtl8822bu/src/include/Hal8710BPhyCfg.h                                                              0000644 0001750 0001750 00000004775 14214766567 016041  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8710BPHYCFG_H__
#define __INC_HAL8710BPHYCFG_H__

/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters End-------------------------------*/


/*------------------------------Define structure----------------------------*/

/*------------------------------Define structure End----------------------------*/

/*--------------------------Exported Function prototype---------------------*/
u32
PHY_QueryBBReg_8710B(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask
);

void
PHY_SetBBReg_8710B(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask,
		u32		Data
);

u32
PHY_QueryRFReg_8710B(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask
);

void
PHY_SetRFReg_8710B(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask,
		u32				Data
);

/* MAC/BB/RF HAL config */
int PHY_BBConfig8710B(PADAPTER	Adapter);

int PHY_RFConfig8710B(PADAPTER	Adapter);

s32 PHY_MACConfig8710B(PADAPTER padapter);

int
PHY_ConfigRFWithParaFile_8710B(
		PADAPTER			Adapter,
		u8				*pFileName,
	enum rf_path				eRFPath
);

void
PHY_SetTxPowerIndex_8710B(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

void
PHY_SetTxPowerLevel8710B(
		PADAPTER		Adapter,
		u8			channel
);

void
PHY_SetSwChnlBWMode8710B(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

/*--------------------------Exported Function prototype End---------------------*/

#endif
   rtl8822bu/src/include/Hal8723DPhyReg.h                                                              0000644 0001750 0001750 00000106034 14214766567 016054  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8723DPHYREG_H__
#define __INC_HAL8723DPHYREG_H__

#define		rSYM_WLBT_PAPE_SEL		0x64
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other definition for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC // RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rTxAGC_B_Rate18_06				0x830
#define		rTxAGC_B_Rate54_24				0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00			0x83c

#define		rTxAGC_B_Mcs07_Mcs04			0x848
#define		rTxAGC_B_Mcs11_Mcs08			0x84c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rTxAGC_B_Mcs15_Mcs12			0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now // RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define	rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC // RF BW Setting?? */
#define	rFPGA1_TxBlock				0x904	/* Useless now */
#define	rFPGA1_DebugSelect			0x908	/* Useless now */
#define	rFPGA1_TxInfo				0x90c	/* Useless now // Status report?? */
#define	rDPDT_control				0x92c
#define	rfe_ctrl_anta_src				0x930
#define	rS0S1_PathSwitch			0x948
#define	rBBrx_DFIR					0x954

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now // Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now // Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport			0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA						0xb00
#define rPdp_AntA_4						0xb04
#define rPdp_AntA_8						0xb08
#define rPdp_AntA_C						0xb0c
#define rPdp_AntA_10					0xb10
#define rPdp_AntA_14					0xb14
#define rPdp_AntA_18					0xb18
#define rPdp_AntA_1C					0xb1c
#define rPdp_AntA_20					0xb20
#define rPdp_AntA_24					0xb24

#define rConfig_Pmpd_AntA				0xb28
#define rConfig_ram64x16				0xb2c

#define rBndA							0xb30
#define rHssiPar						0xb34

#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c

#define rPdp_AntB						0xb70
#define rPdp_AntB_4						0xb74
#define rPdp_AntB_8						0xb78
#define rPdp_AntB_C						0xb7c
#define rPdp_AntB_10					0xb80
#define rPdp_AntB_14					0xb84
#define rPdp_AntB_18					0xb88
#define rPdp_AntB_1C					0xb8c
#define rPdp_AntB_20					0xb90
#define rPdp_AntB_24					0xb94

#define rConfig_Pmpd_AntB				0xb98

#define rBndB							0xba0

#define rAPK							0xbd8
#define rPm_Rx0_AntA					0xbdc
#define rPm_Rx1_AntA					0xbe0
#define rPm_Rx2_AntA					0xbe4
#define rPm_Rx3_AntA					0xbe8
#define rPm_Rx0_AntB					0xbec
#define rPm_Rx1_AntB					0xbf0
#define rPm_Rx2_AntB					0xbf4
#define rPm_Rx3_AntB					0xbf8
/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imbalance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	// DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00			0xe10
#define		rTxAGC_A_Mcs07_Mcs04			0xe14
#define		rTxAGC_A_Mcs11_Mcs08			0xe18
#define		rTxAGC_A_Mcs15_Mcs12			0xe1c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/* */

#define		RF_IQADJ_G1				0x01	/* */
#define		RF_IQADJ_G2				0x02	/* */
#define		RF_BS_PA_APSET_G1_G4		0x03
#define		RF_BS_PA_APSET_G5_G8		0x04
#define		RF_POW_TRSW				0x05	/* */

#define		RF_GAIN_RX					0x06	/* */
#define		RF_GAIN_TX					0x07	/* */

#define		RF_TXM_IDAC				0x08	/* */
#define		RF_IPA_G					0x09	/* */
#define		RF_TXBIAS_G				0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A					0x0C	/* */
#define		RF_TXBIAS_A				0x0D
#define		RF_BS_PA_APSET_G9_G11	0x0E
#define		RF_BS_IQGEN				0x0F	/* */

#define		RF_MODE1					0x10	/* */
#define		RF_MODE2					0x11	/* */

#define		RF_RX_AGC_HP				0x12	/* */
#define		RF_TX_AGC					0x13	/* */
#define		RF_BIAS						0x14	/* */
#define		RF_IPA						0x15	/* */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/* */
#define		RF_MODE_AG				0x18	/* */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/* */

#define		RF_RX_G1					0x1A	/* */
#define		RF_RX_G2					0x1B	/* */

#define		RF_RX_BB2					0x1C	/* */
#define		RF_RX_BB1					0x1D	/* */

#define		RF_RCK1					0x1E	/* */
#define		RF_RCK2					0x1F	/* */

#define		RF_TX_G1					0x20	/* */
#define		RF_TX_G2					0x21	/* */
#define		RF_TX_G3					0x22	/* */

#define		RF_TX_BB1					0x23	/* */

#define		RF_T_METER					0x24	/* */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define	RF_TX_BIAS_A				0x35
#define	RF_TX_BIAS_D				0x36
#define	RF_LOBF_9					0x38
#define	RF_RXRF_A3					0x3C	/*	 */
#define	RF_TRSW					0x3F

#define	RF_TXRF_A2					0x41
#define	RF_T_METER_88E				0x42
#define	RF_TXPA_G4					0x46
#define	RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define	RF_WE_LUT					0xEF
#define	RF_S0S1					0xB0

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
#define		RF_TX_GAIN_OFFSET_8723D(_val) (abs((_val)) | (((_val) > 0) ? BIT(4) : 0))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bAntennaSelect		0x0300

#define		bXBTxAGC                 0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                 0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI              0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength         0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV              0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW               0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           0x1000	/* Useless now */
#define		bCCKSampleRate            0x8       /* 0: 44MHz, 1:88MHz     */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode				0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble			0x8	/* Useless */
#define		bCCKAntDiversity		0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate				0x3000
#define		bCCKDCCancel			0x0800
#define		bCCKISICancel			0x0400
#define		bCCKMatchFilter			0x0200
#define		bCCKEqualizer			0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart			0x300000
#define		bCCKCCACount			0x080000
#define		bCCKcs_lim				0x070000
#define		bCCKBistMode			0x80000000
#define		bCCKCCAMask			0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset			0xf0
#define		bCCKRxDCOffset			0xf
#define		bCCKCCAMode			0xc000
#define		bCCKFalseCS_lim			0x3f00
#define		bCCKCS_ratio			0xc00000
#define		bCCKCorgBit_sel			0x300000
#define		bCCKPD_lim				0x0f0000
#define		bCCKNewCCA			0x80000000
#define		bCCKRxHPofIG			0x8000
#define		bCCKRxIG				0x7f00
#define		bCCKLNAPolarity			0x800000
#define		bCCKRx1stGain			0x7f0000
#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC			0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType	0x0300
#define		bCCKRxDAGCEn			0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0				0x3f0000
#define		bCCKTxC1				0x3f000000
#define		bCCKTxC2				0x3f
#define		bCCKTxC3				0x3f00
#define		bCCKTxC4				0x3f0000
#define		bCCKTxC5				0x3f000000
#define		bCCKTxC6				0x3f
#define		bCCKTxC7				0x3f00
#define		bCCKDebugPort			0xff0000
#define		bCCKDACDebug			0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI				0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel			0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF				0x3	/* Useless */
#define		bShift_L					0xc0
#define		bGI_TH					0xc
#define		bRxPathA				0x1
#define		bRxPathB				0x2
#define		bRxPathC				0x4
#define		bRxPathD				0x8
#define		bTxPathA				0x1
#define		bTxPathB				0x2
#define		bTxPathC				0x4
#define		bTxPathD				0x8
#define		bTRSSIFreq				0x200
#define		bADCBackoff				0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode			0x1800000
#define		bRxDCNFType			0xe000000
#define		bRXIQImb_A				0x3ff
#define		bRXIQImb_B				0xfc00
#define		bRXIQImb_C				0x3f0000
#define		bRXIQImb_D				0xffc00000
#define		bDC_dc_Notch			0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH					0xf
#define		bPD_TH_Opt2			0xc000
#define		bPWED_TH				0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option				0x1000
#define		bMF_Win_L				0xe000
#define		bBW_Search_L			0x30000
#define		bwin_enh_L				0xc0000
#define		bBW_TH					0x700000
#define		bED_TH2				0x3800000
#define		bBW_option				0x4000000
#define		bRatio_TH				0x18000000
#define		bWindow_L				0xe0000000
#define		bSBD_Option				0x1
#define		bFrame_TH				0x1c
#define		bFS_Option				0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune				0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2			0x7
#define		bFrame_GI2_TH			0x38
#define		bGI2_Sync_en			0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum				0x1
#define		bCFOAcc				0x2
#define		bCFOStartOffset			0xc
#define		bCFOLookBack			0x70
#define		bCFOSumWeight			0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A				0x3ff
#define		bTXIQImb_B				0xfc00
#define		bTXIQImb_C				0x3f0000
#define		bTXIQImb_D				0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode			0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption			0x20000
#define		bCCADropThres			0xfff00000
#define		bEDCCA_H				0xf
#define		bEDCCA_L				0xf0
#define		bLambda_ED			0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn				0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En			0x10000000
#define		bRxQuickAGCEn			0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift				0x7f
#define		bTRSW_Tri_Only			0x80
#define		bPowerThres			0x300
#define		bRxAGCEn				0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin				0x4
#define		bRxHP_Ini				0x7
#define		bRxHP_TRLNA			0x70
#define		bRxHP_RSSI				0x700
#define		bRxHP_BBP1				0x7000
#define		bRxHP_BBP2				0x70000
#define		bRxHP_BBP3				0x700000
#define		bRSSI_H					0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW			0x7
#define		bRxSettle_LNA			0x38
#define		bRxSettle_RSSI			0x1c0
#define		bRxSettle_BBP			0xe00
#define		bRxSettle_RxHP			0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI			0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final				0x7000000
#define		bRxHTSettle_BBP			0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn			0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin			0x80000
#define		bRxHTAGCEn				0x100000
#define		bRxHTDAGCEn			0x200000
#define		bRxHTRxHP_BBP			0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH			0x3
#define		bRxPWRatioEn			0x4
#define		bRxMFHold				0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH			0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L			0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH				0xc0000000
#define		bDFSCnt0				0xff
#define		bDFSCnt1				0xff00
#define		bDFSFlag				0xf0000
#define		bMFWeightSum			0x300000
#define		bMinIdxTH				0x7f000000
#define		bDAFormat				0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain				0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn				0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss					0x20
#define		bCFOAntSumD			0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet			0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn				0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re		0x3f
#define		bSigTone_Im		0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail	0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail	0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync	0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength	12   /* total */
#define		bShortCFOFLength	11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength	11
#define		bLongCFOFLength	11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW			0x1
#define		bRxSC				0x6
#define		bRx_HT				0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg	0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain				0x3f
#define		bTableSel			0x40
#define		bTRSW				0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st				0xff
#define		bCSI2nd				0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd			0xff000000
#define		bSIGEVM			0xff
#define		bPWDB				0xff00
#define		bSGIEN				0x10000

#define		bSFactorQAM1		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode			0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType		0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO			0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC					0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF		0x20000
#define		bComChCFO			0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz			0x100000
#define		bUChCfg				0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C	0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW		0x18
#define		bRTL8256_RxLPFBW		0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW		0xc	/* Useless */
#define		bRTL8258_RxLPFBW		0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0				0x1	/* Useless */
#define		bByte1				0x2
#define		bByte2				0x4
#define		bByte3				0x8
#define		bWord0				0x3
#define		bWord1				0xc
#define		bDWord				0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1			0xff00
#define		bMaskByte2			0xff0000
#define		bMaskByte3			0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord			0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes		0xffffff00
#define		bMask12Bits			0xfff
#define		bMaskH4Bits			0xf0000000
#define		bMaskOFDM_D		0xffc00000
#define		bMaskCCK			0x3f3f3f3f


#define		bEnable			0x1	/* Useless */
#define		bDisable		0x0

#define		LeftAntenna		0x0	/* Useless */
#define		RightAntenna	0x1

#define		tCheckTxStatus		500   /* 500ms // Useless */
#define		tUpdateRxCounter	100   /* 100ms */

#define		rateCCK		0	/* Useless */
#define		rateOFDM	1
#define		rateHT		2

/* define Register-End */
#define		bPMAC_End			0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/Hal8192FPhyCfg.h                                                              0000644 0001750 0001750 00000005107 14214766567 016037  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8192FPHYCFG_H__
#define __INC_HAL8192FPHYCFG_H__

/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3

#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters End-------------------------------*/


/*------------------------------Define structure----------------------------*/

/*------------------------------Define structure End----------------------------*/

/*--------------------------Exported Function prototype---------------------*/
u32
PHY_QueryBBReg_8192F(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask
);

void
PHY_SetBBReg_8192F(
		PADAPTER	Adapter,
		u32		RegAddr,
		u32		BitMask,
		u32		Data
);

u32
PHY_QueryRFReg_8192F(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask
);

void
PHY_SetRFReg_8192F(
		PADAPTER		Adapter,
		enum rf_path		eRFPath,
		u32				RegAddr,
		u32				BitMask,
		u32				Data
);

/* MAC/BB/RF HAL config */
int PHY_BBConfig8192F(PADAPTER	Adapter	);

int PHY_RFConfig8192F(PADAPTER	Adapter);

s32 PHY_MACConfig8192F(PADAPTER padapter);

int
PHY_ConfigRFWithParaFile_8192F(
		PADAPTER			Adapter,
		u8				*pFileName,
	enum rf_path				eRFPath
);

void
PHY_SetTxPowerIndex_8192F(
		PADAPTER			Adapter,
		u32					PowerIndex,
		enum rf_path			RFPath,
		u8					Rate
);

void
PHY_SetTxPowerLevel8192F(
		PADAPTER		Adapter,
		u8			channel
);

void
PHY_SetSwChnlBWMode8192F(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

void phy_set_rf_path_switch_8192f(
		PADAPTER	pAdapter,
		bool		bMain
);
/*--------------------------Exported Function prototype End---------------------*/

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/Hal8723BPwrSeq.h                                                              0000644 0001750 0001750 00000055162 14214766567 016102  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8723B
#define REALTEK_POWER_SEQUENCE_8723B

#include "HalPwrSeqCmd.h"

/*
	Check document WM-20130815-JackieLau-RTL8723B_Power_Architecture v08.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8723B_TRANS_CARDEMU_TO_ACT_STEPS	26
#define	RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS	15
#define	RTL8723B_TRANS_CARDEMU_TO_SUS_STEPS	15
#define	RTL8723B_TRANS_SUS_TO_CARDEMU_STEPS	15
#define	RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS	15
#define	RTL8723B_TRANS_PDN_TO_CARDEMU_STEPS	15
#define	RTL8723B_TRANS_ACT_TO_LPS_STEPS		15
#define	RTL8723B_TRANS_LPS_TO_ACT_STEPS		15
#define	RTL8723B_TRANS_ACT_TO_SWLPS_STEPS		22
#define	RTL8723B_TRANS_SWLPS_TO_ACT_STEPS		15
#define	RTL8723B_TRANS_END_STEPS		1


#define RTL8723B_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3 | BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[11]=0*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3), 0},/* disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	\
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/* Enable WL control XTAL setting*/	\
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable GPIO9 interrupt mode*/\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable HSISR GPIO9 interrupt*/\
	{0x0068, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3},/*For GPIO9 internal pull high setting by test chip*/\
	{0x0069, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/*For GPIO9 internal pull high setting*/\


#define RTL8723B_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, 0},/* Enable BT control XTAL setting*/\
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/\


#define RTL8723B_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, (BIT4 | BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8723B_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8723B_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8723B_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/


#define RTL8723B_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK | PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8723B_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8723B_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8723B_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/


#define RTL8723B_TRANS_ACT_TO_SWLPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*enable 32 K source*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1},/*CCK and OFDM are enable*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1},/*CCK and OFDM are enable*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*disable security engine*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x40},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*reset dual TSF*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/*Reset CPU*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*Reset MCUFWDL register*/	\
	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1},/*Reset CPU IO Wrapper*/	\
	{0x0287, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*polling RXFF packet number = 0 */	\
	{0x0286, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/*polling RXDMA idle */	\
	{0x013D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Clear FW RPWM interrupt */\
	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Set FW RPWM interrupt source*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/*switch TSF to 32K*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/*polling TSF stable*/\
	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Set FW LPS*/	\
	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/*polling FW LPS ready */


#define RTL8723B_TRANS_SWLPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/*switch TSF to 32K*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*polling TSF stable*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1, enable security engine*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x06B7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x09}, /*.	reset MAC rx state machine*/\
	{0x06B4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x86}, /*.	reset MAC rx state machine*/\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/* set CPU RAM code ready*/	\
	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* Enable CPU*/	\
	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*enable CPU IO Wrapper*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2},/* Enable CPU*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, BIT7},/*polling FW init ready */	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT6, BIT6},/*polling FW init ready */	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8723B_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8723B_power_on_flow[RTL8723B_TRANS_CARDEMU_TO_ACT_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_radio_off_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_card_disable_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_card_enable_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_suspend_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723B_TRANS_CARDEMU_TO_SUS_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_resume_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723B_TRANS_CARDEMU_TO_SUS_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_hwpdn_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_enter_lps_flow[RTL8723B_TRANS_ACT_TO_LPS_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_leave_lps_flow[RTL8723B_TRANS_LPS_TO_ACT_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_enter_swlps_flow[RTL8723B_TRANS_ACT_TO_SWLPS_STEPS + RTL8723B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8723B_leave_swlps_flow[RTL8723B_TRANS_SWLPS_TO_ACT_STEPS + RTL8723B_TRANS_END_STEPS];
#endif
                                                                                                                                                                                                                                                                                                                                                                                                              rtl8822bu/src/include/rtl8822cs_hal.h                                                               0000755 0001750 0001750 00000002107 14214766567 016077  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822CS_HAL_H_
#define _RTL8822CS_HAL_H_

#include <drv_types.h>		/* PADAPTER */

/* rtl8822cs_ops.c */
void rtl8822cs_set_hal_ops(PADAPTER);

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
void rtl8822cs_disable_interrupt_but_cpwm2(PADAPTER adapter);
#endif

/* rtl8822cs_xmit.c */
s32 rtl8822cs_dequeue_writeport(PADAPTER);
#define _dequeue_writeport(a)	rtl8822cs_dequeue_writeport(a)

#endif /* _RTL8822CS_HAL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/rtl8814bu_hal.h                                                               0000755 0001750 0001750 00000003451 14214766567 016104  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8814BU_HAL_H_
#define _RTL8814BU_HAL_H_

#ifdef CONFIG_USB_HCI
	#include <drv_types.h>		/* PADAPTER */

	#ifdef CONFIG_USB_HCI
		#ifdef USB_PACKET_OFFSET_SZ
			#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
		#else
			#define PACKET_OFFSET_SZ (8)
		#endif
		#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
	#endif

	/* undefine MAX_RECVBUF_SZ from rtl8822c_hal.h  */
	#ifdef MAX_RECVBUF_SZ
		#undef MAX_RECVBUF_SZ
	#endif

	/* recv_buffer must be large than usb agg size */
	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			#ifdef CONFIG_PLATFORM_NOVATEK_NT72668
				#define MAX_RECVBUF_SZ (15360) /* 15k */
				#elif defined(CONFIG_PLATFORM_HISILICON)
				/* use 16k to workaround for HISILICON platform */
				#define MAX_RECVBUF_SZ (16384)
			#else
				#define MAX_RECVBUF_SZ (32768)
			#endif
		#else
			#define MAX_RECVBUF_SZ (4000)
		#endif
	#endif /* !MAX_RECVBUF_SZ */

	/* rtl8814bu_ops.c */
	void rtl8814bu_set_hal_ops(PADAPTER padapter);
	void rtl8814bu_set_hw_type(struct dvobj_priv *pdvobj);

	/* rtl8814bu_io.c */
	void rtl8814bu_set_intf_ops(struct _io_ops *pops);

#endif /* CONFIG_USB_HCI */


#endif /* _RTL8814BU_HAL_H_ */
                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8188f_sreset.h                                                             0000644 0001750 0001750 00000001627 14214766567 016470  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8188F_SRESET_H_
#define _RTL8188F_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
extern void rtl8188f_sreset_xmit_status_check(_adapter *padapter);
extern void rtl8188f_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                         rtl8822bu/src/include/rtw_ioctl_query.h                                                             0000644 0001750 0001750 00000001321 14214766567 017025  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_IOCTL_QUERY_H_
#define _RTW_IOCTL_QUERY_H_


#endif
                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/rtl8703b_xmit.h                                                               0000644 0001750 0001750 00000047066 14214766567 016140  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8703B_XMIT_H__
#define __RTL8703B_XMIT_H__


#define MAX_TID (15)


#ifndef __INC_HAL8703BDESC_H
	#define __INC_HAL8703BDESC_H

	#define RX_STATUS_DESC_SIZE_8703B		24
	#define RX_DRV_INFO_SIZE_UNIT_8703B 8


	/* DWORD 0 */
	#define SET_RX_STATUS_DESC_PKT_LEN_8703B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
	#define SET_RX_STATUS_DESC_EOR_8703B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
	#define SET_RX_STATUS_DESC_OWN_8703B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

	#define GET_RX_STATUS_DESC_PKT_LEN_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
	#define GET_RX_STATUS_DESC_CRC32_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
	#define GET_RX_STATUS_DESC_ICV_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
	#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
	#define GET_RX_STATUS_DESC_SECURITY_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
	#define GET_RX_STATUS_DESC_QOS_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
	#define GET_RX_STATUS_DESC_SHIFT_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
	#define GET_RX_STATUS_DESC_PHY_STATUS_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
	#define GET_RX_STATUS_DESC_SWDEC_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
	#define GET_RX_STATUS_DESC_LAST_SEG_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 28, 1)
	#define GET_RX_STATUS_DESC_FIRST_SEG_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 29, 1)
	#define GET_RX_STATUS_DESC_EOR_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
	#define GET_RX_STATUS_DESC_OWN_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

	/* DWORD 1 */
	#define GET_RX_STATUS_DESC_MACID_8703B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
	#define GET_RX_STATUS_DESC_TID_8703B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
	#define GET_RX_STATUS_DESC_AMSDU_8703B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
	#define GET_RX_STATUS_DESC_RXID_MATCH_8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
	#define GET_RX_STATUS_DESC_PAGGR_8703B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
	#define GET_RX_STATUS_DESC_A1_FIT_8703B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
	#define GET_RX_STATUS_DESC_CHKERR_8703B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
	#define GET_RX_STATUS_DESC_IPVER_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
	#define GET_RX_STATUS_DESC_IS_TCPUDP__8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
	#define GET_RX_STATUS_DESC_CHK_VLD_8703B(__pRxDesc)	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
	#define GET_RX_STATUS_DESC_PAM_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
	#define GET_RX_STATUS_DESC_PWR_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
	#define GET_RX_STATUS_DESC_MORE_DATA_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
	#define GET_RX_STATUS_DESC_MORE_FRAG_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
	#define GET_RX_STATUS_DESC_TYPE_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
	#define GET_RX_STATUS_DESC_MC_8703B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
	#define GET_RX_STATUS_DESC_BC_8703B(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

	/* DWORD 2 */
	#define GET_RX_STATUS_DESC_SEQ_8703B(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
	#define GET_RX_STATUS_DESC_FRAG_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
	#define GET_RX_STATUS_DESC_RX_IS_QOS_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
	#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8703B(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
	#define GET_RX_STATUS_DESC_RPT_SEL_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)

	/* DWORD 3 */
	#define GET_RX_STATUS_DESC_RX_RATE_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
	#define GET_RX_STATUS_DESC_HTC_8703B(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
	#define GET_RX_STATUS_DESC_EOSP_8703B(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
	#define GET_RX_STATUS_DESC_BSSID_FIT_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
	#ifdef CONFIG_USB_RX_AGGREGATION
		#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8703B(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
	#endif
	#define GET_RX_STATUS_DESC_PATTERN_MATCH_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
	#define GET_RX_STATUS_DESC_UNICAST_MATCH_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
	#define GET_RX_STATUS_DESC_MAGIC_MATCH_8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

	/* DWORD 6 */
	#define GET_RX_STATUS_DESC_SPLCP_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 1)
	#define GET_RX_STATUS_DESC_LDPC_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 1, 1)
	#define GET_RX_STATUS_DESC_STBC_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 2, 1)
	#define GET_RX_STATUS_DESC_BW_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 4, 2)

	/* DWORD 5 */
	#define GET_RX_STATUS_DESC_TSFL_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

	#define GET_RX_STATUS_DESC_BUFF_ADDR_8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
	#define GET_RX_STATUS_DESC_BUFF_ADDR64_8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)

	#define SET_RX_STATUS_DESC_BUFF_ADDR_8703B(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)


	/* Dword 0 */
	#define GET_TX_DESC_OWN_8703B(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

	#define SET_TX_DESC_PKT_SIZE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
	#define SET_TX_DESC_OFFSET_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
	#define SET_TX_DESC_BMC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
	#define SET_TX_DESC_HTC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
	#define SET_TX_DESC_LAST_SEG_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
	#define SET_TX_DESC_FIRST_SEG_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
	#define SET_TX_DESC_LINIP_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
	#define SET_TX_DESC_NO_ACM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
	#define SET_TX_DESC_GF_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
	#define SET_TX_DESC_OWN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

	/* Dword 1 */
	#define SET_TX_DESC_MACID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
	#define SET_TX_DESC_QUEUE_SEL_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
	#define SET_TX_DESC_RDG_NAV_EXT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
	#define SET_TX_DESC_LSIG_TXOP_EN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
	#define SET_TX_DESC_PIFS_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
	#define SET_TX_DESC_RATE_ID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
	#define SET_TX_DESC_EN_DESC_ID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
	#define SET_TX_DESC_SEC_TYPE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
	#define SET_TX_DESC_PKT_OFFSET_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)


	/* Dword 2 */
	#define SET_TX_DESC_PAID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
	#define SET_TX_DESC_CCA_RTS_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
	#define SET_TX_DESC_AGG_ENABLE_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
	#define SET_TX_DESC_RDG_ENABLE_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
	#define SET_TX_DESC_AGG_BREAK_8703B(__pTxDesc, __Value)				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
	#define SET_TX_DESC_MORE_FRAG_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
	#define SET_TX_DESC_RAW_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
	#define SET_TX_DESC_SPE_RPT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
	#define SET_TX_DESC_AMPDU_DENSITY_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
	#define SET_TX_DESC_BT_INT_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
	#define SET_TX_DESC_GID_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)


	/* Dword 3 */
	#define SET_TX_DESC_WHEADER_LEN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
	#define SET_TX_DESC_CHK_EN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
	#define SET_TX_DESC_EARLY_MODE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
	#define SET_TX_DESC_HWSEQ_SEL_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
	#define SET_TX_DESC_USE_RATE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
	#define SET_TX_DESC_DISABLE_RTS_FB_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
	#define SET_TX_DESC_DISABLE_FB_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
	#define SET_TX_DESC_CTS2SELF_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
	#define SET_TX_DESC_RTS_ENABLE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
	#define SET_TX_DESC_HW_RTS_ENABLE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
	#define SET_TX_DESC_NAV_USE_HDR_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
	#define SET_TX_DESC_USE_MAX_LEN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
	#define SET_TX_DESC_MAX_AGG_NUM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
	#define SET_TX_DESC_NDPA_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
	#define SET_TX_DESC_AMPDU_MAX_TIME_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

	/* Dword 4 */
	#define SET_TX_DESC_TX_RATE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
	#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
	#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
	#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
	#define SET_TX_DESC_DATA_RETRY_LIMIT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
	#define SET_TX_DESC_RTS_RATE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)


	/* Dword 5 */
	#define SET_TX_DESC_DATA_SC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
	#define SET_TX_DESC_DATA_SHORT_8703B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
	#define SET_TX_DESC_DATA_BW_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
	#define SET_TX_DESC_DATA_LDPC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
	#define SET_TX_DESC_DATA_STBC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
	#define SET_TX_DESC_CTROL_STBC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
	#define SET_TX_DESC_RTS_SHORT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
	#define SET_TX_DESC_RTS_SC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)


	/* Dword 6 */
	#define SET_TX_DESC_SW_DEFINE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
	#define SET_TX_DESC_MBSSID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
	#define SET_TX_DESC_ANTSEL_A_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
	#define SET_TX_DESC_ANTSEL_B_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
	#define SET_TX_DESC_ANTSEL_C_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
	#define SET_TX_DESC_ANTSEL_D_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)

	/* Dword 7 */
	#ifdef CONFIG_PCI_HCI
		#define SET_TX_DESC_TX_BUFFER_SIZE_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
	#endif /*CONFIG_PCI_HCI*/
	#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
		#define SET_TX_DESC_TX_DESC_CHECKSUM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
	#endif
	#define SET_TX_DESC_USB_TXAGG_NUM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
	#ifdef CONFIG_SDIO_HCI
		#define SET_TX_DESC_SDIO_TXSEQ_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
	#endif

	/* Dword 8 */
	#define SET_TX_DESC_HWSEQ_EN_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)

	/* Dword 9 */
	#define SET_TX_DESC_SEQ_8703B(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)

	/* Dword 10 */
	#define SET_TX_DESC_TX_BUFFER_ADDRESS_8703B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
	#define GET_TX_DESC_TX_BUFFER_ADDRESS_8703B(__pTxDesc)	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)

	/* Dword 11 */
	#define SET_TX_DESC_NEXT_DESC_ADDRESS_8703B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)


	#define SET_EARLYMODE_PKTNUM_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
	#define SET_EARLYMODE_LEN0_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
	#define SET_EARLYMODE_LEN1_1_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
	#define SET_EARLYMODE_LEN1_2_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
	#define SET_EARLYMODE_LEN2_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
	#define SET_EARLYMODE_LEN3_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)

#endif
/* -----------------------------------------------------------
 *
 *	Rate
 *
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC8703B_RATE1M				0x00
#define DESC8703B_RATE2M				0x01
#define DESC8703B_RATE5_5M				0x02
#define DESC8703B_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC8703B_RATE6M				0x04
#define DESC8703B_RATE9M				0x05
#define DESC8703B_RATE12M				0x06
#define DESC8703B_RATE18M				0x07
#define DESC8703B_RATE24M				0x08
#define DESC8703B_RATE36M				0x09
#define DESC8703B_RATE48M				0x0a
#define DESC8703B_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC8703B_RATEMCS0				0x0c
#define DESC8703B_RATEMCS1				0x0d
#define DESC8703B_RATEMCS2				0x0e
#define DESC8703B_RATEMCS3				0x0f
#define DESC8703B_RATEMCS4				0x10
#define DESC8703B_RATEMCS5				0x11
#define DESC8703B_RATEMCS6				0x12
#define DESC8703B_RATEMCS7				0x13
#define DESC8703B_RATEMCS8				0x14
#define DESC8703B_RATEMCS9				0x15
#define DESC8703B_RATEMCS10		0x16
#define DESC8703B_RATEMCS11		0x17
#define DESC8703B_RATEMCS12		0x18
#define DESC8703B_RATEMCS13		0x19
#define DESC8703B_RATEMCS14		0x1a
#define DESC8703B_RATEMCS15		0x1b
#define DESC8703B_RATEVHTSS1MCS0		0x2c
#define DESC8703B_RATEVHTSS1MCS1		0x2d
#define DESC8703B_RATEVHTSS1MCS2		0x2e
#define DESC8703B_RATEVHTSS1MCS3		0x2f
#define DESC8703B_RATEVHTSS1MCS4		0x30
#define DESC8703B_RATEVHTSS1MCS5		0x31
#define DESC8703B_RATEVHTSS1MCS6		0x32
#define DESC8703B_RATEVHTSS1MCS7		0x33
#define DESC8703B_RATEVHTSS1MCS8		0x34
#define DESC8703B_RATEVHTSS1MCS9		0x35
#define DESC8703B_RATEVHTSS2MCS0		0x36
#define DESC8703B_RATEVHTSS2MCS1		0x37
#define DESC8703B_RATEVHTSS2MCS2		0x38
#define DESC8703B_RATEVHTSS2MCS3		0x39
#define DESC8703B_RATEVHTSS2MCS4		0x3a
#define DESC8703B_RATEVHTSS2MCS5		0x3b
#define DESC8703B_RATEVHTSS2MCS6		0x3c
#define DESC8703B_RATEVHTSS2MCS7		0x3d
#define DESC8703B_RATEVHTSS2MCS8		0x3e
#define DESC8703B_RATEVHTSS2MCS9		0x3f


#define	RX_HAL_IS_CCK_RATE_8703B(pDesc)\
	(GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE1M || \
	 GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE2M || \
	 GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE5_5M || \
	 GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE11M)


void rtl8703b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
void rtl8703b_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8703bs_init_xmit_priv(PADAPTER padapter);
	void rtl8703bs_free_xmit_priv(PADAPTER padapter);
	s32 rtl8703bs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8703bs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8703bs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8703bs_xmit_buf_handler(PADAPTER padapter);
	thread_return rtl8703bs_xmit_thread(thread_context context);
	#define hal_xmit_handler rtl8703bs_xmit_buf_handler
#endif

#ifdef CONFIG_USB_HCI
	s32 rtl8703bu_xmit_buf_handler(PADAPTER padapter);
	#define hal_xmit_handler rtl8703bu_xmit_buf_handler


	s32 rtl8703bu_init_xmit_priv(PADAPTER padapter);
	void rtl8703bu_free_xmit_priv(PADAPTER padapter);
	s32 rtl8703bu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8703bu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	 rtl8703bu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	/* s32 rtl8812au_xmit_buf_handler(PADAPTER padapter); */
	void rtl8703bu_xmit_tasklet(void *priv);
	s32 rtl8703bu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
	void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8703be_init_xmit_priv(PADAPTER padapter);
	void rtl8703be_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8703be_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	void	rtl8703be_xmitframe_resume(_adapter *padapter);
	s32 rtl8703be_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8703be_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8703be_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8703be_xmit_tasklet(void *priv);
#endif

u8	BWMapping_8703B(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_8703B(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          rtl8822bu/src/include/Hal8814PwrSeq.h                                                               0000644 0001750 0001750 00000053434 14214766567 016001  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/


#ifndef __HAL8814PWRSEQ_H__
#define __HAL8814PWRSEQ_H__

#include "HalPwrSeqCmd.h"

/*
	Check document WB-110628-DZ-RTL8195 (Jaguar) Power Architecture-R04.pdf
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8814A_TRANS_CARDEMU_TO_ACT_STEPS	16
#define	RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS	20
#define	RTL8814A_TRANS_CARDEMU_TO_SUS_STEPS	17
#define	RTL8814A_TRANS_SUS_TO_CARDEMU_STEPS	15
#define	RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS	17
#define	RTL8814A_TRANS_PDN_TO_CARDEMU_STEPS	16
#define	RTL8814A_TRANS_ACT_TO_LPS_STEPS	20
#define	RTL8814A_TRANS_LPS_TO_ACT_STEPS	15
#define	RTL8814A_TRANS_END_STEPS	1


#define RTL8814A_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x002B, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /* ??0x28[24]=1, enable pll phase select*/ \
	{0x0015, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT3 | BIT2 | BIT1), (BIT3 | BIT2 | BIT1)},/* 0x14[11:9]=3'b111, OCP current threshold = 1.5A */ \
	{0x002D, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x0E, 0x08},/* 0x2C[11:9]=3'b100, select lpf R3 */ \
	{0x002D, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x70, 0x50},/* 0x2C[14:12]=3'b101, select lpf Rs*/ \
	{0x007B, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/* 0x78[30]=1'b1, SDM order select*/ \
	/*{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0}, */ /* disable HWPDN 0x04[15]=0*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, 0},/* disable WL suspend*/	\
	{0x00F0, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* */	\
	{0x0081, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x30, 0x20},/* */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/

#define RTL8814A_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},  /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US}, /*Delay 1us*/	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
	{0x1002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},  /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
	{0x0002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US}, /*Delay 1us*/	\
	{0x1002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},  /*0x1F[7:0] = 0 turn off RF*/	\
	/*{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},*/  /*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x28},   /* 0x07[7:0] = 0x28 sps pwm mode 0x2a for BT coex*/	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x02, 0},   /*0x8[1] = 0 ANA clk = 500k */	\
	/*{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 | BIT1, 0},*/   /*  0x02[1:0] = 0	reset BB */	\
	{0x0066, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},   /*0x66[7]=0, disable ckreq for gpio7 output SUS */	\
	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},   /*0x41[4]=0, disable sic for gpio7 output SUS */	\
	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},   /*0x42[1]=0, disable ckout for gpio7 output SUS */	\
	{0x004e, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},   /*0x4E[5]=1, disable LED2 for gpio7 output SUS */	\
	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},   /*0x41[0]=0, disable uart for gpio7 output SUS */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/

#define RTL8814A_TRANS_CARDEMU_TO_SUS													\
	/* format */								\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0061, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x0F, 0x0c},\
	{0x0061, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x0F, 0x0E},\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x0F, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/* suspend option all off */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*0x14[13] = 1 turn on ZCD */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/* 0x14[14] =1 trun on ZCD */	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*0x8[1] = 0 ANA clk = 500k */	\
	{0x0091, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xA0, 0xA0}, /* 0x91[7]=1 0x91[5]=1 , disable sps, ldo sleep mode */	\
	{0x0070, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3}, /* 0x70[3]=1 enable mainbias polling */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 1 enable WL suspend */

#define RTL8814A_TRANS_SUS_TO_CARDEMU													\
	/* format */								\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 0 enable WL suspend*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO sleep mode leave */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, 0},/* 0x14[14] =0 trun off ZCD */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0},/*0x14[13] = 0 turn off ZCD */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */

#define RTL8814A_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	/**{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, //0x194[0]=0 , disable 32K clock*/	\
	/**{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x94}, //0x93 = 0x94 , 90[30] =0 enable 500k ANA clock .switch clock from 12M to 500K , 90 [26] =0 disable EEprom loader clock*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0}, /*0x03[2] = 0, reset 3081*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x01}, /*0x80 = 05h if reload fw, fill the default value of host_CPU handshake field*/	\
	{0x0081, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x30}, /*0x80 = 05h if reload fw, fill the default value of host_CPU handshake field*/	\
	/*{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xF0, 0xcc},*/   \
	/*{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xF0, 0xEC},*/   \
	/*{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x07},*/  /* gpio11 input mode, gpio10~8 output mode */	\
	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/* 0x15[6] =1 trun on ZCD output */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*0x15[5] = 1 turn on ZCD */	\
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, 0},/*0x12[6] = 0 force PFM mode */	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*0x8[1] = 0 ANA clk = 500k */	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0}, /* 0x01f[1]=0 , disable RFC_0  control  REG_RF_CTRL_8814A */	\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0}, /* 0x020[1]=0 , disable RFC_1  control  REG_RF_CTRL_8814A */	\
	{0x0021, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0}, /* 0x021[1]=0 , disable RFC_2  control  REG_RF_CTRL_8814A */	\
	{0x0076, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0}, /* 0x076[1]=0 , disable RFC_3  control REG_OPT_CTRL_8814A +2 */	\
	{0x0091, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xA0, 0xA0}, /* 0x91[7]=1 0x91[5]=1 , disable sps, ldo sleep mode */	\
	{0x0070, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3}, /* 0x70[3]=1 enable mainbias polling */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 1 enable WL suspend*/

#define RTL8814A_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/                       \
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/*0x12[6] = 1 force PWM mode */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0},/*0x15[5] = 0 turn off ZCD */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, 0},/* 0x15[6] =0 trun off ZCD output */	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/*0x23[4] = 0 hpon LDO leave sleep mode */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00}, /* gpio11 input mode, gpio10~8 input mode */ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0}, /*0x04[10] = 0, enable SW LPS PCIE only*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 0, enable WL suspend*/	\
	/*{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2},*/ /*0x03[2] = 1, enable 3081*/	\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/		\
	{0x0071, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/*0x70[10] = 0, CPHY_MBIAS_EN disable*/


#define RTL8814A_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8814A_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8814A_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/		\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated, and RF closed*/	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
	{0x1002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated, and RF closed*/	\
	{0x0002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x1002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/			\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/		\
	{0x05F1, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Respond TxOK to scheduler*/


#define RTL8814A_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/	\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/	\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /* Delay*/	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/	\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /* Polling 0x109[7]=0  TSF in 40M*/			\
	/*{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, */ /*.	??0x29[7:6] = 2b'00	 enable BB clock*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/					\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/	\
	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/	\
	{0x1002, (u8)(~PWR_CUT_TESTCHIP_MSK), PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x1002[1:0] = 2b'11	 enable BB macro*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8814A_TRANS_END																\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/		\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


extern WLAN_PWR_CFG rtl8814A_power_on_flow[RTL8814A_TRANS_CARDEMU_TO_ACT_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_radio_off_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_card_disable_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_card_enable_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_suspend_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8814A_TRANS_CARDEMU_TO_SUS_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_resume_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8814A_TRANS_CARDEMU_TO_SUS_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_hwpdn_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS + RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_enter_lps_flow[RTL8814A_TRANS_ACT_TO_LPS_STEPS + RTL8814A_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8814A_leave_lps_flow[RTL8814A_TRANS_LPS_TO_ACT_STEPS + RTL8814A_TRANS_END_STEPS];

#endif /* __HAL8814PWRSEQ_H__ */
                                                                                                                                                                                                                                    rtl8822bu/src/include/rtl8188f_hal.h                                                                0000644 0001750 0001750 00000022232 14214766567 015722  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_HAL_H__
#define __RTL8188F_HAL_H__

#include "hal_data.h"

#include "rtl8188f_spec.h"
#include "rtl8188f_rf.h"
#include "rtl8188f_dm.h"
#include "rtl8188f_recv.h"
#include "rtl8188f_xmit.h"
#include "rtl8188f_cmd.h"
#include "rtl8188f_led.h"
#include "Hal8188FPwrSeq.h"
#include "Hal8188FPhyReg.h"
#include "Hal8188FPhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
#include "rtl8188f_sreset.h"
#endif

#define FW_8188F_SIZE			0x8000
#define FW_8188F_START_ADDRESS	0x1000
#define FW_8188F_END_ADDRESS		0x1FFF /* 0x5FFF */

#define IS_FW_HEADER_EXIST_8188F(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x88F0)

typedef struct _RT_FIRMWARE {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_8188F_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8188F, *PRT_FIRMWARE_8188F;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
typedef struct _RT_8188F_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u16		Subversion;	/* FW Subversion, default 0x00 */

	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u16		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8188F_FIRMWARE_HDR, *PRT_8188F_FIRMWARE_HDR;

#define DRIVER_EARLY_INT_TIME_8188F		0x05
#define BCN_DMA_ATIME_INT_TIME_8188F		0x02

/* for 8188F
 * TX 32K, RX 16K, Page size 128B for TX, 8B for RX */
#define PAGE_SIZE_TX_8188F			128
#define PAGE_SIZE_RX_8188F			8

#define RX_DMA_SIZE_8188F			0x4000	/* 16K */
#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8188F	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8188F	0x80	/* 128B, reserved for tx report */
#endif

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#define RX_DMA_BOUNDARY_8188F		(RX_DMA_SIZE_8188F - RX_DMA_RESERVED_SIZE_8188F - 1)

/* Note: We will divide number of page equally for each queue other than public queue! */

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * BCN rsvd_page_num = MAX_BEACON_LEN / PAGE_SIZE_TX_8188F,
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1, CTS-2-SELF / LTE QoS Null */

#define BCNQ_PAGE_NUM_8188F		(MAX_BEACON_LEN / PAGE_SIZE_TX_8188F + 6) /*0x08*/

/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt:1 ,PNO: 6
 * NS offload:2 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8188F	0x0b
#else
	#define WOWLAN_PAGE_NUM_8188F	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
#undef WOWLAN_PAGE_NUM_8188F
#define WOWLAN_PAGE_NUM_8188F	0x15
#endif

#ifdef CONFIG_AP_WOWLAN
#define AP_WOWLAN_PAGE_NUM_8188F	0x02
#endif

#define TX_TOTAL_PAGE_NUMBER_8188F	(0xFF - BCNQ_PAGE_NUM_8188F - WOWLAN_PAGE_NUM_8188F)
#define TX_PAGE_BOUNDARY_8188F		(TX_TOTAL_PAGE_NUMBER_8188F + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8188F	TX_TOTAL_PAGE_NUMBER_8188F
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8188F		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8188F + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8188F */
#define NORMAL_PAGE_NUM_HPQ_8188F		0x0C
#define NORMAL_PAGE_NUM_LPQ_8188F		0x02
#define NORMAL_PAGE_NUM_NPQ_8188F		0x02

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8188F		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8188F		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8188F		0x20


#include "HalVerDef.h"
#include "hal_com.h"

#define EFUSE_OOB_PROTECT_BYTES (34 + 1)

#define HAL_EFUSE_MEMORY

#define HWSET_MAX_SIZE_8188F			512
#define EFUSE_REAL_CONTENT_LEN_8188F	256
#define EFUSE_MAP_LEN_8188F				512
#define EFUSE_MAX_SECTION_8188F			(EFUSE_MAP_LEN_8188F / 8)

#define EFUSE_IC_ID_OFFSET			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8188F)

#define EFUSE_ACCESS_ON			0x69	/* For RTL8188 only. */
#define EFUSE_ACCESS_OFF			0x00	/* For RTL8188 only. */

/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
#define EFUSE_BT_REAL_CONTENT_LEN		1536	/* 512*3 */
#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION			128		/* 1024/8 */

#define EFUSE_PROTECT_BYTES_BANK		16

#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

/* rtl8188a_hal_init.c */
s32 rtl8188f_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void rtl8188f_FirmwareSelfReset(PADAPTER padapter);
void rtl8188f_InitializeFirmwareVars(PADAPTER padapter);

void rtl8188f_InitAntenna_Selection(PADAPTER padapter);
void rtl8188f_DeinitAntenna_Selection(PADAPTER padapter);
void rtl8188f_CheckAntenna_Selection(PADAPTER padapter);
void rtl8188f_init_default_value(PADAPTER padapter);

s32 rtl8188f_InitLLTTable(PADAPTER padapter);

s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
s32 CardDisableWithoutHWSM(PADAPTER padapter);

/* EFuse */
u8 GetEEPROMSize8188F(PADAPTER padapter);
void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
void Hal_EfuseParseTxPowerInfo_8188F(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
/* void Hal_EfuseParseBTCoexistInfo_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail); */
void Hal_EfuseParseEEPROMVer_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseChnlPlan_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParsePowerSavingMode_8188F(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseAntennaDiversity_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseXtal_8188F(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseThermalMeter_8188F(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseKFreeData_8188F(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);

#if 0 /* Do not need for rtl8188f */
void Hal_EfuseParseVoltage_8188F(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);
#endif

void rtl8188f_set_pll_ref_clk_sel(_adapter *adapter, u8 sel);

void rtl8188f_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8188f(_adapter *adapter);
u8 SetHwReg8188F(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8188F(PADAPTER padapter, u8 variable, u8 *val);
u8 SetHalDefVar8188F(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8188F(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);

/* register */
void rtl8188f_InitBeaconParameters(PADAPTER padapter);
void rtl8188f_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
void	_InitBurstPktLen_8188FS(PADAPTER Adapter);
void _8051Reset8188(PADAPTER padapter);
#ifdef CONFIG_WOWLAN
void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void rtl8188f_start_thread(_adapter *padapter);
void rtl8188f_stop_thread(_adapter *padapter);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void rtl8188fs_init_checkbthang_workqueue(_adapter *adapter);
	void rtl8188fs_free_checkbthang_workqueue(_adapter *adapter);
	void rtl8188fs_cancle_checkbthang_workqueue(_adapter *adapter);
	void rtl8188fs_hal_check_bt_hang(_adapter *adapter);
#endif

#ifdef CONFIG_GPIO_WAKEUP
void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
#endif

#ifdef CONFIG_MP_INCLUDED
int FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
#endif

void CCX_FwC2HTxRpt_8188f(PADAPTER padapter, u8 *pdata, u8 len);

u8 MRateToHwRate8188F(u8  rate);
u8 HwRateToMRate8188F(u8	 rate);

#ifdef CONFIG_PCI_HCI
BOOLEAN	InterruptRecognized8188FE(PADAPTER Adapter);
void	UpdateInterruptMask8188FE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/Hal8188EPwrSeq.h                                                              0000644 0001750 0001750 00000031755 14214766567 016114  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/


#ifndef __HAL8188EPWRSEQ_H__
#define __HAL8188EPWRSEQ_H__

#include "HalPwrSeqCmd.h"

/*
	Check document WM-20110607-Paul-RTL8188E_Power_Architecture-R02.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END

    PWR SEQ Version: rtl8188E_PwrSeq_V09.h
*/
#define	RTL8188E_TRANS_CARDEMU_TO_ACT_STEPS	10
#define	RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS	10
#define	RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS	10
#define	RTL8188E_TRANS_SUS_TO_CARDEMU_STEPS	10
#define	RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS	10
#define	RTL8188E_TRANS_PDN_TO_CARDEMU_STEPS	10
#define	RTL8188E_TRANS_ACT_TO_LPS_STEPS	15
#define	RTL8188E_TRANS_LPS_TO_ACT_STEPS	15
#define	RTL8188E_TRANS_END_STEPS	1


#define RTL8188E_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 | BIT1, 0}, /* 0x02[1:0] = 0	reset BB*/			\
	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /*0x24[23] = 2b'01 schmit trigger */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0}, /* 0x04[15] = 0 disable HWPDN (control by DRV)*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, 0}, /*0x04[12:11] = 2b'00 disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*0x04[8] = 1 polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0}, /*wait till 0x04[8] = 0*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*LDO normal mode*/	\

#define RTL8188E_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*LDO Sleep mode*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\

#define RTL8188E_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11enable WL suspend for PCIe*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, BIT7}, /*  0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */	\
	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*Clear SIC_EN register 0x40[12] = 1'b0 */	\
	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*Set USB suspend enable local register  0xfe10[4]=1 */	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8188E_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8188E_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /*0x24[23] = 2b'01 schmit trigger */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*  0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */	\
	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*Clear SIC_EN register 0x40[12] = 1'b0 */	\
	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*Set USB suspend enable local register  0xfe10[4]=1 */	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8188E_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8188E_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8188E_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

	/* This is used by driver for LPSRadioOff Procedure, not for FW LPS Step */
#define RTL8188E_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8188E_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8188E_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8188E_power_on_flow[RTL8188E_TRANS_CARDEMU_TO_ACT_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_radio_off_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_card_disable_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_card_enable_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_suspend_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_resume_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_hwpdn_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_enter_lps_flow[RTL8188E_TRANS_ACT_TO_LPS_STEPS + RTL8188E_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188E_leave_lps_flow[RTL8188E_TRANS_LPS_TO_ACT_STEPS + RTL8188E_TRANS_END_STEPS];

#endif /* __HAL8188EPWRSEQ_H__ */
                   rtl8822bu/src/include/Hal8703BPwrSeq.h                                                              0000644 0001750 0001750 00000042372 14214766567 016077  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8703B
#define REALTEK_POWER_SEQUENCE_8703B

#include "HalPwrSeqCmd.h"

/*
	Check document WM-20140402-JackieLau-RTL8703B_Power_Architecture v09.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8703B_TRANS_CARDEMU_TO_ACT_STEPS	23
#define	RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS	15
#define	RTL8703B_TRANS_CARDEMU_TO_SUS_STEPS	15
#define	RTL8703B_TRANS_SUS_TO_CARDEMU_STEPS	15
#define	RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS	15
#define	RTL8703B_TRANS_PDN_TO_CARDEMU_STEPS	15
#define	RTL8703B_TRANS_ACT_TO_LPS_STEPS		15
#define	RTL8703B_TRANS_LPS_TO_ACT_STEPS		15
#define	RTL8703B_TRANS_END_STEPS		1


#define RTL8703B_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3 | BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[11]=0*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
	{0x0004, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 , BIT3},/* enabled usb resume */	\
	{0x0004, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 , 0},/* disable usb resume */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT4 | BIT3), 0},/* disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	\
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/* Enable WL control XTAL setting*/	\
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable GPIO9 interrupt mode*/\
	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/*Enable HSISR GPIO9 interrupt*/\
	{0x0068, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3},/*For GPIO9 internal pull high setting by test chip*/\
	{0x0069, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, BIT6},/*For GPIO9 internal pull high setting*/\


#define RTL8703B_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6, 0},/* Enable BT control XTAL setting*/\
	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/\


#define RTL8703B_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, (BIT4 | BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8703B_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/

#define RTL8703B_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/

#define RTL8703B_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/


#define RTL8703B_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK | PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8703B_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8703B_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\


#define RTL8703B_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8703B_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8703B_power_on_flow[RTL8703B_TRANS_CARDEMU_TO_ACT_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_radio_off_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_card_disable_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_card_enable_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_suspend_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8703B_TRANS_CARDEMU_TO_SUS_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_resume_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8703B_TRANS_CARDEMU_TO_SUS_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_hwpdn_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS + RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_enter_lps_flow[RTL8703B_TRANS_ACT_TO_LPS_STEPS + RTL8703B_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8703B_leave_lps_flow[RTL8703B_TRANS_LPS_TO_ACT_STEPS + RTL8703B_TRANS_END_STEPS];

#endif
                                                                                                                                                                                                                                                                      rtl8822bu/src/include/hal_com_reg.h                                                                 0000644 0001750 0001750 00000204544 14214766567 016045  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_COMMON_REG_H__
#define __HAL_COMMON_REG_H__


#define MAC_ADDR_LEN				6

#define HAL_NAV_UPPER_UNIT		128		/* micro-second */

/* 8188E PKT_BUFF_ACCESS_CTRL value */
#define TXPKT_BUF_SELECT				0x69
#define RXPKT_BUF_SELECT				0xA5
#define DISABLE_TRXPKT_BUF_ACCESS		0x0

#ifndef RTW_HALMAC
/* ************************************************************
*
* ************************************************************ */

/* -----------------------------------------------------
*
*	0x0000h ~ 0x00FFh	System Configuration
*
* ----------------------------------------------------- */
#define REG_SYS_ISO_CTRL				0x0000
#define REG_SYS_FUNC_EN				0x0002
#define REG_APS_FSMCO					0x0004
#define REG_SYS_CLKR					0x0008
#define REG_SYS_CLK_CTRL				REG_SYS_CLKR
#define REG_9346CR						0x000A
#define REG_SYS_EEPROM_CTRL			0x000A
#define REG_EE_VPD						0x000C
#define REG_AFE_MISC					0x0010
#define REG_SPS0_CTRL					0x0011
#define REG_SPS0_CTRL_6					0x0016
#define REG_POWER_OFF_IN_PROCESS		0x0017
#define REG_SPS_OCP_CFG				0x0018
#define REG_RSV_CTRL					0x001C
#define REG_RF_CTRL						0x001F
#define REG_LDOA15_CTRL				0x0020
#define REG_LDOV12D_CTRL				0x0021
#define REG_LDOHCI12_CTRL				0x0022
#define REG_LPLDO_CTRL					0x0023
#define REG_AFE_XTAL_CTRL				0x0024
#define REG_AFE_LDO_CTRL				0x0027 /* 1.5v for 8188EE test chip, 1.4v for MP chip */
#define REG_AFE_PLL_CTRL				0x0028
#define REG_MAC_PHY_CTRL				0x002c /* for 92d, DMDP, SMSP, DMSP contrl */
#define REG_APE_PLL_CTRL_EXT			0x002c
#define REG_EFUSE_CTRL					0x0030
#define REG_EFUSE_TEST					0x0034
#define REG_PWR_DATA					0x0038
#define REG_CAL_TIMER					0x003C
#define REG_ACLK_MON					0x003E
#define REG_GPIO_MUXCFG				0x0040
#define REG_GPIO_IO_SEL					0x0042
#define REG_MAC_PINMUX_CFG			0x0043
#define REG_GPIO_PIN_CTRL				0x0044
#define REG_GPIO_INTM					0x0048
#define REG_LEDCFG0						0x004C
#define REG_LEDCFG1						0x004D
#define REG_LEDCFG2						0x004E
#define REG_LEDCFG3						0x004F
#define REG_FSIMR						0x0050
#define REG_FSISR						0x0054
#define REG_HSIMR						0x0058
#define REG_HSISR						0x005c
#define REG_GPIO_PIN_CTRL_2			0x0060 /* RTL8723 WIFI/BT/GPS Multi-Function GPIO Pin Control. */
#define REG_GPIO_IO_SEL_2				0x0062 /* RTL8723 WIFI/BT/GPS Multi-Function GPIO Select. */
#define REG_PAD_CTRL_1				0x0064
#define REG_MULTI_FUNC_CTRL			0x0068 /* RTL8723 WIFI/BT/GPS Multi-Function control source. */
#define REG_GSSR						0x006c
#define REG_AFE_XTAL_CTRL_EXT			0x0078 /* RTL8188E */
#define REG_XCK_OUT_CTRL				0x007c /* RTL8188E */
#define REG_MCUFWDL					0x0080
#define REG_WOL_EVENT					0x0081 /* RTL8188E */
#define REG_MCUTSTCFG					0x0084
#define REG_FDHM0						0x0088
#define REG_HOST_SUSP_CNT				0x00BC	/* RTL8192C Host suspend counter on FPGA platform */
#define REG_SYSTEM_ON_CTRL			0x00CC	/* For 8723AE Reset after S3 */
#define REG_EFUSE_ACCESS				0x00CF	/* Efuse access protection for RTL8723 */
#define REG_BIST_SCAN					0x00D0
#define REG_BIST_RPT					0x00D4
#define REG_BIST_ROM_RPT				0x00D8
#define REG_USB_SIE_INTF				0x00E0
#define REG_PCIE_MIO_INTF				0x00E4
#define REG_PCIE_MIO_INTD				0x00E8
#define REG_HPON_FSM					0x00EC
#define REG_SYS_CFG						0x00F0
#define REG_GPIO_OUTSTS				0x00F4	/* For RTL8723 only. */
#define REG_TYPE_ID						0x00FC

/*
* 2010/12/29 MH Add for 92D
*   */
#define REG_MAC_PHY_CTRL_NORMAL		0x00f8


/* -----------------------------------------------------
*
*	0x0100h ~ 0x01FFh	MACTOP General Configuration
*
* ----------------------------------------------------- */
#define REG_CR							0x0100
#define REG_PBP							0x0104
#define REG_PKT_BUFF_ACCESS_CTRL		0x0106
#define REG_TRXDMA_CTRL				0x010C
#define REG_TRXFF_BNDY					0x0114
#define REG_TRXFF_STATUS				0x0118
#define REG_RXFF_PTR					0x011C
#define REG_HIMR						0x0120
#define REG_FE1IMR						0x0120
#define REG_HISR							0x0124
#define REG_HIMRE						0x0128
#define REG_HISRE						0x012C
#define REG_CPWM						0x012F
#define REG_FWIMR						0x0130
#define REG_FWISR						0x0134
#define REG_FTIMR						0x0138
#define REG_FTISR						0x013C /* RTL8192C */
#define REG_PKTBUF_DBG_CTRL			0x0140
#define REG_RXPKTBUF_CTRL				(REG_PKTBUF_DBG_CTRL+2)
#define REG_PKTBUF_DBG_DATA_L			0x0144
#define REG_PKTBUF_DBG_DATA_H		0x0148

#define REG_TC0_CTRL					0x0150
#define REG_TC1_CTRL					0x0154
#define REG_TC2_CTRL					0x0158
#define REG_TC3_CTRL					0x015C
#define REG_TC4_CTRL					0x0160
#define REG_TCUNIT_BASE				0x0164
#define REG_MBIST_START				0x0174
#define REG_MBIST_DONE					0x0178
#define REG_MBIST_FAIL					0x017C
#define REG_32K_CTRL					0x0194 /* RTL8188E */
#define REG_C2HEVT_MSG_NORMAL		0x01A0
#define REG_C2HEVT_CLEAR				0x01AF
#define REG_MCUTST_1					0x01c0
#define REG_MCUTST_WOWLAN			0x01C7	/* Defined after 8188E series. */
#define REG_FMETHR						0x01C8
#define REG_HMETFR						0x01CC
#define REG_HMEBOX_0					0x01D0
#define REG_HMEBOX_1					0x01D4
#define REG_HMEBOX_2					0x01D8
#define REG_HMEBOX_3					0x01DC
#define REG_LLT_INIT					0x01E0
#define REG_HMEBOX_EXT_0				0x01F0
#define REG_HMEBOX_EXT_1				0x01F4
#define REG_HMEBOX_EXT_2				0x01F8
#define REG_HMEBOX_EXT_3				0x01FC


/* -----------------------------------------------------
*
*	0x0200h ~ 0x027Fh	TXDMA Configuration
*
* ----------------------------------------------------- */
#define REG_RQPN						0x0200
#define REG_FIFOPAGE					0x0204
#define REG_TDECTRL						0x0208
#define REG_TXDMA_OFFSET_CHK			0x020C
#define REG_TXDMA_STATUS				0x0210
#define REG_RQPN_NPQ					0x0214
#define REG_TQPNT1						0x0218
#define REG_TQPNT2						0x021C
#define REG_AUTO_LLT					0x0224


/* -----------------------------------------------------
*
*	0x0280h ~ 0x02FFh	RXDMA Configuration
*
* ----------------------------------------------------- */
#define REG_RXDMA_AGG_PG_TH			0x0280
#define REG_RXPKT_NUM					0x0284
#define REG_RXDMA_STATUS				0x0288

/* -----------------------------------------------------
*
*	0x0300h ~ 0x03FFh	PCIe
*
* ----------------------------------------------------- */
#ifndef CONFIG_TRX_BD_ARCH	/* prevent CONFIG_TRX_BD_ARCH to use old registers */

#define REG_PCIE_CTRL_REG				0x0300
#define REG_INT_MIG					0x0304	/* Interrupt Migration */
#define REG_BCNQ_DESA					0x0308	/* TX Beacon Descriptor Address */
#define REG_HQ_DESA					0x0310	/* TX High Queue Descriptor Address */
#define REG_MGQ_DESA					0x0318	/* TX Manage Queue Descriptor Address */
#define REG_VOQ_DESA					0x0320	/* TX VO Queue Descriptor Address */
#define REG_VIQ_DESA					0x0328	/* TX VI Queue Descriptor Address */
#define REG_BEQ_DESA					0x0330	/* TX BE Queue Descriptor Address */
#define REG_BKQ_DESA					0x0338	/* TX BK Queue Descriptor Address */
#define REG_RX_DESA					0x0340	/* RX Queue Descriptor Address */
/* sherry added for DBI Read/Write  20091126 */
#define REG_DBI_WDATA					0x0348	/*  Backdoor REG for Access Configuration */
#define REG_DBI_RDATA					0x034C	/* Backdoor REG for Access Configuration */
#define REG_DBI_CTRL					0x0350	/* Backdoor REG for Access Configuration */
#define REG_DBI_FLAG					0x0352	/* Backdoor REG for Access Configuration */
#define REG_MDIO					0x0354	/* MDIO for Access PCIE PHY */
#define REG_DBG_SEL					0x0360	/* Debug Selection Register */
#define REG_WATCH_DOG					0x0368
#define REG_RX_RXBD_NUM					0x0382

/* RTL8723 series ------------------------------- */
#define REG_PCIE_HISR_EN				0x0394	/* PCIE Local Interrupt Enable Register */
#define REG_PCIE_HISR					0x03A0
#define REG_PCIE_HISRE					0x03A4
#define REG_PCIE_HIMR					0x03A8
#define REG_PCIE_HIMRE					0x03AC

#endif /* !CONFIG_TRX_BD_ARCH */

#define REG_USB_HIMR					0xFE38
#define REG_USB_HIMRE					0xFE3C
#define REG_USB_HISR					0xFE78
#define REG_USB_HISRE					0xFE7C


/* -----------------------------------------------------
*
*	0x0400h ~ 0x047Fh	Protocol Configuration
*
* ----------------------------------------------------- */

/* 92C, 92D */
#define REG_VOQ_INFO	0x0400
#define REG_VIQ_INFO	0x0404
#define REG_BEQ_INFO	0x0408
#define REG_BKQ_INFO	0x040C

/* 88E, 8723A, 8812A, 8821A, 92E, 8723B */
#define REG_Q0_INFO	0x400
#define REG_Q1_INFO	0x404
#define REG_Q2_INFO	0x408
#define REG_Q3_INFO	0x40C

#define REG_MGQ_INFO	0x0410
#define REG_HGQ_INFO	0x0414
#define REG_BCNQ_INFO	0x0418
#define REG_TXPKT_EMPTY				0x041A
#define REG_CPU_MGQ_INFORMATION		0x041C
#define REG_FWHW_TXQ_CTRL				0x0420
#define REG_HWSEQ_CTRL					0x0423
#define REG_BCNQ_BDNY					0x0424
#define REG_MGQ_BDNY					0x0425
#define REG_LIFETIME_EN					0x0426
#define REG_MULTI_BCNQ_OFFSET			0x0427
#define REG_SPEC_SIFS					0x0428
#define REG_RETRY_LIMIT					0x042A
#define REG_DARFRC						0x0430
#define REG_RARFRC						0x0438
#define REG_RRSR						0x0440
#define REG_ARFR0						0x0444
#define REG_ARFR1						0x0448
#define REG_ARFR2						0x044C
#define REG_ARFR3						0x0450
#define REG_CCK_CHECK					0x0454
#define REG_BCNQ1_BDNY					0x0457

#define REG_AGGLEN_LMT					0x0458
#define REG_AMPDU_MIN_SPACE			0x045C
#define REG_WMAC_LBK_BF_HD			0x045D
#define REG_FAST_EDCA_CTRL				0x0460
#define REG_RD_RESP_PKT_TH				0x0463

/* 8723A, 8812A, 8821A, 92E, 8723B */
#define REG_Q4_INFO	0x468
#define REG_Q5_INFO	0x46C
#define REG_Q6_INFO	0x470
#define REG_Q7_INFO	0x474

#define REG_INIRTS_RATE_SEL				0x0480
#define REG_INIDATA_RATE_SEL			0x0484

/* 8723B, 92E, 8812A, 8821A*/
#define REG_MACID_SLEEP_3				0x0484
#define REG_MACID_SLEEP_1				0x0488

#define REG_POWER_STAGE1				0x04B4
#define REG_POWER_STAGE2				0x04B8
#define REG_PKT_LIFE_TIME			0x04C0
#define REG_PKT_LIFE_TIME_VO_VI		0x04C0
#define REG_PKT_LIFE_TIME_BE_BK		0x04C2
#define REG_STBC_SETTING				0x04C4
#define REG_QUEUE_CTRL					0x04C6
#define REG_SINGLE_AMPDU_CTRL			0x04c7
#define REG_PROT_MODE_CTRL			0x04C8
#define REG_MAX_AGGR_NUM				0x04CA
#define REG_RTS_MAX_AGGR_NUM			0x04CB
#define REG_BAR_MODE_CTRL				0x04CC
#define REG_RA_TRY_RATE_AGG_LMT		0x04CF

/* 8723A */
#define REG_MACID_DROP	0x04D0

/* 88E */
#define REG_EARLY_MODE_CONTROL	0x04D0

/* 8723B, 92E, 8812A, 8821A */
#define REG_MACID_SLEEP_2	0x04D0

/* 8723A, 8723B, 92E, 8812A, 8821A */
#define REG_MACID_SLEEP	0x04D4

#define REG_NQOS_SEQ					0x04DC
#define REG_HW_SEQ0						0x04D8
#define REG_HW_SEQ1						0x04DA
#define REG_HW_SEQ2						0x04DC
#define REG_HW_SEQ3						0x04DE

#define REG_QOS_SEQ					0x04DE
#define REG_NEED_CPU_HANDLE			0x04E0
#define REG_PKT_LOSE_RPT				0x04E1
#define REG_PTCL_ERR_STATUS			0x04E2
#define REG_TX_RPT_CTRL					0x04EC
#define REG_TX_RPT_TIME					0x04F0	/* 2 byte */
#define REG_DUMMY						0x04FC

/* -----------------------------------------------------
*
*	0x0500h ~ 0x05FFh	EDCA Configuration
*
* ----------------------------------------------------- */
#define REG_EDCA_VO_PARAM				0x0500
#define REG_EDCA_VI_PARAM				0x0504
#define REG_EDCA_BE_PARAM				0x0508
#define REG_EDCA_BK_PARAM				0x050C
#define REG_BCNTCFG						0x0510
#define REG_PIFS							0x0512
#define REG_RDG_PIFS					0x0513
#define REG_SIFS_CTX					0x0514
#define REG_SIFS_TRX					0x0516
#define REG_TSFTR_SYN_OFFSET			0x0518
#define REG_AGGR_BREAK_TIME			0x051A
#define REG_SLOT						0x051B
#define REG_TX_PTCL_CTRL				0x0520
#define REG_TXPAUSE						0x0522
#define REG_DIS_TXREQ_CLR				0x0523
#define REG_RD_CTRL						0x0524
/*
* Format for offset 540h-542h:
*	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
*	[7:4]:   Reserved.
*	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
*	[23:20]: Reserved
* Description:
*	              |
*      |<--Setup--|--Hold------------>|
*   --------------|----------------------
*                 |
*                TBTT
* Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
* Described by Designer Tim and Bruce, 2011-01-14.
*   */
#define REG_TBTT_PROHIBIT				0x0540
#define REG_RD_NAV_NXT					0x0544
#define REG_NAV_PROT_LEN				0x0546
#define REG_BCN_CTRL					0x0550
#define REG_BCN_CTRL_1					0x0551
#define REG_MBID_NUM					0x0552
#define REG_DUAL_TSF_RST				0x0553
#define REG_MBSSID_BCN_SPACE			0x0554
#define REG_DRVERLYINT					0x0558
#define REG_BCNDMATIM					0x0559
#define REG_ATIMWND					0x055A
#define REG_USTIME_TSF					0x055C
#define REG_BCN_MAX_ERR				0x055D
#define REG_RXTSF_OFFSET_CCK			0x055E
#define REG_RXTSF_OFFSET_OFDM			0x055F
#define REG_TSFTR						0x0560
#define REG_TSFTR1						0x0568	/* HW Port 1 TSF Register */
#define REG_ATIMWND_1					0x0570
#define REG_P2P_CTWIN					0x0572 /* 1 Byte long (in unit of TU) */
#define REG_PSTIMER						0x0580
#define REG_TIMER0						0x0584
#define REG_TIMER1						0x0588
#define REG_HIQ_NO_LMT_EN				0x05A7
#define REG_ACMHWCTRL					0x05C0
#define REG_NOA_DESC_SEL				0x05CF
#define REG_NOA_DESC_DURATION		0x05E0
#define REG_NOA_DESC_INTERVAL			0x05E4
#define REG_NOA_DESC_START			0x05E8
#define REG_NOA_DESC_COUNT			0x05EC

#define REG_DMC							0x05F0	/* Dual MAC Co-Existence Register */
#define REG_SCH_TX_CMD					0x05F8

#define REG_FW_RESET_TSF_CNT_1		0x05FC
#define REG_FW_RESET_TSF_CNT_0		0x05FD
#define REG_FW_BCN_DIS_CNT			0x05FE

/* -----------------------------------------------------
*
*	0x0600h ~ 0x07FFh	WMAC Configuration
*
* ----------------------------------------------------- */
#define REG_APSD_CTRL					0x0600
#define REG_BWOPMODE					0x0603
#define REG_TCR							0x0604
#define REG_RCR							0x0608
#define REG_RX_PKT_LIMIT				0x060C
#define REG_RX_DLK_TIME				0x060D
#define REG_RX_DRVINFO_SZ				0x060F

#define REG_MACID						0x0610
#define REG_BSSID						0x0618
#define REG_MAR							0x0620
#define REG_MBIDCAMCFG_1				0x0628
#define REG_MBIDCAMCFG_2				0x062C

#define REG_PNO_STATUS					0x0631
#define REG_USTIME_EDCA				0x0638
#define REG_MAC_SPEC_SIFS				0x063A
/* 20100719 Joseph: Hardware register definition change. (HW datasheet v54) */
#define REG_RESP_SIFS_CCK				0x063C	/* [15:8]SIFS_R2T_OFDM, [7:0]SIFS_R2T_CCK */
#define REG_RESP_SIFS_OFDM                    0x063E	/* [15:8]SIFS_T2T_OFDM, [7:0]SIFS_T2T_CCK */

#define REG_ACKTO						0x0640
#define REG_CTS2TO						0x0641
#define REG_EIFS							0x0642

/*REG_TCR*/
#define BIT_PWRBIT_OW_EN BIT(7)

/* RXERR_RPT */
#define RXERR_TYPE_OFDM_PPDU			0
#define RXERR_TYPE_OFDM_FALSE_ALARM	1
#define RXERR_TYPE_OFDM_MPDU_OK		2
#define RXERR_TYPE_OFDM_MPDU_FAIL	3
#define RXERR_TYPE_CCK_PPDU			4
#define RXERR_TYPE_CCK_FALSE_ALARM	5
#define RXERR_TYPE_CCK_MPDU_OK		6
#define RXERR_TYPE_CCK_MPDU_FAIL		7
#define RXERR_TYPE_HT_PPDU				8
#define RXERR_TYPE_HT_FALSE_ALARM	9
#define RXERR_TYPE_HT_MPDU_TOTAL		10
#define RXERR_TYPE_HT_MPDU_OK			11
#define RXERR_TYPE_HT_MPDU_FAIL		12
#define RXERR_TYPE_RX_FULL_DROP		15

#define RXERR_COUNTER_MASK			0xFFFFF
#define RXERR_RPT_RST					BIT(27)
#define _RXERR_RPT_SEL(type)			((type) << 28)

/*
* Note:
*	The NAV upper value is very important to WiFi 11n 5.2.3 NAV test. The default value is
*	always too small, but the WiFi TestPlan test by 25,000 microseconds of NAV through sending
*	CTS in the air. We must update this value greater than 25,000 microseconds to pass the item.
*	The offset of NAV_UPPER in 8192C Spec is incorrect, and the offset should be 0x0652. Commented
*	by SD1 Scott.
* By Bruce, 2011-07-18.
*   */
#define REG_NAV_UPPER					0x0652	/* unit of 128 */

/* WMA, BA, CCX */
#define REG_NAV_CTRL					0x0650
#define REG_BACAMCMD					0x0654
#define REG_BACAMCONTENT				0x0658
#define REG_LBDLY						0x0660
#define REG_FWDLY						0x0661
#define REG_RXERR_RPT					0x0664
#define REG_WMAC_TRXPTCL_CTL			0x0668

/* Security */
#define REG_CAMCMD						0x0670
#define REG_CAMWRITE					0x0674
#define REG_CAMREAD					0x0678
#define REG_CAMDBG						0x067C
#define REG_SECCFG						0x0680

/* Power */
#define REG_WOW_CTRL					0x0690
#define REG_PS_RX_INFO					0x0692
#define REG_WMMPS_UAPSD_TID			0x0693
#define REG_WKFMCAM_CMD				0x0698
#define REG_WKFMCAM_NUM				REG_WKFMCAM_CMD
#define REG_WKFMCAM_RWD				0x069C
#define REG_RXFLTMAP0					0x06A0
#define REG_RXFLTMAP1					0x06A2
#define REG_RXFLTMAP2					0x06A4
#define REG_BCN_PSR_RPT				0x06A8
#define REG_BT_COEX_TABLE				0x06C0

#define BIT_WKFCAM_WE					BIT(16)
#define BIT_WKFCAM_POLLING_V1				BIT(31)
#define BIT_WKFCAM_CLR_V1				BIT(30)
#define BIT_SHIFT_WKFCAM_ADDR_V2			8
#define BIT_MASK_WKFCAM_ADDR_V2			0xff
#define BIT_WKFCAM_ADDR_V2(x)				(((x) & BIT_MASK_WKFCAM_ADDR_V2) << BIT_SHIFT_WKFCAM_ADDR_V2)

/* Hardware Port 1 */
#define REG_MACID1						0x0700
#define REG_BSSID1						0x0708

/* Enable/Disable Port 0 and Port 1 for Specific ICs (ex. 8192F)*/
#define REG_WLAN_ACT_MASK_CTRL_1		0x076C

/* GPIO Control */
#define REG_SW_GPIO_SHARE_CTRL			0x1038
#define REG_SW_GPIO_A_OUT				0x1040
#define REG_SW_GPIO_A_OEN				0x1044

/* Hardware Port 2 */
#define REG_MACID2						0x1620
#define REG_BSSID2						0x1628
/* Hardware Port 3*/
#define REG_MACID3						0x1630
#define REG_BSSID3						0x1638
/* Hardware Port 4 */
#define REG_MACID4						0x1640
#define REG_BSSID4						0x1648


#define REG_CR_EXT						0x1100

/* -----------------------------------------------------
*
*	0xFE00h ~ 0xFE55h	USB Configuration
*
* ----------------------------------------------------- */
#define REG_USB_INFO					0xFE17
#define REG_USB_SPECIAL_OPTION		0xFE55
#define REG_USB_DMA_AGG_TO			0xFE5B
#define REG_USB_AGG_TO					0xFE5C
#define REG_USB_AGG_TH					0xFE5D

#define REG_USB_HRPWM					0xFE58
#define REG_USB_HCPWM					0xFE57

/* for 92DU high_Queue low_Queue Normal_Queue select */
#define REG_USB_High_NORMAL_Queue_Select_MAC0	0xFE44
/* #define REG_USB_LOW_Queue_Select_MAC0		0xFE45 */
#define REG_USB_High_NORMAL_Queue_Select_MAC1	0xFE47
/* #define REG_USB_LOW_Queue_Select_MAC1		0xFE48 */

/* For test chip */
#define REG_TEST_USB_TXQS				0xFE48
#define REG_TEST_SIE_VID				0xFE60		/* 0xFE60~0xFE61 */
#define REG_TEST_SIE_PID				0xFE62		/* 0xFE62~0xFE63 */
#define REG_TEST_SIE_OPTIONAL			0xFE64
#define REG_TEST_SIE_CHIRP_K			0xFE65
#define REG_TEST_SIE_PHY				0xFE66		/* 0xFE66~0xFE6B */
#define REG_TEST_SIE_MAC_ADDR			0xFE70		/* 0xFE70~0xFE75 */
#define REG_TEST_SIE_STRING			0xFE80		/* 0xFE80~0xFEB9 */


/* For normal chip */
#define REG_NORMAL_SIE_VID				0xFE60		/* 0xFE60~0xFE61 */
#define REG_NORMAL_SIE_PID				0xFE62		/* 0xFE62~0xFE63 */
#define REG_NORMAL_SIE_OPTIONAL		0xFE64
#define REG_NORMAL_SIE_EP				0xFE65		/* 0xFE65~0xFE67 */
#define REG_NORMAL_SIE_PHY			0xFE68		/* 0xFE68~0xFE6B */
#define REG_NORMAL_SIE_OPTIONAL2		0xFE6C
#define REG_NORMAL_SIE_GPS_EP			0xFE6D		/* 0xFE6D, for RTL8723 only. */
#define REG_NORMAL_SIE_MAC_ADDR		0xFE70		/* 0xFE70~0xFE75 */
#define REG_NORMAL_SIE_STRING			0xFE80		/* 0xFE80~0xFEDF */


/* -----------------------------------------------------
*
*	Redifine 8192C register definition for compatibility
*
* ----------------------------------------------------- */

/* TODO: use these definition when using REG_xxx naming rule.
* NOTE: DO NOT Remove these definition. Use later. */

#define EFUSE_CTRL				REG_EFUSE_CTRL		/* E-Fuse Control. */
#define EFUSE_TEST				REG_EFUSE_TEST		/* E-Fuse Test. */
#define MSR						(REG_CR + 2)		/* Media Status register */
/* #define ISR						REG_HISR */
#define MSR1						REG_CR_EXT

#define TSFR						REG_TSFTR			/* Timing Sync Function Timer Register. */
#define TSFR1					REG_TSFTR1			/* HW Port 1 TSF Register */

#define PBP						REG_PBP

/* Redifine MACID register, to compatible prior ICs. */
#define IDR0						REG_MACID			/* MAC ID Register, Offset 0x0050-0x0053 */
#define IDR4						(REG_MACID + 4)		/* MAC ID Register, Offset 0x0054-0x0055 */

/* Unused register */
#define UnusedRegister			0x1BF
#define DCAM					UnusedRegister
#define PSR						UnusedRegister
#define BBAddr					UnusedRegister
#define PhyDataR					UnusedRegister

/* Min Spacing related settings. */
#define MAX_MSS_DENSITY_2T			0x13
#define MAX_MSS_DENSITY_1T			0x0A

/* ----------------------------------------------------------------------------
* 8192C Cmd9346CR bits					(Offset 0xA, 16bit)
* ---------------------------------------------------------------------------- */
#define CmdEEPROM_En				BIT(5)	 /* EEPROM enable when set 1 */
#define CmdEERPOMSEL				BIT(4)	/* System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346 */
#define Cmd9346CR_9356SEL			BIT(4)

/* ----------------------------------------------------------------------------
* 8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
* ---------------------------------------------------------------------------- */
#define GPIOSEL_GPIO				0
#define GPIOSEL_ENBT				BIT(5)

/* ----------------------------------------------------------------------------
* 8192C GPIO PIN Control Register (offset 0x44, 4 byte)
* ---------------------------------------------------------------------------- */
#define GPIO_IN					REG_GPIO_PIN_CTRL		/* GPIO pins input value */
#define GPIO_OUT				(REG_GPIO_PIN_CTRL+1)	/* GPIO pins output value */
#define GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	/* GPIO pins output enable when a bit is set to "1"; otherwise, input is configured. */
#define GPIO_MOD				(REG_GPIO_PIN_CTRL+3)

/* ----------------------------------------------------------------------------
* 8811A GPIO PIN Control Register (offset 0x60, 4 byte)
* ---------------------------------------------------------------------------- */
#define GPIO_IN_8811A			REG_GPIO_PIN_CTRL_2		/* GPIO pins input value */
#define GPIO_OUT_8811A			(REG_GPIO_PIN_CTRL_2+1)	/* GPIO pins output value */
#define GPIO_IO_SEL_8811A		(REG_GPIO_PIN_CTRL_2+2)	/* GPIO pins output enable when a bit is set to "1"; otherwise, input is configured. */
#define GPIO_MOD_8811A			(REG_GPIO_PIN_CTRL_2+3)

/* ----------------------------------------------------------------------------
* 8723/8188E Host System Interrupt Mask Register (offset 0x58, 32 byte)
* ---------------------------------------------------------------------------- */
#define HSIMR_GPIO12_0_INT_EN			BIT(0)
#define HSIMR_SPS_OCP_INT_EN			BIT(5)
#define HSIMR_RON_INT_EN				BIT(6)
#define HSIMR_PDN_INT_EN				BIT(7)
#define HSIMR_GPIO9_INT_EN				BIT(25)

/* ----------------------------------------------------------------------------
* 8723/8188E Host System Interrupt Status Register (offset 0x5C, 32 byte)
* ---------------------------------------------------------------------------- */
#define HSISR_GPIO12_0_INT				BIT(0)
#define HSISR_SPS_OCP_INT				BIT(5)
#define HSISR_RON_INT					BIT(6)
#define HSISR_PDNINT					BIT(7)
#define HSISR_GPIO9_INT					BIT(25)

/* ----------------------------------------------------------------------------
* 8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
* ---------------------------------------------------------------------------- */
/*
Network Type
00: No link
01: Link in ad hoc network
10: Link in infrastructure network
11: AP mode
Default: 00b.
*/
#define MSR_NOLINK				0x00
#define MSR_ADHOC				0x01
#define MSR_INFRA				0x02
#define MSR_AP					0x03

/* ----------------------------------------------------------------------------
* USB INTR CONTENT
* ---------------------------------------------------------------------------- */
#define USB_C2H_CMDID_OFFSET					0
#define USB_C2H_SEQ_OFFSET					1
#define USB_C2H_EVENT_OFFSET					2
#define USB_INTR_CPWM_OFFSET					16
#define USB_INTR_CONTENT_C2H_OFFSET			0
#define USB_INTR_CONTENT_CPWM1_OFFSET		16
#define USB_INTR_CONTENT_CPWM2_OFFSET		20
#define USB_INTR_CONTENT_HISR_OFFSET			48
#define USB_INTR_CONTENT_HISRE_OFFSET		52
#define USB_INTR_CONTENT_LENGTH				56


/* WOL bit information */
#define HAL92C_WOL_PTK_UPDATE_EVENT		BIT(0)
#define HAL92C_WOL_GTK_UPDATE_EVENT		BIT(1)
#define HAL92C_WOL_DISASSOC_EVENT		BIT(2)
#define HAL92C_WOL_DEAUTH_EVENT			BIT(3)
#define HAL92C_WOL_FW_DISCONNECT_EVENT	BIT(4)


/*----------------------------------------------------------------------------
**      REG_CCK_CHECK						(offset 0x454)
------------------------------------------------------------------------------*/
#define BIT_BCN_PORT_SEL		BIT(5)
#define BIT_EN_BCN_PKT_REL		BIT(6)

#endif /* RTW_HALMAC */

/* ----------------------------------------------------------------------------
* Response Rate Set Register	(offset 0x440, 24bits)
* ---------------------------------------------------------------------------- */
#define RRSR_1M					BIT(0)
#define RRSR_2M					BIT(1)
#define RRSR_5_5M				BIT(2)
#define RRSR_11M				BIT(3)
#define RRSR_6M					BIT(4)
#define RRSR_9M					BIT(5)
#define RRSR_12M				BIT(6)
#define RRSR_18M				BIT(7)
#define RRSR_24M				BIT(8)
#define RRSR_36M				BIT(9)
#define RRSR_48M				BIT(10)
#define RRSR_54M				BIT(11)
#define RRSR_MCS0				BIT(12)
#define RRSR_MCS1				BIT(13)
#define RRSR_MCS2				BIT(14)
#define RRSR_MCS3				BIT(15)
#define RRSR_MCS4				BIT(16)
#define RRSR_MCS5				BIT(17)
#define RRSR_MCS6				BIT(18)
#define RRSR_MCS7				BIT(19)

#define RRSR_CCK_RATES (RRSR_11M | RRSR_5_5M | RRSR_2M | RRSR_1M)
#define RRSR_OFDM_RATES (RRSR_54M | RRSR_48M | RRSR_36M | RRSR_24M | RRSR_18M | RRSR_12M | RRSR_9M | RRSR_6M)

/* ----------------------------------------------------------------------------
 * Rate Definition
 * ---------------------------------------------------------------------------- */
/* CCK */
#define	RATR_1M					0x00000001
#define	RATR_2M					0x00000002
#define	RATR_55M					0x00000004
#define	RATR_11M					0x00000008
/* OFDM		 */
#define	RATR_6M					0x00000010
#define	RATR_9M					0x00000020
#define	RATR_12M					0x00000040
#define	RATR_18M					0x00000080
#define	RATR_24M					0x00000100
#define	RATR_36M					0x00000200
#define	RATR_48M					0x00000400
#define	RATR_54M					0x00000800
/* MCS 1 Spatial Stream	 */
#define	RATR_MCS0					0x00001000
#define	RATR_MCS1					0x00002000
#define	RATR_MCS2					0x00004000
#define	RATR_MCS3					0x00008000
#define	RATR_MCS4					0x00010000
#define	RATR_MCS5					0x00020000
#define	RATR_MCS6					0x00040000
#define	RATR_MCS7					0x00080000
/* MCS 2 Spatial Stream */
#define	RATR_MCS8					0x00100000
#define	RATR_MCS9					0x00200000
#define	RATR_MCS10					0x00400000
#define	RATR_MCS11					0x00800000
#define	RATR_MCS12					0x01000000
#define	RATR_MCS13					0x02000000
#define	RATR_MCS14					0x04000000
#define	RATR_MCS15					0x08000000

/* CCK */
#define RATE_1M					BIT(0)
#define RATE_2M					BIT(1)
#define RATE_5_5M				BIT(2)
#define RATE_11M				BIT(3)
/* OFDM */
#define RATE_6M					BIT(4)
#define RATE_9M					BIT(5)
#define RATE_12M				BIT(6)
#define RATE_18M				BIT(7)
#define RATE_24M				BIT(8)
#define RATE_36M				BIT(9)
#define RATE_48M				BIT(10)
#define RATE_54M				BIT(11)
/* MCS 1 Spatial Stream */
#define RATE_MCS0				BIT(12)
#define RATE_MCS1				BIT(13)
#define RATE_MCS2				BIT(14)
#define RATE_MCS3				BIT(15)
#define RATE_MCS4				BIT(16)
#define RATE_MCS5				BIT(17)
#define RATE_MCS6				BIT(18)
#define RATE_MCS7				BIT(19)
/* MCS 2 Spatial Stream */
#define RATE_MCS8				BIT(20)
#define RATE_MCS9				BIT(21)
#define RATE_MCS10				BIT(22)
#define RATE_MCS11				BIT(23)
#define RATE_MCS12				BIT(24)
#define RATE_MCS13				BIT(25)
#define RATE_MCS14				BIT(26)
#define RATE_MCS15				BIT(27)


/* ALL CCK Rate */
#define	RATE_ALL_CCK				(RATR_1M | RATR_2M | RATR_55M | RATR_11M)
#define	RATE_ALL_OFDM_AG			(RATR_6M | RATR_9M | RATR_12M | RATR_18M | RATR_24M|\
	RATR_36M | RATR_48M | RATR_54M)
#define	RATE_ALL_OFDM_1SS			(RATR_MCS0 | RATR_MCS1 | RATR_MCS2 | RATR_MCS3 |\
	RATR_MCS4 | RATR_MCS5 | RATR_MCS6 | RATR_MCS7)
#define	RATE_ALL_OFDM_2SS			(RATR_MCS8 | RATR_MCS9 | RATR_MCS10 | RATR_MCS11|\
	RATR_MCS12 | RATR_MCS13 | RATR_MCS14 | RATR_MCS15)

#define RATE_BITMAP_ALL			0xFFFFF

/* Only use CCK 1M rate for ACK */
#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
#define RATE_RRSR_WITHOUT_CCK		0xFFFF0

/* ----------------------------------------------------------------------------
 * BW_OPMODE bits				(Offset 0x603, 8bit)
 * ---------------------------------------------------------------------------- */
#define BW_OPMODE_20MHZ			BIT(2)
#define BW_OPMODE_5G				BIT(1)

/* ----------------------------------------------------------------------------
 * CAM Config Setting (offset 0x680, 1 byte)
 * ----------------------------------------------------------------------------			 */
#define CAM_VALID				BIT(15)
#define CAM_NOTVALID			0x0000
#define CAM_USEDK				BIT(5)

#define CAM_CONTENT_COUNT	8

#define CAM_NONE				0x0
#define CAM_WEP40				0x01
#define CAM_TKIP				0x02
#define CAM_AES					0x04
#define CAM_WEP104				0x05
#define CAM_SMS4				0x6

#define TOTAL_CAM_ENTRY		32
#define HALF_CAM_ENTRY			16

#define CAM_CONFIG_USEDK		_TRUE
#define CAM_CONFIG_NO_USEDK	_FALSE

#define CAM_WRITE				BIT(16)
#define CAM_READ				0x00000000
#define CAM_POLLINIG			BIT(31)

/*
 * 10. Power Save Control Registers
 *   */
#define WOW_PMEN				BIT(0) /* Power management Enable. */
#define WOW_WOMEN				BIT(1) /* WoW function on or off. */
#define WOW_MAGIC				BIT(2) /* Magic packet */
#define WOW_UWF				BIT(3) /* Unicast Wakeup frame. */

/*
 * 12. Host Interrupt Status Registers
 *
 * ----------------------------------------------------------------------------
 * 8190 IMR/ISR bits
 * ---------------------------------------------------------------------------- */
#define IMR8190_DISABLED		0x0
#define IMR_DISABLED			0x0
/* IMR DW0 Bit 0-31 */
#define IMR_BCNDMAINT6			BIT(31)		/* Beacon DMA Interrupt 6 */
#define IMR_BCNDMAINT5			BIT(30)		/* Beacon DMA Interrupt 5 */
#define IMR_BCNDMAINT4			BIT(29)		/* Beacon DMA Interrupt 4 */
#define IMR_BCNDMAINT3			BIT(28)		/* Beacon DMA Interrupt 3 */
#define IMR_BCNDMAINT2			BIT(27)		/* Beacon DMA Interrupt 2 */
#define IMR_BCNDMAINT1			BIT(26)		/* Beacon DMA Interrupt 1 */
#define IMR_BCNDOK8				BIT(25)		/* Beacon Queue DMA OK Interrupt 8 */
#define IMR_BCNDOK7				BIT(24)		/* Beacon Queue DMA OK Interrupt 7 */
#define IMR_BCNDOK6				BIT(23)		/* Beacon Queue DMA OK Interrupt 6 */
#define IMR_BCNDOK5				BIT(22)		/* Beacon Queue DMA OK Interrupt 5 */
#define IMR_BCNDOK4				BIT(21)		/* Beacon Queue DMA OK Interrupt 4 */
#define IMR_BCNDOK3				BIT(20)		/* Beacon Queue DMA OK Interrupt 3 */
#define IMR_BCNDOK2				BIT(19)		/* Beacon Queue DMA OK Interrupt 2 */
#define IMR_BCNDOK1				BIT(18)		/* Beacon Queue DMA OK Interrupt 1 */
#define IMR_TIMEOUT2			BIT(17)		/* Timeout interrupt 2 */
#define IMR_TIMEOUT1			BIT(16)		/* Timeout interrupt 1 */
#define IMR_TXFOVW				BIT(15)		/* Transmit FIFO Overflow */
#define IMR_PSTIMEOUT			BIT(14)		/* Power save time out interrupt */
#define IMR_BcnInt				BIT(13)		/* Beacon DMA Interrupt 0 */
#define IMR_RXFOVW				BIT(12)		/* Receive FIFO Overflow */
#define IMR_RDU					BIT(11)		/* Receive Descriptor Unavailable */
#define IMR_ATIMEND				BIT(10)		/* For 92C, ATIM Window End Interrupt. For 8723 and later ICs, it also means P2P CTWin End interrupt. */
#define IMR_BDOK				BIT(9)		/* Beacon Queue DMA OK Interrupt */
#define IMR_HIGHDOK				BIT(8)		/* High Queue DMA OK Interrupt */
#define IMR_TBDOK				BIT(7)		/* Transmit Beacon OK interrupt */
#define IMR_MGNTDOK			BIT(6)		/* Management Queue DMA OK Interrupt */
#define IMR_TBDER				BIT(5)		/* For 92C, Transmit Beacon Error Interrupt */
#define IMR_BKDOK				BIT(4)		/* AC_BK DMA OK Interrupt */
#define IMR_BEDOK				BIT(3)		/* AC_BE DMA OK Interrupt */
#define IMR_VIDOK				BIT(2)		/* AC_VI DMA OK Interrupt */
#define IMR_VODOK				BIT(1)		/* AC_VO DMA Interrupt */
#define IMR_ROK					BIT(0)		/* Receive DMA OK Interrupt */

/* 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh) */
#define IMR_TSF_BIT32_TOGGLE	BIT(15)
#define IMR_BcnInt_E				BIT(12)
#define IMR_TXERR				BIT(11)
#define IMR_RXERR				BIT(10)
#define IMR_C2HCMD				BIT(9)
#define IMR_CPWM				BIT(8)
/* RSVD [2-7] */
#define IMR_OCPINT				BIT(1)
#define IMR_WLANOFF			BIT(0)

/* ----------------------------------------------------------------------------
 * 8723E series PCIE Host IMR/ISR bit
 * ---------------------------------------------------------------------------- */
/* IMR DW0 Bit 0-31 */
#define PHIMR_TIMEOUT2				BIT(31)
#define PHIMR_TIMEOUT1				BIT(30)
#define PHIMR_PSTIMEOUT			BIT(29)
#define PHIMR_GTINT4				BIT(28)
#define PHIMR_GTINT3				BIT(27)
#define PHIMR_TXBCNERR				BIT(26)
#define PHIMR_TXBCNOK				BIT(25)
#define PHIMR_TSF_BIT32_TOGGLE	BIT(24)
#define PHIMR_BCNDMAINT3			BIT(23)
#define PHIMR_BCNDMAINT2			BIT(22)
#define PHIMR_BCNDMAINT1			BIT(21)
#define PHIMR_BCNDMAINT0			BIT(20)
#define PHIMR_BCNDOK3				BIT(19)
#define PHIMR_BCNDOK2				BIT(18)
#define PHIMR_BCNDOK1				BIT(17)
#define PHIMR_BCNDOK0				BIT(16)
#define PHIMR_HSISR_IND_ON			BIT(15)
#define PHIMR_BCNDMAINT_E			BIT(14)
#define PHIMR_ATIMEND_E			BIT(13)
#define PHIMR_ATIM_CTW_END		BIT(12)
#define PHIMR_HISRE_IND			BIT(11)	/* RO. HISRE Indicator (HISRE & HIMRE is true, this bit is set to 1) */
#define PHIMR_C2HCMD				BIT(10)
#define PHIMR_CPWM2				BIT(9)
#define PHIMR_CPWM					BIT(8)
#define PHIMR_HIGHDOK				BIT(7)		/* High Queue DMA OK Interrupt */
#define PHIMR_MGNTDOK				BIT(6)		/* Management Queue DMA OK Interrupt */
#define PHIMR_BKDOK					BIT(5)		/* AC_BK DMA OK Interrupt */
#define PHIMR_BEDOK					BIT(4)		/* AC_BE DMA OK Interrupt */
#define PHIMR_VIDOK					BIT(3)		/* AC_VI DMA OK Interrupt */
#define PHIMR_VODOK				BIT(2)		/* AC_VO DMA Interrupt */
#define PHIMR_RDU					BIT(1)		/* Receive Descriptor Unavailable */
#define PHIMR_ROK					BIT(0)		/* Receive DMA OK Interrupt */

/* PCIE Host Interrupt Status Extension bit */
#define PHIMR_BCNDMAINT7			BIT(23)
#define PHIMR_BCNDMAINT6			BIT(22)
#define PHIMR_BCNDMAINT5			BIT(21)
#define PHIMR_BCNDMAINT4			BIT(20)
#define PHIMR_BCNDOK7				BIT(19)
#define PHIMR_BCNDOK6				BIT(18)
#define PHIMR_BCNDOK5				BIT(17)
#define PHIMR_BCNDOK4				BIT(16)
/* bit12 15: RSVD */
#define PHIMR_TXERR					BIT(11)
#define PHIMR_RXERR					BIT(10)
#define PHIMR_TXFOVW				BIT(9)
#define PHIMR_RXFOVW				BIT(8)
/* bit2-7: RSVD */
#define PHIMR_OCPINT				BIT(1)
/* bit0: RSVD */

#define UHIMR_TIMEOUT2				BIT(31)
#define UHIMR_TIMEOUT1				BIT(30)
#define UHIMR_PSTIMEOUT			BIT(29)
#define UHIMR_GTINT4				BIT(28)
#define UHIMR_GTINT3				BIT(27)
#define UHIMR_TXBCNERR				BIT(26)
#define UHIMR_TXBCNOK				BIT(25)
#define UHIMR_TSF_BIT32_TOGGLE	BIT(24)
#define UHIMR_BCNDMAINT3			BIT(23)
#define UHIMR_BCNDMAINT2			BIT(22)
#define UHIMR_BCNDMAINT1			BIT(21)
#define UHIMR_BCNDMAINT0			BIT(20)
#define UHIMR_BCNDOK3				BIT(19)
#define UHIMR_BCNDOK2				BIT(18)
#define UHIMR_BCNDOK1				BIT(17)
#define UHIMR_BCNDOK0				BIT(16)
#define UHIMR_HSISR_IND			BIT(15)
#define UHIMR_BCNDMAINT_E			BIT(14)
/* RSVD	BIT(13) */
#define UHIMR_CTW_END				BIT(12)
/* RSVD	BIT(11) */
#define UHIMR_C2HCMD				BIT(10)
#define UHIMR_CPWM2				BIT(9)
#define UHIMR_CPWM					BIT(8)
#define UHIMR_HIGHDOK				BIT(7)		/* High Queue DMA OK Interrupt */
#define UHIMR_MGNTDOK				BIT(6)		/* Management Queue DMA OK Interrupt */
#define UHIMR_BKDOK				BIT(5)		/* AC_BK DMA OK Interrupt */
#define UHIMR_BEDOK				BIT(4)		/* AC_BE DMA OK Interrupt */
#define UHIMR_VIDOK					BIT(3)		/* AC_VI DMA OK Interrupt */
#define UHIMR_VODOK				BIT(2)		/* AC_VO DMA Interrupt */
#define UHIMR_RDU					BIT(1)		/* Receive Descriptor Unavailable */
#define UHIMR_ROK					BIT(0)		/* Receive DMA OK Interrupt */

/* USB Host Interrupt Status Extension bit */
#define UHIMR_BCNDMAINT7			BIT(23)
#define UHIMR_BCNDMAINT6			BIT(22)
#define UHIMR_BCNDMAINT5			BIT(21)
#define UHIMR_BCNDMAINT4			BIT(20)
#define UHIMR_BCNDOK7				BIT(19)
#define UHIMR_BCNDOK6				BIT(18)
#define UHIMR_BCNDOK5				BIT(17)
#define UHIMR_BCNDOK4				BIT(16)
/* bit14-15: RSVD */
#define UHIMR_ATIMEND_E			BIT(13)
#define UHIMR_ATIMEND				BIT(12)
#define UHIMR_TXERR					BIT(11)
#define UHIMR_RXERR					BIT(10)
#define UHIMR_TXFOVW				BIT(9)
#define UHIMR_RXFOVW				BIT(8)
/* bit2-7: RSVD */
#define UHIMR_OCPINT				BIT(1)
/* bit0: RSVD */


#define HAL_NIC_UNPLUG_ISR			0xFFFFFFFF	/* The value when the NIC is unplugged for PCI. */
#define HAL_NIC_UNPLUG_PCI_ISR		0xEAEAEAEA	/* The value when the NIC is unplugged for PCI in PCI interrupt (page 3). */

/* ----------------------------------------------------------------------------
 * 8188 IMR/ISR bits
 * ---------------------------------------------------------------------------- */
#define IMR_DISABLED_88E			0x0
/* IMR DW0(0x0060-0063) Bit 0-31 */
#define IMR_TXCCK_88E				BIT(30)		/* TXRPT interrupt when CCX bit of the packet is set	 */
#define IMR_PSTIMEOUT_88E			BIT(29)		/* Power Save Time Out Interrupt */
#define IMR_GTINT4_88E				BIT(28)		/* When GTIMER4 expires, this bit is set to 1	 */
#define IMR_GTINT3_88E				BIT(27)		/* When GTIMER3 expires, this bit is set to 1	 */
#define IMR_TBDER_88E				BIT(26)		/* Transmit Beacon0 Error			 */
#define IMR_TBDOK_88E				BIT(25)		/* Transmit Beacon0 OK			 */
#define IMR_TSF_BIT32_TOGGLE_88E	BIT(24)		/* TSF Timer BIT32 toggle indication interrupt			 */
#define IMR_BCNDMAINT0_88E		BIT(20)		/* Beacon DMA Interrupt 0			 */
#define IMR_BCNDERR0_88E			BIT(16)		/* Beacon Queue DMA Error 0 */
#define IMR_HSISR_IND_ON_INT_88E	BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)			 */
#define IMR_BCNDMAINT_E_88E		BIT(14)		/* Beacon DMA Interrupt Extension for Win7			 */
#define IMR_ATIMEND_88E			BIT(12)		/* CTWidnow End or ATIM Window End */
#define IMR_HISR1_IND_INT_88E		BIT(11)		/* HISR1 Indicator (HISR1 & HIMR1 is true, this bit is set to 1) */
#define IMR_C2HCMD_88E				BIT(10)		/* CPU to Host Command INT Status, Write 1 clear	 */
#define IMR_CPWM2_88E				BIT(9)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define IMR_CPWM_88E				BIT(8)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
#define IMR_HIGHDOK_88E			BIT(7)			/* High Queue DMA OK	 */
#define IMR_MGNTDOK_88E			BIT(6)			/* Management Queue DMA OK	 */
#define IMR_BKDOK_88E				BIT(5)			/* AC_BK DMA OK		 */
#define IMR_BEDOK_88E				BIT(4)			/* AC_BE DMA OK	 */
#define IMR_VIDOK_88E				BIT(3)			/* AC_VI DMA OK		 */
#define IMR_VODOK_88E				BIT(2)			/* AC_VO DMA OK	 */
#define IMR_RDU_88E					BIT(1)			/* Rx Descriptor Unavailable	 */
#define IMR_ROK_88E					BIT(0)			/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define IMR_BCNDMAINT7_88E		BIT(27)		/* Beacon DMA Interrupt 7 */
#define IMR_BCNDMAINT6_88E		BIT(26)		/* Beacon DMA Interrupt 6 */
#define IMR_BCNDMAINT5_88E		BIT(25)		/* Beacon DMA Interrupt 5 */
#define IMR_BCNDMAINT4_88E		BIT(24)		/* Beacon DMA Interrupt 4 */
#define IMR_BCNDMAINT3_88E		BIT(23)		/* Beacon DMA Interrupt 3 */
#define IMR_BCNDMAINT2_88E		BIT(22)		/* Beacon DMA Interrupt 2 */
#define IMR_BCNDMAINT1_88E		BIT(21)		/* Beacon DMA Interrupt 1 */
#define IMR_BCNDOK7_88E			BIT(20)		/* Beacon Queue DMA OK Interrupt 7 */
#define IMR_BCNDOK6_88E			BIT(19)		/* Beacon Queue DMA OK Interrupt 6 */
#define IMR_BCNDOK5_88E			BIT(18)		/* Beacon Queue DMA OK Interrupt 5 */
#define IMR_BCNDOK4_88E			BIT(17)		/* Beacon Queue DMA OK Interrupt 4 */
#define IMR_BCNDOK3_88E			BIT(16)		/* Beacon Queue DMA OK Interrupt 3 */
#define IMR_BCNDOK2_88E			BIT(15)		/* Beacon Queue DMA OK Interrupt 2 */
#define IMR_BCNDOK1_88E			BIT(14)		/* Beacon Queue DMA OK Interrupt 1 */
#define IMR_ATIMEND_E_88E			BIT(13)		/* ATIM Window End Extension for Win7 */
#define IMR_TXERR_88E				BIT(11)		/* Tx Error Flag Interrupt Status, write 1 clear. */
#define IMR_RXERR_88E				BIT(10)		/* Rx Error Flag INT Status, Write 1 clear */
#define IMR_TXFOVW_88E				BIT(9)			/* Transmit FIFO Overflow */
#define IMR_RXFOVW_88E				BIT(8)			/* Receive FIFO Overflow */

/*===================================================================
=====================================================================
Here the register defines are for 92C. When the define is as same with 92C,
we will use the 92C's define for the consistency
So the following defines for 92C is not entire!!!!!!
=====================================================================
=====================================================================*/
/*
Based on Datasheet V33---090401
Register Summary
Current IOREG MAP
0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
*/
/* ---------------------------------------------------------------------------- */
/*		 8192C (TXPAUSE) transmission pause 	(Offset 0x522, 8 bits) */
/* ---------------------------------------------------------------------------- */
/* Note:
*	The the bits of stoping AC(VO/VI/BE/BK) queue in datasheet RTL8192S/RTL8192C are wrong,
*	the correct arragement is VO - Bit0, VI - Bit1, BE - Bit2, and BK - Bit3.
*	8723 and 88E may be not correct either in the eralier version. Confirmed with DD Tim.
* By Bruce, 2011-09-22. */
#define StopBecon		BIT(6)
#define StopHigh			BIT(5)
#define StopMgt			BIT(4)
#define StopBK			BIT(3)
#define StopBE			BIT(2)
#define StopVI			BIT(1)
#define StopVO			BIT(0)

/* ----------------------------------------------------------------------------
 * 8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
 * ---------------------------------------------------------------------------- */
#define RCR_APPFCS				BIT(31)	/* WMAC append FCS after pauload */
#define RCR_APP_MIC				BIT(30)	/* MACRX will retain the MIC at the bottom of the packet. */
#define RCR_APP_ICV				BIT(29)	/* MACRX will retain the ICV at the bottom of the packet. */
#define RCR_APP_PHYST_RXFF		BIT(28)	/* PHY Status is appended before RX packet in RXFF */
#define RCR_APP_BA_SSN			BIT(27)	/* SSN of previous TXBA is appended as after original RXDESC as the 4-th DW of RXDESC. */
#define RCR_VHT_DACK			BIT(26)	/* This bit to control response type for vht single mpdu data packet. 1. ACK as response 0. BA as response */
#define RCR_TCPOFLD_EN			BIT(25)	/* Enable TCP checksum offload */
#define RCR_ENMBID				BIT(24)	/* Enable Multiple BssId. Only response ACK to the packets whose DID(A1) matching to the addresses in the MBSSID CAM Entries. */
#define RCR_LSIGEN				BIT(23)	/* Enable LSIG TXOP Protection function. Search KEYCAM for each rx packet to check if LSIGEN bit is set. */
#define RCR_MFBEN				BIT(22)	/* Enable immediate MCS Feedback function. When Rx packet with MRQ = 1'b1, then search KEYCAM to find sender's MCS Feedback function and send response. */
#define RCR_DISCHKPPDLLEN		BIT(21)	/* Do not check PPDU while the PPDU length is smaller than 14 byte. */
#define RCR_PKTCTL_DLEN			BIT(20)	/* While rx path dead lock occurs, reset rx path */
#define RCR_DISGCLK				BIT(19)	/* Disable macrx clock gating control (no used) */
#define RCR_TIM_PARSER_EN		BIT(18)	/* RX Beacon TIM Parser. */
#define RCR_BC_MD_EN			BIT(17)	/* Broadcast data packet more data bit check interrupt enable.*/
#define RCR_UC_MD_EN			BIT(16)	/* Unicast data packet more data bit check interrupt enable. */
#define RCR_RXSK_PERPKT			BIT(15)	/* Executing key search per MPDU */
#define RCR_HTC_LOC_CTRL		BIT(14)	/* MFC<--HTC = 1 MFC-->HTC = 0 */
#define RCR_AMF					BIT(13)	/* Accept management type frame */
#define RCR_ACF					BIT(12)	/* Accept control type frame. Control frames BA, BAR, and PS-Poll (when in AP mode) are not controlled by this bit. They are controlled by ADF. */
#define RCR_ADF					BIT(11)	/* Accept data type frame. This bit also regulates BA, BAR, and PS-Poll (AP mode only). */
#define RCR_DISDECMYPKT			BIT(10)	/* This bit determines whether hw need to do decryption.1: If A1 match, do decryption.0: Do decryption. */
#define RCR_AICV					BIT(9)		/* Accept ICV error packet */
#define RCR_ACRC32				BIT(8)		/* Accept CRC32 error packet */
#define RCR_CBSSID_BCN			BIT(7)		/* Accept BSSID match packet (Rx beacon, probe rsp) */
#define RCR_CBSSID_DATA		BIT(6)		/* Accept BSSID match packet (Data) */
#define RCR_APWRMGT			BIT(5)		/* Accept power management packet */
#define RCR_ADD3				BIT(4)		/* Accept address 3 match packet */
#define RCR_AB					BIT(3)		/* Accept broadcast packet */
#define RCR_AM					BIT(2)		/* Accept multicast packet */
#define RCR_APM					BIT(1)		/* Accept physical match packet */
#define RCR_AAP					BIT(0)		/* Accept all unicast packet */


/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */

/* 2 SYS_ISO_CTRL */
#define ISO_MD2PP				BIT(0)
#define ISO_UA2USB				BIT(1)
#define ISO_UD2CORE				BIT(2)
#define ISO_PA2PCIE				BIT(3)
#define ISO_PD2CORE				BIT(4)
#define ISO_IP2MAC				BIT(5)
#define ISO_DIOP					BIT(6)
#define ISO_DIOE					BIT(7)
#define ISO_EB2CORE				BIT(8)
#define ISO_DIOR					BIT(9)
#define PWC_EV12V				BIT(15)


/* 2 SYS_FUNC_EN */
#define FEN_BBRSTB				BIT(0)
#define FEN_BB_GLB_RSTn		BIT(1)
#define FEN_USBA				BIT(2)
#define FEN_UPLL				BIT(3)
#define FEN_USBD				BIT(4)
#define FEN_DIO_PCIE			BIT(5)
#define FEN_PCIEA				BIT(6)
#define FEN_PPLL					BIT(7)
#define FEN_PCIED				BIT(8)
#define FEN_DIOE				BIT(9)
#define FEN_CPUEN				BIT(10)
#define FEN_DCORE				BIT(11)
#define FEN_ELDR				BIT(12)
#define FEN_EN_25_1				BIT(13)
#define FEN_HWPDN				BIT(14)
#define FEN_MREGEN				BIT(15)

/* 2 APS_FSMCO */
#define PFM_LDALL				BIT(0)
#define PFM_ALDN				BIT(1)
#define PFM_LDKP				BIT(2)
#define PFM_WOWL				BIT(3)
#define EnPDN					BIT(4)
#define PDN_PL					BIT(5)
#define APFM_ONMAC				BIT(8)
#define APFM_OFF				BIT(9)
#define APFM_RSM				BIT(10)
#define AFSM_HSUS				BIT(11)
#define AFSM_PCIE				BIT(12)
#define APDM_MAC				BIT(13)
#define APDM_HOST				BIT(14)
#define APDM_HPDN				BIT(15)
#define RDY_MACON				BIT(16)
#define SUS_HOST				BIT(17)
#define ROP_ALD					BIT(20)
#define ROP_PWR					BIT(21)
#define ROP_SPS					BIT(22)
#define SOP_MRST				BIT(25)
#define SOP_FUSE				BIT(26)
#define SOP_ABG					BIT(27)
#define SOP_AMB					BIT(28)
#define SOP_RCK					BIT(29)
#define SOP_A8M					BIT(30)
#define XOP_BTCK				BIT(31)

/* 2 SYS_CLKR */
#define ANAD16V_EN				BIT(0)
#define ANA8M					BIT(1)
#define MACSLP					BIT(4)
#define LOADER_CLK_EN			BIT(5)


/* 2 9346CR /REG_SYS_EEPROM_CTRL */
#define BOOT_FROM_EEPROM		BIT(4)
#define EEPROMSEL				BIT(4)
#define EEPROM_EN				BIT(5)


/* 2 RF_CTRL */
#define RF_EN					BIT(0)
#define RF_RSTB					BIT(1)
#define RF_SDMRSTB				BIT(2)


/* 2 LDOV12D_CTRL */
#define LDV12_EN				BIT(0)
#define LDV12_SDBY				BIT(1)
#define LPLDO_HSM				BIT(2)
#define LPLDO_LSM_DIS			BIT(3)
#define _LDV12_VADJ(x)			(((x) & 0xF) << 4)



/* 2 EFUSE_TEST (For RTL8723 partially) */
#define EF_TRPT					BIT(7)
#define EF_CELL_SEL				(BIT(8) | BIT(9)) /* 00: Wifi Efuse, 01: BT Efuse0, 10: BT Efuse1, 11: BT Efuse2 */
#define LDOE25_EN				BIT(31)
#define EFUSE_SEL(x)				(((x) & 0x3) << 8)
#define EFUSE_SEL_MASK			0x300
#define EFUSE_WIFI_SEL_0		0x0
#define EFUSE_BT_SEL_0			0x1
#define EFUSE_BT_SEL_1			0x2
#define EFUSE_BT_SEL_2			0x3

/* 2 REG_GPIO_INTM				(Offset 0x0048) */
#define BIT_EXTWOL_EN 			BIT(16)

/* 2 REG_LED_CFG				(Offset 0x004C) */
#define BIT_SW_SPDT_SEL			BIT(22)

/* 2 REG_SW_GPIO_SHARE_CTRL		(Offset 0x1038) */
#define BIT_BTGP_WAKE_LOC		(BIT(10) | BIT(11))
#define BIT_SW_GPIO_FUNC 		BIT(0)

/* 2 8051FWDL
 * 2 MCUFWDL */
#define MCUFWDL_EN				BIT(0)
#define MCUFWDL_RDY			BIT(1)
#define FWDL_ChkSum_rpt		BIT(2)
#define MACINI_RDY				BIT(3)
#define BBINI_RDY				BIT(4)
#define RFINI_RDY				BIT(5)
#define WINTINI_RDY				BIT(6)
#define RAM_DL_SEL				BIT(7)
#define CPU_DL_READY			BIT(15) /* add flag  by gw for fw download ready 20130826 */
#define ROM_DLEN				BIT(19)
#define CPRST					BIT(23)


/* 2 REG_SYS_CFG */
#define XCLK_VLD				BIT(0)
#define ACLK_VLD				BIT(1)
#define UCLK_VLD				BIT(2)
#define PCLK_VLD				BIT(3)
#define PCIRSTB					BIT(4)
#define V15_VLD					BIT(5)
#define SW_OFFLOAD_EN			BIT(7)
#define SIC_IDLE					BIT(8)
#define BD_MAC2					BIT(9)
#define BD_MAC1					BIT(10)
#define IC_MACPHY_MODE		BIT(11)
#define CHIP_VER				(BIT(12) | BIT(13) | BIT(14) | BIT(15))
#define BT_FUNC					BIT(16)
#define VENDOR_ID				BIT(19)
#define EXT_VENDOR_ID			(BIT(18) | BIT(19)) /* Currently only for RTL8723B */
#define PAD_HWPD_IDN			BIT(22)
#define TRP_VAUX_EN				BIT(23)	/* RTL ID */
#define TRP_BT_EN				BIT(24)
#define BD_PKG_SEL				BIT(25)
#define BD_HCI_SEL				BIT(26)
#define TYPE_ID					BIT(27)
#define RF_TYPE_ID				BIT(27)

#define RTL_ID					BIT(23) /* TestChip ID, 1:Test(RLE); 0:MP(RL) */
#define SPS_SEL					BIT(24) /* 1:LDO regulator mode; 0:Switching regulator mode */


#define CHIP_VER_RTL_MASK		0xF000	/* Bit 12 ~ 15 */
#define CHIP_VER_RTL_SHIFT		12
#define EXT_VENDOR_ID_SHIFT	18

/* 2 REG_GPIO_OUTSTS (For RTL8723 only) */
#define EFS_HCI_SEL				(BIT(0) | BIT(1))
#define PAD_HCI_SEL				(BIT(2) | BIT(3))
#define HCI_SEL					(BIT(4) | BIT(5))
#define PKG_SEL_HCI				BIT(6)
#define FEN_GPS					BIT(7)
#define FEN_BT					BIT(8)
#define FEN_WL					BIT(9)
#define FEN_PCI					BIT(10)
#define FEN_USB					BIT(11)
#define BTRF_HWPDN_N			BIT(12)
#define WLRF_HWPDN_N			BIT(13)
#define PDN_BT_N				BIT(14)
#define PDN_GPS_N				BIT(15)
#define BT_CTL_HWPDN			BIT(16)
#define GPS_CTL_HWPDN			BIT(17)
#define PPHY_SUSB				BIT(20)
#define UPHY_SUSB				BIT(21)
#define PCI_SUSEN				BIT(22)
#define USB_SUSEN				BIT(23)
#define RF_RL_ID					(BIT(31) | BIT(30) | BIT(29) | BIT(28))


/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */

/* 2 Function Enable Registers
 * 2 CR */
#define HCI_TXDMA_EN			BIT(0)
#define HCI_RXDMA_EN			BIT(1)
#define TXDMA_EN				BIT(2)
#define RXDMA_EN				BIT(3)
#define PROTOCOL_EN				BIT(4)
#define SCHEDULE_EN				BIT(5)
#define MACTXEN					BIT(6)
#define MACRXEN					BIT(7)
#define ENSWBCN					BIT(8)
#define ENSEC					BIT(9)
#define CALTMR_EN				BIT(10)	/* 32k CAL TMR enable */

/* Network type */
#define _NETTYPE(x)				(((x) & 0x3) << 16)
#define MASK_NETTYPE			0x30000
#define NT_NO_LINK				0x0
#define NT_LINK_AD_HOC			0x1
#define NT_LINK_AP				0x2
#define NT_AS_AP				0x3

/* 2 PBP - Page Size Register */
#define GET_RX_PAGE_SIZE(value)			((value) & 0xF)
#define GET_TX_PAGE_SIZE(value)			(((value) & 0xF0) >> 4)
#define _PSRX_MASK				0xF
#define _PSTX_MASK				0xF0
#define _PSRX(x)				(x)
#define _PSTX(x)				((x) << 4)

#define PBP_64					0x0
#define PBP_128					0x1
#define PBP_256					0x2
#define PBP_512					0x3
#define PBP_1024				0x4


/* 2 TX/RXDMA */
#define RXDMA_ARBBW_EN		BIT(0)
#define RXSHFT_EN				BIT(1)
#define RXDMA_AGG_EN			BIT(2)
#define QS_VO_QUEUE			BIT(8)
#define QS_VI_QUEUE				BIT(9)
#define QS_BE_QUEUE			BIT(10)
#define QS_BK_QUEUE			BIT(11)
#define QS_MANAGER_QUEUE		BIT(12)
#define QS_HIGH_QUEUE			BIT(13)

#define HQSEL_VOQ				BIT(0)
#define HQSEL_VIQ				BIT(1)
#define HQSEL_BEQ				BIT(2)
#define HQSEL_BKQ				BIT(3)
#define HQSEL_MGTQ				BIT(4)
#define HQSEL_HIQ				BIT(5)

/* For normal driver, 0x10C */
#define _TXDMA_CMQ_MAP(x)			(((x) & 0x3) << 16)
#define _TXDMA_HIQ_MAP(x)			(((x) & 0x3) << 14)
#define _TXDMA_MGQ_MAP(x)			(((x) & 0x3) << 12)
#define _TXDMA_BKQ_MAP(x)			(((x) & 0x3) << 10)
#define _TXDMA_BEQ_MAP(x)			(((x) & 0x3) << 8)
#define _TXDMA_VIQ_MAP(x)			(((x) & 0x3) << 6)
#define _TXDMA_VOQ_MAP(x)			(((x) & 0x3) << 4)

#define QUEUE_EXTRA				0
#define QUEUE_LOW				1
#define QUEUE_NORMAL			2
#define QUEUE_HIGH				3
#define QUEUE_EXTRA_1			4
#define QUEUE_EXTRA_2			5

/* 2 TRXFF_BNDY */


/* 2 LLT_INIT */
#define _LLT_NO_ACTIVE				0x0
#define _LLT_WRITE_ACCESS			0x1
#define _LLT_READ_ACCESS			0x2

#define _LLT_INIT_DATA(x)			((x) & 0xFF)
#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
#define _LLT_OP(x)					(((x) & 0x3) << 30)
#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)


/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
/* 2 RQPN */
#define _HPQ(x)					((x) & 0xFF)
#define _LPQ(x)					(((x) & 0xFF) << 8)
#define _PUBQ(x)					(((x) & 0xFF) << 16)
#define _NPQ(x)					((x) & 0xFF)			/* NOTE: in RQPN_NPQ register */
#define _EPQ(x)					(((x) & 0xFF) << 16)	/* NOTE: in RQPN_EPQ register */


#define HPQ_PUBLIC_DIS			BIT(24)
#define LPQ_PUBLIC_DIS			BIT(25)
#define LD_RQPN					BIT(31)


/* 2 TDECTL */
#define BLK_DESC_NUM_SHIFT			4
#define BLK_DESC_NUM_MASK			0xF


/* 2 TXDMA_OFFSET_CHK */
#define DROP_DATA_EN				BIT(9)

/* 2 AUTO_LLT */
#define BIT_SHIFT_TXPKTNUM 24
#define BIT_MASK_TXPKTNUM 0xff
#define BIT_TXPKTNUM(x) (((x) & BIT_MASK_TXPKTNUM) << BIT_SHIFT_TXPKTNUM)

#define BIT_TDE_DBG_SEL BIT(23)
#define BIT_AUTO_INIT_LLT BIT(16)

#define BIT_SHIFT_Tx_OQT_free_space 8
#define BIT_MASK_Tx_OQT_free_space 0xff
#define BIT_Tx_OQT_free_space(x) (((x) & BIT_MASK_Tx_OQT_free_space) << BIT_SHIFT_Tx_OQT_free_space)


/* -----------------------------------------------------
 *
 *	0x0120h ~ 0x0123h	RX DMA Configuration
 *
 * ----------------------------------------------------- */
#define BIT_FS_RXDONE_INT_EN				BIT(16)


/* REG_RXPKT_NUM				(Offset 0x0284) */
#define BIT_RW_RELEASE_EN				BIT(18)

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x028Bh	RX DMA Configuration
 *
 * ----------------------------------------------------- */

/* 2 REG_RXDMA_CONTROL, 0x0286h
 * Write only. When this bit is set, RXDMA will decrease RX PKT counter by one. Before
 * this bit is polled, FW shall update RXFF_RD_PTR first. This register is write pulse and auto clear.
 * #define RXPKT_RELEASE_POLL			BIT(0)
 * Read only. When RXMA finishes on-going DMA operation, RXMDA will report idle state in
 * this bit. FW can start releasing packets after RXDMA entering idle mode.
 * #define RXDMA_IDLE					BIT(1)
 * When this bit is set, RXDMA will enter this mode after on-going RXDMA packet to host
 * completed, and stop DMA packet to host. RXDMA will then report Default: 0;
 * #define RW_RELEASE_EN				BIT(2) */

/* 2 REG_RXPKT_NUM, 0x0284 */
#define	RXPKT_RELEASE_POLL	BIT(16)
#define	RXDMA_IDLE				BIT(17)
#define	RW_RELEASE_EN			BIT(18)

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
/* 2 FWHW_TXQ_CTRL */
#define EN_AMPDU_RTY_NEW			BIT(7)


/* 2 SPEC SIFS */
#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)

/* 2 RL */
#define BIT_SHIFT_SRL 8
#define BIT_MASK_SRL 0x3f
#define BIT_SRL(x) (((x) & BIT_MASK_SRL) << BIT_SHIFT_SRL)

#define BIT_SHIFT_LRL 0
#define BIT_MASK_LRL 0x3f
#define BIT_LRL(x) (((x) & BIT_MASK_LRL) << BIT_SHIFT_LRL)

#define	RL_VAL_AP					7
#ifdef CONFIG_RTW_CUSTOMIZE_RLSTA
#define	RL_VAL_STA					CONFIG_RTW_CUSTOMIZE_RLSTA
#else
#define	RL_VAL_STA					0x30
#endif
/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */

/* 2 EDCA setting */
#define AC_PARAM_TXOP_LIMIT_OFFSET		16
#define AC_PARAM_ECW_MAX_OFFSET			12
#define AC_PARAM_ECW_MIN_OFFSET			8
#define AC_PARAM_AIFS_OFFSET				0

/* 2 BCN_CTRL */
#define EN_TXBCN_RPT			BIT(2)
#define EN_BCN_FUNCTION		BIT(3)
#define STOP_BCNQ				BIT(6)
#define DIS_RX_BSSID_FIT		BIT(6)

#define DIS_ATIM					BIT(0)
#define DIS_BCNQ_SUB			BIT(1)
#define DIS_TSF_UDT				BIT(4)

/* 2 ACMHWCTRL */
#define AcmHw_HwEn				BIT(0)
#define AcmHw_VoqEn			BIT(1)
#define AcmHw_ViqEn				BIT(2)
#define AcmHw_BeqEn			BIT(3)
#define AcmHw_VoqStatus		BIT(5)
#define AcmHw_ViqStatus			BIT(6)
#define AcmHw_BeqStatus		BIT(7)

/* 2 */ /* REG_DUAL_TSF_RST (0x553) */
#define DUAL_TSF_RST_P2P		BIT(4)

/* 2 */ /* REG_NOA_DESC_SEL (0x5CF) */
#define NOA_DESC_SEL_0			0
#define NOA_DESC_SEL_1			BIT(4)

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */

/* 2 APSD_CTRL */
#define APSDOFF					BIT(6)

/* 2 TCR */
#define TSFRST					BIT(0)
#define DIS_GCLK					BIT(1)
#define PAD_SEL					BIT(2)
#define PWR_ST					BIT(6)
#define PWRBIT_OW_EN			BIT(7)
#define ACRC						BIT(8)
#define CFENDFORM				BIT(9)
#define ICV						BIT(10)


/* 2 RCR */
#define AAP						BIT(0)
#define APM						BIT(1)
#define AM						BIT(2)
#define AB						BIT(3)
#define ADD3						BIT(4)
#define APWRMGT				BIT(5)
#define CBSSID					BIT(6)
#define CBSSID_DATA				BIT(6)
#define CBSSID_BCN				BIT(7)
#define ACRC32					BIT(8)
#define AICV						BIT(9)
#define ADF						BIT(11)
#define ACF						BIT(12)
#define AMF						BIT(13)
#define HTC_LOC_CTRL			BIT(14)
#define UC_DATA_EN				BIT(16)
#define BM_DATA_EN				BIT(17)
#define MFBEN					BIT(22)
#define LSIGEN					BIT(23)
#define EnMBID					BIT(24)
#define FORCEACK				BIT(26)
#define APP_BASSN				BIT(27)
#define APP_PHYSTS				BIT(28)
#define APP_ICV					BIT(29)
#define APP_MIC					BIT(30)
#define APP_FCS					BIT(31)


/* 2 SECCFG */
#define SCR_TxUseDK				BIT(0)			/* Force Tx Use Default Key */
#define SCR_RxUseDK				BIT(1)			/* Force Rx Use Default Key */
#define SCR_TxEncEnable			BIT(2)			/* Enable Tx Encryption */
#define SCR_RxDecEnable			BIT(3)			/* Enable Rx Decryption */
#define SCR_SKByA2				BIT(4)			/* Search kEY BY A2 */
#define SCR_NoSKMC				BIT(5)			/* No Key Search Multicast */
#define SCR_TXBCUSEDK			BIT(6)			/* Force Tx Broadcast packets Use Default Key */
#define SCR_RXBCUSEDK			BIT(7)			/* Force Rx Broadcast packets Use Default Key */
#define SCR_CHK_KEYID			BIT(8)
#define SCR_CHK_BMC				BIT(9)			/* add option to support a2+keyid+bcm */

/*REG_MBIDCAMCFG           (Offset 0x0628/0x62C)*/
#define BIT_MBIDCAM_POLL		BIT(31)
#define BIT_MBIDCAM_WT_EN		BIT(30)

#define MBIDCAM_ADDR_MASK		0x1F
#define MBIDCAM_ADDR_SHIFT		24

#define BIT_MBIDCAM_VALID		BIT(23)
#define BIT_LSIC_TXOP_EN		BIT(17)
#define BIT_CTS_EN				BIT(16)

/*REG_RXFLTMAP1 (Offset 0x6A2)*/
#define BIT_CTRLFLT10EN	BIT(10) /*PS-POLL*/

/*REG_WLAN_ACT_MASK_CTRL_1	(Offset 0x76C)*/
#define EN_PORT_0_FUNCTION		BIT(12)
#define EN_PORT_1_FUNCTION		BIT(13)

/* -----------------------------------------------------
 *
 *	SDIO Bus Specification
 *
 * ----------------------------------------------------- */

/* I/O bus domain address mapping */
#define SDIO_LOCAL_BASE		0x10250000
#define WLAN_IOREG_BASE		0x10260000
#define FIRMWARE_FIFO_BASE	0x10270000
#define TX_HIQ_BASE				0x10310000
#define TX_MIQ_BASE				0x10320000
#define TX_LOQ_BASE				0x10330000
#define TX_EPQ_BASE				0x10350000
#define RX_RX0FF_BASE			0x10340000

/* SDIO host local register space mapping. */
#define SDIO_LOCAL_MSK				0x0FFF
#define WLAN_IOREG_MSK		0x7FFF
#define WLAN_FIFO_MSK			      	0x1FFF	/* Aggregation Length[12:0] */
#define WLAN_RX0FF_MSK				0x0003

#define SDIO_WITHOUT_REF_DEVICE_ID	0	/* Without reference to the SDIO Device ID */
#define SDIO_LOCAL_DEVICE_ID           		0	/* 0b[16], 000b[15:13] */
#define WLAN_TX_HIQ_DEVICE_ID			4	/* 0b[16], 100b[15:13] */
#define WLAN_TX_MIQ_DEVICE_ID 		5	/* 0b[16], 101b[15:13] */
#define WLAN_TX_LOQ_DEVICE_ID 		6	/* 0b[16], 110b[15:13] */
#define WLAN_TX_EXQ_DEVICE_ID		3	/* 0b[16], 011b[15:13] */
#define WLAN_RX0FF_DEVICE_ID 			7	/* 0b[16], 111b[15:13] */
#define WLAN_IOREG_DEVICE_ID 			8	/* 1b[16] */

/* SDIO Tx Free Page Index */
#define HI_QUEUE_IDX			0
#define MID_QUEUE_IDX			1
#define LOW_QUEUE_IDX				2
#define PUBLIC_QUEUE_IDX			3

#define SDIO_MAX_TX_QUEUE			3		/* HIQ, MIQ and LOQ */
#define SDIO_MAX_RX_QUEUE			1

#define SDIO_REG_TX_CTRL			0x0000 /* SDIO Tx Control */
#define SDIO_REG_TIMEOUT			0x0002/*SDIO status timeout*/
#define SDIO_REG_HIMR				0x0014 /* SDIO Host Interrupt Mask */
#define SDIO_REG_HISR				0x0018 /* SDIO Host Interrupt Service Routine */
#define SDIO_REG_HCPWM			0x0019 /* HCI Current Power Mode */
#define SDIO_REG_RX0_REQ_LEN		0x001C /* RXDMA Request Length */
#define SDIO_REG_OQT_FREE_PG		0x001E /* OQT Free Page */
#define SDIO_REG_FREE_TXPG			0x0020 /* Free Tx Buffer Page */
#define SDIO_REG_HCPWM1			0x0024 /* HCI Current Power Mode 1 */
#define SDIO_REG_HCPWM2			0x0026 /* HCI Current Power Mode 2 */
#define SDIO_REG_FREE_TXPG_SEQ	0x0028 /* Free Tx Page Sequence */
#define SDIO_REG_HTSFR_INFO		0x0030 /* HTSF Informaion */
#define SDIO_REG_HRPWM1			0x0080 /* HCI Request Power Mode 1 */
#define SDIO_REG_HRPWM2			0x0082 /* HCI Request Power Mode 2 */
#define SDIO_REG_HPS_CLKR			0x0084 /* HCI Power Save Clock */
#define SDIO_REG_HSUS_CTRL			0x0086 /* SDIO HCI Suspend Control */
#define SDIO_REG_HIMR_ON			0x0090 /* SDIO Host Extension Interrupt Mask Always */
#define SDIO_REG_HISR_ON			0x0091 /* SDIO Host Extension Interrupt Status Always */

#define SDIO_HIMR_DISABLED			0

/* RTL8723/RTL8188E SDIO Host Interrupt Mask Register */
#define SDIO_HIMR_RX_REQUEST_MSK		BIT(0)
#define SDIO_HIMR_AVAL_MSK			BIT(1)
#define SDIO_HIMR_TXERR_MSK			BIT(2)
#define SDIO_HIMR_RXERR_MSK			BIT(3)
#define SDIO_HIMR_TXFOVW_MSK			BIT(4)
#define SDIO_HIMR_RXFOVW_MSK			BIT(5)
#define SDIO_HIMR_TXBCNOK_MSK			BIT(6)
#define SDIO_HIMR_TXBCNERR_MSK		BIT(7)
#define SDIO_HIMR_BCNERLY_INT_MSK		BIT(16)
#define SDIO_HIMR_C2HCMD_MSK			BIT(17)
#define SDIO_HIMR_CPWM1_MSK			BIT(18)
#define SDIO_HIMR_CPWM2_MSK			BIT(19)
#define SDIO_HIMR_HSISR_IND_MSK		BIT(20)
#define SDIO_HIMR_GTINT3_IND_MSK		BIT(21)
#define SDIO_HIMR_GTINT4_IND_MSK		BIT(22)
#define SDIO_HIMR_PSTIMEOUT_MSK		BIT(23)
#define SDIO_HIMR_OCPINT_MSK			BIT(24)
#define SDIO_HIMR_ATIMEND_MSK			BIT(25)
#define SDIO_HIMR_ATIMEND_E_MSK		BIT(26)
#define SDIO_HIMR_CTWEND_MSK			BIT(27)

/* RTL8188E SDIO Specific */
#define SDIO_HIMR_MCU_ERR_MSK			BIT(28)
#define SDIO_HIMR_TSF_BIT32_TOGGLE_MSK		BIT(29)

/* SDIO Host Interrupt Service Routine */
#define SDIO_HISR_RX_REQUEST			BIT(0)
#define SDIO_HISR_AVAL					BIT(1)
#define SDIO_HISR_TXERR					BIT(2)
#define SDIO_HISR_RXERR					BIT(3)
#define SDIO_HISR_TXFOVW				BIT(4)
#define SDIO_HISR_RXFOVW				BIT(5)
#define SDIO_HISR_TXBCNOK				BIT(6)
#define SDIO_HISR_TXBCNERR				BIT(7)
#define SDIO_HISR_BCNERLY_INT			BIT(16)
#define SDIO_HISR_C2HCMD				BIT(17)
#define SDIO_HISR_CPWM1				BIT(18)
#define SDIO_HISR_CPWM2				BIT(19)
#define SDIO_HISR_HSISR_IND			BIT(20)
#define SDIO_HISR_GTINT3_IND			BIT(21)
#define SDIO_HISR_GTINT4_IND			BIT(22)
#define SDIO_HISR_PSTIMEOUT			BIT(23)
#define SDIO_HISR_OCPINT				BIT(24)
#define SDIO_HISR_ATIMEND				BIT(25)
#define SDIO_HISR_ATIMEND_E			BIT(26)
#define SDIO_HISR_CTWEND				BIT(27)

/* RTL8188E SDIO Specific */
#define SDIO_HISR_MCU_ERR				BIT(28)
#define SDIO_HISR_TSF_BIT32_TOGGLE	BIT(29)

#define MASK_SDIO_HISR_CLEAR		(SDIO_HISR_TXERR |\
		SDIO_HISR_RXERR |\
		SDIO_HISR_TXFOVW |\
		SDIO_HISR_RXFOVW |\
		SDIO_HISR_TXBCNOK |\
		SDIO_HISR_TXBCNERR |\
		SDIO_HISR_C2HCMD |\
		SDIO_HISR_CPWM1 |\
		SDIO_HISR_CPWM2 |\
		SDIO_HISR_HSISR_IND |\
		SDIO_HISR_GTINT3_IND |\
		SDIO_HISR_GTINT4_IND |\
		SDIO_HISR_PSTIMEOUT |\
		SDIO_HISR_OCPINT)

/* SDIO HCI Suspend Control Register */
#define HCI_RESUME_PWR_RDY			BIT(1)
#define HCI_SUS_CTRL					BIT(0)

/* SDIO Tx FIFO related */
#define SDIO_TX_FREE_PG_QUEUE			4	/* The number of Tx FIFO free page */
#define SDIO_TX_FIFO_PAGE_SZ			128

/* indirect access */
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
#define SDIO_REG_INDIRECT_REG_CFG		0x40
#define SDIO_REG_INDIRECT_REG_DATA	0x44
#define SET_INDIRECT_REG_ADDR(_cmd, _addr)	SET_BITS_TO_LE_2BYTE(((u8 *)(_cmd)) + 0, 0, 16, (_addr))
#define SET_INDIRECT_REG_SIZE_1BYTE(_cmd)		SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 0, 2, 0)
#define SET_INDIRECT_REG_SIZE_2BYTE(_cmd)		SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 0, 2, 1)
#define SET_INDIRECT_REG_SIZE_4BYTE(_cmd)		SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 0, 2, 2)
#define SET_INDIRECT_REG_WRITE(_cmd)			SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 2, 1, 1)
#define SET_INDIRECT_REG_READ(_cmd)			SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 3, 1, 1)
#define GET_INDIRECT_REG_RDY(_cmd)			LE_BITS_TO_1BYTE(((u8 *)(_cmd)) + 2, 4, 1)
#endif/*CONFIG_SDIO_INDIRECT_ACCESS*/

#ifdef CONFIG_SDIO_HCI
	#define MAX_TX_AGG_PACKET_NUMBER	0x8
#else
	#define MAX_TX_AGG_PACKET_NUMBER	0xFF
	#define MAX_TX_AGG_PACKET_NUMBER_8812	64
#endif

/* -----------------------------------------------------
 *
 *	0xFE00h ~ 0xFE55h	USB Configuration
 *
 * ----------------------------------------------------- */

/* 2 USB Information (0xFE17) */
#define USB_IS_HIGH_SPEED			0
#define USB_IS_FULL_SPEED			1
#define USB_SPEED_MASK				BIT(5)

#define USB_NORMAL_SIE_EP_MASK	0xF
#define USB_NORMAL_SIE_EP_SHIFT	4

/* 2 Special Option */
#define USB_AGG_EN				BIT(3)

/* 0; Use interrupt endpoint to upload interrupt pkt
 * 1; Use bulk endpoint to upload interrupt pkt, */
#define INT_BULK_SEL			BIT(4)

/* 2REG_C2HEVT_CLEAR */
#define C2H_EVT_HOST_CLOSE		0x00	/* Set by driver and notify FW that the driver has read the C2H command message */
#define C2H_EVT_FW_CLOSE		0xFF	/* Set by FW indicating that FW had set the C2H command message and it's not yet read by driver. */


/* 2REG_MULTI_FUNC_CTRL(For RTL8723 Only) */
#define WL_HWPDN_EN			BIT(0)	/* Enable GPIO[9] as WiFi HW PDn source */
#define WL_HWPDN_SL			BIT(1)	/* WiFi HW PDn polarity control */
#define WL_FUNC_EN				BIT(2)	/* WiFi function enable */
#define WL_HWROF_EN			BIT(3)	/* Enable GPIO[9] as WiFi RF HW PDn source */
#define BT_HWPDN_EN			BIT(16)	/* Enable GPIO[11] as BT HW PDn source */
#define BT_HWPDN_SL			BIT(17)	/* BT HW PDn polarity control */
#define BT_FUNC_EN				BIT(18)	/* BT function enable */
#define BT_HWROF_EN			BIT(19)	/* Enable GPIO[11] as BT/GPS RF HW PDn source */
#define GPS_HWPDN_EN			BIT(20)	/* Enable GPIO[10] as GPS HW PDn source */
#define GPS_HWPDN_SL			BIT(21)	/* GPS HW PDn polarity control */
#define GPS_FUNC_EN			BIT(22)	/* GPS function enable */

/* 3 REG_LIFECTRL_CTRL */
#define HAL92C_EN_PKT_LIFE_TIME_BK		BIT(3)
#define HAL92C_EN_PKT_LIFE_TIME_BE		BIT(2)
#define HAL92C_EN_PKT_LIFE_TIME_VI		BIT(1)
#define HAL92C_EN_PKT_LIFE_TIME_VO		BIT(0)

#define HAL92C_MSDU_LIFE_TIME_UNIT		128	/* in us, said by Tim. */

/* 2 8192D PartNo. */
#define PARTNO_92D_NIC							(BIT7 | BIT6)
#define PARTNO_92D_NIC_REMARK				(BIT5 | BIT4)
#define PARTNO_SINGLE_BAND_VS				BIT(3)
#define PARTNO_SINGLE_BAND_VS_REMARK		BIT(1)
#define PARTNO_CONCURRENT_BAND_VC			(BIT3 | BIT2)
#define PARTNO_CONCURRENT_BAND_VC_REMARK	(BIT1 | BIT0)

/* ********************************************************
 * General definitions
 * ******************************************************** */

#ifdef CONFIG_USB_HCI
	#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(__Adapter)	(175)
#else
	#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(__Adapter)	(IS_VENDOR_8188E_I_CUT_SERIES(__Adapter) ? 255 : 175)
#endif
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8812			255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723B		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8192C		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8703B		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC	127
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188F		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188GTV		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723D		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8710B		255
#define LAST_ENTRY_OF_TX_PKT_BUFFER_8192F		255
#define POLLING_LLT_THRESHOLD				20
#if defined(CONFIG_RTL8723B) && defined(CONFIG_PCI_HCI)
	#define POLLING_READY_TIMEOUT_COUNT		6000
#else
	#define POLLING_READY_TIMEOUT_COUNT		1000
#endif


/* GPIO BIT */
#define	HAL_8812A_HW_GPIO_WPS_BIT	BIT(2)
#define	HAL_8192C_HW_GPIO_WPS_BIT	BIT(2)
#define	HAL_8192EU_HW_GPIO_WPS_BIT	BIT(7)
#define	HAL_8188E_HW_GPIO_WPS_BIT	BIT(7)

#endif /* __HAL_COMMON_H__ */
                                                                                                                                                            rtl8822bu/src/include/rtl8814b_hal.h                                                                0000755 0001750 0001750 00000021362 14214766567 015720  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8814B_HAL_H_
#define _RTL8814B_HAL_H_

#include <osdep_service.h>		/* BIT(x) */
#include <drv_types.h>			/* PADAPTER */
#include "../hal/halmac/halmac_api.h"	/* MAC REG definition */


#ifdef CONFIG_SUPPORT_TRX_SHARED
#define MAX_RECVBUF_SZ		46080	/* 45KB, TX: (256-64)KB */
#else /* !CONFIG_SUPPORT_TRX_SHARED */
#define MAX_RECVBUF_SZ		24576	/* 24KB, TX: 256KB */
#endif /* !CONFIG_SUPPORT_TRX_SHARED */

#if 0
/*
 * MAC Register definition
 */
#define REG_AFE_XTAL_CTRL	REG_AFE_CTRL1_8814B	/* hal_com.c & phydm */
#define REG_AFE_PLL_CTRL	REG_AFE_CTRL2_8814B	/* hal_com.c & phydm */
#define REG_MAC_PHY_CTRL	REG_AFE_CTRL3_8814B	/* phydm only */
#endif
#define REG_LEDCFG0		REG_LED_CFG_8814B	/* rtw_mp.c */
#if 0
#define MSR			(REG_CR_8814B + 2)	/* rtw_mp.c & hal_com.c */
#define MSR1			REG_CR_EXT_8814B	/* rtw_mp.c & hal_com.c */
#endif
#define REG_C2HEVT_MSG_NORMAL	0x1A0			/* hal_com.c */
#if 0
#define REG_C2HEVT_CLEAR	0x1AF			/* hal_com.c */

#define REG_GPIO_PIN_CTRL_2		REG_GPIO_EXT_CTRL_8814B		/* hal_com.c */
#endif
#define REG_WKFMCAM_NUM		REG_WKFMCAM_CMD_8814B	/* hal_com.c: WOWLAN */
#define REG_WOWLAN_WAKE_REASON	0x01C7 /* hal_com.c: WOWLAN */
#define REG_RXPKTBUF_CTRL	(REG_PKTBUF_DBG_CTRL_8814B + 2)	/* hal_com.c: WOWLAN */
#define REG_RXPKT_NUM		REG_RXDMA_CTRL_8814B	/* hal_com.c: WOWLAN */

/* RXERR_RPT, for rtw_mp.c */
#define RXERR_TYPE_OFDM_PPDU		0
#define RXERR_TYPE_OFDM_FALSE_ALARM	2
#define RXERR_TYPE_OFDM_MPDU_OK		0
#define RXERR_TYPE_OFDM_MPDU_FAIL	1
#define RXERR_TYPE_CCK_PPDU		3
#define RXERR_TYPE_CCK_FALSE_ALARM	5
#define RXERR_TYPE_CCK_MPDU_OK		3
#define RXERR_TYPE_CCK_MPDU_FAIL	4
#define RXERR_TYPE_HT_PPDU		8
#define RXERR_TYPE_HT_FALSE_ALARM	9
#define RXERR_TYPE_HT_MPDU_TOTAL	6
#define RXERR_TYPE_HT_MPDU_OK		6
#define RXERR_TYPE_HT_MPDU_FAIL		7
#define RXERR_TYPE_RX_FULL_DROP		10

#define RXERR_COUNTER_MASK		BIT_MASK_RPT_COUNTER_8814B
#define RXERR_RPT_RST			BIT_RXERR_RPT_RST_8814B
#define _RXERR_RPT_SEL(type)		(BIT_RXERR_RPT_SEL_V1_3_0_8814B(type) \
					| ((type & 0x10) ? BIT_RXERR_RPT_SEL_V1_4_8814B : 0))

/* hal_com.c:rtw_lps_state_chk() */
#define BIT_PWRBIT_OW_EN		BIT_WMAC_TCRPWRMGT_HWDATA_EN_8814B

/*
 * BB Register definition
 */
#define rPMAC_Reset			0x100	/* hal_mp.c */

#define	rFPGA0_RFMOD			0x800
#define rFPGA0_TxInfo			0x804
#define rOFDMCCKEN_Jaguar		0x808	/* hal_mp.c */
#define rFPGA0_TxGainStage		0x80C	/* phydm only */
#define rFPGA0_XA_HSSIParameter1	0x820	/* hal_mp.c */
#define rFPGA0_XA_HSSIParameter2	0x824	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter1	0x828	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter2	0x82C	/* hal_mp.c */
#define rTxAGC_B_Rate18_06		0x830
#define rTxAGC_B_Rate54_24		0x834
#define rTxAGC_B_CCK1_55_Mcs32		0x838
#define rCCAonSec_Jaguar		0x838	/* hal_mp.c */
#define rTxAGC_B_Mcs03_Mcs00		0x83C
#define rTxAGC_B_Mcs07_Mcs04		0x848
#define rTxAGC_B_Mcs11_Mcs08		0x84C
#define rFPGA0_XA_RFInterfaceOE		0x860
#define rFPGA0_XB_RFInterfaceOE		0x864
#define rTxAGC_B_Mcs15_Mcs12		0x868
#define rTxAGC_B_CCK11_A_CCK2_11	0x86C
#define rFPGA0_XAB_RFInterfaceSW	0x870
#define rFPGA0_XAB_RFParameter		0x878
#define rFPGA0_AnalogParameter4		0x88C	/* hal_mp.c & phydm */
#define rFPGA0_XB_LSSIReadBack		0x8A4	/* phydm */
#define rHSSIRead_Jaguar		0x8B0	/* RF read addr (rtl8814b_phy.c) */

#define	rC_TxScale_Jaguar2		0x181C  /* Pah_C TX scaling factor (hal_mp.c) */
#define	rC_IGI_Jaguar2			0x1850	/* Initial Gain for path-C (hal_mp.c) */

#define rFPGA1_TxInfo			0x90C	/* hal_mp.c */
#define rSingleTone_ContTx_Jaguar	0x914	/* hal_mp.c */
/* TX BeamForming */
#define REG_BB_TX_PATH_SEL_1_8814B	0x93C	/* rtl8814b_phy.c */
#define REG_BB_TX_PATH_SEL_2_8814B	0x940	/* rtl8814b_phy.c */

/* TX BeamForming */
#define REG_BB_TXBF_ANT_SET_BF1_8814B	0x19AC	/* rtl8814b_phy.c */
#define REG_BB_TXBF_ANT_SET_BF0_8814B	0x19B4	/* rtl8814b_phy.c */

#define rCCK0_System			0xA00
#define rCCK0_AFESetting		0xA04

#define rCCK0_DSPParameter2		0xA1C
#define rCCK0_TxFilter1			0xA20
#define rCCK0_TxFilter2			0xA24
#define rCCK0_DebugPort			0xA28
#define rCCK0_FalseAlarmReport		0xA2C

#define	rD_TxScale_Jaguar2		0x1A1C  /* Path_D TX scaling factor (hal_mp.c) */
#define	rD_IGI_Jaguar2			0x1A50	/* Initial Gain for path-D (hal_mp.c) */

#define rOFDM0_TRxPathEnable		0xC04
#define rOFDM0_TRMuxPar			0xC08
#define rA_TxScale_Jaguar		0xC1C	/* Pah_A TX scaling factor (hal_mp.c) */
#define rOFDM0_RxDetector1		0xC30	/* rtw_mp.c */
#define rOFDM0_ECCAThreshold		0xC4C	/* phydm only */
#define rOFDM0_XAAGCCore1		0xC50	/* phydm only */
#define rA_IGI_Jaguar			0xC50	/* Initial Gain for path-A (hal_mp.c) */
#define rOFDM0_XBAGCCore1		0xC58	/* phydm only */
#define rOFDM0_XATxIQImbalance		0xC80	/* phydm only */
#define rA_LSSIWrite_Jaguar		0xC90	/* RF write addr, LSSI Parameter (rtl8814b_phy.c) */

#define rOFDM1_LSTF			0xD00
#define rOFDM1_TRxPathEnable		0xD04	/* hal_mp.c */
#define rA_PIRead_Jaguar		0xD04	/* RF readback with PI (rtl8814b_phy.c) */
#define rA_SIRead_Jaguar		0xD08	/* RF readback with SI (rtl8814b_phy.c) */
#define rB_PIRead_Jaguar		0xD44	/* RF readback with PI (rtl8814b_phy.c) */
#define rB_SIRead_Jaguar		0xD48	/* RF readback with SI (rtl8814b_phy.c) */

#define rTxAGC_A_Rate18_06		0xE00
#define rTxAGC_A_Rate54_24		0xE04
#define rTxAGC_A_CCK1_Mcs32		0xE08
#define rTxAGC_A_Mcs03_Mcs00		0xE10
#define rTxAGC_A_Mcs07_Mcs04		0xE14
#define rTxAGC_A_Mcs11_Mcs08		0xE18
#define rTxAGC_A_Mcs15_Mcs12		0xE1C
#define rB_TxScale_Jaguar		0xE1C	/* Path_B TX scaling factor (hal_mp.c) */
#define rB_IGI_Jaguar			0xE50	/* Initial Gain for path-B (hal_mp.c) */
#define rB_LSSIWrite_Jaguar		0xE90	/* RF write addr, LSSI Parameter (rtl8814b_phy.c) */
/* RFE */
#define rA_RFE_Pinmux_Jaguar	0xCB0	/* hal_mp.c */
#define	rB_RFE_Pinmux_Jaguar	0xEB0	/* Path_B RFE control pinmux */
#define	rA_RFE_Inv_Jaguar		0xCB4	/* Path_A RFE cotrol */  
#define	rB_RFE_Inv_Jaguar		0xEB4	/* Path_B RFE control */
#define	rA_RFE_Jaguar			0xCB8 	/* Path_A RFE cotrol */  
#define	rB_RFE_Jaguar			0xEB8	/* Path_B RFE control */
#define	rA_RFE_Inverse_Jaguar	0xCBC	/* Path_A RFE control inverse */
#define	rB_RFE_Inverse_Jaguar	0xEBC	/* Path_B RFE control inverse */
#define	r_ANTSEL_SW_Jaguar		0x900	/* ANTSEL SW Control */
#define	bMask_RFEInv_Jaguar	0x3FF00000
#define	bMask_AntselPathFollow_Jaguar 0x00030000

#define		rC_RFE_Pinmux_Jaguar	0x18B4	/* Path_C RFE cotrol pinmux*/
#define		rD_RFE_Pinmux_Jaguar	0x1AB4	/* Path_D RFE cotrol pinmux*/
#define		rA_RFE_Sel_Jaguar2		0x1990

/* Page1(0x100) */
#define bBBResetB			0x100

/* Page8(0x800) */
#define bCCKEn				0x1000000
#define bOFDMEn				0x2000000
/* Reg 0x80C rFPGA0_TxGainStage */
#define bXBTxAGC			0xF00
#define bXCTxAGC			0xF000
#define bXDTxAGC			0xF0000

/* PageA(0xA00) */
#define bCCKBBMode			0x3

#define bCCKScramble			0x8
#define bCCKTxRate			0x3000

/* General */
#define bMaskByte0		0xFF		/* mp, rtw_odm.c & phydm */
#define bMaskByte1		0xFF00		/* hal_mp.c & phydm */
#define bMaskByte2		0xFF0000	/* hal_mp.c & phydm */
#define bMaskByte3		0xFF000000	/* hal_mp.c & phydm */
#define bMaskHWord		0xFFFF0000	/* hal_com.c, rtw_mp.c */
#define bMaskLWord		0x0000FFFF	/* mp, hal_com.c & phydm */
#define bMaskDWord		0xFFFFFFFF	/* mp, hal, rtw_odm.c & phydm */

#define bEnable			0x1		/* hal_mp.c, rtw_mp.c */
#define bDisable		0x0		/* rtw_mp.c */

#define MAX_STALL_TIME		50		/* unit: us, hal_com_phycfg.c */

#define Rx_Smooth_Factor	20		/* phydm only */

/*
 * RF Register definition
 */
#define RF_AC			0x00
#define RF_AC_Jaguar		0x00	/* hal_mp.c */
#define RF_CHNLBW		0x18	/* rtl8814b_phy.c */
#define RF_ModeTableAddr	0x30	/* rtl8814b_phy.c */
#define RF_ModeTableData0	0x31	/* rtl8814b_phy.c */
#define RF_ModeTableData1	0x32	/* rtl8814b_phy.c */
#define RF_0x52			0x52
#define RF_WeLut_Jaguar		0xEF	/* rtl8814b_phy.c */

/* General Functions */
void rtl8814b_init_hal_spec(PADAPTER);				/* hal/hal_com.c */

#ifdef CONFIG_MP_INCLUDED
/* MP Functions */
#include <rtw_mp.h>		/* struct mp_priv */
void rtl8814b_prepare_mp_txdesc(PADAPTER, struct mp_priv *);	/* rtw_mp.c */
void rtl8814b_mp_config_rfpath(PADAPTER);			/* hal_mp.c */
#endif
void hw_var_set_dl_rsvd_page(PADAPTER adapter, u8 mstatus);

#ifdef CONFIG_USB_HCI
#include <rtl8814bu_hal.h>
#elif defined(CONFIG_PCI_HCI)
#include <rtl8814be_hal.h>
#endif

#endif /* _RTL8814B_HAL_H_ */
                                                                                                                                                                                                                                                                              rtl8822bu/src/include/hal_ic_cfg.h                                                                  0000644 0001750 0001750 00000035361 14214766567 015643  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_IC_CFG_H__
#define __HAL_IC_CFG_H__

#define RTL8188E_SUPPORT				0
#define RTL8812A_SUPPORT				0
#define RTL8821A_SUPPORT				0
#define RTL8723B_SUPPORT				0
#define RTL8723D_SUPPORT				0
#define RTL8192E_SUPPORT				0
#define RTL8192F_SUPPORT				0
#define RTL8814A_SUPPORT				0
#define RTL8195A_SUPPORT				0
#define RTL8197F_SUPPORT				0
#define RTL8703B_SUPPORT				0
#define RTL8188F_SUPPORT				0
#define RTL8822B_SUPPORT				0
#define RTL8821B_SUPPORT				0
#define RTL8821C_SUPPORT				0
#define RTL8710B_SUPPORT				0
#define RTL8814B_SUPPORT				0
#define RTL8824B_SUPPORT				0
#define RTL8198F_SUPPORT				0
#define RTL8195B_SUPPORT				0
#define RTL8822C_SUPPORT				0
#define RTL8721D_SUPPORT				0
#define RTL8812F_SUPPORT				0
#define RTL8197G_SUPPORT				0
#define RTL8710C_SUPPORT				0


/*#if (RTL8188E_SUPPORT==1)*/
#define RATE_ADAPTIVE_SUPPORT			0
#define POWER_TRAINING_ACTIVE			0

#ifdef CONFIG_MULTIDRV
#endif

#ifdef CONFIG_RTL8188E
	#undef RTL8188E_SUPPORT
	#undef RATE_ADAPTIVE_SUPPORT
	#undef POWER_TRAINING_ACTIVE

	#define RTL8188E_SUPPORT				1
	#define RATE_ADAPTIVE_SUPPORT			1
	#define POWER_TRAINING_ACTIVE			1

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8812A
	#undef RTL8812A_SUPPORT
	#define RTL8812A_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifdef CONFIG_BEAMFORMING
		#define CONFIG_BEAMFORMER_FW_NDPA
		#define BEAMFORMING_SUPPORT		1	/*for phydm beamforming*/
		#define SUPPORT_MU_BF				0
	#endif /*CONFIG_BEAMFORMING*/
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8821A
	#undef RTL8821A_SUPPORT
	#define RTL8821A_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifdef CONFIG_BEAMFORMING
		#define CONFIG_BEAMFORMER_FW_NDPA
		#define BEAMFORMING_SUPPORT		1	/*for phydm beamforming*/
		#define SUPPORT_MU_BF				0
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8192E
	#undef RTL8192E_SUPPORT
	#define RTL8192E_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8192F
	#undef RTL8192F_SUPPORT
	#define RTL8192F_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif
	/*#define CONFIG_AMPDU_PRETX_CD*/
	/*#define DBG_LA_MODE*/
	#ifdef CONFIG_P2P_PS
		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	#endif
	#define CONFIG_RTS_FULL_BW
/*	#define CONFIG_NARROWBAND_SUPPORTING	*/
	#ifdef CONFIG_NARROWBAND_SUPPORTING
		#define CONFIG_NB_VALUE		RTW_NB_CONFIG_NONE	/*RTW_NB_CONFIG_WIDTH_10 or RTW_NB_CONFIG_WIDTH_5	*/
	#endif
	#ifdef CONFIG_WOWLAN
		#define CONFIG_WOW_PATTERN_IN_TXFIFO
	#endif

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8723B
	#undef RTL8723B_SUPPORT
	#define RTL8723B_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8723D
	#undef RTL8723D_SUPPORT
	#define RTL8723D_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif
	#ifndef CONFIG_RTW_CUSTOMER_STR
		#define CONFIG_RTW_CUSTOMER_STR
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8814A
	#undef RTL8814A_SUPPORT
	#define RTL8814A_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#define CONFIG_FW_CORRECT_BCN
	#ifdef CONFIG_BEAMFORMING
		#define BEAMFORMING_SUPPORT		1	/*for phydm beamforming*/
		#define SUPPORT_MU_BF				0
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8703B
	#undef RTL8703B_SUPPORT
	#define RTL8703B_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8188F
	#undef RTL8188F_SUPPORT
	#define RTL8188F_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif
	#ifndef CONFIG_RTW_CUSTOMER_STR
		#define CONFIG_RTW_CUSTOMER_STR
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8188GTV
	#undef RTL8188F_SUPPORT
	#define RTL8188F_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif
	#ifndef CONFIG_RTW_CUSTOMER_STR
		#define CONFIG_RTW_CUSTOMER_STR
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8822B
	#undef RTL8822B_SUPPORT
	#define RTL8822B_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif /* CONFIG_FW_C2H_PKT */
	#define RTW_TX_PA_BIAS	/* Adjust TX PA Bias from eFuse */
	#define RTW_AMPDU_AGG_RETRY_AND_NEW

	#ifdef CONFIG_WOWLAN
		#define CONFIG_GTK_OL
		/*#define CONFIG_ARP_KEEP_ALIVE*/

		#ifdef CONFIG_GPIO_WAKEUP
			#ifndef WAKEUP_GPIO_IDX
				#define WAKEUP_GPIO_IDX	6	/* WIFI Chip Side */
			#endif /* !WAKEUP_GPIO_IDX */
		#endif /* CONFIG_GPIO_WAKEUP */
	#endif /* CONFIG_WOWLAN */

	#ifdef CONFIG_CONCURRENT_MODE
		#define CONFIG_AP_PORT_SWAP
		#define CONFIG_FW_MULTI_PORT_SUPPORT
	#endif /* CONFIG_CONCURRENT_MODE */

	/*
	 * Beamforming related definition
	 */
	/* Only support new beamforming mechanism */
	#ifdef CONFIG_BEAMFORMING
		#define RTW_BEAMFORMING_VERSION_2
	#endif /* CONFIG_BEAMFORMING */

	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif /* CONFIG_RTW_MAC_HIDDEN_RPT */

	#ifndef DBG_RX_DFRAME_RAW_DATA
		#define DBG_RX_DFRAME_RAW_DATA
	#endif /* DBG_RX_DFRAME_RAW_DATA */

	#ifndef RTW_IQK_FW_OFFLOAD
		#define RTW_IQK_FW_OFFLOAD
	#endif /* RTW_IQK_FW_OFFLOAD */

	/* Checksum offload feature */
	/*#define CONFIG_TCP_CSUM_OFFLOAD_TX*/
	#if defined(CONFIG_TCP_CSUM_OFFLOAD_TX) && !defined(CONFIG_RTW_NETIF_SG)
		#define CONFIG_RTW_NETIF_SG
	#endif
	#define CONFIG_TCP_CSUM_OFFLOAD_RX

	#define CONFIG_ADVANCE_OTA

	#ifdef CONFIG_MCC_MODE
		#define CONFIG_MCC_MODE_V2
		#define CONFIG_MCC_PHYDM_OFFLOAD
	#endif /* CONFIG_MCC_MODE */

	#if defined(CONFIG_TDLS) && defined(CONFIG_TDLS_CH_SW)
		#define CONFIG_TDLS_CH_SW_V2
	#endif

	#ifndef RTW_CHANNEL_SWITCH_OFFLOAD
		#ifdef CONFIG_TDLS_CH_SW_V2
			#define RTW_CHANNEL_SWITCH_OFFLOAD
		#endif
	#endif /* RTW_CHANNEL_SWITCH_OFFLOAD */

	#if defined(CONFIG_RTW_MESH) && !defined(RTW_PER_CMD_SUPPORT_FW)
		/* Supported since fw v22.1 */
		#define RTW_PER_CMD_SUPPORT_FW
	#endif /* RTW_PER_CMD_SUPPORT_FW */
	#define CONFIG_SUPPORT_FIFO_DUMP
	#define CONFIG_HW_P0_TSF_SYNC
	#define CONFIG_BCN_RECV_TIME
	#ifdef CONFIG_P2P_PS
		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifdef CONFIG_LPS
		#define CONFIG_LPS_ACK	/* Supported after FW v30 & v27.9 */
	#endif

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif /* CONFIG_RTL8822B */

#ifdef CONFIG_RTL8822C
	#undef RTL8822C_SUPPORT
	#define RTL8822C_SUPPORT				1
	/*#define DBG_LA_MODE*/
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif /* CONFIG_FW_C2H_PKT */
	#define RTW_TX_PA_BIAS	/* Adjust TX PA Bias from eFuse */

	#ifdef CONFIG_WOWLAN
		#define CONFIG_GTK_OL
		/*#define CONFIG_ARP_KEEP_ALIVE*/

		#ifdef CONFIG_GPIO_WAKEUP
			#ifndef WAKEUP_GPIO_IDX
				#define WAKEUP_GPIO_IDX	6	/* WIFI Chip Side */
			#endif /* !WAKEUP_GPIO_IDX */
		#endif /* CONFIG_GPIO_WAKEUP */
	#endif /* CONFIG_WOWLAN */

	#ifdef CONFIG_CONCURRENT_MODE
		#define CONFIG_AP_PORT_SWAP
		#define CONFIG_FW_MULTI_PORT_SUPPORT
	#endif /* CONFIG_CONCURRENT_MODE */

	/*
	 * Beamforming related definition
	 */
	/* Only support new beamforming mechanism */
	#ifdef CONFIG_BEAMFORMING
		#define RTW_BEAMFORMING_VERSION_2
	#endif /* CONFIG_BEAMFORMING */

	#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
		#define CONFIG_RTW_MAC_HIDDEN_RPT
	#endif /* CONFIG_RTW_MAC_HIDDEN_RPT */

	#ifndef DBG_RX_DFRAME_RAW_DATA
		#define DBG_RX_DFRAME_RAW_DATA
	#endif /* DBG_RX_DFRAME_RAW_DATA */

	#ifndef RTW_IQK_FW_OFFLOAD
		/* #define RTW_IQK_FW_OFFLOAD */
	#endif /* RTW_IQK_FW_OFFLOAD */
	#define CONFIG_ADVANCE_OTA

	#ifdef CONFIG_MCC_MODE
		#define CONFIG_MCC_MODE_V2
	#endif /* CONFIG_MCC_MODE */

	#if defined(CONFIG_TDLS) && defined(CONFIG_TDLS_CH_SW)
		#define CONFIG_TDLS_CH_SW_V2
	#endif

	#ifndef RTW_CHANNEL_SWITCH_OFFLOAD
		#ifdef CONFIG_TDLS_CH_SW_V2
			#define RTW_CHANNEL_SWITCH_OFFLOAD
		#endif
	#endif /* RTW_CHANNEL_SWITCH_OFFLOAD */

	#if defined(CONFIG_RTW_MESH) && !defined(RTW_PER_CMD_SUPPORT_FW)
		/* Supported since fw v22.1 */
		#define RTW_PER_CMD_SUPPORT_FW
	#endif /* RTW_PER_CMD_SUPPORT_FW */
	#define CONFIG_SUPPORT_FIFO_DUMP
	#define CONFIG_HW_P0_TSF_SYNC
	#define CONFIG_BCN_RECV_TIME

	/*#define CONFIG_TCP_CSUM_OFFLOAD_TX*/
	#if defined(CONFIG_TCP_CSUM_OFFLOAD_TX) && !defined(CONFIG_RTW_NETIF_SG)
		#define CONFIG_RTW_NETIF_SG
	#endif
	#define CONFIG_TCP_CSUM_OFFLOAD_RX

	#ifdef CONFIG_P2P_PS
		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	#endif
	#define CONFIG_RTS_FULL_BW
	
	#ifdef CONFIG_LPS
		#define CONFIG_LPS_ACK	/* Supported after FW v07 */
		#define CONFIG_LPS_1T1R /* Supported after FW v07 */
	#endif

	#define CONFIG_BT_EFUSE_MASK

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
	#ifndef CONFIG_TXPWR_PG_WITH_TSSI_OFFSET
	#define CONFIG_TXPWR_PG_WITH_TSSI_OFFSET
	#endif
#endif /* CONFIG_RTL8822C */

#ifdef CONFIG_RTL8821C
	#undef RTL8821C_SUPPORT
	#define RTL8821C_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#ifdef CONFIG_NO_FW
		#ifdef CONFIG_RTW_MAC_HIDDEN_RPT
			#undef CONFIG_RTW_MAC_HIDDEN_RPT
		#endif
	#else
		#ifndef CONFIG_RTW_MAC_HIDDEN_RPT
			#define CONFIG_RTW_MAC_HIDDEN_RPT
		#endif
	#endif
	#define LOAD_FW_HEADER_FROM_DRIVER
	#define CONFIG_PHY_CAPABILITY_QUERY
	#ifdef CONFIG_CONCURRENT_MODE
	#define CONFIG_AP_PORT_SWAP
	#define CONFIG_FW_MULTI_PORT_SUPPORT
	#endif
	#define CONFIG_SUPPORT_FIFO_DUMP
	#ifndef RTW_IQK_FW_OFFLOAD
		#define RTW_IQK_FW_OFFLOAD
	#endif /* RTW_IQK_FW_OFFLOAD */
	/*#define CONFIG_AMPDU_PRETX_CD*/
	/*#define DBG_PRE_TX_HANG*/

	/* Beamforming related definition */
	/* Only support new beamforming mechanism */
	#ifdef CONFIG_BEAMFORMING
		#define RTW_BEAMFORMING_VERSION_2
	#endif /* CONFIG_BEAMFORMING */
	#define CONFIG_HW_P0_TSF_SYNC
	#define CONFIG_BCN_RECV_TIME
	#ifdef CONFIG_P2P_PS
		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifdef CONFIG_LPS
		/* #define CONFIG_LPS_ACK */	/* Supported after FW v25 */
	#endif

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif /*CONFIG_RTL8821C*/

#ifdef CONFIG_RTL8710B
	#undef RTL8710B_SUPPORT
	#define RTL8710B_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif
	#define CONFIG_RTS_FULL_BW

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
#endif

#ifdef CONFIG_RTL8814B
	#undef RTL8814B_SUPPORT
	#define RTL8814B_SUPPORT				1
	#ifndef CONFIG_FW_C2H_PKT
		#define CONFIG_FW_C2H_PKT
	#endif /* CONFIG_FW_C2H_PKT */
	#define RTW_TX_PA_BIAS	/* Adjust TX PA Bias from eFuse */
	#define RTW_AMPDU_AGG_RETRY_AND_NEW

	#ifdef CONFIG_WOWLAN
		#define CONFIG_GTK_OL
		/*#define CONFIG_ARP_KEEP_ALIVE*/

		#ifdef CONFIG_GPIO_WAKEUP
			#ifndef WAKEUP_GPIO_IDX
				#define WAKEUP_GPIO_IDX	6	/* WIFI Chip Side */
			#endif /* !WAKEUP_GPIO_IDX */
		#endif /* CONFIG_GPIO_WAKEUP */
	#endif /* CONFIG_WOWLAN */

	#ifdef CONFIG_CONCURRENT_MODE
		/*#define CONFIG_AP_PORT_SWAP*/
		#define CONFIG_FW_MULTI_PORT_SUPPORT
		#define CONFIG_SUPPORT_AP_PORT1
	#endif /* CONFIG_CONCURRENT_MODE */

	/*
	 * Beamforming related definition
	 */
	/* Only support new beamforming mechanism */
	#ifdef CONFIG_BEAMFORMING
		#define RTW_BEAMFORMING_VERSION_2
	#endif /* CONFIG_BEAMFORMING */

	#ifndef DBG_RX_DFRAME_RAW_DATA
		#define DBG_RX_DFRAME_RAW_DATA
	#endif /* DBG_RX_DFRAME_RAW_DATA */

	#ifndef RTW_IQK_FW_OFFLOAD
		#define RTW_IQK_FW_OFFLOAD
	#endif /* RTW_IQK_FW_OFFLOAD */

	/* Checksum offload feature */
	/*#define CONFIG_TCP_CSUM_OFFLOAD_TX*/ /* not ready */
	#define CONFIG_TCP_CSUM_OFFLOAD_RX

	#define CONFIG_ADVANCE_OTA

	#ifdef CONFIG_MCC_MODE
		#define CONFIG_MCC_MODE_V2
		#define CONFIG_MCC_PHYDM_OFFLOAD
	#endif /* CONFIG_MCC_MODE */

	#if defined(CONFIG_TDLS) && defined(CONFIG_TDLS_CH_SW)
		#define CONFIG_TDLS_CH_SW_V2
	#endif

	#ifndef RTW_CHANNEL_SWITCH_OFFLOAD
		#ifdef CONFIG_TDLS_CH_SW_V2
			#define RTW_CHANNEL_SWITCH_OFFLOAD
		#endif
	#endif /* RTW_CHANNEL_SWITCH_OFFLOAD */

	#if defined(CONFIG_RTW_MESH) && !defined(RTW_PER_CMD_SUPPORT_FW)
		/* Supported since fw v22.1 */
		#define RTW_PER_CMD_SUPPORT_FW
	#endif /* RTW_PER_CMD_SUPPORT_FW */
	#define CONFIG_SUPPORT_FIFO_DUMP
	#define CONFIG_HW_P0_TSF_SYNC
	#define CONFIG_BCN_RECV_TIME
	#ifdef CONFIG_P2P_PS
		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
	#endif
	#define CONFIG_RTS_FULL_BW

	#define CONFIG_PROTSEL_PORT
	#define CONFIG_PROTSEL_ATIMDTIM
	#define CONFIG_PROTSEL_MACSLEEP

	#define CONFIG_HAS_HW_VAR_BCN_CTRL_ADDR
	#define CONFIG_HAS_HW_VAR_BCN_FUNC
	#define CONFIG_HAS_HW_VAR_MLME_DISCONNECT
	#define CONFIG_HAS_HW_VAR_MLME_JOIN
	#define CONFIG_HAS_HW_VAR_CORRECT_TSF
	#define CONFIG_HAS_TX_BEACON_PAUSE

	#define CONFIG_RTW_TX_NPATH_EN		/* 8814B is always 4TX */

	#ifdef CONFIG_LPS
		/* #define CONFIG_LPS_ACK */	/* Supported after FW v04 */
	#endif

	#ifndef CONFIG_TXPWR_PG_WITH_PWR_IDX
	#define CONFIG_TXPWR_PG_WITH_PWR_IDX
	#endif
	#ifndef CONFIG_TXPWR_PG_WITH_TSSI_OFFSET
	#define CONFIG_TXPWR_PG_WITH_TSSI_OFFSET
	#endif
#endif /* CONFIG_RTL8814B */

#endif /*__HAL_IC_CFG_H__*/
                                                                                                                                                                                                                                                                               rtl8822bu/src/include/rtl8723b_cmd.h                                                                0000644 0001750 0001750 00000027112 14214766567 015712  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_CMD_H__
#define __RTL8723B_CMD_H__

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

enum h2c_cmd_8723B {
	/* Common Class: 000 */
	H2C_8723B_RSVD_PAGE = 0x00,
	H2C_8723B_MEDIA_STATUS_RPT = 0x01,
	H2C_8723B_SCAN_ENABLE = 0x02,
	H2C_8723B_KEEP_ALIVE = 0x03,
	H2C_8723B_DISCON_DECISION = 0x04,
	H2C_8723B_PSD_OFFLOAD = 0x05,
	H2C_8723B_AP_OFFLOAD = 0x08,
	H2C_8723B_BCN_RSVDPAGE = 0x09,
	H2C_8723B_PROBERSP_RSVDPAGE = 0x0A,
	H2C_8723B_FCS_RSVDPAGE = 0x10,
	H2C_8723B_FCS_INFO = 0x11,
	H2C_8723B_AP_WOW_GPIO_CTRL = 0x13,

	/* PoweSave Class: 001 */
	H2C_8723B_SET_PWR_MODE = 0x20,
	H2C_8723B_PS_TUNING_PARA = 0x21,
	H2C_8723B_PS_TUNING_PARA2 = 0x22,
	H2C_8723B_P2P_LPS_PARAM = 0x23,
	H2C_8723B_P2P_PS_OFFLOAD = 0x24,
	H2C_8723B_PS_SCAN_ENABLE = 0x25,
	H2C_8723B_SAP_PS_ = 0x26,
	H2C_8723B_INACTIVE_PS_ = 0x27, /* Inactive_PS */
	H2C_8723B_FWLPS_IN_IPS_ = 0x28,

	/* Dynamic Mechanism Class: 010 */
	H2C_8723B_MACID_CFG = 0x40,
	H2C_8723B_TXBF = 0x41,
	H2C_8723B_RSSI_SETTING = 0x42,
	H2C_8723B_AP_REQ_TXRPT = 0x43,
	H2C_8723B_INIT_RATE_COLLECT = 0x44,
	H2C_8723B_RA_PARA_ADJUST = 0x46,

	/* BT Class: 011 */
	H2C_8723B_B_TYPE_TDMA = 0x60,
	H2C_8723B_BT_INFO = 0x61,
	H2C_8723B_FORCE_BT_TXPWR = 0x62,
	H2C_8723B_BT_IGNORE_WLANACT = 0x63,
	H2C_8723B_DAC_SWING_VALUE = 0x64,
	H2C_8723B_ANT_SEL_RSV = 0x65,
	H2C_8723B_WL_OPMODE = 0x66,
	H2C_8723B_BT_MP_OPER = 0x67,
	H2C_8723B_BT_CONTROL = 0x68,
	H2C_8723B_BT_WIFI_CTRL = 0x69,
	H2C_8723B_BT_FW_PATCH = 0x6A,
	H2C_8723B_BT_WLAN_CALIBRATION = 0x6D,

	/* WOWLAN Class: 100 */
	H2C_8723B_WOWLAN = 0x80,
	H2C_8723B_REMOTE_WAKE_CTRL = 0x81,
	H2C_8723B_AOAC_GLOBAL_INFO = 0x82,
	H2C_8723B_AOAC_RSVD_PAGE = 0x83,
	H2C_8723B_AOAC_RSVD_PAGE2 = 0x84,
	H2C_8723B_D0_SCAN_OFFLOAD_CTRL = 0x85,
	H2C_8723B_D0_SCAN_OFFLOAD_INFO = 0x86,
	H2C_8723B_CHNL_SWITCH_OFFLOAD = 0x87,
	H2C_8723B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
	H2C_8723B_P2P_OFFLOAD = 0x8B,

	H2C_8723B_RESET_TSF = 0xC0,
	H2C_8723B_MAXID,
};

/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
 * ---------------------------------------------------------------------------------------------------------
 * _RSVDPAGE_LOC_CMD_0x00 */
#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
#define SET_8723B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8723B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8723B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

/* _KEEP_ALIVE_CMD_0x03 */
#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8723B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
#define SET_8723B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _DISCONNECT_DECISION_CMD_0x04 */
#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
#define SET_8723B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8723B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)

/* _PWR_MOD_CMD_0x20 */
#define SET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
#define SET_8723B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
#define SET_8723B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8723B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8723B_H2CCMD_PWRMODE_PARM_BCN_EARLY_C2H_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 2, 1, __Value)
#define SET_8723B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)

#define GET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)

/* _PS_TUNE_PARAM_CMD_0x21 */
#define SET_8723B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8723B_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
#define SET_8723B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
#define SET_8723B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _MACID_CFG_CMD_0x40 */
#define SET_8723B_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)

/* _RSSI_SETTING_CMD_0x42 */
#define SET_8723B_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723B_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
#define SET_8723B_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)

/* _AP_REQ_TXRPT_CMD_0x43 */
#define SET_8723B_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
#define SET_8723B_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)

/* _FORCE_BT_TXPWR_CMD_0x62 */
#define SET_8723B_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)

/* _FORCE_BT_MP_OPER_CMD_0x67 */
#define SET_8723B_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
#define SET_8723B_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
#define SET_8723B_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
#define SET_8723B_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
#define SET_8723B_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
#define SET_8723B_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)

/* _BT_FW_PATCH_0x6A */
#define SET_8723B_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((u8 *)(__pH2CCmd), 0, 16, __Value)
#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)

/* ---------------------------------------------------------------------------------------------------------
 * -------------------------------------------    Structure    --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------------------------------------
 * ----------------------------------    Function Statement     --------------------------------------------------
 * --------------------------------------------------------------------------------------------------------- */

/* host message to firmware cmd */
void rtl8723b_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
void rtl8723b_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
void rtl8723b_fw_try_ap_cmd(PADAPTER padapter, u32 need_ack);
/* s32 rtl8723b_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable); */
void rtl8723b_set_FwPsTuneParam_cmd(PADAPTER padapter);
void rtl8723b_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
void rtl8723b_download_rsvd_page(PADAPTER padapter, u8 mstatus);
#ifdef CONFIG_BT_COEXIST
	void rtl8723b_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
#endif /* CONFIG_BT_COEXIST */
#ifdef CONFIG_P2P
	void rtl8723b_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
#endif /* CONFIG_P2P */

#ifdef CONFIG_TDLS
	#ifdef CONFIG_TDLS_CH_SW
		void rtl8723b_set_BcnEarly_C2H_Rpt_cmd(PADAPTER padapter, u8 enable);
	#endif
#endif

#ifdef CONFIG_P2P_WOWLAN
	void rtl8723b_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
#endif

void rtl8723b_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);

s32 FillH2CCmd8723B(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
u8 GetTxBufferRsvdPageNum8723B(_adapter *padapter, bool wowlan);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                      rtl8822bu/src/include/usb_ops_linux.h                                                               0000644 0001750 0001750 00000011104 14214766567 016463  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __USB_OPS_LINUX_H__
#define __USB_OPS_LINUX_H__

#define VENDOR_CMD_MAX_DATA_LEN	254
#define FW_START_ADDRESS	0x1000

#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10/* ms */
#define RTW_USB_CONTROL_MSG_TIMEOUT	500/* ms */

#define RECV_BULK_IN_ADDR		0x80/* assign by drv, not real address */
#define RECV_INT_IN_ADDR		0x81/* assign by drv, not real address */

#define INTERRUPT_MSG_FORMAT_LEN 60

#if defined(CONFIG_VENDOR_REQ_RETRY) && defined(CONFIG_USB_VENDOR_REQ_MUTEX)
	/* vendor req retry should be in the situation when each vendor req is atomically submitted from others */
	#define MAX_USBCTRL_VENDORREQ_TIMES	10
#else
	#define MAX_USBCTRL_VENDORREQ_TIMES	1
#endif

#define RTW_USB_BULKOUT_TIMEOUT	5000/* ms */

#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
#define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
#define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
#define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
#define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
#define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
#define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 12))
#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms))
#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), (timeout_ms))
#else
#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), \
		((timeout_ms) == 0) || ((timeout_ms) * HZ / 1000 > 0) ? ((timeout_ms) * HZ / 1000) : 1)
#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), \
		((timeout_ms) == 0) || ((timeout_ms) * HZ / 1000 > 0) ? ((timeout_ms) * HZ / 1000) : 1)
#endif


#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
int usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
int usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
int usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */

unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr);

void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);

void usb_read_port_cancel(struct intf_hdl *pintfhdl);

u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
void usb_write_port_cancel(struct intf_hdl *pintfhdl);

int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,
		u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */

u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr);
u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr);
u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr);
int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
void usb_recv_tasklet(void *priv);

#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs);
u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr);
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                            rtl8822bu/src/include/rtl8192e_hal.h                                                                0000644 0001750 0001750 00000031645 14214766567 015724  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_HAL_H__
#define __RTL8192E_HAL_H__

/* #include "hal_com.h" */

#include "hal_data.h"

/* include HAL Related header after HAL Related compiling flags */
#include "rtl8192e_spec.h"
#include "rtl8192e_rf.h"
#include "rtl8192e_dm.h"
#include "rtl8192e_recv.h"
#include "rtl8192e_xmit.h"
#include "rtl8192e_cmd.h"
#include "rtl8192e_led.h"
#include "Hal8192EPwrSeq.h"
#include "Hal8192EPhyReg.h"
#include "Hal8192EPhyCfg.h"


#ifdef DBG_CONFIG_ERROR_DETECT
	#include "rtl8192e_sreset.h"
#endif

/* ---------------------------------------------------------------------
 *		RTL8192E Power Configuration CMDs for PCIe interface
 * --------------------------------------------------------------------- */
#define Rtl8192E_NIC_PWR_ON_FLOW				rtl8192E_power_on_flow
#define Rtl8192E_NIC_RF_OFF_FLOW				rtl8192E_radio_off_flow
#define Rtl8192E_NIC_DISABLE_FLOW				rtl8192E_card_disable_flow
#define Rtl8192E_NIC_ENABLE_FLOW				rtl8192E_card_enable_flow
#define Rtl8192E_NIC_SUSPEND_FLOW				rtl8192E_suspend_flow
#define Rtl8192E_NIC_RESUME_FLOW				rtl8192E_resume_flow
#define Rtl8192E_NIC_PDN_FLOW					rtl8192E_hwpdn_flow
#define Rtl8192E_NIC_LPS_ENTER_FLOW			rtl8192E_enter_lps_flow
#define Rtl8192E_NIC_LPS_LEAVE_FLOW			rtl8192E_leave_lps_flow


#if 1 /* download firmware related data structure */
#define FW_SIZE_8192E			0x8000 /* Compatible with RTL8192e Maximal RAM code size 32k */
#define FW_START_ADDRESS		0x1000
#define FW_END_ADDRESS			0x5FFF


#define IS_FW_HEADER_EXIST_8192E(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8192E(_pFwHdr) & 0xFFF0) == 0x92E0)



typedef struct _RT_FIRMWARE_8192E {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_SIZE_8192E];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8192E, *PRT_FIRMWARE_8192E;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */

/* *****************************************************
 *					Firmware Header(8-byte alinment required)
 * *****************************************************
 * --- LONG WORD 0 ---- */
#define GET_FIRMWARE_HDR_SIGNATURE_8192E(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16) /* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
#define GET_FIRMWARE_HDR_CATEGORY_8192E(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) /* AP/NIC and USB/PCI */
#define GET_FIRMWARE_HDR_FUNCTION_8192E(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 24, 8) /* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
#define GET_FIRMWARE_HDR_VERSION_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)/* FW Version */
#define GET_FIRMWARE_HDR_SUB_VER_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) /* FW Subversion, default 0x00 */
#define GET_FIRMWARE_HDR_RSVD1_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8)

/* --- LONG WORD 1 ---- */
#define GET_FIRMWARE_HDR_MONTH_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 8) /* Release time Month field */
#define GET_FIRMWARE_HDR_DATE_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 8, 8) /* Release time Date field */
#define GET_FIRMWARE_HDR_HOUR_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 16, 8)/* Release time Hour field */
#define GET_FIRMWARE_HDR_MINUTE_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 24, 8)/* Release time Minute field */
#define GET_FIRMWARE_HDR_ROMCODE_SIZE_8192E(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+12, 0, 16)/* The size of RAM code */
#define GET_FIRMWARE_HDR_RSVD2_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 16, 16)

/* --- LONG WORD 2 ---- */
#define GET_FIRMWARE_HDR_SVN_IDX_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+16, 0, 32)/* The SVN entry index */
#define GET_FIRMWARE_HDR_RSVD3_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 0, 32)

/* --- LONG WORD 3 ---- */
#define GET_FIRMWARE_HDR_RSVD4_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 0, 32)
#define GET_FIRMWARE_HDR_RSVD5_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)

#endif /* download firmware related data structure */

#define DRIVER_EARLY_INT_TIME_8192E		0x05
#define BCN_DMA_ATIME_INT_TIME_8192E		0x02
#define RX_DMA_SIZE_8192E					0x4000	/* 16K*/

#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8192E	0x100	/* 256B, reserved for c2h debug message*/
#else
	#define RX_DMA_RESERVED_SIZE_8192E	0x40	/* 64B, reserved for c2h event(16bytes) or ccx(8 Bytes)*/
#endif
#define MAX_RX_DMA_BUFFER_SIZE_8192E		(RX_DMA_SIZE_8192E-RX_DMA_RESERVED_SIZE_8192E)	/*RX 16K*/


#define PAGE_SIZE_TX_92E	PAGE_SIZE_256

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * if (CONFIG_2BCN_EN) Beacon:4, PS-Poll:1, Null Data:1,Prob Rsp:1,Qos Null Data:1
 * Beacon: MAX_BEACON_LEN / PAGE_SIZE_TX_92E
 * PS-Poll:1, Null Data:1,Prob Rsp:1,Qos Null Data:1,CTS-2-SELF / LTE QoS Null*/

#define RSVD_PAGE_NUM_8192E		(MAX_BEACON_LEN / PAGE_SIZE_TX_92E + 6) /*0x08*/
/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt: 1,PNO: 6
 * NS offload: 2 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	#define WOWLAN_PAGE_NUM_8192E	0x0b
#else
	#define WOWLAN_PAGE_NUM_8192E	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
	#undef WOWLAN_PAGE_NUM_8192E
	#define WOWLAN_PAGE_NUM_8192E	0x0d
#endif

/* Note:
Tx FIFO Size : 64KB
Tx page Size : 256B
Total page numbers : 256(0x100)
*/

#define	TOTAL_RSVD_PAGE_NUMBER_8192E	(RSVD_PAGE_NUM_8192E + WOWLAN_PAGE_NUM_8192E)

#define	TOTAL_PAGE_NUMBER_8192E	(0x100)
#define	TX_TOTAL_PAGE_NUMBER_8192E	(TOTAL_PAGE_NUMBER_8192E - TOTAL_RSVD_PAGE_NUMBER_8192E)

#define	TX_PAGE_BOUNDARY_8192E	(TX_TOTAL_PAGE_NUMBER_8192E) /* beacon header start address */


#define RSVD_PKT_LEN_92E	(TOTAL_RSVD_PAGE_NUMBER_8192E * PAGE_SIZE_TX_92E)

#define TX_PAGE_LOAD_FW_BOUNDARY_8192E		0x47 /* 0xA5 */
#define TX_PAGE_BOUNDARY_WOWLAN_8192E		0xE0

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_92C */

#define NORMAL_PAGE_NUM_HPQ_8192E			0x10
#define NORMAL_PAGE_NUM_LPQ_8192E			0x10
#define NORMAL_PAGE_NUM_NPQ_8192E			0x10
#define NORMAL_PAGE_NUM_EPQ_8192E			0x00


/* Note: For WMM Normal Chip Setting ,modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8192E		NORMAL_PAGE_NUM_HPQ_8192E
#define WMM_NORMAL_PAGE_NUM_LPQ_8192E		NORMAL_PAGE_NUM_LPQ_8192E
#define WMM_NORMAL_PAGE_NUM_NPQ_8192E		NORMAL_PAGE_NUM_NPQ_8192E


/* -------------------------------------------------------------------------
 *	Chip specific
 * ------------------------------------------------------------------------- */

/* pic buffer descriptor */
#define RTL8192EE_SEG_NUM			TX_BUFFER_SEG_NUM
#define TX_DESC_NUM_92E			128
#define RX_DESC_NUM_92E			128

/* -------------------------------------------------------------------------
 *	Channel Plan
 * ------------------------------------------------------------------------- */

#define		HWSET_MAX_SIZE_8192E			512

#define		EFUSE_REAL_CONTENT_LEN_8192E	512

#define		EFUSE_MAP_LEN_8192E			512
#define		EFUSE_MAX_SECTION_8192E		64
#define		EFUSE_MAX_WORD_UNIT_8192E		4
#define		EFUSE_IC_ID_OFFSET_8192E		506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
#define		AVAILABLE_EFUSE_ADDR_8192E(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8192E)
/*
 * <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
 * 9bytes + 1byt + 5bytes and pre 1byte.
 * For worst case:
 * | 1byte|----8bytes----|1byte|--5bytes--|
 * |         |            Reserved(14bytes)	      |
 *   */
#define		EFUSE_OOB_PROTECT_BYTES_8192E 		15	/* PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte. */



/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define		EFUSE_BT_REAL_BANK_CONTENT_LEN_8192E	512
#define		EFUSE_BT_REAL_CONTENT_LEN_8192E			1024	/* 512*2 */
#define		EFUSE_BT_MAP_LEN_8192E					1024	/* 1k bytes */
#define		EFUSE_BT_MAX_SECTION_8192E				128		/* 1024/8 */

#define		EFUSE_PROTECT_BYTES_BANK_8192E			16
#define		EFUSE_MAX_BANK_8192E					3
/* *********************************************************** */

#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

/* #define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? _TRUE : _FALSE) */

/* #define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) ) */

/* rtl8812_hal_init.c */
void	_8051Reset8192E(PADAPTER padapter);
s32	FirmwareDownload8192E(PADAPTER Adapter, BOOLEAN bUsedWoWLANFw);
void	InitializeFirmwareVars8192E(PADAPTER padapter);

s32	InitLLTTable8192E(PADAPTER padapter, u8 txpktbuf_bndy);

/* EFuse */
u8	GetEEPROMSize8192E(PADAPTER padapter);
void	hal_InitPGData_8192E(PADAPTER padapter, u8 *PROMContent);
void	Hal_EfuseParseIDCode8192E(PADAPTER padapter, u8 *hwinfo);
void	Hal_ReadPROMVersion8192E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_ReadPowerSavingMode8192E(PADAPTER padapter, u8	*hwinfo, BOOLEAN	AutoLoadFail);
void	Hal_ReadTxPowerInfo8192E(PADAPTER padapter, u8 *hwinfo, BOOLEAN	AutoLoadFail);
void	Hal_ReadBoardType8192E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_ReadThermalMeter_8192E(PADAPTER	Adapter, u8 *PROMContent, BOOLEAN	AutoloadFail);
void	Hal_ReadChannelPlan8192E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_EfuseParseXtal_8192E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_ReadAntennaDiversity8192E(PADAPTER pAdapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
void	Hal_ReadPAType_8192E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	Hal_ReadAmplifierType_8192E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	Hal_ReadRFEType_8192E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void	Hal_EfuseParseBTCoexistInfo8192E(PADAPTER Adapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
void	Hal_EfuseParseKFreeData_8192E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);

u8 Hal_CrystalAFEAdjust(_adapter *Adapter);

BOOLEAN HalDetectPwrDownMode8192E(PADAPTER Adapter);

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

/***********************************************************/
/* RTL8192E-MAC Setting */
void _InitQueueReservedPage_8192E(PADAPTER Adapter);
void _InitQueuePriority_8192E(PADAPTER Adapter);
void _InitTxBufferBoundary_8192E(PADAPTER Adapter, u8 txpktbuf_bndy);
void _InitPageBoundary_8192E(PADAPTER Adapter);
/* void _InitTransferPageSize_8192E(PADAPTER Adapter); */
void _InitDriverInfoSize_8192E(PADAPTER Adapter, u8 drvInfoSize);
void _InitRDGSetting_8192E(PADAPTER Adapter);
void _InitID_8192E(PADAPTER Adapter);
void _InitNetworkType_8192E(PADAPTER Adapter);
void _InitWMACSetting_8192E(PADAPTER Adapter);
void _InitAdaptiveCtrl_8192E(PADAPTER Adapter);
void _InitEDCA_8192E(PADAPTER Adapter);
void _InitRetryFunction_8192E(PADAPTER Adapter);
void _BBTurnOnBlock_8192E(PADAPTER Adapter);
void _InitBeaconParameters_8192E(PADAPTER Adapter);
void _InitBeaconMaxError_8192E(
		PADAPTER	Adapter,
		BOOLEAN		InfraMode
);
void SetBeaconRelatedRegisters8192E(PADAPTER padapter);
void hal_ReadRFType_8192E(PADAPTER	Adapter);
/* RTL8192E-MAC Setting
 ***********************************************************/

u8 SetHwReg8192E(PADAPTER Adapter, u8 variable, u8 *val);
void GetHwReg8192E(PADAPTER Adapter, u8 variable, u8 *val);
u8
SetHalDefVar8192E(
		PADAPTER				Adapter,
		HAL_DEF_VARIABLE		eVariable,
		void						*pValue
);
u8
GetHalDefVar8192E(
		PADAPTER				Adapter,
		HAL_DEF_VARIABLE		eVariable,
		void						*pValue
);

void rtl8192e_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8192e(_adapter *adapter);
void rtl8192e_init_default_value(_adapter *padapter);

void rtl8192e_start_thread(_adapter *padapter);
void rtl8192e_stop_thread(_adapter *padapter);

#ifdef CONFIG_PCI_HCI
	BOOLEAN	InterruptRecognized8192EE(PADAPTER Adapter);
	u16	get_txbd_rw_reg(u16 ff_hwaddr);
#endif

#ifdef CONFIG_SDIO_HCI
	#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT
		void _init_available_page_threshold(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
	#endif
#endif

#ifdef CONFIG_BT_COEXIST
	void rtl8192e_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
#endif

#endif /* __RTL8192E_HAL_H__ */
                                                                                           rtl8822bu/src/include/gspi_ops.h                                                                    0000644 0001750 0001750 00000017151 14214766567 015425  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __GSPI_OPS_H__
#define __GSPI_OPS_H__

/* follwing defination is based on
 * GSPI spec of RTL8723, we temp
 * suppose that it will be the same
 * for diff chips of GSPI, if not
 * we should move it to HAL folder */
#define SPI_LOCAL_DOMAIN				0x0
#define WLAN_IOREG_DOMAIN			0x8
#define FW_FIFO_DOMAIN				0x4
#define TX_HIQ_DOMAIN					0xc
#define TX_MIQ_DOMAIN					0xd
#define TX_LOQ_DOMAIN					0xe
#define RX_RXFIFO_DOMAIN				0x1f

/* IO Bus domain address mapping */
#define DEFUALT_OFFSET					0x0
#define SPI_LOCAL_OFFSET				0x10250000
#define WLAN_IOREG_OFFSET			0x10260000
#define FW_FIFO_OFFSET				0x10270000
#define TX_HIQ_OFFSET					0x10310000
#define TX_MIQ_OFFSET					0x1032000
#define TX_LOQ_OFFSET					0x10330000
#define RX_RXOFF_OFFSET				0x10340000

/* SPI Local registers */
#define SPI_REG_TX_CTRL					0x0000 /* SPI Tx Control */
#define SPI_REG_STATUS_RECOVERY		0x0004
#define SPI_REG_INT_TIMEOUT			0x0006
#define SPI_REG_HIMR					0x0014 /* SPI Host Interrupt Mask */
#define SPI_REG_HISR					0x0018 /* SPI Host Interrupt Service Routine */
#define SPI_REG_RX0_REQ_LEN			0x001C /* RXDMA Request Length */
#define SPI_REG_FREE_TXPG				0x0020 /* Free Tx Buffer Page */
#define SPI_REG_HCPWM1					0x0024 /* HCI Current Power Mode 1 */
#define SPI_REG_HCPWM2					0x0026 /* HCI Current Power Mode 2 */
#define SPI_REG_HTSFR_INFO				0x0030 /* HTSF Informaion */
#define SPI_REG_HRPWM1					0x0080 /* HCI Request Power Mode 1 */
#define SPI_REG_HRPWM2					0x0082 /* HCI Request Power Mode 2 */
#define SPI_REG_HPS_CLKR				0x0084 /* HCI Power Save Clock */
#define SPI_REG_HSUS_CTRL				0x0086 /* SPI HCI Suspend Control */
#define SPI_REG_HIMR_ON				0x0090 /* SPI Host Extension Interrupt Mask Always */
#define SPI_REG_HISR_ON				0x0091 /* SPI Host Extension Interrupt Status Always */
#define SPI_REG_CFG						0x00F0 /* SPI Configuration Register */

#define SPI_TX_CTRL				(SPI_REG_TX_CTRL | SPI_LOCAL_OFFSET)
#define SPI_STATUS_RECOVERY			(SPI_REG_STATUS_RECOVERY | SPI_LOCAL_OFFSET)
#define SPI_INT_TIMEOUT					(SPI_REG_INT_TIMEOUT | SPI_LOCAL_OFFSET)
#define SPI_HIMR				(SPI_REG_HIMR | SPI_LOCAL_OFFSET)
#define SPI_HISR				(SPI_REG_HISR | SPI_LOCAL_OFFSET)
#define SPI_RX0_REQ_LEN_1_BYTE		(SPI_REG_RX0_REQ_LEN | SPI_LOCAL_OFFSET)
#define SPI_FREE_TXPG			(SPI_REG_FREE_TXPG | SPI_LOCAL_OFFSET)

#define	SPI_HIMR_DISABLED				0

/* SPI HIMR MASK diff with SDIO */
#define SPI_HISR_RX_REQUEST			BIT(0)
#define SPI_HISR_AVAL					BIT(1)
#define SPI_HISR_TXERR					BIT(2)
#define SPI_HISR_RXERR					BIT(3)
#define SPI_HISR_TXFOVW				BIT(4)
#define SPI_HISR_RXFOVW				BIT(5)
#define SPI_HISR_TXBCNOK				BIT(6)
#define SPI_HISR_TXBCNERR				BIT(7)
#define SPI_HISR_BCNERLY_INT			BIT(16)
#define SPI_HISR_ATIMEND				BIT(17)
#define SPI_HISR_ATIMEND_E				BIT(18)
#define SPI_HISR_CTWEND				BIT(19)
#define SPI_HISR_C2HCMD				BIT(20)
#define SPI_HISR_CPWM1					BIT(21)
#define SPI_HISR_CPWM2					BIT(22)
#define SPI_HISR_HSISR_IND				BIT(23)
#define SPI_HISR_GTINT3_IND				BIT(24)
#define SPI_HISR_GTINT4_IND				BIT(25)
#define SPI_HISR_PSTIMEOUT				BIT(26)
#define SPI_HISR_OCPINT					BIT(27)
#define SPI_HISR_TSF_BIT32_TOGGLE		BIT(29)

#define MASK_SPI_HISR_CLEAR		(SPI_HISR_TXERR |\
		SPI_HISR_RXERR |\
		SPI_HISR_TXFOVW |\
		SPI_HISR_RXFOVW |\
		SPI_HISR_TXBCNOK |\
		SPI_HISR_TXBCNERR |\
		SPI_HISR_C2HCMD |\
		SPI_HISR_CPWM1 |\
		SPI_HISR_CPWM2 |\
		SPI_HISR_HSISR_IND |\
		SPI_HISR_GTINT3_IND |\
		SPI_HISR_GTINT4_IND |\
		SPI_HISR_PSTIMEOUT |\
		SPI_HISR_OCPINT)

#define REG_LEN_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 0, 8, x)/* (x<<(unsigned int)24) */
#define REG_ADDR_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 8, 16, x)/* (x<<(unsigned int)16) */
#define REG_DOMAIN_ID_FORMAT(pcmd, x) 		SET_BITS_TO_LE_4BYTE(pcmd, 24, 5, x)/* (x<<(unsigned int)0) */
#define REG_FUN_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 29, 2, x)/* (x<<(unsigned int)5) */
#define REG_RW_FORMAT(pcmd, x) 				SET_BITS_TO_LE_4BYTE(pcmd, 31, 1, x)/* (x<<(unsigned int)7) */

#define FIFO_LEN_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 0, 16, x)/* (x<<(unsigned int)24)
 * #define FIFO_ADDR_FORMAT(pcmd,x) 			SET_BITS_TO_LE_4BYTE(pcmd, 8, 16, x) */ /* (x<<(unsigned int)16) */
#define FIFO_DOMAIN_ID_FORMAT(pcmd, x) 	SET_BITS_TO_LE_4BYTE(pcmd, 24, 5, x)/* (x<<(unsigned int)0) */
#define FIFO_FUN_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 29, 2, x)/* (x<<(unsigned int)5) */
#define FIFO_RW_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 31, 1, x)/* (x<<(unsigned int)7) */


/* get status dword0 */
#define GET_STATUS_PUB_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 24, 8)
#define GET_STATUS_HI_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 18, 6)
#define GET_STATUS_MID_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 12, 6)
#define GET_STATUS_LOW_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 6, 6)
#define GET_STATUS_HISR_HI6BIT(status)			LE_BITS_TO_4BYTE(status, 0, 6)

/* get status dword1 */
#define GET_STATUS_HISR_MID8BIT(status)		LE_BITS_TO_4BYTE(status + 4, 24, 8)
#define GET_STATUS_HISR_LOW8BIT(status)		LE_BITS_TO_4BYTE(status + 4, 16, 8)
#define GET_STATUS_ERROR(status)				LE_BITS_TO_4BYTE(status + 4, 17, 1)
#define GET_STATUS_INT(status)				LE_BITS_TO_4BYTE(status + 4, 16, 1)
#define GET_STATUS_RX_LENGTH(status)			LE_BITS_TO_4BYTE(status + 4, 0, 16)


#define RXDESC_SIZE	24


struct spi_more_data {
	unsigned long more_data;
	unsigned long len;
};

#ifdef CONFIG_RTL8188E
	void rtl8188es_set_hal_ops(PADAPTER padapter);
	#define set_hal_ops rtl8188es_set_hal_ops
#endif
extern void spi_set_chip_endian(PADAPTER padapter);
extern unsigned int spi_write8_endian(ADAPTER *Adapter, unsigned int addr, unsigned int buf, u32 big);
extern void spi_set_intf_ops(_adapter *padapter, struct _io_ops *pops);
extern void spi_set_chip_endian(PADAPTER padapter);
extern void InitInterrupt8723ASdio(PADAPTER padapter);
extern void InitSysInterrupt8723ASdio(PADAPTER padapter);
extern void EnableInterrupt8723ASdio(PADAPTER padapter);
extern void DisableInterrupt8723ASdio(PADAPTER padapter);
extern void spi_int_hdl(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8723ASdio(PADAPTER padapter);
#ifdef CONFIG_RTL8723B
	extern void InitInterrupt8723BSdio(PADAPTER padapter);
	extern void InitSysInterrupt8723BSdio(PADAPTER padapter);
	extern void EnableInterrupt8723BSdio(PADAPTER padapter);
	extern void DisableInterrupt8723BSdio(PADAPTER padapter);
	extern u8 HalQueryTxBufferStatus8723BSdio(PADAPTER padapter);
#endif

#ifdef CONFIG_RTL8188E
	extern void InitInterrupt8188EGspi(PADAPTER padapter);
	extern void EnableInterrupt8188EGspi(PADAPTER padapter);
	extern void DisableInterrupt8188EGspi(PADAPTER padapter);
	extern void UpdateInterruptMask8188EGspi(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
	extern u8 HalQueryTxBufferStatus8189EGspi(PADAPTER padapter);
	extern u8 HalQueryTxOQTBufferStatus8189EGspi(PADAPTER padapter);
	extern void ClearInterrupt8188EGspi(PADAPTER padapter);
	extern u8 CheckIPSStatus(PADAPTER padapter);
#endif /* CONFIG_RTL8188E */
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
	extern u8 RecvOnePkt(PADAPTER padapter);
#endif /* CONFIG_WOWLAN */

#endif /* __GSPI_OPS_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8188f_xmit.h                                                               0000644 0001750 0001750 00000046476 14214766567 016157  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_XMIT_H__
#define __RTL8188F_XMIT_H__


#define MAX_TID (15)


#ifndef __INC_HAL8188FDESC_H
#define __INC_HAL8188FDESC_H

#define RX_STATUS_DESC_SIZE_8188F		24
#define RX_DRV_INFO_SIZE_UNIT_8188F 8


/* DWORD 0 */
#define SET_RX_STATUS_DESC_PKT_LEN_8188F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_STATUS_DESC_EOR_8188F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 30, 1, __Value)
#define SET_RX_STATUS_DESC_OWN_8188F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 31, 1, __Value)

#define GET_RX_STATUS_DESC_PKT_LEN_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 0, 14)
#define GET_RX_STATUS_DESC_CRC32_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
#define GET_RX_STATUS_DESC_ICV_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 4)
#define GET_RX_STATUS_DESC_SECURITY_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 20, 3)
#define GET_RX_STATUS_DESC_QOS_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 23, 1)
#define GET_RX_STATUS_DESC_SHIFT_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 24, 2)
#define GET_RX_STATUS_DESC_PHY_STATUS_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 26, 1)
#define GET_RX_STATUS_DESC_SWDEC_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 27, 1)
#define GET_RX_STATUS_DESC_LAST_SEG_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc, 28, 1)
#define GET_RX_STATUS_DESC_FIRST_SEG_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 29, 1)
#define GET_RX_STATUS_DESC_EOR_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 30, 1)
#define GET_RX_STATUS_DESC_OWN_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)

/* DWORD 1 */
#define GET_RX_STATUS_DESC_MACID_8188F(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
#define GET_RX_STATUS_DESC_TID_8188F(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
#define GET_RX_STATUS_DESC_AMSDU_8188F(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
#define GET_RX_STATUS_DESC_RXID_MATCH_8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
#define GET_RX_STATUS_DESC_PAGGR_8188F(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 15, 1)
#define GET_RX_STATUS_DESC_A1_FIT_8188F(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 16, 4)
#define GET_RX_STATUS_DESC_CHKERR_8188F(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 20, 1)
#define GET_RX_STATUS_DESC_IPVER_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
#define GET_RX_STATUS_DESC_IS_TCPUDP__8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
#define GET_RX_STATUS_DESC_CHK_VLD_8188F(__pRxDesc)	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
#define GET_RX_STATUS_DESC_PAM_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 24, 1)
#define GET_RX_STATUS_DESC_PWR_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 25, 1)
#define GET_RX_STATUS_DESC_MORE_DATA_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 26, 1)
#define GET_RX_STATUS_DESC_MORE_FRAG_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 27, 1)
#define GET_RX_STATUS_DESC_TYPE_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 28, 2)
#define GET_RX_STATUS_DESC_MC_8188F(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 30, 1)
#define GET_RX_STATUS_DESC_BC_8188F(__pRxDesc)				LE_BITS_TO_4BYTE(__pRxDesc+4, 31, 1)

/* DWORD 2 */
#define GET_RX_STATUS_DESC_SEQ_8188F(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 0, 12)
#define GET_RX_STATUS_DESC_FRAG_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 12, 4)
#define GET_RX_STATUS_DESC_RX_IS_QOS_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 16, 1)
#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8188F(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 18, 6)
#define GET_RX_STATUS_DESC_RPT_SEL_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+8, 28, 1)

/* DWORD 3 */
#define GET_RX_STATUS_DESC_RX_RATE_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 0, 7)
#define GET_RX_STATUS_DESC_HTC_8188F(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 10, 1)
#define GET_RX_STATUS_DESC_EOSP_8188F(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 11, 1)
#define GET_RX_STATUS_DESC_BSSID_FIT_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 12, 2)
#ifdef CONFIG_USB_RX_AGGREGATION
#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8188F(__pRxStatusDesc)	LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 16, 8)
#endif
#define GET_RX_STATUS_DESC_PATTERN_MATCH_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 29, 1)
#define GET_RX_STATUS_DESC_UNICAST_MATCH_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+12, 30, 1)
#define GET_RX_STATUS_DESC_MAGIC_MATCH_8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+12, 31, 1)

/* DWORD 6 */
#define GET_RX_STATUS_DESC_SPLCP_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 0, 1)
#define GET_RX_STATUS_DESC_LDPC_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 1, 1)
#define GET_RX_STATUS_DESC_STBC_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 2, 1)
#define GET_RX_STATUS_DESC_BW_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+16, 4, 2)

/* DWORD 5 */
#define GET_RX_STATUS_DESC_TSFL_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+20, 0, 32)

#define GET_RX_STATUS_DESC_BUFF_ADDR_8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
#define GET_RX_STATUS_DESC_BUFF_ADDR64_8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)

#define SET_RX_STATUS_DESC_BUFF_ADDR_8188F(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)


/* Dword 0 */
#define GET_TX_DESC_OWN_8188F(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

#define SET_TX_DESC_PKT_SIZE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define SET_TX_DESC_OFFSET_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define SET_TX_DESC_BMC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_LAST_SEG_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
#define SET_TX_DESC_FIRST_SEG_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_LINIP_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
#define SET_TX_DESC_NO_ACM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
#define SET_TX_DESC_OWN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)

/* Dword 1 */
#define SET_TX_DESC_MACID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)


/* Dword 2 */
#define SET_TX_DESC_PAID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
#define SET_TX_DESC_CCA_RTS_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_AGG_BREAK_8188F(__pTxDesc, __Value)				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define SET_TX_DESC_RAW_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define SET_TX_DESC_SPE_RPT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_INT_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_GID_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)


/* Dword 3 */
#define SET_TX_DESC_WHEADER_LEN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
#define SET_TX_DESC_CHK_EN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
#define SET_TX_DESC_EARLY_MODE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
#define SET_TX_DESC_HWSEQ_SEL_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_NAV_USE_HDR_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
#define SET_TX_DESC_USE_MAX_LEN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_NDPA_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)


/* Dword 5 */
#define SET_TX_DESC_DATA_SC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_8188F(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_LDPC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
#define SET_TX_DESC_DATA_STBC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_CTROL_STBC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)


/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_MBSSID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
#define SET_TX_DESC_ANTSEL_A_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
#define SET_TX_DESC_ANTSEL_B_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
#define SET_TX_DESC_ANTSEL_C_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
#define SET_TX_DESC_ANTSEL_D_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)

/* Dword 7 */
#ifdef CONFIG_PCI_HCI
#define SET_TX_DESC_TX_BUFFER_SIZE_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
#define SET_TX_DESC_TX_DESC_CHECKSUM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif
#define SET_TX_DESC_USB_TXAGG_NUM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
#ifdef CONFIG_SDIO_HCI
#define SET_TX_DESC_SDIO_TXSEQ_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
#endif

/* Dword 8 */
#define SET_TX_DESC_HWSEQ_EN_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)

/* Dword 9 */
#define SET_TX_DESC_SEQ_8188F(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)

/* Dword 10 */
#define SET_TX_DESC_TX_BUFFER_ADDRESS_8188F(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
#define GET_TX_DESC_TX_BUFFER_ADDRESS_8188F(__pTxDesc)	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)

/* Dword 11 */
#define SET_TX_DESC_NEXT_DESC_ADDRESS_8188F(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)


#define SET_EARLYMODE_PKTNUM_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
#define SET_EARLYMODE_LEN3_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)

#endif
/* -----------------------------------------------------------
 *
 *	Rate
 *
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC8188F_RATE1M				0x00
#define DESC8188F_RATE2M				0x01
#define DESC8188F_RATE5_5M				0x02
#define DESC8188F_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC8188F_RATE6M				0x04
#define DESC8188F_RATE9M				0x05
#define DESC8188F_RATE12M				0x06
#define DESC8188F_RATE18M				0x07
#define DESC8188F_RATE24M				0x08
#define DESC8188F_RATE36M				0x09
#define DESC8188F_RATE48M				0x0a
#define DESC8188F_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC8188F_RATEMCS0				0x0c
#define DESC8188F_RATEMCS1				0x0d
#define DESC8188F_RATEMCS2				0x0e
#define DESC8188F_RATEMCS3				0x0f
#define DESC8188F_RATEMCS4				0x10
#define DESC8188F_RATEMCS5				0x11
#define DESC8188F_RATEMCS6				0x12
#define DESC8188F_RATEMCS7				0x13
#define DESC8188F_RATEMCS8				0x14
#define DESC8188F_RATEMCS9				0x15
#define DESC8188F_RATEMCS10		0x16
#define DESC8188F_RATEMCS11		0x17
#define DESC8188F_RATEMCS12		0x18
#define DESC8188F_RATEMCS13		0x19
#define DESC8188F_RATEMCS14		0x1a
#define DESC8188F_RATEMCS15		0x1b
#define DESC8188F_RATEVHTSS1MCS0		0x2c
#define DESC8188F_RATEVHTSS1MCS1		0x2d
#define DESC8188F_RATEVHTSS1MCS2		0x2e
#define DESC8188F_RATEVHTSS1MCS3		0x2f
#define DESC8188F_RATEVHTSS1MCS4		0x30
#define DESC8188F_RATEVHTSS1MCS5		0x31
#define DESC8188F_RATEVHTSS1MCS6		0x32
#define DESC8188F_RATEVHTSS1MCS7		0x33
#define DESC8188F_RATEVHTSS1MCS8		0x34
#define DESC8188F_RATEVHTSS1MCS9		0x35
#define DESC8188F_RATEVHTSS2MCS0		0x36
#define DESC8188F_RATEVHTSS2MCS1		0x37
#define DESC8188F_RATEVHTSS2MCS2		0x38
#define DESC8188F_RATEVHTSS2MCS3		0x39
#define DESC8188F_RATEVHTSS2MCS4		0x3a
#define DESC8188F_RATEVHTSS2MCS5		0x3b
#define DESC8188F_RATEVHTSS2MCS6		0x3c
#define DESC8188F_RATEVHTSS2MCS7		0x3d
#define DESC8188F_RATEVHTSS2MCS8		0x3e
#define DESC8188F_RATEVHTSS2MCS9		0x3f


#define	RX_HAL_IS_CCK_RATE_8188F(pDesc)\
	(GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE1M || \
	 GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE2M || \
	 GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE5_5M || \
	 GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE11M)


void rtl8188f_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
void rtl8188f_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
#if defined(CONFIG_CONCURRENT_MODE)
void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
s32 rtl8188fs_init_xmit_priv(PADAPTER padapter);
void rtl8188fs_free_xmit_priv(PADAPTER padapter);
s32 rtl8188fs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8188fs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32	rtl8188fs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
s32 rtl8188fs_xmit_buf_handler(PADAPTER padapter);
thread_return rtl8188fs_xmit_thread(thread_context context);
#define hal_xmit_handler rtl8188fs_xmit_buf_handler
#endif

#ifdef CONFIG_USB_HCI
#ifdef CONFIG_XMIT_THREAD_MODE
s32 rtl8188fu_xmit_buf_handler(PADAPTER padapter);
#define hal_xmit_handler rtl8188fu_xmit_buf_handler
#endif

s32 rtl8188fu_init_xmit_priv(PADAPTER padapter);
void rtl8188fu_free_xmit_priv(PADAPTER padapter);
s32 rtl8188fu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8188fu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32	 rtl8188fu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
/* s32 rtl8812au_xmit_buf_handler(PADAPTER padapter); */
void rtl8188fu_xmit_tasklet(void *priv);
s32 rtl8188fu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
#endif

#ifdef CONFIG_PCI_HCI
s32 rtl8188fe_init_xmit_priv(PADAPTER padapter);
void rtl8188fe_free_xmit_priv(PADAPTER padapter);
struct xmit_buf *rtl8188fe_dequeue_xmitbuf(struct rtw_tx_ring *ring);
void	rtl8188fe_xmitframe_resume(_adapter *padapter);
s32 rtl8188fe_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
s32 rtl8188fe_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
s32	rtl8188fe_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
void rtl8188fe_xmit_tasklet(void *priv);
#endif

u8	BWMapping_8188F(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_8188F(PADAPTER Adapter, struct pkt_attrib	*pattrib);

#endif
                                                                                                                                                                                                  rtl8822bu/src/include/rtw_sdio.h                                                                    0000644 0001750 0001750 00000002225 14214766567 015430  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_SDIO_H_
#define _RTW_SDIO_H_

#include <drv_types.h>		/* struct dvobj_priv and etc. */

u8 rtw_sdio_read_cmd52(struct dvobj_priv *, u32 addr, void *buf, size_t len);
u8 rtw_sdio_read_cmd53(struct dvobj_priv *, u32 addr, void *buf, size_t len);
u8 rtw_sdio_write_cmd52(struct dvobj_priv *, u32 addr, void *buf, size_t len);
u8 rtw_sdio_write_cmd53(struct dvobj_priv *, u32 addr, void *buf, size_t len);
u8 rtw_sdio_f0_read(struct dvobj_priv *, u32 addr, void *buf, size_t len);

#endif /* _RTW_SDIO_H_ */
                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/hal_com.h                                                                     0000644 0001750 0001750 00000070730 14214766567 015206  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_COMMON_H__
#define __HAL_COMMON_H__

#include "HalVerDef.h"
#include "hal_pg.h"
#include "hal_phy.h"
#include "hal_phy_reg.h"
#include "hal_com_reg.h"
#include "hal_com_phycfg.h"
#include "../hal/hal_com_c2h.h"

/*------------------------------ Tx Desc definition Macro ------------------------*/
/* #pragma mark -- Tx Desc related definition. -- */
/* ----------------------------------------------------------------------------
 * -----------------------------------------------------------
 *	Rate
 * -----------------------------------------------------------
 * CCK Rates, TxHT = 0 */
#define DESC_RATE1M					0x00
#define DESC_RATE2M					0x01
#define DESC_RATE5_5M				0x02
#define DESC_RATE11M				0x03

/* OFDM Rates, TxHT = 0 */
#define DESC_RATE6M					0x04
#define DESC_RATE9M					0x05
#define DESC_RATE12M				0x06
#define DESC_RATE18M				0x07
#define DESC_RATE24M				0x08
#define DESC_RATE36M				0x09
#define DESC_RATE48M				0x0a
#define DESC_RATE54M				0x0b

/* MCS Rates, TxHT = 1 */
#define DESC_RATEMCS0				0x0c
#define DESC_RATEMCS1				0x0d
#define DESC_RATEMCS2				0x0e
#define DESC_RATEMCS3				0x0f
#define DESC_RATEMCS4				0x10
#define DESC_RATEMCS5				0x11
#define DESC_RATEMCS6				0x12
#define DESC_RATEMCS7				0x13
#define DESC_RATEMCS8				0x14
#define DESC_RATEMCS9				0x15
#define DESC_RATEMCS10				0x16
#define DESC_RATEMCS11				0x17
#define DESC_RATEMCS12				0x18
#define DESC_RATEMCS13				0x19
#define DESC_RATEMCS14				0x1a
#define DESC_RATEMCS15				0x1b
#define DESC_RATEMCS16				0x1C
#define DESC_RATEMCS17				0x1D
#define DESC_RATEMCS18				0x1E
#define DESC_RATEMCS19				0x1F
#define DESC_RATEMCS20				0x20
#define DESC_RATEMCS21				0x21
#define DESC_RATEMCS22				0x22
#define DESC_RATEMCS23				0x23
#define DESC_RATEMCS24				0x24
#define DESC_RATEMCS25				0x25
#define DESC_RATEMCS26				0x26
#define DESC_RATEMCS27				0x27
#define DESC_RATEMCS28				0x28
#define DESC_RATEMCS29				0x29
#define DESC_RATEMCS30				0x2A
#define DESC_RATEMCS31				0x2B
#define DESC_RATEVHTSS1MCS0		0x2C
#define DESC_RATEVHTSS1MCS1		0x2D
#define DESC_RATEVHTSS1MCS2		0x2E
#define DESC_RATEVHTSS1MCS3		0x2F
#define DESC_RATEVHTSS1MCS4		0x30
#define DESC_RATEVHTSS1MCS5		0x31
#define DESC_RATEVHTSS1MCS6		0x32
#define DESC_RATEVHTSS1MCS7		0x33
#define DESC_RATEVHTSS1MCS8		0x34
#define DESC_RATEVHTSS1MCS9		0x35
#define DESC_RATEVHTSS2MCS0		0x36
#define DESC_RATEVHTSS2MCS1		0x37
#define DESC_RATEVHTSS2MCS2		0x38
#define DESC_RATEVHTSS2MCS3		0x39
#define DESC_RATEVHTSS2MCS4		0x3A
#define DESC_RATEVHTSS2MCS5		0x3B
#define DESC_RATEVHTSS2MCS6		0x3C
#define DESC_RATEVHTSS2MCS7		0x3D
#define DESC_RATEVHTSS2MCS8		0x3E
#define DESC_RATEVHTSS2MCS9		0x3F
#define DESC_RATEVHTSS3MCS0		0x40
#define DESC_RATEVHTSS3MCS1		0x41
#define DESC_RATEVHTSS3MCS2		0x42
#define DESC_RATEVHTSS3MCS3		0x43
#define DESC_RATEVHTSS3MCS4		0x44
#define DESC_RATEVHTSS3MCS5		0x45
#define DESC_RATEVHTSS3MCS6		0x46
#define DESC_RATEVHTSS3MCS7		0x47
#define DESC_RATEVHTSS3MCS8		0x48
#define DESC_RATEVHTSS3MCS9		0x49
#define DESC_RATEVHTSS4MCS0		0x4A
#define DESC_RATEVHTSS4MCS1		0x4B
#define DESC_RATEVHTSS4MCS2		0x4C
#define DESC_RATEVHTSS4MCS3		0x4D
#define DESC_RATEVHTSS4MCS4		0x4E
#define DESC_RATEVHTSS4MCS5		0x4F
#define DESC_RATEVHTSS4MCS6		0x50
#define DESC_RATEVHTSS4MCS7		0x51
#define DESC_RATEVHTSS4MCS8		0x52
#define DESC_RATEVHTSS4MCS9		0x53

#define IS_CCK_HRATE(_rate)		((_rate) <= DESC_RATE11M)
#define IS_OFDM_HRATE(_rate)	((_rate) >= DESC_RATE6M && (_rate) <= DESC_RATE54M)
#define IS_LEGACY_HRATE(_rate)	((_rate) <= DESC_RATE54M)
#define IS_HT_HRATE(_rate)		((_rate) >= DESC_RATEMCS0 && (_rate) <= DESC_RATEMCS31)
#define IS_VHT_HRATE(_rate)		((_rate) >= DESC_RATEVHTSS1MCS0 && (_rate) <= DESC_RATEVHTSS4MCS9)

#define IS_HT1SS_HRATE(_rate) ((_rate) >= DESC_RATEMCS0 && (_rate) <= DESC_RATEMCS7)
#define IS_HT2SS_HRATE(_rate) ((_rate) >= DESC_RATEMCS8 && (_rate) <= DESC_RATEMCS15)
#define IS_HT3SS_HRATE(_rate) ((_rate) >= DESC_RATEMCS16 && (_rate) <= DESC_RATEMCS23)
#define IS_HT4SS_HRATE(_rate) ((_rate) >= DESC_RATEMCS24 && (_rate) <= DESC_RATEMCS31)

#define IS_VHT1SS_HRATE(_rate) ((_rate) >= DESC_RATEVHTSS1MCS0 && (_rate) <= DESC_RATEVHTSS1MCS9)
#define IS_VHT2SS_HRATE(_rate) ((_rate) >= DESC_RATEVHTSS2MCS0 && (_rate) <= DESC_RATEVHTSS2MCS9)
#define IS_VHT3SS_HRATE(_rate) ((_rate) >= DESC_RATEVHTSS3MCS0 && (_rate) <= DESC_RATEVHTSS3MCS9)
#define IS_VHT4SS_HRATE(_rate) ((_rate) >= DESC_RATEVHTSS4MCS0 && (_rate) <= DESC_RATEVHTSS4MCS9)

#define IS_1SS_HRATE(_rate)	(IS_CCK_HRATE((_rate)) || IS_OFDM_HRATE((_rate)) || IS_HT1SS_HRATE((_rate)) || IS_VHT1SS_HRATE((_rate)))
#define IS_2SS_HRATE(_rate)	(IS_HT2SS_HRATE((_rate)) || IS_VHT2SS_HRATE((_rate)))
#define IS_3SS_HRATE(_rate)	(IS_HT3SS_HRATE((_rate)) || IS_VHT3SS_HRATE((_rate)))
#define IS_4SS_HRATE(_rate)	(IS_HT4SS_HRATE((_rate)) || IS_VHT4SS_HRATE((_rate)))

#define HRARE_SS_NUM(_rate) (IS_1SS_HRATE(_rate) ? 1 : (IS_2SS_HRATE(_rate) ? 2 : (IS_3SS_HRATE(_rate) ? 3 : (IS_4SS_HRATE(_rate) ? 4 : 0))))

#define HDATA_RATE(rate)\
	(rate == DESC_RATE1M) ? "CCK_1M" :\
	(rate == DESC_RATE2M) ? "CCK_2M" :\
	(rate == DESC_RATE5_5M) ? "CCK5_5M" :\
	(rate == DESC_RATE11M) ? "CCK_11M" :\
	(rate == DESC_RATE6M) ? "OFDM_6M" :\
	(rate == DESC_RATE9M) ? "OFDM_9M" :\
	(rate == DESC_RATE12M) ? "OFDM_12M" :\
	(rate == DESC_RATE18M) ? "OFDM_18M" :\
	(rate == DESC_RATE24M) ? "OFDM_24M" :\
	(rate == DESC_RATE36M) ? "OFDM_36M" :\
	(rate == DESC_RATE48M) ? "OFDM_48M" :\
	(rate == DESC_RATE54M) ? "OFDM_54M" :\
	(rate == DESC_RATEMCS0) ? "MCS0" :\
	(rate == DESC_RATEMCS1) ? "MCS1" :\
	(rate == DESC_RATEMCS2) ? "MCS2" :\
	(rate == DESC_RATEMCS3) ? "MCS3" :\
	(rate == DESC_RATEMCS4) ? "MCS4" :\
	(rate == DESC_RATEMCS5) ? "MCS5" :\
	(rate == DESC_RATEMCS6) ? "MCS6" :\
	(rate == DESC_RATEMCS7) ? "MCS7" :\
	(rate == DESC_RATEMCS8) ? "MCS8" :\
	(rate == DESC_RATEMCS9) ? "MCS9" :\
	(rate == DESC_RATEMCS10) ? "MCS10" :\
	(rate == DESC_RATEMCS11) ? "MCS11" :\
	(rate == DESC_RATEMCS12) ? "MCS12" :\
	(rate == DESC_RATEMCS13) ? "MCS13" :\
	(rate == DESC_RATEMCS14) ? "MCS14" :\
	(rate == DESC_RATEMCS15) ? "MCS15" :\
	(rate == DESC_RATEMCS16) ? "MCS16" :\
	(rate == DESC_RATEMCS17) ? "MCS17" :\
	(rate == DESC_RATEMCS18) ? "MCS18" :\
	(rate == DESC_RATEMCS19) ? "MCS19" :\
	(rate == DESC_RATEMCS20) ? "MCS20" :\
	(rate == DESC_RATEMCS21) ? "MCS21" :\
	(rate == DESC_RATEMCS22) ? "MCS22" :\
	(rate == DESC_RATEMCS23) ? "MCS23" :\
	(rate == DESC_RATEMCS24) ? "MCS24" :\
	(rate == DESC_RATEMCS25) ? "MCS25" :\
	(rate == DESC_RATEMCS26) ? "MCS26" :\
	(rate == DESC_RATEMCS27) ? "MCS27" :\
	(rate == DESC_RATEMCS28) ? "MCS28" :\
	(rate == DESC_RATEMCS29) ? "MCS29" :\
	(rate == DESC_RATEMCS30) ? "MCS30" :\
	(rate == DESC_RATEMCS31) ? "MCS31" :\
	(rate == DESC_RATEVHTSS1MCS0) ? "VHTSS1MCS0" :\
	(rate == DESC_RATEVHTSS1MCS1) ? "VHTSS1MCS1" :\
	(rate == DESC_RATEVHTSS1MCS2) ? "VHTSS1MCS2" :\
	(rate == DESC_RATEVHTSS1MCS3) ? "VHTSS1MCS3" :\
	(rate == DESC_RATEVHTSS1MCS4) ? "VHTSS1MCS4" :\
	(rate == DESC_RATEVHTSS1MCS5) ? "VHTSS1MCS5" :\
	(rate == DESC_RATEVHTSS1MCS6) ? "VHTSS1MCS6" :\
	(rate == DESC_RATEVHTSS1MCS7) ? "VHTSS1MCS7" :\
	(rate == DESC_RATEVHTSS1MCS8) ? "VHTSS1MCS8" :\
	(rate == DESC_RATEVHTSS1MCS9) ? "VHTSS1MCS9" :\
	(rate == DESC_RATEVHTSS2MCS0) ? "VHTSS2MCS0" :\
	(rate == DESC_RATEVHTSS2MCS1) ? "VHTSS2MCS1" :\
	(rate == DESC_RATEVHTSS2MCS2) ? "VHTSS2MCS2" :\
	(rate == DESC_RATEVHTSS2MCS3) ? "VHTSS2MCS3" :\
	(rate == DESC_RATEVHTSS2MCS4) ? "VHTSS2MCS4" :\
	(rate == DESC_RATEVHTSS2MCS5) ? "VHTSS2MCS5" :\
	(rate == DESC_RATEVHTSS2MCS6) ? "VHTSS2MCS6" :\
	(rate == DESC_RATEVHTSS2MCS7) ? "VHTSS2MCS7" :\
	(rate == DESC_RATEVHTSS2MCS8) ? "VHTSS2MCS8" :\
	(rate == DESC_RATEVHTSS2MCS9) ? "VHTSS2MCS9" :\
	(rate == DESC_RATEVHTSS3MCS0) ? "VHTSS3MCS0" :\
	(rate == DESC_RATEVHTSS3MCS1) ? "VHTSS3MCS1" :\
	(rate == DESC_RATEVHTSS3MCS2) ? "VHTSS3MCS2" :\
	(rate == DESC_RATEVHTSS3MCS3) ? "VHTSS3MCS3" :\
	(rate == DESC_RATEVHTSS3MCS4) ? "VHTSS3MCS4" :\
	(rate == DESC_RATEVHTSS3MCS5) ? "VHTSS3MCS5" :\
	(rate == DESC_RATEVHTSS3MCS6) ? "VHTSS3MCS6" :\
	(rate == DESC_RATEVHTSS3MCS7) ? "VHTSS3MCS7" :\
	(rate == DESC_RATEVHTSS3MCS8) ? "VHTSS3MCS8" :\
	(rate == DESC_RATEVHTSS3MCS9) ? "VHTSS3MCS9" :\
	(rate == DESC_RATEVHTSS4MCS0) ? "VHTSS4MCS0" :\
	(rate == DESC_RATEVHTSS4MCS1) ? "VHTSS4MCS1" :\
	(rate == DESC_RATEVHTSS4MCS2) ? "VHTSS4MCS2" :\
	(rate == DESC_RATEVHTSS4MCS3) ? "VHTSS4MCS3" :\
	(rate == DESC_RATEVHTSS4MCS4) ? "VHTSS4MCS4" :\
	(rate == DESC_RATEVHTSS4MCS5) ? "VHTSS4MCS5" :\
	(rate == DESC_RATEVHTSS4MCS6) ? "VHTSS4MCS6" :\
	(rate == DESC_RATEVHTSS4MCS7) ? "VHTSS4MCS7" :\
	(rate == DESC_RATEVHTSS4MCS8) ? "VHTSS4MCS8" :\
	(rate == DESC_RATEVHTSS4MCS9) ? "VHTSS4MCS9" :\
	"UNKNOWN"

enum {
	UP_LINK,
	DOWN_LINK,
};
typedef enum _RT_MEDIA_STATUS {
	RT_MEDIA_DISCONNECT = 0,
	RT_MEDIA_CONNECT       = 1
} RT_MEDIA_STATUS;

#define MAX_DLFW_PAGE_SIZE			4096	/* @ page : 4k bytes */
typedef enum _FIRMWARE_SOURCE {
	FW_SOURCE_IMG_FILE = 0,
	FW_SOURCE_HEADER_FILE = 1,		/* from header file */
} FIRMWARE_SOURCE, *PFIRMWARE_SOURCE;

typedef enum _CH_SW_USE_CASE {
	CH_SW_USE_CASE_TDLS		= 0,
	CH_SW_USE_CASE_MCC		= 1
} CH_SW_USE_CASE;

typedef enum _WAKEUP_REASON{
	RX_PAIRWISEKEY					= 0x01,
	RX_GTK							= 0x02,
	RX_FOURWAY_HANDSHAKE			= 0x03,
	RX_DISASSOC						= 0x04,
	RX_DEAUTH						= 0x08,
	RX_ARP_REQUEST					= 0x09,
	FW_DECISION_DISCONNECT			= 0x10,
	RX_MAGIC_PKT					= 0x21,
	RX_UNICAST_PKT					= 0x22,
	RX_PATTERN_PKT					= 0x23,
	RTD3_SSID_MATCH					= 0x24,
	RX_REALWOW_V2_WAKEUP_PKT		= 0x30,
	RX_REALWOW_V2_ACK_LOST			= 0x31,
	ENABLE_FAIL_DMA_IDLE			= 0x40,
	ENABLE_FAIL_DMA_PAUSE			= 0x41,
	RTIME_FAIL_DMA_IDLE				= 0x42,
	RTIME_FAIL_DMA_PAUSE			= 0x43,
	RX_PNO							= 0x55,
	AP_OFFLOAD_WAKEUP				= 0x66,
	CLK_32K_UNLOCK					= 0xFD,
	CLK_32K_LOCK					= 0xFE
}WAKEUP_REASON;

/*
 * Queue Select Value in TxDesc
 *   */
#define QSLT_BK							0x2/* 0x01 */
#define QSLT_BE							0x0
#define QSLT_VI							0x5/* 0x4 */
#define QSLT_VO							0x7/* 0x6 */
#define QSLT_BEACON						0x10
#define QSLT_HIGH						0x11
#define QSLT_MGNT						0x12
#define QSLT_CMD						0x13

/* BK, BE, VI, VO, HCCA, MANAGEMENT, COMMAND, HIGH, BEACON.
 * #define MAX_TX_QUEUE		9 */

#define TX_SELE_HQ			BIT(0)		/* High Queue */
#define TX_SELE_LQ			BIT(1)		/* Low Queue */
#define TX_SELE_NQ			BIT(2)		/* Normal Queue */
#define TX_SELE_EQ			BIT(3)		/* Extern Queue */

#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len) & 0x7F ? 1 : 0))
#define PageNum_256(_Len)		(u32)(((_Len)>>8) + ((_Len) & 0xFF ? 1 : 0))
#define PageNum_512(_Len)		(u32)(((_Len)>>9) + ((_Len) & 0x1FF ? 1 : 0))
#define PageNum(_Len, _Size)		(u32)(((_Len)/(_Size)) + ((_Len)&((_Size) - 1) ? 1 : 0))

struct dbg_rx_counter {
	u32	rx_pkt_ok;
	u32	rx_pkt_crc_error;
	u32	rx_pkt_drop;
	u32	rx_ofdm_fa;
	u32	rx_cck_fa;
	u32	rx_ht_fa;
};

u8 rtw_hal_get_port(_adapter *adapter);

#ifdef CONFIG_MBSSID_CAM
	#define DBG_MBID_CAM_DUMP

	void rtw_mbid_cam_init(struct dvobj_priv *dvobj);
	void rtw_mbid_cam_deinit(struct dvobj_priv *dvobj);
	void rtw_mbid_cam_reset(_adapter *adapter);
	u8 rtw_get_max_mbid_cam_id(_adapter *adapter);
	u8 rtw_get_mbid_cam_entry_num(_adapter *adapter);
	int rtw_mbid_cam_cache_dump(void *sel, const char *fun_name , _adapter *adapter);
	int rtw_mbid_cam_dump(void *sel, const char *fun_name, _adapter *adapter);
	void rtw_mi_set_mbid_cam(_adapter *adapter);
	u8 rtw_mbid_camid_alloc(_adapter *adapter, u8 *mac_addr);
	void rtw_ap_set_mbid_num(_adapter *adapter, u8 ap_num);
	void rtw_mbid_cam_enable(_adapter *adapter);
#endif

#ifdef CONFIG_MI_WITH_MBSSID_CAM
	void rtw_hal_set_macaddr_mbid(_adapter *adapter, u8 *mac_addr);
	void rtw_hal_change_macaddr_mbid(_adapter *adapter, u8 *mac_addr);
	#ifdef CONFIG_SWTIMER_BASED_TXBCN
	u16 rtw_hal_bcn_interval_adjust(_adapter *adapter, u16 bcn_interval);
	#endif
	void hw_var_set_opmode_mbid(_adapter *Adapter, u8 mode);
#endif

void rtw_dump_mac_rx_counters(_adapter *padapter, struct dbg_rx_counter *rx_counter);
void rtw_dump_phy_rx_counters(_adapter *padapter, struct dbg_rx_counter *rx_counter);
void rtw_reset_mac_rx_counters(_adapter *padapter);
void rtw_reset_phy_rx_counters(_adapter *padapter);
void rtw_reset_phy_trx_ok_counters(_adapter *padapter);

#ifdef DBG_RX_COUNTER_DUMP
	#define DUMP_DRV_RX_COUNTER	BIT0
	#define DUMP_MAC_RX_COUNTER	BIT1
	#define DUMP_PHY_RX_COUNTER	BIT2
	#define DUMP_DRV_TRX_COUNTER_DATA	BIT3

	void rtw_dump_phy_rxcnts_preprocess(_adapter *padapter, u8 rx_cnt_mode);
	void rtw_dump_rx_counters(_adapter *padapter);
#endif

void dump_chip_info(HAL_VERSION	ChipVersion);

#define BAND_CAP_2G			BIT0
#define BAND_CAP_5G			BIT1
#define BAND_CAP_BIT_NUM	2

#define BW_CAP_5M		BIT0
#define BW_CAP_10M		BIT1
#define BW_CAP_20M		BIT2
#define BW_CAP_40M		BIT3
#define BW_CAP_80M		BIT4
#define BW_CAP_160M		BIT5
#define BW_CAP_80_80M	BIT6
#define BW_CAP_BIT_NUM	7

#define PROTO_CAP_11B		BIT0
#define PROTO_CAP_11G		BIT1
#define PROTO_CAP_11N		BIT2
#define PROTO_CAP_11AC		BIT3
#define PROTO_CAP_BIT_NUM	4

#define WL_FUNC_P2P			BIT0
#define WL_FUNC_MIRACAST	BIT1
#define WL_FUNC_TDLS		BIT2
#define WL_FUNC_FTM			BIT3
#define WL_FUNC_BIT_NUM		4

#define TBTT_PROHIBIT_SETUP_TIME 0x04 /* 128us, unit is 32us */
#define TBTT_PROHIBIT_HOLD_TIME 0x80 /* 4ms, unit is 32us*/
#define TBTT_PROHIBIT_HOLD_TIME_STOP_BCN 0x64 /* 3.2ms unit is 32us*/

int hal_spec_init(_adapter *adapter);
void dump_hal_spec(void *sel, _adapter *adapter);

bool hal_chk_band_cap(_adapter *adapter, u8 cap);
bool hal_chk_bw_cap(_adapter *adapter, u8 cap);
bool hal_chk_proto_cap(_adapter *adapter, u8 cap);
bool hal_is_band_support(_adapter *adapter, u8 band);
bool hal_is_bw_support(_adapter *adapter, u8 bw);
bool hal_is_wireless_mode_support(_adapter *adapter, u8 mode);
bool hal_is_mimo_support(_adapter *adapter);
u8 hal_largest_bw(_adapter *adapter, u8 in_bw);

bool hal_chk_wl_func(_adapter *adapter, u8 func);

void hal_com_config_channel_plan(
		PADAPTER padapter,
		char *hw_alpha2,
		u8 hw_chplan,
		char *sw_alpha2,
		u8 sw_chplan,
		BOOLEAN AutoLoadFail
);

int hal_config_macaddr(_adapter *adapter, bool autoload_fail);
#ifdef RTW_HALMAC
void rtw_hal_hw_port_enable(_adapter *adapter);
void rtw_hal_hw_port_disable(_adapter *adapter);
#endif

BOOLEAN
HAL_IsLegalChannel(
		PADAPTER	Adapter,
		u32			Channel
);

u8	MRateToHwRate(u8 rate);

u8	hw_rate_to_m_rate(u8 rate);

void	HalSetBrateCfg(
		PADAPTER		Adapter,
		u8			*mBratesOS,
		u16			*pBrateCfg);

BOOLEAN
Hal_MappingOutPipe(
		PADAPTER	pAdapter,
		u8		NumOutPipe
);

void rtw_dump_fw_info(void *sel, _adapter *adapter);
void rtw_restore_hw_port_cfg(_adapter *adapter);
void rtw_mi_set_mac_addr(_adapter *adapter);/*set mac addr when hal_init for all iface*/
void rtw_hal_dump_macaddr(void *sel, _adapter *adapter);

void rtw_init_hal_com_default_value(PADAPTER Adapter);

#ifdef CONFIG_FW_C2H_REG
void c2h_evt_clear(_adapter *adapter);
s32 c2h_evt_read_88xx(_adapter *adapter, u8 *buf);
#endif

#ifdef CONFIG_FW_C2H_PKT
void rtw_hal_c2h_pkt_pre_hdl(_adapter *adapter, u8 *buf, u16 len);
void rtw_hal_c2h_pkt_hdl(_adapter *adapter, u8 *buf, u16 len);
#endif

u8 rtw_get_mgntframe_raid(_adapter *adapter, unsigned char network_type);

void rtw_hal_update_sta_wset(_adapter *adapter, struct sta_info *psta);
s8 rtw_get_sta_rx_nss(_adapter *adapter, struct sta_info *psta);
s8 rtw_get_sta_tx_nss(_adapter *adapter, struct sta_info *psta);
void rtw_hal_update_sta_ra_info(PADAPTER padapter, struct sta_info *psta);

/* access HW only */
u32 rtw_sec_read_cam(_adapter *adapter, u8 addr);
void rtw_sec_write_cam(_adapter *adapter, u8 addr, u32 wdata);
void rtw_sec_read_cam_ent(_adapter *adapter, u8 id, u8 *ctrl, u8 *mac, u8 *key);
void rtw_sec_write_cam_ent(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
void rtw_sec_clr_cam_ent(_adapter *adapter, u8 id);
bool rtw_sec_read_cam_is_gk(_adapter *adapter, u8 id);

u8 rtw_hal_rcr_check(_adapter *adapter, u32 check_bit);

u8 rtw_hal_rcr_add(_adapter *adapter, u32 add);
u8 rtw_hal_rcr_clear(_adapter *adapter, u32 clear);
void rtw_hal_rcr_set_chk_bssid(_adapter *adapter, u8 self_action);

void rtw_iface_enable_tsf_update(_adapter *adapter);
void rtw_iface_disable_tsf_update(_adapter *adapter);
void rtw_hal_periodic_tsf_update_chk(_adapter *adapter);
void rtw_hal_periodic_tsf_update_end_timer_hdl(void *ctx);

#if CONFIG_TX_AC_LIFETIME
#define TX_ACLT_CONF_DEFAULT	0
#define TX_ACLT_CONF_AP_M2U		1
#define TX_ACLT_CONF_MESH		2
#define TX_ACLT_CONF_NUM		3

extern const char *const _tx_aclt_conf_str[];
#define tx_aclt_conf_str(conf) (((conf) >= TX_ACLT_CONF_NUM) ? _tx_aclt_conf_str[TX_ACLT_CONF_NUM] : _tx_aclt_conf_str[(conf)])

struct tx_aclt_conf_t {
	u8 en;
	u32 vo_vi;
	u32 be_bk;
};

void dump_tx_aclt_force_val(void *sel, struct dvobj_priv *dvobj);
void rtw_hal_set_tx_aclt_force_val(_adapter *adapter, struct tx_aclt_conf_t *input, u8 arg_num);
void dump_tx_aclt_confs(void *sel, struct dvobj_priv *dvobj);
void rtw_hal_set_tx_aclt_conf(_adapter *adapter, u8 conf_idx, struct tx_aclt_conf_t *input, u8 arg_num);
void rtw_hal_update_tx_aclt(_adapter *adapter);
#endif

void hw_var_port_switch(_adapter *adapter);
void rtw_var_set_basic_rate(PADAPTER padapter, u8 *val);
u8 SetHwReg(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg(PADAPTER padapter, u8 variable, u8 *val);
void rtw_hal_check_rxfifo_full(_adapter *adapter);
void rtw_hal_reqtxrpt(_adapter *padapter, u8 macid);

u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);

BOOLEAN
eqNByte(
	u8	*str1,
	u8	*str2,
	u32	num
);

u32
MapCharToHexDigit(
		char	chTmp
);

BOOLEAN
GetHexValueFromString(
			char		*szStr,
			u32			*pu4bVal,
			u32			*pu4bMove
);

BOOLEAN
GetFractionValueFromString(
			char	*szStr,
			u8		*pInteger,
			u8		*pFraction,
			u32		*pu4bMove
);

BOOLEAN
IsCommentString(
			char		*szStr
);

BOOLEAN
ParseQualifiedString(
		char *In,
		u32 *Start,
		char *Out,
		char LeftQualifier,
		char RightQualifier
);

BOOLEAN
GetU1ByteIntegerFromStringInDecimal(
			char *Str,
			u8 *pInt
);

BOOLEAN
isAllSpaceOrTab(
	u8	*data,
	u8	size
);

void linked_info_dump(_adapter *padapter, u8 benable);
#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
	void rtw_get_raw_rssi_info(void *sel, _adapter *padapter);
	void rtw_dump_raw_rssi_info(_adapter *padapter, void *sel);
#endif

#ifdef DBG_RX_DFRAME_RAW_DATA
	void rtw_dump_rx_dframe_info(_adapter *padapter, void *sel);
#endif
void rtw_store_phy_info(_adapter *padapter, union recv_frame *prframe);
#define		HWSET_MAX_SIZE			1024

#ifdef CONFIG_EFUSE_CONFIG_FILE
u32 Hal_readPGDataFromConfigFile(PADAPTER padapter);
u32 Hal_ReadMACAddrFromFile(PADAPTER padapter, u8 *mac_addr);
#endif /* CONFIG_EFUSE_CONFIG_FILE */

int hal_efuse_macaddr_offset(_adapter *adapter);
int Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8 *mac_addr);
void rtw_dump_cur_efuse(PADAPTER padapter);

#ifdef CONFIG_RF_POWER_TRIM
	void rtw_bb_rf_gain_offset(_adapter *padapter);
#endif /*CONFIG_RF_POWER_TRIM*/

void dm_DynamicUsbTxAgg(_adapter *padapter, u8 from_timer);
u8 rtw_hal_busagg_qsel_check(_adapter *padapter, u8 pre_qsel, u8 next_qsel);

u8 rtw_get_current_tx_rate(_adapter *padapter, struct sta_info *psta);
u8 rtw_get_current_tx_sgi(_adapter *padapter, struct sta_info *psta);
#ifdef CONFIG_CUSTOMER01_SMART_ANTENNA
void rtw_hal_set_pathb_phase(_adapter *adapter, u8 phase_idx);
#endif
void rtw_hal_set_fw_rsvd_page(_adapter *adapter, bool finished);
u8 rtw_hal_get_rsvd_page_num(struct _ADAPTER *adapter);

#ifdef CONFIG_TSF_RESET_OFFLOAD
int rtw_hal_reset_tsf(_adapter *adapter, u8 reset_port);
#endif
u64 rtw_hal_get_tsftr_by_port(_adapter *adapter, u8 port);

#ifdef CONFIG_TDLS
	#ifdef CONFIG_TDLS_CH_SW
		s32 rtw_hal_ch_sw_oper_offload(_adapter *padapter, u8 channel, u8 channel_offset, u16 bwmode);
	#endif
#endif
#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
s32 rtw_hal_set_wifi_btc_port_id_cmd(_adapter *adapter);
#endif

void rtw_lps_state_chk(_adapter *adapter, u8 ps_mode);

#ifdef CONFIG_GPIO_API
	u8 rtw_hal_get_gpio(_adapter *adapter, u8 gpio_num);
	int rtw_hal_set_gpio_output_value(_adapter *adapter, u8 gpio_num, bool isHigh);
	int rtw_hal_config_gpio(_adapter *adapter, u8 gpio_num, bool isOutput);
	int rtw_hal_register_gpio_interrupt(_adapter *adapter, int gpio_num, void(*callback)(u8 level));
	int rtw_hal_disable_gpio_interrupt(_adapter *adapter, int gpio_num);
#endif

s8 rtw_hal_ch_sw_iqk_info_search(_adapter *padapter, u8 central_chnl, u8 bw_mode);
void rtw_hal_ch_sw_iqk_info_backup(_adapter *adapter);
void rtw_hal_ch_sw_iqk_info_restore(_adapter *padapter, u8 ch_sw_use_case);

#ifdef CONFIG_GPIO_WAKEUP
	void rtw_hal_switch_gpio_wl_ctrl(_adapter *padapter, u8 index, u8 enable);
	void rtw_hal_set_output_gpio(_adapter *padapter, u8 index, u8 outputval);
	void rtw_hal_set_input_gpio(_adapter *padapter, u8 index);
#endif

#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
	extern char *rtw_phy_file_path;
	extern char rtw_phy_para_file_path[PATH_LENGTH_MAX];
	#define GetLineFromBuffer(buffer)   strsep(&buffer, "\r\n")
#endif

void update_IOT_info(_adapter *padapter);
#ifdef CONFIG_RTS_FULL_BW
void rtw_set_rts_bw(_adapter *padapter);
#endif/*CONFIG_RTS_FULL_BW*/

void ResumeTxBeacon(_adapter *padapter);
void StopTxBeacon(_adapter *padapter);

#ifdef CONFIG_ANTENNA_DIVERSITY
	u8	rtw_hal_antdiv_before_linked(_adapter *padapter);
	void	rtw_hal_antdiv_rssi_compared(_adapter *padapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
#endif

#ifdef DBG_SEC_CAM_MOVE
	void rtw_hal_move_sta_gk_to_dk(_adapter *adapter);
	void rtw_hal_read_sta_dk_key(_adapter *adapter, u8 key_id);
#endif

#ifdef CONFIG_LPS_PG
#define LPSPG_RSVD_PAGE_SET_MACID(_rsvd_pag, _value)		SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 0, 8, _value)/*used macid*/
#define LPSPG_RSVD_PAGE_SET_MBSSCAMID(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 8, 8, _value)/*used BSSID CAM entry*/
#define LPSPG_RSVD_PAGE_SET_PMC_NUM(_rsvd_pag, _value)		SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 16, 8, _value)/*Max used Pattern Match CAM entry*/
#define LPSPG_RSVD_PAGE_SET_MU_RAID_GID(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 24, 8, _value)/*Max MU rate table Group ID*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_NUM(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x04, 0, 8, _value)/*used Security CAM entry number*/
#define LPSPG_RSVD_PAGE_SET_DRV_RSVDPAGE_NUM(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x04, 8, 8, _value)/*Txbuf used page number for fw offload*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID1(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 0, 8, _value)/*used Security CAM entry -1*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID2(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 8, 8, _value)/*used Security CAM entry -2*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID3(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 16, 8, _value)/*used Security CAM entry -3*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID4(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 24, 8, _value)/*used Security CAM entry -4*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID5(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 0, 8, _value)/*used Security CAM entry -5*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID6(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 8, 8, _value)/*used Security CAM entry -6*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID7(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 16, 8, _value)/*used Security CAM entry -7*/
#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID8(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 24, 8, _value)/*used Security CAM entry -8*/
enum lps_pg_hdl_id {
	LPS_PG_INFO_CFG = 0,
	LPS_PG_REDLEMEM,
	LPS_PG_PHYDM_DIS,
	LPS_PG_PHYDM_EN,
};

u8 rtw_hal_set_lps_pg_info(_adapter *adapter);
#endif

int rtw_hal_get_rsvd_page(_adapter *adapter, u32 page_offset, u32 page_num, u8 *buffer, u32 buffer_size);
void rtw_hal_construct_beacon(_adapter *padapter, u8 *pframe, u32 *pLength);
void rtw_hal_construct_NullFunctionData(PADAPTER, u8 *pframe, u32 *pLength,
				u8 bQoS, u8 AC, u8 bEosp, u8 bForcePowerSave);

#ifdef CONFIG_WOWLAN
struct rtl_wow_pattern {
	u16	crc;
	u8	type;
	u32	mask[4];
};
void rtw_wow_pattern_cam_dump(_adapter *adapter);

#ifdef CONFIG_WOW_PATTERN_HW_CAM
void rtw_wow_pattern_read_cam_ent(_adapter *adapter, u8 id, struct  rtl_wow_pattern *context);
void rtw_dump_wow_pattern(void *sel, struct rtl_wow_pattern *pwow_pattern, u8 idx);
#endif

struct rtw_ndp_info {
	u8 enable:1;
	u8 check_remote_ip:1; /* Need to Check Sender IP or not */
	u8 rsvd:6;
	u8 num_of_target_ip; /* Number of Check IP which NA query IP */
	u8 target_link_addr[6]; /* DUT's MAC address */
	u8 remote_ipv6_addr[16]; /* Just respond IP */
	u8 target_ipv6_addr[16]; /* target IP */
};
#define REMOTE_INFO_CTRL_SET_VALD_EN(target, _value) \
	SET_BITS_TO_LE_4BYTE(target + 0, 0, 8, _value)
#define REMOTE_INFO_CTRL_SET_PTK_EN(target, _value) \
	SET_BITS_TO_LE_4BYTE(target + 1, 0, 1, _value)
#define REMOTE_INFO_CTRL_SET_GTK_EN(target, _value) \
	SET_BITS_TO_LE_4BYTE(target + 1, 1, 1, _value)
#define REMOTE_INFO_CTRL_SET_GTK_IDX(target, _value) \
	SET_BITS_TO_LE_4BYTE(target + 2, 0, 8, _value)
#endif /*CONFIG_WOWLAN*/

void rtw_dump_phy_cap(void *sel, _adapter *adapter);
void rtw_dump_rsvd_page(void *sel, _adapter *adapter, u8 page_offset, u8 page_num);
#ifdef CONFIG_SUPPORT_FIFO_DUMP
void rtw_dump_fifo(void *sel, _adapter *adapter, u8 fifo_sel, u32 fifo_addr, u32 fifo_size);
#endif

#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
s32 rtw_hal_set_default_port_id_cmd(_adapter *adapter, u8 mac_id);
s32 rtw_set_default_port_id(_adapter *adapter);
s32 rtw_set_ps_rsvd_page(_adapter *adapter);

#define get_dft_portid(adapter) (adapter_to_dvobj(adapter)->dft.port_id)
#define get_dft_macid(adapter) (adapter_to_dvobj(adapter)->dft.mac_id)

/*void rtw_search_default_port(_adapter *adapter);*/
#endif

#ifdef CONFIG_P2P_PS
#ifdef RTW_HALMAC
void rtw_set_p2p_ps_offload_cmd(_adapter *adapter, u8 p2p_ps_state);
#endif
#endif

#ifdef RTW_CHANNEL_SWITCH_OFFLOAD
void rtw_hal_switch_chnl_and_set_bw_offload(_adapter *adapter, u8 central_ch, u8 pri_ch_idx, u8 bw);
#endif

s16 translate_dbm_to_percentage(s16 signal);

#ifdef CONFIG_SUPPORT_MULTI_BCN
void rtw_ap_multi_bcn_cfg(_adapter *adapter);
#endif

#ifdef CONFIG_SWTIMER_BASED_TXBCN
#ifdef CONFIG_BCN_RECOVERY
u8 rtw_ap_bcn_recovery(_adapter *padapter);
#endif
#ifdef CONFIG_BCN_XMIT_PROTECT
u8 rtw_ap_bcn_queue_empty_check(_adapter *padapter, u32 txbcn_timer_ms);
#endif
#endif /*CONFIG_SWTIMER_BASED_TXBCN*/

#ifdef CONFIG_FW_HANDLE_TXBCN
void rtw_ap_mbid_bcn_en(_adapter *adapter, u8 mbcn_id);
void rtw_ap_mbid_bcn_dis(_adapter *adapter, u8 mbcn_id);
#endif

void rtw_hal_get_trx_path(struct dvobj_priv *d, enum rf_type *type,
			 enum bb_path *tx, enum bb_path *rx);
#ifdef CONFIG_BEAMFORMING
#ifdef RTW_BEAMFORMING_VERSION_2
void rtw_hal_beamforming_config_csirate(PADAPTER adapter);
#endif
#endif

u8 phy_get_current_tx_num(PADAPTER pAdapter, u8 Rate);

#ifdef CONFIG_RTL8812A
u8 * rtw_hal_set_8812a_vendor_ie(_adapter *padapter , u8 *pframe ,uint *frlen );
#endif

#ifdef CONFIG_PROTSEL_PORT
void rtw_enter_protsel_port(_adapter *padapter, u8 port_sel);
bool rtw_assert_protsel_port(_adapter *padapter, u32 addr, u8 len);
void rtw_leave_protsel_port(_adapter *padapter);
#else
static inline void rtw_enter_protsel_port(_adapter *padapter, u8 port_sel) {}
static inline bool rtw_assert_protsel_port(_adapter *padapter, u32 addr, u8 len) {return true; }
static inline void rtw_leave_protsel_port(_adapter *padapter) {}
#endif
#ifdef CONFIG_PROTSEL_ATIMDTIM
void rtw_enter_protsel_atimdtim(_adapter *padapter, u8 port_sel);
bool rtw_assert_protsel_atimdtim(_adapter *padapter, u32 addr, u8 len);
void rtw_leave_protsel_atimdtim(_adapter *padapter);
#else
static inline void rtw_enter_protsel_atimdtim(_adapter *padapter, u8 port_sel) {}
static inline bool rtw_assert_protsel_atimdtim(_adapter *padapter, u32 addr, u8 len) {return true; }
static inline void rtw_leave_protsel_atimdtim(_adapter *padapter) {}
#endif
#ifdef CONFIG_PROTSEL_MACSLEEP
void rtw_enter_protsel_macsleep(_adapter *padapter, u8 sel);
bool rtw_assert_protsel_macsleep(_adapter *padapter, u32 addr, u8 len);
void rtw_leave_protsel_macsleep(_adapter *padapter);
#else
static inline void rtw_enter_protsel_macsleep(_adapter *padapter, u8 port_sel) {}
static inline bool rtw_assert_protsel_macsleep(_adapter *padapter, u32 addr, u8 len) {return true; }
static inline void rtw_leave_protsel_macsleep(_adapter *padapter) {}
#endif
#endif /* __HAL_COMMON_H__ */
                                        rtl8822bu/src/include/rtw_io.h                                                                      0000644 0001750 0001750 00000045001 14214766567 015100  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/

#ifndef _RTW_IO_H_
#define _RTW_IO_H_

#define NUM_IOREQ		8

#ifdef PLATFORM_LINUX
	#define MAX_PROT_SZ	(64-16)
#endif

#define _IOREADY			0
#define _IO_WAIT_COMPLETE   1
#define _IO_WAIT_RSP        2

/* IO COMMAND TYPE */
#define _IOSZ_MASK_		(0x7F)
#define _IO_WRITE_		BIT(7)
#define _IO_FIXED_		BIT(8)
#define _IO_BURST_		BIT(9)
#define _IO_BYTE_		BIT(10)
#define _IO_HW_			BIT(11)
#define _IO_WORD_		BIT(12)
#define _IO_SYNC_		BIT(13)
#define _IO_CMDMASK_	(0x1F80)


/*
	For prompt mode accessing, caller shall free io_req
	Otherwise, io_handler will free io_req
*/



/* IO STATUS TYPE */
#define _IO_ERR_		BIT(2)
#define _IO_SUCCESS_	BIT(1)
#define _IO_DONE_		BIT(0)


#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)

#define IO_RD32_ASYNC	(_IO_WORD_)
#define IO_RD16_ASYNC	(_IO_HW_)
#define IO_RD8_ASYNC	(_IO_BYTE_)

#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)

#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)

/*

	Only Sync. burst accessing is provided.

*/

#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))



/* below is for the intf_option bit defition... */

#define _INTF_ASYNC_	BIT(0)	/* support async io */

struct intf_priv;
struct intf_hdl;
struct io_queue;

struct _io_ops {
	u8(*_read8)(struct intf_hdl *pintfhdl, u32 addr);
	u16(*_read16)(struct intf_hdl *pintfhdl, u32 addr);
	u32(*_read32)(struct intf_hdl *pintfhdl, u32 addr);

	int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
	int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
	int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
	int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);

	int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
	int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
	int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);

	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);

	void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);

	u32(*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);

	u32(*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
	u32(*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);

	u32(*_write_scsi)(struct intf_hdl *pintfhdl, u32 cnt, u8 *pmem);

	void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
	void (*_write_port_cancel)(struct intf_hdl *pintfhdl);

#ifdef CONFIG_SDIO_HCI
	u8(*_sd_f0_read8)(struct intf_hdl *pintfhdl, u32 addr);
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
	u8(*_sd_iread8)(struct intf_hdl *pintfhdl, u32 addr);
	u16(*_sd_iread16)(struct intf_hdl *pintfhdl, u32 addr);
	u32(*_sd_iread32)(struct intf_hdl *pintfhdl, u32 addr);
	int (*_sd_iwrite8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
	int (*_sd_iwrite16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
	int (*_sd_iwrite32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
#endif

};

struct io_req {
	_list	list;
	u32	addr;
	volatile u32	val;
	u32	command;
	u32	status;
	u8	*pbuf;
	_sema	sema;
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt);
	u8 *cnxt;
};

struct	intf_hdl {
	_adapter *padapter;
	struct dvobj_priv *pintf_dev;/*	pointer to &(padapter->dvobjpriv); */
	struct _io_ops	io_ops;
};

struct reg_protocol_rd {

#ifdef CONFIG_LITTLE_ENDIAN

	/* DW1 */
	u32		NumOfTrans:4;
	u32		Reserved1:4;
	u32		Reserved2:24;
	/* DW2 */
	u32		ByteCount:7;
	u32		WriteEnable:1;		/* 0:read, 1:write */
	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
	u32		BurstMode:1;
	u32		Byte1Access:1;
	u32		Byte2Access:1;
	u32		Byte4Access:1;
	u32		Reserved3:3;
	u32		Reserved4:16;
	/* DW3 */
	u32		BusAddress;
	/* DW4 */
	/* u32		Value; */
#else


	/* DW1 */
	u32 Reserved1:4;
	u32 NumOfTrans:4;

	u32 Reserved2:24;

	/* DW2 */
	u32 WriteEnable:1;
	u32 ByteCount:7;


	u32 Reserved3:3;
	u32 Byte4Access:1;

	u32 Byte2Access:1;
	u32 Byte1Access:1;
	u32 BurstMode:1;
	u32 FixOrContinuous:1;

	u32 Reserved4:16;

	/* DW3 */
	u32		BusAddress;

	/* DW4 */
	/* u32		Value; */

#endif

};


struct reg_protocol_wt {


#ifdef CONFIG_LITTLE_ENDIAN

	/* DW1 */
	u32		NumOfTrans:4;
	u32		Reserved1:4;
	u32		Reserved2:24;
	/* DW2 */
	u32		ByteCount:7;
	u32		WriteEnable:1;		/* 0:read, 1:write */
	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
	u32		BurstMode:1;
	u32		Byte1Access:1;
	u32		Byte2Access:1;
	u32		Byte4Access:1;
	u32		Reserved3:3;
	u32		Reserved4:16;
	/* DW3 */
	u32		BusAddress;
	/* DW4 */
	u32		Value;

#else
	/* DW1 */
	u32 Reserved1:4;
	u32 NumOfTrans:4;

	u32 Reserved2:24;

	/* DW2 */
	u32 WriteEnable:1;
	u32 ByteCount:7;

	u32 Reserved3:3;
	u32 Byte4Access:1;

	u32 Byte2Access:1;
	u32 Byte1Access:1;
	u32 BurstMode:1;
	u32 FixOrContinuous:1;

	u32 Reserved4:16;

	/* DW3 */
	u32		BusAddress;

	/* DW4 */
	u32		Value;

#endif

};
#ifdef CONFIG_PCI_HCI
#define MAX_CONTINUAL_IO_ERR 4
#endif

#ifdef CONFIG_USB_HCI
#define MAX_CONTINUAL_IO_ERR 4
#endif

#ifdef CONFIG_SDIO_HCI
#define SD_IO_TRY_CNT (8)
#define MAX_CONTINUAL_IO_ERR SD_IO_TRY_CNT
#endif

#ifdef CONFIG_GSPI_HCI
#define SD_IO_TRY_CNT (8)
#define MAX_CONTINUAL_IO_ERR SD_IO_TRY_CNT
#endif


int rtw_inc_and_chk_continual_io_error(struct dvobj_priv *dvobj);
void rtw_reset_continual_io_error(struct dvobj_priv *dvobj);

/*
Below is the data structure used by _io_handler

*/

struct io_queue {
	_lock	lock;
	_list	free_ioreqs;
	_list		pending;		/* The io_req list that will be served in the single protocol read/write.	 */
	_list		processing;
	u8	*free_ioreqs_buf; /* 4-byte aligned */
	u8	*pallocated_free_ioreqs_buf;
	struct	intf_hdl	intf;
};

struct io_priv {

	_adapter *padapter;

	struct intf_hdl intf;

};

extern uint ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
extern void sync_ioreq_enqueue(struct io_req *preq, struct io_queue *ioqueue);
extern uint sync_ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);


extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
extern struct io_req *alloc_ioreq(struct io_queue *pio_q);

extern uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl);
extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);

extern void _rtw_attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
extern void _rtw_attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);

extern u8 _rtw_read8(_adapter *adapter, u32 addr);
extern u16 _rtw_read16(_adapter *adapter, u32 addr);
extern u32 _rtw_read32(_adapter *adapter, u32 addr);
extern void _rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
extern void _rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
extern void _rtw_read_port_cancel(_adapter *adapter);


extern int _rtw_write8(_adapter *adapter, u32 addr, u8 val);
extern int _rtw_write16(_adapter *adapter, u32 addr, u16 val);
extern int _rtw_write32(_adapter *adapter, u32 addr, u32 val);
extern int _rtw_writeN(_adapter *adapter, u32 addr, u32 length, u8 *pdata);

#ifdef CONFIG_SDIO_HCI
u8 _rtw_sd_f0_read8(_adapter *adapter, u32 addr);
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
u8 _rtw_sd_iread8(_adapter *adapter, u32 addr);
u16 _rtw_sd_iread16(_adapter *adapter, u32 addr);
u32 _rtw_sd_iread32(_adapter *adapter, u32 addr);
int _rtw_sd_iwrite8(_adapter *adapter, u32 addr, u8 val);
int _rtw_sd_iwrite16(_adapter *adapter, u32 addr, u16 val);
int _rtw_sd_iwrite32(_adapter *adapter, u32 addr, u32 val);
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
#endif /* CONFIG_SDIO_HCI */

extern int _rtw_write8_async(_adapter *adapter, u32 addr, u8 val);
extern int _rtw_write16_async(_adapter *adapter, u32 addr, u16 val);
extern int _rtw_write32_async(_adapter *adapter, u32 addr, u32 val);

extern void _rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
extern u32 _rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
u32 _rtw_write_port_and_wait(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem, int timeout_ms);
extern void _rtw_write_port_cancel(_adapter *adapter);

#ifdef DBG_IO
u32 match_read_sniff(_adapter *adapter, u32 addr, u16 len, u32 val);
u32 match_write_sniff(_adapter *adapter, u32 addr, u16 len, u32 val);
bool match_rf_read_sniff_ranges(_adapter *adapter, u8 path, u32 addr, u32 mask);
bool match_rf_write_sniff_ranges(_adapter *adapter, u8 path, u32 addr, u32 mask);

void dbg_rtw_reg_read_monitor(_adapter *adapter, u32 addr, u32 len, u32 val, const char *caller, const int line);
void dbg_rtw_reg_write_monitor(_adapter *adapter, u32 addr, u32 len, u32 val, const char *caller, const int line);

extern u8 dbg_rtw_read8(_adapter *adapter, u32 addr, const char *caller, const int line);
extern u16 dbg_rtw_read16(_adapter *adapter, u32 addr, const char *caller, const int line);
extern u32 dbg_rtw_read32(_adapter *adapter, u32 addr, const char *caller, const int line);

extern int dbg_rtw_write8(_adapter *adapter, u32 addr, u8 val, const char *caller, const int line);
extern int dbg_rtw_write16(_adapter *adapter, u32 addr, u16 val, const char *caller, const int line);
extern int dbg_rtw_write32(_adapter *adapter, u32 addr, u32 val, const char *caller, const int line);
extern int dbg_rtw_writeN(_adapter *adapter, u32 addr , u32 length , u8 *data, const char *caller, const int line);

#ifdef CONFIG_SDIO_HCI
u8 dbg_rtw_sd_f0_read8(_adapter *adapter, u32 addr, const char *caller, const int line);
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
u8 dbg_rtw_sd_iread8(_adapter *adapter, u32 addr, const char *caller, const int line);
u16 dbg_rtw_sd_iread16(_adapter *adapter, u32 addr, const char *caller, const int line);
u32 dbg_rtw_sd_iread32(_adapter *adapter, u32 addr, const char *caller, const int line);
int dbg_rtw_sd_iwrite8(_adapter *adapter, u32 addr, u8 val, const char *caller, const int line);
int dbg_rtw_sd_iwrite16(_adapter *adapter, u32 addr, u16 val, const char *caller, const int line);
int dbg_rtw_sd_iwrite32(_adapter *adapter, u32 addr, u32 val, const char *caller, const int line);
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
#endif /* CONFIG_SDIO_HCI */

#define rtw_read8(adapter, addr) dbg_rtw_read8((adapter), (addr), __FUNCTION__, __LINE__)
#define rtw_read16(adapter, addr) dbg_rtw_read16((adapter), (addr), __FUNCTION__, __LINE__)
#define rtw_read32(adapter, addr) dbg_rtw_read32((adapter), (addr), __FUNCTION__, __LINE__)
#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))

#define  rtw_write8(adapter, addr, val) dbg_rtw_write8((adapter), (addr), (val), __FUNCTION__, __LINE__)
#define  rtw_write16(adapter, addr, val) dbg_rtw_write16((adapter), (addr), (val), __FUNCTION__, __LINE__)
#define  rtw_write32(adapter, addr, val) dbg_rtw_write32((adapter), (addr), (val), __FUNCTION__, __LINE__)
#define  rtw_writeN(adapter, addr, length, data) dbg_rtw_writeN((adapter), (addr), (length), (data), __FUNCTION__, __LINE__)

#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))

#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), addr, cnt, mem)
#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port(adapter, addr, cnt, mem)
#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel(adapter)

#ifdef CONFIG_SDIO_HCI
#define rtw_sd_f0_read8(adapter, addr) dbg_rtw_sd_f0_read8((adapter), (addr), __func__, __LINE__)
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
#define rtw_sd_iread8(adapter, addr) dbg_rtw_sd_iread8((adapter), (addr), __func__, __LINE__)
#define rtw_sd_iread16(adapter, addr) dbg_rtw_sd_iread16((adapter), (addr), __func__, __LINE__)
#define rtw_sd_iread32(adapter, addr) dbg_rtw_sd_iread32((adapter), (addr), __func__, __LINE__)
#define rtw_sd_iwrite8(adapter, addr, val) dbg_rtw_sd_iwrite8((adapter), (addr), (val), __func__, __LINE__)
#define rtw_sd_iwrite16(adapter, addr, val) dbg_rtw_sd_iwrite16((adapter), (addr), (val), __func__, __LINE__)
#define rtw_sd_iwrite32(adapter, addr, val) dbg_rtw_sd_iwrite32((adapter), (addr), (val), __func__, __LINE__)
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
#endif /* CONFIG_SDIO_HCI */

#else /* DBG_IO */
#define rtw_read8(adapter, addr) _rtw_read8((adapter), (addr))
#define rtw_read16(adapter, addr) _rtw_read16((adapter), (addr))
#define rtw_read32(adapter, addr) _rtw_read32((adapter), (addr))
#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))

#define  rtw_write8(adapter, addr, val) _rtw_write8((adapter), (addr), (val))
#define  rtw_write16(adapter, addr, val) _rtw_write16((adapter), (addr), (val))
#define  rtw_write32(adapter, addr, val) _rtw_write32((adapter), (addr), (val))
#define  rtw_writeN(adapter, addr, length, data) _rtw_writeN((adapter), (addr), (length), (data))

#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))

#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), (addr), (cnt), (mem))
#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port((adapter), (addr), (cnt), (mem))
#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel((adapter))

#ifdef CONFIG_SDIO_HCI
#define rtw_sd_f0_read8(adapter, addr) _rtw_sd_f0_read8((adapter), (addr))
#ifdef CONFIG_SDIO_INDIRECT_ACCESS
#define rtw_sd_iread8(adapter, addr) _rtw_sd_iread8((adapter), (addr))
#define rtw_sd_iread16(adapter, addr) _rtw_sd_iread16((adapter), (addr))
#define rtw_sd_iread32(adapter, addr) _rtw_sd_iread32((adapter), (addr))
#define rtw_sd_iwrite8(adapter, addr, val) _rtw_sd_iwrite8((adapter), (addr), (val))
#define rtw_sd_iwrite16(adapter, addr, val) _rtw_sd_iwrite16((adapter), (addr), (val))
#define rtw_sd_iwrite32(adapter, addr, val) _rtw_sd_iwrite32((adapter), (addr), (val))
#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
#endif /* CONFIG_SDIO_HCI */

#endif /* DBG_IO */

extern void rtw_write_scsi(_adapter *adapter, u32 cnt, u8 *pmem);

/* ioreq */
extern void ioreq_read8(_adapter *adapter, u32 addr, u8 *pval);
extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);
extern void ioreq_read32(_adapter *adapter, u32 addr, u32 *pval);
extern void ioreq_write8(_adapter *adapter, u32 addr, u8 val);
extern void ioreq_write16(_adapter *adapter, u32 addr, u16 val);
extern void ioreq_write32(_adapter *adapter, u32 addr, u32 val);


extern uint async_read8(_adapter *adapter, u32 addr, u8 *pbuff,
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
extern uint async_read16(_adapter *adapter, u32 addr,  u8 *pbuff,
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
extern uint async_read32(_adapter *adapter, u32 addr,  u8 *pbuff,
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);

extern void async_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
extern void async_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);

extern void async_write8(_adapter *adapter, u32 addr, u8 val,
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
extern void async_write16(_adapter *adapter, u32 addr, u16 val,
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
extern void async_write32(_adapter *adapter, u32 addr, u32 val,
	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);

extern void async_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
extern void async_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);


int rtw_init_io_priv(_adapter *padapter, void (*set_intf_ops)(_adapter *padapter, struct _io_ops *pops));


extern uint alloc_io_queue(_adapter *adapter);
extern void free_io_queue(_adapter *adapter);
extern void async_bus_io(struct io_queue *pio_q);
extern void bus_sync_io(struct io_queue *pio_q);
extern u32 _ioreq2rwmem(struct io_queue *pio_q);

/*
#define RTL_R8(reg)		rtw_read8(padapter, reg)
#define RTL_R16(reg)            rtw_read16(padapter, reg)
#define RTL_R32(reg)            rtw_read32(padapter, reg)
#define RTL_W8(reg, val8)       rtw_write8(padapter, reg, val8)
#define RTL_W16(reg, val16)     rtw_write16(padapter, reg, val16)
#define RTL_W32(reg, val32)     rtw_write32(padapter, reg, val32)
*/

/*
#define RTL_W8_ASYNC(reg, val8) rtw_write32_async(padapter, reg, val8)
#define RTL_W16_ASYNC(reg, val16) rtw_write32_async(padapter, reg, val16)
#define RTL_W32_ASYNC(reg, val32) rtw_write32_async(padapter, reg, val32)

#define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(padapter, reg, val32)
#define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
*/

#define PlatformEFIOWrite1Byte(_a, _b, _c)		\
	rtw_write8(_a, _b, _c)
#define PlatformEFIOWrite2Byte(_a, _b, _c)		\
	rtw_write16(_a, _b, _c)
#define PlatformEFIOWrite4Byte(_a, _b, _c)		\
	rtw_write32(_a, _b, _c)

#define PlatformEFIORead1Byte(_a, _b)		\
	rtw_read8(_a, _b)
#define PlatformEFIORead2Byte(_a, _b)		\
	rtw_read16(_a, _b)
#define PlatformEFIORead4Byte(_a, _b)		\
	rtw_read32(_a, _b)

#endif /* _RTL8711_IO_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/osdep_service_linux.h                                                         0000644 0001750 0001750 00000035045 14214766567 017655  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __OSDEP_LINUX_SERVICE_H_
#define __OSDEP_LINUX_SERVICE_H_

#include <linux/version.h>
#include <linux/spinlock.h>
#include <linux/compiler.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/namei.h>
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 5))
	#include <linux/kref.h>
#endif
/* #include <linux/smp_lock.h> */
#include <linux/netdevice.h>
#include <linux/inetdevice.h>
#include <linux/skbuff.h>
#include <linux/circ_buf.h>
#include <asm/uaccess.h>
#include <asm/byteorder.h>
#include <asm/atomic.h>
#include <asm/io.h>
#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
	#include <asm/semaphore.h>
#else
	#include <linux/semaphore.h>
#endif
#include <linux/sem.h>
#include <linux/sched.h>
#include <linux/etherdevice.h>
#include <linux/wireless.h>
#include <net/iw_handler.h>
#include <net/addrconf.h>
#include <linux/if_arp.h>
#include <linux/rtnetlink.h>
#include <linux/delay.h>
#include <linux/interrupt.h>	/* for struct tasklet_struct */
#include <linux/ip.h>
#include <linux/kthread.h>
#include <linux/list.h>
#include <linux/vmalloc.h>

#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 5, 41))
	#include <linux/tqueue.h>
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
	#include <uapi/linux/limits.h>
#else
	#include <linux/limits.h>
#endif

#ifdef RTK_DMP_PLATFORM
	#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 12))
		#include <linux/pageremap.h>
	#endif
	#include <asm/io.h>
#endif

#ifdef CONFIG_NET_RADIO
	#define CONFIG_WIRELESS_EXT
#endif

/* Monitor mode */
#include <net/ieee80211_radiotap.h>

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
	#include <linux/ieee80211.h>
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25) && \
	 LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
	#define CONFIG_IEEE80211_HT_ADDT_INFO
#endif

#ifdef CONFIG_IOCTL_CFG80211
	/*	#include <linux/ieee80211.h> */
	#include <net/cfg80211.h>
#endif /* CONFIG_IOCTL_CFG80211 */


#ifdef CONFIG_HAS_EARLYSUSPEND
	#include <linux/earlysuspend.h>
#endif /* CONFIG_HAS_EARLYSUSPEND */

#ifdef CONFIG_EFUSE_CONFIG_FILE
	#include <linux/fs.h>
#endif

#ifdef CONFIG_USB_HCI
	#include <linux/usb.h>
	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 21))
		#include <linux/usb_ch9.h>
	#else
		#include <linux/usb/ch9.h>
	#endif
#endif

#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
	#include <net/sock.h>
	#include <net/tcp.h>
	#include <linux/udp.h>
	#include <linux/in.h>
	#include <linux/netlink.h>
#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */

#ifdef CONFIG_USB_HCI
	typedef struct urb   *PURB;
	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22))
		#ifdef CONFIG_USB_SUSPEND
			#define CONFIG_AUTOSUSPEND	1
		#endif
	#endif
#endif

#if defined(CONFIG_RTW_GRO) && (!defined(CONFIG_RTW_NAPI))

	#error "Enable NAPI before enable GRO\n"

#endif


#if (KERNEL_VERSION(2, 6, 29) > LINUX_VERSION_CODE && defined(CONFIG_RTW_NAPI))

	#undef CONFIG_RTW_NAPI
	/*#warning "Linux Kernel version too old to support NAPI (should newer than 2.6.29)\n"*/

#endif

#if (KERNEL_VERSION(2, 6, 33) > LINUX_VERSION_CODE && defined(CONFIG_RTW_GRO))

	#undef CONFIG_RTW_GRO
	/*#warning "Linux Kernel version too old to support GRO(should newer than 2.6.33)\n"*/

#endif

typedef struct	semaphore _sema;
typedef	spinlock_t	_lock;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
	typedef struct mutex		_mutex;
#else
	typedef struct semaphore	_mutex;
#endif
struct rtw_timer_list {
	struct timer_list timer;
	void (*function)(void *);
	void *arg;
};

typedef struct rtw_timer_list _timer;
typedef struct completion _completion;

struct	__queue	{
	struct	list_head	queue;
	_lock	lock;
};

typedef	struct sk_buff	_pkt;
typedef unsigned char	_buffer;

typedef struct	__queue	_queue;
typedef struct	list_head	_list;

/* hlist */
typedef struct	hlist_head	rtw_hlist_head;
typedef struct	hlist_node	rtw_hlist_node;

/* RCU */
typedef struct rcu_head rtw_rcu_head;
#define rtw_rcu_dereference(p) rcu_dereference((p))
#define rtw_rcu_dereference_protected(p, c) rcu_dereference_protected(p, c)
#define rtw_rcu_assign_pointer(p, v) rcu_assign_pointer((p), (v))
#define rtw_rcu_read_lock() rcu_read_lock()
#define rtw_rcu_read_unlock() rcu_read_unlock()
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
#define rtw_rcu_access_pointer(p) rcu_access_pointer(p)
#endif

/* rhashtable */
#include "../os_dep/linux/rtw_rhashtable.h"

typedef	int	_OS_STATUS;
/* typedef u32	_irqL; */
typedef unsigned long _irqL;
typedef	struct	net_device *_nic_hdl;

typedef void		*_thread_hdl_;
typedef int		thread_return;
typedef void	*thread_context;

typedef void timer_hdl_return;
typedef void *timer_hdl_context;

#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
	typedef struct work_struct _workitem;
#else
	typedef struct tq_struct _workitem;
#endif

#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
#endif

typedef unsigned long systime;
typedef struct tasklet_struct _tasklet;

#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22))
/* Porting from linux kernel, for compatible with old kernel. */
static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
{
	return skb->tail;
}

static inline void skb_reset_tail_pointer(struct sk_buff *skb)
{
	skb->tail = skb->data;
}

static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
{
	skb->tail = skb->data + offset;
}

static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->end;
}
#endif

__inline static void rtw_list_delete(_list *plist)
{
	list_del_init(plist);
}

__inline static _list *get_next(_list	*list)
{
	return list->next;
}

#define LIST_CONTAINOR(ptr, type, member) \
	((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))

#define rtw_list_first_entry(ptr, type, member) list_first_entry(ptr, type, member)

#define rtw_hlist_for_each_entry(pos, head, member) hlist_for_each_entry(pos, head, member)
#define rtw_hlist_for_each_safe(pos, n, head) hlist_for_each_safe(pos, n, head)
#define rtw_hlist_entry(ptr, type, member) hlist_entry(ptr, type, member)
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
#define rtw_hlist_for_each_entry_safe(pos, np, n, head, member) hlist_for_each_entry_safe(pos, n, head, member)
#define rtw_hlist_for_each_entry_rcu(pos, node, head, member) hlist_for_each_entry_rcu(pos, head, member)
#else
#define rtw_hlist_for_each_entry_safe(pos, np, n, head, member) hlist_for_each_entry_safe(pos, np, n, head, member)
#define rtw_hlist_for_each_entry_rcu(pos, node, head, member) hlist_for_each_entry_rcu(pos, node, head, member)
#endif

__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
{
	spin_lock_irqsave(plock, *pirqL);
}

__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
{
	spin_unlock_irqrestore(plock, *pirqL);
}

__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
{
	spin_lock_irqsave(plock, *pirqL);
}

__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
{
	spin_unlock_irqrestore(plock, *pirqL);
}

__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
{
	spin_lock_bh(plock);
}

__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
{
	spin_unlock_bh(plock);
}

__inline static void enter_critical_bh(_lock *plock)
{
	spin_lock_bh(plock);
}

__inline static void exit_critical_bh(_lock *plock)
{
	spin_unlock_bh(plock);
}

__inline static int _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{
	int ret = 0;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
	/* mutex_lock(pmutex); */
	ret = mutex_lock_interruptible(pmutex);
#else
	ret = down_interruptible(pmutex);
#endif
	return ret;
}


__inline static int _enter_critical_mutex_lock(_mutex *pmutex, _irqL *pirqL)
{
	int ret = 0;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
	mutex_lock(pmutex);
#else
	down(pmutex);
#endif
	return ret;
}

__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
	mutex_unlock(pmutex);
#else
	up(pmutex);
#endif
}

__inline static _list	*get_list_head(_queue	*queue)
{
	return &(queue->queue);
}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
static inline void timer_hdl(struct timer_list *in_timer)
#else
static inline void timer_hdl(unsigned long cntx)
#endif
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
	_timer *ptimer = from_timer(ptimer, in_timer, timer);
#else
	_timer *ptimer = (_timer *)cntx;
#endif
	ptimer->function(ptimer->arg);
}

__inline static void _init_timer(_timer *ptimer, _nic_hdl nic_hdl, void *pfunc, void *cntx)
{
	ptimer->function = pfunc;
	ptimer->arg = cntx;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
	timer_setup(&ptimer->timer, timer_hdl, 0);
#else
	/* setup_timer(ptimer, pfunc,(u32)cntx);	 */
	ptimer->timer.function = timer_hdl;
	ptimer->timer.data = (unsigned long)ptimer;
	init_timer(&ptimer->timer);
#endif
}

__inline static void _set_timer(_timer *ptimer, u32 delay_time)
{
	mod_timer(&ptimer->timer , (jiffies + (delay_time * HZ / 1000)));
}

__inline static void _cancel_timer(_timer *ptimer, u8 *bcancelled)
{
	*bcancelled = del_timer_sync(&ptimer->timer) == 1 ? 1 : 0;
}

static inline void _init_workitem(_workitem *pwork, void *pfunc, void *cntx)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20))
	INIT_WORK(pwork, pfunc);
#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
	INIT_WORK(pwork, pfunc, pwork);
#else
	INIT_TQUEUE(pwork, pfunc, pwork);
#endif
}

__inline static void _set_workitem(_workitem *pwork)
{
#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
	schedule_work(pwork);
#else
	schedule_task(pwork);
#endif
}

__inline static void _cancel_workitem_sync(_workitem *pwork)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22))
	cancel_work_sync(pwork);
#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
	flush_scheduled_work();
#else
	flush_scheduled_tasks();
#endif
}
/*
 * Global Mutex: can only be used at PASSIVE level.
 *   */

#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
	{                                                               \
		while (atomic_inc_return((atomic_t *)&(_MutexCounter)) != 1) { \
			atomic_dec((atomic_t *)&(_MutexCounter));        \
			msleep(10);                          \
		}                                                           \
	}

#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
	{                                                               \
		atomic_dec((atomic_t *)&(_MutexCounter));        \
	}

static inline int rtw_netif_queue_stopped(struct net_device *pnetdev)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
	return (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&
		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&
		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)));
#else
	return netif_queue_stopped(pnetdev);
#endif
}

static inline void rtw_netif_wake_queue(struct net_device *pnetdev)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
	netif_tx_wake_all_queues(pnetdev);
#else
	netif_wake_queue(pnetdev);
#endif
}

static inline void rtw_netif_start_queue(struct net_device *pnetdev)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
	netif_tx_start_all_queues(pnetdev);
#else
	netif_start_queue(pnetdev);
#endif
}

static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
	netif_tx_stop_all_queues(pnetdev);
#else
	netif_stop_queue(pnetdev);
#endif
}
static inline void rtw_netif_device_attach(struct net_device *pnetdev)
{
	netif_device_attach(pnetdev);
}
static inline void rtw_netif_device_detach(struct net_device *pnetdev)
{
	netif_device_detach(pnetdev);
}
static inline void rtw_netif_carrier_on(struct net_device *pnetdev)
{
	netif_carrier_on(pnetdev);
}
static inline void rtw_netif_carrier_off(struct net_device *pnetdev)
{
	netif_carrier_off(pnetdev);
}

static inline int rtw_merge_string(char *dst, int dst_len, const char *src1, const char *src2)
{
	int	len = 0;
	len += snprintf(dst + len, dst_len - len, "%s", src1);
	len += snprintf(dst + len, dst_len - len, "%s", src2);

	return len;
}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
	#define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)), (sig), 1)
#else /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
	#define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */


/* Suspend lock prevent system from going suspend */
#ifdef CONFIG_WAKELOCK
	#include <linux/wakelock.h>
#elif defined(CONFIG_ANDROID_POWER)
	#include <linux/android_power.h>
#endif

/* limitation of path length */
#define PATH_LENGTH_MAX PATH_MAX

/* Atomic integer operations */
#define ATOMIC_T atomic_t

#define rtw_netdev_priv(netdev) (((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv)

#define NDEV_FMT "%s"
#define NDEV_ARG(ndev) ndev->name
#define ADPT_FMT "%s"
#define ADPT_ARG(adapter) (adapter->pnetdev ? adapter->pnetdev->name : NULL)
#define FUNC_NDEV_FMT "%s(%s)"
#define FUNC_NDEV_ARG(ndev) __func__, ndev->name
#define FUNC_ADPT_FMT "%s(%s)"
#define FUNC_ADPT_ARG(adapter) __func__, (adapter->pnetdev ? adapter->pnetdev->name : NULL)

struct rtw_netdev_priv_indicator {
	void *priv;
	u32 sizeof_priv;
};
struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
extern struct net_device *rtw_alloc_etherdev(int sizeof_priv);

#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
#define rtw_get_same_net_ndev_by_name(ndev, name) dev_get_by_name(name)
#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
#define rtw_get_same_net_ndev_by_name(ndev, name) dev_get_by_name(ndev->nd_net, name)
#else
#define rtw_get_same_net_ndev_by_name(ndev, name) dev_get_by_name(dev_net(ndev), name)
#endif

#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
#define rtw_get_bridge_ndev_by_name(name) dev_get_by_name(name)
#else
#define rtw_get_bridge_ndev_by_name(name) dev_get_by_name(&init_net, name)
#endif

#define STRUCT_PACKED __attribute__ ((packed))


#endif /* __OSDEP_LINUX_SERVICE_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/rtl8188e_rf.h                                                                 0000644 0001750 0001750 00000001671 14214766567 015570  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_RF_H__
#define __RTL8188E_RF_H__



int	PHY_RF6052_Config8188E(PADAPTER		Adapter);
void		rtl8188e_RF_ChangeTxPath(PADAPTER	Adapter,
			u16		DataRate);
void		rtl8188e_PHY_RF6052SetBandwidth(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);

#endif/* __RTL8188E_RF_H__ */
                                                                       rtl8822bu/src/include/rtw_ap.h                                                                      0000644 0001750 0001750 00000012646 14214766567 015102  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTW_AP_H_
#define __RTW_AP_H_


#ifdef CONFIG_AP_MODE

/* external function */
extern void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta);
extern void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta);


void init_mlme_ap_info(_adapter *padapter);
void free_mlme_ap_info(_adapter *padapter);
u8 rtw_set_tim_ie(u8 dtim_cnt, u8 dtim_period
	, const u8 *tim_bmp, u8 tim_bmp_len, u8 *tim_ie);
/* void update_BCNTIM(_adapter *padapter); */
void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, u8 flags, const char *tag);
#define update_beacon(adapter, ie_id, oui, tx, flags) _update_beacon((adapter), (ie_id), (oui), (tx), (flags), __func__)
/*update_beacon - (flags) can set to normal enqueue (0) and RTW_CMDF_WAIT_ACK enqueue. 
 (flags) = RTW_CMDF_DIRECTLY  is not currently implemented, it will do normal enqueue.*/

void rtw_ap_update_sta_ra_info(_adapter *padapter, struct sta_info *psta);

void expire_timeout_chk(_adapter *padapter);
void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
void rtw_start_bss_hdl_after_chbw_decided(_adapter *adapter);
void start_bss_network(_adapter *padapter, struct createbss_parm *parm);
int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len);
void rtw_ap_restore_network(_adapter *padapter);

#if CONFIG_RTW_MACADDR_ACL
void rtw_macaddr_acl_init(_adapter *adapter, u8 period);
void rtw_macaddr_acl_deinit(_adapter *adapter, u8 period);
void rtw_macaddr_acl_clear(_adapter *adapter, u8 period);
void rtw_set_macaddr_acl(_adapter *adapter, u8 period, int mode);
int rtw_acl_add_sta(_adapter *adapter, u8 period, const u8 *addr);
int rtw_acl_remove_sta(_adapter *adapter, u8 period, const u8 *addr);
#endif /* CONFIG_RTW_MACADDR_ACL */

u8 rtw_ap_set_sta_key(_adapter *adapter, const u8 *addr, u8 alg, const u8 *key, u8 keyid, u8 gk);
u8 rtw_ap_set_pairwise_key(_adapter *padapter, struct sta_info *psta);
int rtw_ap_set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid);
int rtw_ap_set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid, u8 set_tx);

#ifdef CONFIG_NATIVEAP_MLME
void associated_clients_update(_adapter *padapter, u8 updated, u32 sta_info_type);
void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta);
u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta);
void sta_info_update(_adapter *padapter, struct sta_info *psta);
void ap_sta_info_defer_update(_adapter *padapter, struct sta_info *psta);
u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reason, bool enqueue);
int rtw_sta_flush(_adapter *padapter, bool enqueue);
int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset);
void start_ap_mode(_adapter *padapter);
void stop_ap_mode(_adapter *padapter);
#endif

void rtw_ap_update_bss_chbw(_adapter *adapter, WLAN_BSSID_EX *bss, u8 ch, u8 bw, u8 offset);
u8 rtw_ap_chbw_decision(_adapter *adapter, u8 ifbmp, u8 excl_ifbmp
	, s16 req_ch, s8 req_bw, s8 req_offset, u8 *ch, u8 *bw, u8 *offset, u8 *chbw_allow);

#ifdef CONFIG_AUTO_AP_MODE
void rtw_auto_ap_rx_msg_dump(_adapter *padapter, union recv_frame *precv_frame, u8 *ehdr_pos);
extern void rtw_start_auto_ap(_adapter *adapter);
#endif /* CONFIG_AUTO_AP_MODE */

void rtw_ap_parse_sta_capability(_adapter *adapter, struct sta_info *sta, u8 *cap);
u16 rtw_ap_parse_sta_supported_rates(_adapter *adapter, struct sta_info *sta, u8 *tlv_ies, u16 tlv_ies_len);
u16 rtw_ap_parse_sta_security_ie(_adapter *adapter, struct sta_info *sta, struct rtw_ieee802_11_elems *elems);
void rtw_ap_parse_sta_wmm_ie(_adapter *adapter, struct sta_info *sta, u8 *tlv_ies, u16 tlv_ies_len);
void rtw_ap_parse_sta_ht_ie(_adapter *adapter, struct sta_info *sta, struct rtw_ieee802_11_elems *elems);
void rtw_ap_parse_sta_vht_ie(_adapter *adapter, struct sta_info *sta, struct rtw_ieee802_11_elems *elems);

void update_bmc_sta(_adapter *padapter);

#ifdef CONFIG_BMC_TX_RATE_SELECT
void rtw_update_bmc_sta_tx_rate(_adapter *adapter);
#endif

void rtw_process_ht_action_smps(_adapter *padapter, u8 *ta, u8 ctrl_field);
void rtw_process_public_act_bsscoex(_adapter *padapter, u8 *pframe, uint frame_len);
#ifdef CONFIG_80211N_HT
int rtw_ht_operation_update(_adapter *padapter);
#endif /* CONFIG_80211N_HT */
u8 rtw_ap_sta_states_check(_adapter *adapter);

#ifdef CONFIG_FW_HANDLE_TXBCN
#define rtw_ap_get_nums(adapter)	(adapter_to_dvobj(adapter)->nr_ap_if)
bool rtw_ap_nums_check(_adapter *adapter);
#endif

#ifdef CONFIG_SWTIMER_BASED_TXBCN
void tx_beacon_handlder(struct dvobj_priv *pdvobj);
void tx_beacon_timer_handlder(void *ctx);
#endif /*CONFIG_SWTIMER_BASED_TXBCN*/

#endif /* end of CONFIG_AP_MODE */
#endif /*__RTW_AP_H_*/
                                                                                          rtl8822bu/src/include/rtl8192f_hal.h                                                                0000644 0001750 0001750 00000024552 14214766567 015724  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_HAL_H__
#define __RTL8192F_HAL_H__

#include "hal_data.h"

#include "rtl8192f_spec.h"
#include "rtl8192f_rf.h"
#include "rtl8192f_dm.h"
#include "rtl8192f_recv.h"
#include "rtl8192f_xmit.h"
#include "rtl8192f_cmd.h"
#include "rtl8192f_led.h"
#include "Hal8192FPwrSeq.h"
#include "Hal8192FPhyReg.h"
#include "Hal8192FPhyCfg.h"
#ifdef DBG_CONFIG_ERROR_DETECT
#include "rtl8192f_sreset.h"
#endif
#ifdef CONFIG_LPS_POFF
	#include "rtl8192f_lps_poff.h"
#endif

#define FW_8192F_SIZE		0x8000
#define FW_8192F_START_ADDRESS	0x4000
#define FW_8192F_END_ADDRESS	0x5000 /* brian_zhang@realsil.com.cn */

#define IS_FW_HEADER_EXIST_8192F(_pFwHdr)\
	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x92F0)

typedef struct _RT_FIRMWARE {
	FIRMWARE_SOURCE	eFWSource;
#ifdef CONFIG_EMBEDDED_FWIMG
	u8			*szFwBuffer;
#else
	u8			szFwBuffer[FW_8192F_SIZE];
#endif
	u32			ulFwLength;
} RT_FIRMWARE_8192F, *PRT_FIRMWARE_8192F;

/*
 * This structure must be cared byte-ordering
 *
 * Added by tynli. 2009.12.04. */
typedef struct _RT_8192F_FIRMWARE_HDR {
	/* 8-byte alinment required */

	/* --- LONG WORD 0 ---- */
	u16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
	u8		Category;	/* AP/NIC and USB/PCI */
	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
	u16		Version;		/* FW Version */
	u16		Subversion;	/* FW Subversion, default 0x00 */

	/* --- LONG WORD 1 ---- */
	u8		Month;	/* Release time Month field */
	u8		Date;	/* Release time Date field */
	u8		Hour;	/* Release time Hour field */
	u8		Minute;	/* Release time Minute field */
	u16		RamCodeSize;	/* The size of RAM code */
	u16		Rsvd2;

	/* --- LONG WORD 2 ---- */
	u32		SvnIdx;	/* The SVN entry index */
	u32		Rsvd3;

	/* --- LONG WORD 3 ---- */
	u32		Rsvd4;
	u32		Rsvd5;
} RT_8192F_FIRMWARE_HDR, *PRT_8192F_FIRMWARE_HDR;
#define DRIVER_EARLY_INT_TIME_8192F		0x05
#define BCN_DMA_ATIME_INT_TIME_8192F		0x02
/* for 8192F
 * TX 64K, RX 16K, Page size 256B for TX*/
#define PAGE_SIZE_TX_8192F			256
#define PAGE_SIZE_RX_8192F			8
#define TX_DMA_SIZE_8192F			0x10000/* 64K(TX) */
#define RX_DMA_SIZE_8192F			0x4000/* 16K(RX) */
#ifdef CONFIG_WOWLAN
	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
#else
	#define RESV_FMWF	0
#endif

#ifdef CONFIG_FW_C2H_DEBUG
	#define RX_DMA_RESERVED_SIZE_8192F	0x100	/* 256B, reserved for c2h debug message */
#else
	#define RX_DMA_RESERVED_SIZE_8192F	0xc0	/* 192B, reserved for tx report 24*8=192*/
#endif
#define RX_DMA_BOUNDARY_8192F\
	(RX_DMA_SIZE_8192F - RX_DMA_RESERVED_SIZE_8192F - 1)


/* Note: We will divide number of page equally for each queue other than public queue! */

/* For General Reserved Page Number(Beacon Queue is reserved page)
 * Beacon:MAX_BEACON_LEN/PAGE_SIZE_TX_8192F
 * PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1,CTS-2-SELF,LTE QoS Null*/
#define BCNQ_PAGE_NUM_8192F		(MAX_BEACON_LEN/PAGE_SIZE_TX_8192F + 6) /*0x08*/


/* For WoWLan , more reserved page
 * ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, AOAC rpt 1, PNO: 6
 * NS offload: 2 NDP info: 1
 */
#ifdef CONFIG_WOWLAN
	/* 7 pages for wow rsvd page + 2 pages for pattern */
	#define WOWLAN_PAGE_NUM_8192F	0x09
#else
	#define WOWLAN_PAGE_NUM_8192F	0x00
#endif

#ifdef CONFIG_PNO_SUPPORT
	#undef WOWLAN_PAGE_NUM_8192F
	#define WOWLAN_PAGE_NUM_8192F	0x15
#endif

#ifdef CONFIG_AP_WOWLAN
	#define AP_WOWLAN_PAGE_NUM_8192F	0x02
#endif

#ifdef DBG_LA_MODE
	#define LA_MODE_PAGE_NUM 0xE0
#endif

#define MAX_RX_DMA_BUFFER_SIZE_8192F	(RX_DMA_SIZE_8192F - RX_DMA_RESERVED_SIZE_8192F)

#ifdef DBG_LA_MODE
	#define TX_TOTAL_PAGE_NUMBER_8192F	(0xFF - LA_MODE_PAGE_NUM)
#else
	#define TX_TOTAL_PAGE_NUMBER_8192F	(0xFF - BCNQ_PAGE_NUM_8192F - WOWLAN_PAGE_NUM_8192F)
#endif

#define TX_PAGE_BOUNDARY_8192F		(TX_TOTAL_PAGE_NUMBER_8192F + 1)

#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8192F \
	TX_TOTAL_PAGE_NUMBER_8192F
#define WMM_NORMAL_TX_PAGE_BOUNDARY_8192F \
	(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8192F + 1)

/* For Normal Chip Setting
 * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8192F */
#define NORMAL_PAGE_NUM_HPQ_8192F		0x8
#define NORMAL_PAGE_NUM_LPQ_8192F		0x8
#define NORMAL_PAGE_NUM_NPQ_8192F		0x8
#define NORMAL_PAGE_NUM_EPQ_8192F		0x00

/* Note: For Normal Chip Setting, modify later */
#define WMM_NORMAL_PAGE_NUM_HPQ_8192F		0x30
#define WMM_NORMAL_PAGE_NUM_LPQ_8192F		0x20
#define WMM_NORMAL_PAGE_NUM_NPQ_8192F		0x20
#define WMM_NORMAL_PAGE_NUM_EPQ_8192F		0x00


#include "HalVerDef.h"
#include "hal_com.h"

#define EFUSE_OOB_PROTECT_BYTES 56 /*0x1C8~0x1FF*/

#define HAL_EFUSE_MEMORY
#define HWSET_MAX_SIZE_8192F                512
#define EFUSE_REAL_CONTENT_LEN_8192F        512
#define EFUSE_MAP_LEN_8192F                 512
#define EFUSE_MAX_SECTION_8192F            64

/* For some inferiority IC purpose. added by Roger, 2009.09.02.*/
#define EFUSE_IC_ID_OFFSET			506
#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN_8192F)

#define EFUSE_ACCESS_ON		0x69
#define EFUSE_ACCESS_OFF	0x00

/* ********************************************************
 *			EFUSE for BT definition
 * ******************************************************** */
#define BANK_NUM			1
#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
#define EFUSE_BT_REAL_CONTENT_LEN	1536/*512 * 3 */
/*	(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)*/
#define EFUSE_BT_MAP_LEN		1024	/* 1k bytes */
#define EFUSE_BT_MAX_SECTION		128 /* 1024/8 */
#define EFUSE_PROTECT_BYTES_BANK	16

typedef enum tag_Package_Definition {
	PACKAGE_DEFAULT,
	PACKAGE_QFN32,
	PACKAGE_QFN40,
	PACKAGE_QFN46
} PACKAGE_TYPE_E;

#define INCLUDE_MULTI_FUNC_BT(_Adapter) \
	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
#define INCLUDE_MULTI_FUNC_GPS(_Adapter) \
	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)

#ifdef CONFIG_FILE_FWIMG
	extern char *rtw_fw_file_path;
	extern char *rtw_fw_wow_file_path;
	#ifdef CONFIG_MP_INCLUDED
		extern char *rtw_fw_mp_bt_file_path;
	#endif /* CONFIG_MP_INCLUDED */
#endif /* CONFIG_FILE_FWIMG */

/* rtl8192f_hal_init.c */
s32 rtl8192f_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
void rtl8192f_FirmwareSelfReset(PADAPTER padapter);
void rtl8192f_InitializeFirmwareVars(PADAPTER padapter);

void rtl8192f_InitAntenna_Selection(PADAPTER padapter);
void rtl8192f_DeinitAntenna_Selection(PADAPTER padapter);
void rtl8192f_CheckAntenna_Selection(PADAPTER padapter);
void rtl8192f_init_default_value(PADAPTER padapter);

s32 rtl8192f_InitLLTTable(PADAPTER padapter);

s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
s32 CardDisableWithoutHWSM(PADAPTER padapter);

/* EFuse */
u8 GetEEPROMSize8192F(PADAPTER padapter);
void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
void Hal_EfuseParseTxPowerInfo_8192F(PADAPTER padapter,
					u8 *PROMContent, BOOLEAN AutoLoadFail);
#ifdef CONFIG_BT_COEXIST
void Hal_EfuseParseBTCoexistInfo_8192F(PADAPTER padapter,
				       u8 *hwinfo, BOOLEAN AutoLoadFail);
#endif /* CONFIG_BT_COEXIST */
void Hal_EfuseParseEEPROMVer_8192F(PADAPTER padapter,
				   u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseChnlPlan_8192F(PADAPTER padapter,
				  u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseCustomerID_8192F(PADAPTER padapter,
				    u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseAntennaDiversity_8192F(PADAPTER padapter,
		u8 *hwinfo, BOOLEAN AutoLoadFail);
void Hal_EfuseParseXtal_8192F(PADAPTER pAdapter,
			      u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseThermalMeter_8192F(PADAPTER padapter,
				      u8 *hwinfo, u8 AutoLoadFail);
void Hal_EfuseParseVoltage_8192F(PADAPTER pAdapter,
				 u8 *hwinfo, BOOLEAN	AutoLoadFail);
void Hal_EfuseParseBoardType_8192F(PADAPTER Adapter,
				   u8	*PROMContent, BOOLEAN AutoloadFail);
u8	Hal_ReadRFEType_8192F(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
void rtl8192f_set_hal_ops(struct hal_ops *pHalFunc);
void init_hal_spec_8192f(_adapter *adapter);
u8 SetHwReg8192F(PADAPTER padapter, u8 variable, u8 *val);
void GetHwReg8192F(PADAPTER padapter, u8 variable, u8 *val);
u8 SetHalDefVar8192F(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
u8 GetHalDefVar8192F(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);

/* register */
void rtl8192f_InitBeaconParameters(PADAPTER padapter);
void rtl8192f_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);

void _InitMacAPLLSetting_8192F(PADAPTER Adapter);
void _8051Reset8192F(PADAPTER padapter);
#ifdef CONFIG_WOWLAN
	void Hal_DetectWoWMode(PADAPTER pAdapter);
#endif /* CONFIG_WOWLAN */

void rtl8192f_start_thread(_adapter *padapter);
void rtl8192f_stop_thread(_adapter *padapter);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void rtl8192fs_init_checkbthang_workqueue(_adapter *adapter);
	void rtl8192fs_free_checkbthang_workqueue(_adapter *adapter);
	void rtl8192fs_cancle_checkbthang_workqueue(_adapter *adapter);
	void rtl8192fs_hal_check_bt_hang(_adapter *adapter);
#endif

#ifdef CONFIG_GPIO_WAKEUP
	void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
#endif
#ifdef CONFIG_MP_INCLUDED
int FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
#endif
void CCX_FwC2HTxRpt_8192f(PADAPTER padapter, u8 *pdata, u8 len);

u8 MRateToHwRate8192F(u8 rate);
u8 HwRateToMRate8192F(u8 rate);

#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
	void check_bt_status_work(void *data);
#endif


void rtl8192f_cal_txdesc_chksum(struct tx_desc *ptxdesc);

#ifdef CONFIG_AMPDU_PRETX_CD
void rtl8192f_pretx_cd_config(_adapter *adapter);
#endif

#ifdef CONFIG_PCI_HCI
	BOOLEAN	InterruptRecognized8192FE(PADAPTER Adapter);
	void	UpdateInterruptMask8192FE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
	void InitMAC_TRXBD_8192FE(PADAPTER Adapter);

	u16 get_txbd_rw_reg(u16 ff_hwaddr);
#endif

#endif
                                                                                                                                                      rtl8822bu/src/include/hal_gspi.h                                                                    0000644 0001750 0001750 00000002231 14214766567 015361  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_GSPI_H_
#define __HAL_GSPI_H_

#define ffaddr2deviceId(pdvobj, addr)	(pdvobj->Queue2Pipe[addr])

u8 rtw_hal_gspi_max_txoqt_free_space(_adapter *padapter);
u8 rtw_hal_gspi_query_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
void rtw_hal_gspi_update_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
void rtw_hal_set_gspi_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
u32 rtw_hal_get_gspi_tx_max_length(PADAPTER padapter, u8 queue_idx);

#endif
                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8723d_recv.h                                                               0000644 0001750 0001750 00000010131 14214766567 016101  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723D_RECV_H__
#define __RTL8723D_RECV_H__

#define RECV_BLK_SZ 512
#define RECV_BLK_CNT 16
#define RECV_BLK_TH RECV_BLK_CNT

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
			#else
				#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
			#endif
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	/* #ifndef CONFIG_MINIMAL_MEMORY_USAGE */
	/*	#define MAX_RECVBUF_SZ (9100) */
	/* #else */
	#define MAX_RECVBUF_SZ (4000) /* about 4K
	* #endif */


#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)

	#define MAX_RECVBUF_SZ (RX_DMA_BOUNDARY_8723D + 1)

#endif

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

#ifdef CONFIG_SDIO_HCI
	#ifndef CONFIG_SDIO_RX_COPY
		#undef MAX_RECVBUF_SZ
		#define MAX_RECVBUF_SZ	(RX_DMA_SIZE_8723D - RX_DMA_RESERVED_SIZE_8723D)
	#endif /* !CONFIG_SDIO_RX_COPY */
#endif /* CONFIG_SDIO_HCI */

/*-----------------------------------------------------------------*/
/*	RTL8723D RX BUFFER DESC                                      */
/*-----------------------------------------------------------------*/
/*DWORD 0*/
#define SET_RX_BUFFER_DESC_DATA_LENGTH_8723D(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_BUFFER_DESC_LS_8723D(__pRxStatusDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 15, 1, __Value)
#define SET_RX_BUFFER_DESC_FS_8723D(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 1, __Value)
#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_8723D(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 15, __Value)

#define GET_RX_BUFFER_DESC_OWN_8723D(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)
#define GET_RX_BUFFER_DESC_LS_8723D(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_BUFFER_DESC_FS_8723D(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 1)
#ifdef USING_RX_TAG
	#define GET_RX_BUFFER_DESC_RX_TAG_8723D(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 13)
#else
	#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_8723D(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 15)
#endif

/*DWORD 1*/
#define SET_RX_BUFFER_PHYSICAL_LOW_8723D(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+4, 0, 32, __Value)

/*DWORD 2*/
#ifdef CONFIG_64BIT_DMA
	#define SET_RX_BUFFER_PHYSICAL_HIGH_8723D(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+8, 0, 32, __Value)
#else
	#define SET_RX_BUFFER_PHYSICAL_HIGH_8723D(__pRxStatusDesc, __Value)
#endif


#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8723ds_init_recv_priv(PADAPTER padapter);
	void rtl8723ds_free_recv_priv(PADAPTER padapter);
	s32 rtl8723ds_recv_hdl(_adapter *padapter);
#endif

#ifdef CONFIG_USB_HCI
	int rtl8723du_init_recv_priv(_adapter *padapter);
	void rtl8723du_free_recv_priv(_adapter *padapter);
	void rtl8723du_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8723de_init_recv_priv(PADAPTER padapter);
	void rtl8723de_free_recv_priv(PADAPTER padapter);
#endif

void rtl8723d_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8723D_RECV_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8188e_sreset.h                                                             0000644 0001750 0001750 00000001631 14214766567 016462  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8188E_SRESET_H_
#define _RTL8188E_SRESET_H_

#include <rtw_sreset.h>

#ifdef DBG_CONFIG_ERROR_DETECT
	extern void rtl8188e_sreset_xmit_status_check(_adapter *padapter);
	extern void rtl8188e_sreset_linked_status_check(_adapter *padapter);
#endif
#endif
                                                                                                       rtl8822bu/src/include/rtw_wapi.h                                                                    0000644 0001750 0001750 00000014716 14214766567 015442  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_WAPI_H
#define __INC_WAPI_H


#define CONFIG_WAPI_SW_SMS4
#define WAPI_DEBUG

#define SMS4_MIC_LEN                16
#define WAPI_EXT_LEN                18
#define MAX_WAPI_IE_LEN		    256
#define sMacHdrLng				24		/* octets in data header, no WEP */

#ifdef WAPI_DEBUG

/* WAPI trace debug */
extern u32 wapi_debug_component;

static inline void dump_buf(u8 *buf, u32 len)
{
	u32 i;
	printk("-----------------Len %d----------------\n", len);
	for (i = 0; i < len; i++)
		printk("%2.2x-", *(buf + i));
	printk("\n");
}

#define WAPI_TRACE(component, x, args...) \
	do { if (wapi_debug_component & (component)) \
			printk(KERN_DEBUG "WAPI" ":" x "" , \
			       ##args);\
	} while (0);

#define WAPI_DATA(component, x, buf, len) \
	do { if (wapi_debug_component & (component)) { \
			printk("%s:\n", x);\
			dump_buf((buf), (len)); } \
	} while (0);

#define RT_ASSERT_RET(_Exp)								\
	if (!(_Exp)) {									\
		printk("RTWLAN: ");					\
		printk("Assertion failed! %s,%s, line=%d\n", \
		       #_Exp, __FUNCTION__, __LINE__);          \
		return;						\
	}
#define RT_ASSERT_RET_VALUE(_Exp, Ret)								\
	if (!(_Exp)) {									\
		printk("RTWLAN: ");					\
		printk("Assertion failed! %s,%s, line=%d\n", \
		       #_Exp, __FUNCTION__, __LINE__);          \
		return Ret;						\
	}

#else
#define RT_ASSERT_RET(_Exp) do {} while (0)
#define RT_ASSERT_RET_VALUE(_Exp, Ret) do {} while (0)
#define WAPI_TRACE(component, x, args...) do {} while (0)
#define WAPI_DATA(component, x, buf, len) do {} while (0)
#endif


enum WAPI_DEBUG {
	WAPI_INIT				= 1,
	WAPI_API				= 1 << 1,
	WAPI_TX				= 1 << 2,
	WAPI_RX				= 1 << 3,
	WAPI_MLME				= 1 << 4,
	WAPI_IOCTL				= 1 << 5,
	WAPI_ERR			= 1 << 31
};

#define			WAPI_MAX_BKID_NUM				4
#define			WAPI_MAX_STAINFO_NUM			4
#define			WAPI_CAM_ENTRY_NUM			14	/* 28/2 = 14 */

typedef struct  _RT_WAPI_BKID {
	struct list_head	list;
	u8				bkid[16];
} RT_WAPI_BKID, *PRT_WAPI_BKID;

typedef struct  _RT_WAPI_KEY {
	u8			dataKey[16];
	u8			micKey[16];
	u8			keyId;
	bool			bSet;
	bool             bTxEnable;
} RT_WAPI_KEY, *PRT_WAPI_KEY;

typedef enum _RT_WAPI_PACKET_TYPE {
	WAPI_NONE = 0,
	WAPI_PREAUTHENTICATE = 1,
	WAPI_STAKEY_REQUEST = 2,
	WAPI_AUTHENTICATE_ACTIVE = 3,
	WAPI_ACCESS_AUTHENTICATE_REQUEST = 4,
	WAPI_ACCESS_AUTHENTICATE_RESPONSE = 5,
	WAPI_CERTIFICATE_AUTHENTICATE_REQUEST = 6,
	WAPI_CERTIFICATE_AUTHENTICATE_RESPONSE = 7,
	WAPI_USK_REQUEST = 8,
	WAPI_USK_RESPONSE = 9,
	WAPI_USK_CONFIRM = 10,
	WAPI_MSK_NOTIFICATION = 11,
	WAPI_MSK_RESPONSE = 12
} RT_WAPI_PACKET_TYPE;

typedef struct	_RT_WAPI_STA_INFO {
	struct list_head		list;
	u8					PeerMacAddr[6];
	RT_WAPI_KEY		      wapiUsk;
	RT_WAPI_KEY		      wapiUskUpdate;
	RT_WAPI_KEY		      wapiMsk;
	RT_WAPI_KEY		      wapiMskUpdate;
	u8					lastRxUnicastPN[16];
	u8					lastTxUnicastPN[16];
	u8					lastRxMulticastPN[16];
	u8					lastRxUnicastPNBEQueue[16];
	u8					lastRxUnicastPNBKQueue[16];
	u8					lastRxUnicastPNVIQueue[16];
	u8					lastRxUnicastPNVOQueue[16];
	bool					bSetkeyOk;
	bool					bAuthenticateInProgress;
	bool					bAuthenticatorInUpdata;
} RT_WAPI_STA_INFO, *PRT_WAPI_STA_INFO;

/* Added for HW wapi en/decryption */
typedef struct _RT_WAPI_CAM_ENTRY {
	/* RT_LIST_ENTRY		list; */
	u8			IsUsed;
	u8			entry_idx;/* for cam entry */
	u8			keyidx;	/* 0 or 1,new or old key */
	u8			PeerMacAddr[6];
	u8			type;	/* should be 110,wapi */
} RT_WAPI_CAM_ENTRY, *PRT_WAPI_CAM_ENTRY;

typedef struct _RT_WAPI_T {
	/* BKID */
	RT_WAPI_BKID		wapiBKID[WAPI_MAX_BKID_NUM];
	struct list_head		wapiBKIDIdleList;
	struct list_head		wapiBKIDStoreList;
	/* Key for Tx Multicast/Broadcast */
	RT_WAPI_KEY		      wapiTxMsk;

	/* sec related */
	u8				lastTxMulticastPN[16];
	/* STA list */
	RT_WAPI_STA_INFO	wapiSta[WAPI_MAX_STAINFO_NUM];
	struct list_head		wapiSTAIdleList;
	struct list_head		wapiSTAUsedList;
	/*  */
	bool				bWapiEnable;

	/* store WAPI IE */
	u8				wapiIE[256];
	u8				wapiIELength;
	bool				bWapiPSK;
	/* last sequece number for wai packet */
	u16				wapiSeqnumAndFragNum;
	int extra_prefix_len;
	int extra_postfix_len;

	RT_WAPI_CAM_ENTRY	wapiCamEntry[WAPI_CAM_ENTRY_NUM];
} RT_WAPI_T, *PRT_WAPI_T;

typedef struct _WLAN_HEADER_WAPI_EXTENSION {
	u8      KeyIdx;
	u8      Reserved;
	u8      PN[16];
} WLAN_HEADER_WAPI_EXTENSION, *PWLAN_HEADER_WAPI_EXTENSION;

u32 WapiComparePN(u8 *PN1, u8 *PN2);


void rtw_wapi_init(_adapter *padapter);

void rtw_wapi_free(_adapter *padapter);

void rtw_wapi_disable_tx(_adapter *padapter);

u8 rtw_wapi_is_wai_packet(_adapter *padapter, u8 *pkt_data);

void rtw_wapi_update_info(_adapter *padapter, union recv_frame *precv_frame);

u8 rtw_wapi_check_for_drop(_adapter *padapter, union recv_frame *precv_frame, u8 *ehdr_ops);

void rtw_build_probe_resp_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);

void rtw_build_beacon_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);

void rtw_build_assoc_req_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);

void rtw_wapi_on_assoc_ok(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);

void rtw_wapi_return_one_sta_info(_adapter *padapter, u8 *MacAddr);

void rtw_wapi_return_all_sta_info(_adapter *padapter);

void rtw_wapi_clear_cam_entry(_adapter *padapter, u8 *pMacAddr);

void rtw_wapi_clear_all_cam_entry(_adapter *padapter);

void rtw_wapi_set_key(_adapter *padapter, RT_WAPI_KEY *pWapiKey, RT_WAPI_STA_INFO *pWapiSta, u8 bGroupKey, u8 bUseDefaultKey);

int rtw_wapi_create_event_send(_adapter *padapter, u8 EventId, u8 *MacAddr, u8 *Buff, u16 BufLen);

u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe);

u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe);

void rtw_wapi_get_iv(_adapter *padapter, u8 *pRA, u8 *IV);

u8 WapiIncreasePN(u8 *PN, u8 AddCount);

bool rtw_wapi_drop_for_key_absent(_adapter *padapter, u8 *pRA);

void rtw_wapi_set_set_encryption(_adapter *padapter, struct ieee_param *param);

#endif
                                                  rtl8822bu/src/include/xmit_osdep.h                                                                  0000644 0001750 0001750 00000005073 14214766567 015755  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __XMIT_OSDEP_H_
#define __XMIT_OSDEP_H_


struct pkt_file {
	_pkt *pkt;
	SIZE_T pkt_len;	 /* the remainder length of the open_file */
	_buffer *cur_buffer;
	u8 *buf_start;
	u8 *cur_addr;
	SIZE_T buf_len;
};

#ifdef PLATFORM_WINDOWS

#ifdef PLATFORM_OS_XP
#ifdef CONFIG_USB_HCI
#include <usb.h>
#include <usbdlib.h>
#include <usbioctl.h>
#endif
#endif

#ifdef CONFIG_GSPI_HCI
	#define NR_XMITFRAME     64
#else
	#define NR_XMITFRAME     128
#endif

#define ETH_ALEN	6

extern NDIS_STATUS rtw_xmit_entry(
	_nic_hdl		cnxt,
	NDIS_PACKET		*pkt,
	u32				flags
);

#endif /* PLATFORM_WINDOWS */

#ifdef PLATFORM_FREEBSD
#define NR_XMITFRAME	256
extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
extern void rtw_xmit_entry_wrap(struct ifnet *pifp);
#endif /* PLATFORM_FREEBSD */

#ifdef PLATFORM_LINUX

#define NR_XMITFRAME	256

struct xmit_priv;
struct pkt_attrib;
struct sta_xmit_priv;
struct xmit_frame;
struct xmit_buf;

extern int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);

#endif /* PLATFORM_LINUX */

void rtw_os_xmit_schedule(_adapter *padapter);

int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 alloc_sz, u8 flag);
void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 free_sz, u8 flag);

extern void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib);

extern uint rtw_remainder_len(struct pkt_file *pfile);
extern void _rtw_open_pktfile(_pkt *pkt, struct pkt_file *pfile);
extern uint _rtw_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen);
extern sint rtw_endofpktfile(struct pkt_file *pfile);

extern void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt);
extern void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);

void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed);

void dump_os_queue(void *sel, _adapter *padapter);

#endif /* __XMIT_OSDEP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/wifi.h                                                                        0000644 0001750 0001750 00000123673 14214766567 014547  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _WIFI_H_
#define _WIFI_H_


#ifndef BIT
#define BIT(x)	(1 << (x))
#endif


#define WLAN_ETHHDR_LEN		14
#define WLAN_ETHADDR_LEN	6
#define WLAN_IEEE_OUI_LEN	3
#define WLAN_ADDR_LEN		6
#define WLAN_CRC_LEN		4
#define WLAN_BSSID_LEN		6
#define WLAN_BSS_TS_LEN		8
#define WLAN_HDR_A3_LEN		24
#define WLAN_HDR_A4_LEN		30
#define WLAN_HDR_A3_QOS_LEN	26
#define WLAN_HDR_A4_QOS_LEN	32
#define WLAN_SSID_MAXLEN	32
#define WLAN_DATA_MAXLEN	2312

#define WLAN_A3_PN_OFFSET	24
#define WLAN_A4_PN_OFFSET	30

#define WLAN_MIN_ETHFRM_LEN	60
#define WLAN_MAX_ETHFRM_LEN	1514
#define WLAN_ETHHDR_LEN		14
#define WLAN_WMM_LEN		24
#define VENDOR_NAME_LEN		20

#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
#define WLAN_MAX_VENDOR_IE_LEN 255
#define WLAN_MAX_VENDOR_IE_NUM 5
#define WIFI_BEACON_VENDOR_IE_BIT BIT(0)
#define WIFI_PROBEREQ_VENDOR_IE_BIT BIT(1)
#define WIFI_PROBERESP_VENDOR_IE_BIT BIT(2)
#define WIFI_ASSOCREQ_VENDOR_IE_BIT BIT(3)
#define WIFI_ASSOCRESP_VENDOR_IE_BIT BIT(4)
#ifdef CONFIG_P2P
#define WIFI_P2P_PROBEREQ_VENDOR_IE_BIT BIT(5)
#define WIFI_P2P_PROBERESP_VENDOR_IE_BIT BIT(6)
#define WLAN_MAX_VENDOR_IE_MASK_MAX 7
#else
#define WLAN_MAX_VENDOR_IE_MASK_MAX 5
#endif
#endif

#define P80211CAPTURE_VERSION	0x80211001

/* This value is tested by WiFi 11n Test Plan 5.2.3.
 * This test verifies the WLAN NIC can update the NAV through sending the CTS with large duration. */
#define	WiFiNavUpperUs				30000	/* 30 ms */

#ifdef GREEN_HILL
#pragma pack(1)
#endif

enum WIFI_FRAME_TYPE {
	WIFI_MGT_TYPE  =	(0),
	WIFI_CTRL_TYPE =	(BIT(2)),
	WIFI_DATA_TYPE =	(BIT(3)),
	WIFI_QOS_DATA_TYPE	= (BIT(7) | BIT(3)),	/* !< QoS Data	 */
};

enum WIFI_FRAME_SUBTYPE {

	/* below is for mgt frame */
	WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
	WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
	WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
	WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
	WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
	WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
	WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
	WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
	WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
	WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
	WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
	WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
	WIFI_ACTION_NOACK = (BIT(7) | BIT(6) | BIT(5) | WIFI_MGT_TYPE),

	/* below is for control frame */
	WIFI_BF_REPORT_POLL = (BIT(6) | WIFI_CTRL_TYPE),
	WIFI_NDPA         = (BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
	WIFI_BAR            = (BIT(7) | WIFI_CTRL_TYPE),
	WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
	WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
	WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
	WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
	WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
	WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),

	/* below is for data frame */
	WIFI_DATA           = (0 | WIFI_DATA_TYPE),
	WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
	WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
	WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
	WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
	WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
	WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
	WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
	WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
};

enum WIFI_REASON_CODE	{
	_RSON_RESERVED_					= 0,
	_RSON_UNSPECIFIED_				= 1,
	_RSON_AUTH_NO_LONGER_VALID_		= 2,
	_RSON_DEAUTH_STA_LEAVING_		= 3,
	_RSON_INACTIVITY_				= 4,
	_RSON_UNABLE_HANDLE_			= 5,
	_RSON_CLS2_						= 6,
	_RSON_CLS3_						= 7,
	_RSON_DISAOC_STA_LEAVING_		= 8,
	_RSON_ASOC_NOT_AUTH_			= 9,

	/* WPA reason */
	_RSON_INVALID_IE_				= 13,
	_RSON_MIC_FAILURE_				= 14,
	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
	_RSON_DIFF_IE_					= 17,
	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
	_RSON_AKMP_NOT_VALID_			= 20,
	_RSON_UNSUPPORT_RSNE_VER_		= 21,
	_RSON_INVALID_RSNE_CAP_			= 22,
	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,

	/* belowing are Realtek definition */
	_RSON_PMK_NOT_AVAILABLE_		= 24,
	_RSON_TDLS_TEAR_TOOFAR_			= 25,
	_RSON_TDLS_TEAR_UN_RSN_			= 26,
};

/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
#if 0
#define WLAN_REASON_UNSPECIFIED 1
#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
#define WLAN_REASON_DEAUTH_LEAVING 3
#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
#define WLAN_REASON_DISASSOC_AP_BUSY 5
#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
#endif
/* IEEE 802.11h */
#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
#if 0
/* IEEE 802.11i */
#define WLAN_REASON_INVALID_IE 13
#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
#define WLAN_REASON_AKMP_NOT_VALID 20
#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
#endif

enum WIFI_STATUS_CODE {
	_STATS_SUCCESSFUL_			= 0,
	_STATS_FAILURE_				= 1,
	_STATS_SEC_DISABLED_			= 5,
	_STATS_NOT_IN_SAME_BSS_		= 7,
	_STATS_CAP_FAIL_			= 10,
	_STATS_NO_ASOC_				= 11,
	_STATS_OTHER_				= 12,
	_STATS_NO_SUPP_ALG_			= 13,
	_STATS_OUT_OF_AUTH_SEQ_		= 14,
	_STATS_CHALLENGE_FAIL_		= 15,
	_STATS_AUTH_TIMEOUT_		= 16,
	_STATS_UNABLE_HANDLE_STA_	= 17,
	_STATS_RATE_FAIL_			= 18,
	_STATS_REFUSED_TEMPORARILY_ = 30,
	_STATS_DECLINE_REQ_			= 37,
	_STATS_INVALID_PARAMETERS_	= 38,
	_STATS_INVALID_RSNIE_			= 72,
};

/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
#if 0
#define WLAN_STATUS_SUCCESS 0
#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
#define WLAN_STATUS_CAPS_UNSUPPORTED 10
#define WLAN_STATUS_REASSOC_NO_ASSOC 11
#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
#define WLAN_STATUS_CHALLENGE_FAIL 15
#define WLAN_STATUS_AUTH_TIMEOUT 16
#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
#define WLAN_STATUS_ASSOC_DENIED_RATES 18
#endif
/* entended */
/* IEEE 802.11b */
#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
/* IEEE 802.11h */
#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
/* IEEE 802.11g */
#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
/* IEEE 802.11w */
#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
/* IEEE 802.11i */
#define WLAN_STATUS_INVALID_IE 40
#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
#define WLAN_STATUS_AKMP_NOT_VALID 43
#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
#define WLAN_STATUS_TS_NOT_CREATED 47
#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
/* IEEE 802.11r */
#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
#define WLAN_STATUS_INVALID_PMKID 53
#define WLAN_STATUS_INVALID_MDIE 54
#define WLAN_STATUS_INVALID_FTIE 55


enum WIFI_REG_DOMAIN {
	DOMAIN_FCC		= 1,
	DOMAIN_IC		= 2,
	DOMAIN_ETSI		= 3,
	DOMAIN_SPAIN	= 4,
	DOMAIN_FRANCE	= 5,
	DOMAIN_MKK		= 6,
	DOMAIN_ISRAEL	= 7,
	DOMAIN_MKK1		= 8,
	DOMAIN_MKK2		= 9,
	DOMAIN_MKK3		= 10,
	DOMAIN_MAX
};

#define _TO_DS_		BIT(8)
#define _FROM_DS_	BIT(9)
#define _MORE_FRAG_	BIT(10)
#define _RETRY_		BIT(11)
#define _PWRMGT_	BIT(12)
#define _MORE_DATA_	BIT(13)
#define _PRIVACY_	BIT(14)
#define _ORDER_			BIT(15)

#define SetToDs(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
	} while (0)

#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)

#define ClearToDs(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
	} while (0)

#define SetFrDs(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
	} while (0)

#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)

#define ClearFrDs(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
	} while (0)

#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))


#define SetMFrag(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
	} while (0)

#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)

#define ClearMFrag(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
	} while (0)

#define SetRetry(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
	} while (0)

#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)

#define ClearRetry(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
	} while (0)

#define SetPwrMgt(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
	} while (0)

#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)

#define ClearPwrMgt(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
	} while (0)

#define SetMData(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
	} while (0)

#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)

#define ClearMData(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
	} while (0)

#define SetPrivacy(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
	} while (0)

#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)

#define ClearPrivacy(pbuf)	\
	do	{	\
		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
	} while (0)


#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)

#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & (BIT(3) | BIT(2)))

#define SetFrameType(pbuf, type)	\
	do {	\
		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
	} while (0)

#define get_frame_sub_type(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))


#define set_frame_sub_type(pbuf, type) \
	do {    \
		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
	} while (0)


#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) >> 4)

#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)

#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)))

#define SetFragNum(pbuf, num) \
	do {    \
		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
				cpu_to_le16(0x0f & (num));     \
	} while (0)

#define SetSeqNum(pbuf, num) \
	do {    \
		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
	} while (0)

#define set_duration(pbuf, dur) \
	do {    \
		*(unsigned short *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
	} while (0)


/* QoS control field */
#define SetPriority(qc, tid)	SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 0, 4, tid)
#define SetEOSP(qc, eosp)		SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 4, 1, eosp)
#define SetAckpolicy(qc, ack)	SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 5, 2, ack)
#define SetAMsdu(qc, amsdu)		SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 7, 1, amsdu)

#define GetPriority(qc)		LE_BITS_TO_2BYTE(((u8 *)(qc)), 0, 4)
#define GetEOSP(qc)			LE_BITS_TO_2BYTE(((u8 *)(qc)), 4, 1)
#define GetAckpolicy(qc)	LE_BITS_TO_2BYTE(((u8 *)(qc)), 5, 2)
#define GetAMsdu(qc)		LE_BITS_TO_2BYTE(((u8 *)(qc)), 7, 1)

/* QoS control field (MSTA only) */
#define set_mctrl_present(qc, p)	SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 8, 1, p)
#define set_mps_lv(qc, lv)			SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 9, 1, lv)
#define set_rspi(qc, rspi)			SET_BITS_TO_LE_2BYTE(((u8 *)(qc)), 10, 1, rspi)

#define get_mctrl_present(qc)	LE_BITS_TO_2BYTE(((u8 *)(qc)), 8, 1)
#define get_mps_lv(qc)			LE_BITS_TO_2BYTE(((u8 *)(qc)), 9, 1)
#define get_rspi(qc)			LE_BITS_TO_2BYTE(((u8 *)(qc)), 10, 1)


#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)

#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1) | GetFrDs(pbuf)) == 3 ? 30 : 24))) & 0x000f)

#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))

#define get_addr2_ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))

#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))

#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))


#define MacAddr_isBcst(addr) \
	(\
	 ((addr[0] == 0xff) && (addr[1] == 0xff) && \
	  (addr[2] == 0xff) && (addr[3] == 0xff) && \
	  (addr[4] == 0xff) && (addr[5] == 0xff)) ? _TRUE : _FALSE \
	)

__inline static int IS_MCAST(const u8 *da)
{
	if ((*da) & 0x01)
		return _TRUE;
	else
		return _FALSE;
}

__inline static unsigned char *get_ra(unsigned char *pframe)
{
	unsigned char	*ra;
	ra = GetAddr1Ptr(pframe);
	return ra;
}
__inline static unsigned char *get_ta(unsigned char *pframe)
{
	unsigned char	*ta;
	ta = get_addr2_ptr(pframe);
	return ta;
}

/* can't apply to mesh mode */
__inline static unsigned char *get_da(unsigned char *pframe)
{
	unsigned char	*da;
	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);

	switch (to_fr_ds) {
	case 0x00:	/* ToDs=0, FromDs=0 */
		da = GetAddr1Ptr(pframe);
		break;
	case 0x01:	/* ToDs=0, FromDs=1 */
		da = GetAddr1Ptr(pframe);
		break;
	case 0x02:	/* ToDs=1, FromDs=0 */
		da = GetAddr3Ptr(pframe);
		break;
	default:	/* ToDs=1, FromDs=1 */
		da = GetAddr3Ptr(pframe);
		break;
	}

	return da;
}

/* can't apply to mesh mode */
__inline static unsigned char *get_sa(unsigned char *pframe)
{
	unsigned char	*sa;
	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);

	switch (to_fr_ds) {
	case 0x00:	/* ToDs=0, FromDs=0 */
		sa = get_addr2_ptr(pframe);
		break;
	case 0x01:	/* ToDs=0, FromDs=1 */
		sa = GetAddr3Ptr(pframe);
		break;
	case 0x02:	/* ToDs=1, FromDs=0 */
		sa = get_addr2_ptr(pframe);
		break;
	default:	/* ToDs=1, FromDs=1 */
		sa = GetAddr4Ptr(pframe);
		break;
	}

	return sa;
}

/* can't apply to mesh mode */
__inline static unsigned char *get_hdr_bssid(unsigned char *pframe)
{
	unsigned char	*sa = NULL;
	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);

	switch (to_fr_ds) {
	case 0x00:	/* ToDs=0, FromDs=0 */
		sa = GetAddr3Ptr(pframe);
		break;
	case 0x01:	/* ToDs=0, FromDs=1 */
		sa = get_addr2_ptr(pframe);
		break;
	case 0x02:	/* ToDs=1, FromDs=0 */
		sa = GetAddr1Ptr(pframe);
		break;
	case 0x03:	/* ToDs=1, FromDs=1 */
		sa = GetAddr1Ptr(pframe);
		break;
	}

	return sa;
}


__inline static int IsFrameTypeCtrl(unsigned char *pframe)
{
	if (WIFI_CTRL_TYPE == GetFrameType(pframe))
		return _TRUE;
	else
		return _FALSE;
}
static inline int IsFrameTypeMgnt(unsigned char *pframe)
{
	if (GetFrameType(pframe) == WIFI_MGT_TYPE)
		return _TRUE;
	else
		return _FALSE;
}
static inline int IsFrameTypeData(unsigned char *pframe)
{
	if (GetFrameType(pframe) == WIFI_DATA_TYPE)
		return _TRUE;
	else
		return _FALSE;
}


/*-----------------------------------------------------------------------------
			Below is for the security related definition
------------------------------------------------------------------------------*/
#define _RESERVED_FRAME_TYPE_	0
#define _SKB_FRAME_TYPE_		2
#define _PRE_ALLOCMEM_			1
#define _PRE_ALLOCHDR_			3
#define _PRE_ALLOCLLCHDR_		4
#define _PRE_ALLOCICVHDR_		5
#define _PRE_ALLOCMICHDR_		6

#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A) ? 16 : 10)
#define _ACKCTSLNG_				14	/* 14 bytes long, including crclng */
#define _CRCLNG_				4

#define _ASOCREQ_IE_OFFSET_		4	/* excluding wlan_hdr */
#define	_ASOCRSP_IE_OFFSET_		6
#define _REASOCREQ_IE_OFFSET_	10
#define _REASOCRSP_IE_OFFSET_	6
#define _PROBEREQ_IE_OFFSET_	0
#define	_PROBERSP_IE_OFFSET_	12
#define _AUTH_IE_OFFSET_		6
#define _DEAUTH_IE_OFFSET_		0
#define _BEACON_IE_OFFSET_		12
#define _PUBLIC_ACTION_IE_OFFSET_	8

#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_

#define _SSID_IE_				0
#define _SUPPORTEDRATES_IE_	1
#define _DSSET_IE_				3
#define _TIM_IE_					5
#define _IBSS_PARA_IE_			6
#define _COUNTRY_IE_			7
#define _CHLGETXT_IE_			16
#define _SUPPORTED_CH_IE_		36
#define _CH_SWTICH_ANNOUNCE_	37	/* Secondary Channel Offset */
#define	_MEAS_REQ_IE_		38
#define	_MEAS_RSP_IE_		39
#define _RSN_IE_2_				48
#define _SSN_IE_1_					221
#define _ERPINFO_IE_			42
#define _EXT_SUPPORTEDRATES_IE_	50

#define _HT_CAPABILITY_IE_			45
#define _MDIE_					54
#define _FTIE_					55
#define _TIMEOUT_ITVL_IE_			56
#define _SRC_IE_				59
#define _HT_EXTRA_INFO_IE_			61
#define _HT_ADD_INFO_IE_			61 /* _HT_EXTRA_INFO_IE_ */
#define _WAPI_IE_				68
#define _EID_RRM_EN_CAP_IE_			70


/* #define EID_BSSCoexistence			72 */ /* 20/40 BSS Coexistence
 * #define EID_BSSIntolerantChlReport	73 */
#define _RIC_Descriptor_IE_			75
#ifdef CONFIG_IEEE80211W
#define _MME_IE_					76 /* 802.11w Management MIC element */
#endif /* CONFIG_IEEE80211W */
#define _LINK_ID_IE_					101
#define _CH_SWITCH_TIMING_		104
#define _PTI_BUFFER_STATUS_		106
#define _EXT_CAP_IE_				127
#define _VENDOR_SPECIFIC_IE_		221

#define	_RESERVED47_				47

typedef	enum _ELEMENT_ID {
	EID_SsId					= 0, /* service set identifier (0:32) */
	EID_SupRates				= 1, /* supported rates (1:8) */
	EID_FHParms				= 2, /* FH parameter set (5) */
	EID_DSParms				= 3, /* DS parameter set (1) */
	EID_CFParms				= 4, /* CF parameter set (6) */
	EID_Tim						= 5, /* Traffic Information Map (4:254) */
	EID_IbssParms				= 6, /* IBSS parameter set (2) */
	EID_Country					= 7, /* */

	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
	EID_QBSSLoad				= 11,
	EID_EDCAParms				= 12,
	EID_TSpec					= 13,
	EID_TClass					= 14,
	EID_Schedule				= 15,
	/*  */

	EID_Ctext					= 16, /* challenge text*/
	EID_POWER_CONSTRAINT		= 32, /* Power Constraint*/

	/* vivi for WIFITest, 802.11h AP, 20100427 */
	/* 2010/12/26 MH The definition we can declare always!! */
	EID_PowerCap				= 33,
	EID_TPC				= 35,
	EID_SupportedChannels		= 36,
	EID_ChlSwitchAnnounce		= 37,

	EID_MeasureRequest			= 38, /* Measurement Request */
	EID_MeasureReport			= 39, /* Measurement Report */

	EID_ERPInfo				= 42,

	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
	EID_TSDelay				= 43,
	EID_TCLASProc				= 44,
	EID_HTCapability			= 45,
	EID_QoSCap					= 46,
	/*  */

	EID_WPA2					= 48,
	EID_ExtSupRates			= 50,

	EID_FTIE					= 55, /* Defined in 802.11r */
	EID_Timeout				= 56, /* Defined in 802.11r */

	EID_SupRegulatory			= 59, /* Supported Requlatory Classes 802.11y */
	EID_HTInfo					= 61,
	EID_SecondaryChnlOffset		= 62,

	EID_BSSCoexistence			= 72, /* 20/40 BSS Coexistence */
	EID_BSSIntolerantChlReport	= 73,
	EID_OBSS					= 74, /* Overlapping BSS Scan Parameters */

	EID_LinkIdentifier			= 101, /* Defined in 802.11z */
	EID_WakeupSchedule		= 102, /* Defined in 802.11z */
	EID_ChnlSwitchTimeing		= 104, /* Defined in 802.11z */
	EID_PTIControl				= 105, /* Defined in 802.11z */
	EID_PUBufferStatus			= 106, /* Defined in 802.11z */

	EID_EXTCapability			= 127, /* Extended Capabilities */
	/* From S19:Aironet IE and S21:AP IP address IE in CCX v1.13, p16 and p18. */
	EID_Aironet					= 133, /* 0x85: Aironet Element for Cisco CCX */
	EID_CiscoIP					= 149, /* 0x95: IP Address IE for Cisco CCX */

	EID_CellPwr					= 150, /* 0x96: Cell Power Limit IE. Ref. 0x96. */

	EID_CCKM					= 156,

	EID_Vendor					= 221, /* 0xDD: Vendor Specific */

	EID_WAPI					= 68,
	EID_VHTCapability 			= 191, /* Based on 802.11ac D2.0 */
	EID_VHTOperation 			= 192, /* Based on 802.11ac D2.0 */
	EID_AID						= 197, /* Based on 802.11ac D4.0 */
	EID_OpModeNotification		= 199, /* Based on 802.11ac D3.0 */
} ELEMENT_ID, *PELEMENT_ID;

/* ---------------------------------------------------------------------------
					Below is the fixed elements...
-----------------------------------------------------------------------------*/
#define _AUTH_ALGM_NUM_			2
#define _AUTH_SEQ_NUM_			2
#define _BEACON_ITERVAL_		2
#define _CAPABILITY_			2
#define _CURRENT_APADDR_		6
#define _LISTEN_INTERVAL_		2
#define _RSON_CODE_				2
#define _ASOC_ID_				2
#define _STATUS_CODE_			2
#define _TIMESTAMP_				8

#define AUTH_ODD_TO				0
#define AUTH_EVEN_TO			1

#define WLAN_ETHCONV_ENCAP		1
#define WLAN_ETHCONV_RFC1042	2
#define WLAN_ETHCONV_8021h		3

#define cap_ESS BIT(0)
#define cap_IBSS BIT(1)
#define cap_CFPollable BIT(2)
#define cap_CFRequest BIT(3)
#define cap_Privacy BIT(4)
#define cap_ShortPremble BIT(5)
#define cap_PBCC	BIT(6)
#define cap_ChAgility	BIT(7)
#define cap_SpecMgmt	BIT(8)
#define cap_QoS	BIT(9)
#define cap_ShortSlot	BIT(10)

/*-----------------------------------------------------------------------------
				Below is the definition for 802.11i / 802.1x
------------------------------------------------------------------------------*/
#define _IEEE8021X_MGT_			1		/* WPA */
#define _IEEE8021X_PSK_			2		/* WPA with pre-shared key */

#if 0
#define _NO_PRIVACY_			0
#define _WEP_40_PRIVACY_		1
#define _TKIP_PRIVACY_			2
#define _WRAP_PRIVACY_			3
#define _CCMP_PRIVACY_			4
#define _WEP_104_PRIVACY_		5
#define _WEP_WPA_MIXED_PRIVACY_ 6	/*  WEP + WPA */
#endif

#define _MME_IE_LENGTH_  18

/*-----------------------------------------------------------------------------
				Below is the definition for WMM
------------------------------------------------------------------------------*/
#define _WMM_IE_Length_				7  /* for WMM STA */


/*-----------------------------------------------------------------------------
				Below is the definition for 802.11n
------------------------------------------------------------------------------*/

/* #ifdef CONFIG_80211N_HT */

#define set_order_bit(pbuf)	\
		do	{	\
			*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
		} while (0)



#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)

#define ACT_CAT_VENDOR				0x7F/* 127 */

/**
 * struct rtw_ieee80211_bar - HT Block Ack Request
 *
 * This structure refers to "HT BlockAckReq" as
 * described in 802.11n draft section 7.2.1.7.1
 */
#if defined(PLATFORM_LINUX)
struct rtw_ieee80211_bar {
	unsigned short frame_control;
	unsigned short duration;
	unsigned char ra[6];
	unsigned char ta[6];
	unsigned short control;
	unsigned short start_seq_num;
} __attribute__((packed));
#endif

/* 802.11 BAR control masks */
#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004


#if defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)



/**
* struct rtw_ieee80211_ht_cap - HT capabilities
*
* This structure refers to "HT capabilities element" as
* described in 802.11n draft section 7.3.2.52
*/

struct rtw_ieee80211_ht_cap {
	unsigned short	cap_info;
	unsigned char	ampdu_params_info;
	unsigned char	supp_mcs_set[16];
	unsigned short	extended_ht_cap_info;
	unsigned int		tx_BF_cap_info;
	unsigned char	       antenna_selection_info;
} __attribute__((packed));

/**
 * struct rtw_ieee80211_ht_cap - HT additional information
 *
 * This structure refers to "HT information element" as
 * described in 802.11n draft section 7.3.2.53
 */
#ifndef CONFIG_IEEE80211_HT_ADDT_INFO
struct ieee80211_ht_addt_info {
	unsigned char	control_chan;
	unsigned char		ht_param;
	unsigned short	operation_mode;
	unsigned short	stbc_param;
	unsigned char		basic_set[16];
} __attribute__((packed));
#endif

struct HT_caps_element {
	union {
		struct {
			unsigned short	HT_caps_info;
			unsigned char	AMPDU_para;
			unsigned char	MCS_rate[16];
			unsigned short	HT_ext_caps;
			unsigned int	Beamforming_caps;
			unsigned char	ASEL_caps;
		} HT_cap_element;
		unsigned char HT_cap[26];
	} u;
} __attribute__((packed));

struct HT_info_element {
	unsigned char	primary_channel;
	unsigned char	infos[5];
	unsigned char	MCS_rate[16];
}  __attribute__((packed));

struct AC_param {
	unsigned char		ACI_AIFSN;
	unsigned char		CW;
	unsigned short	TXOP_limit;
}  __attribute__((packed));

struct WMM_para_element {
	unsigned char		QoS_info;
	unsigned char		reserved;
	struct AC_param	ac_param[4];
}  __attribute__((packed));

struct ADDBA_request {
	unsigned char		dialog_token;
	unsigned short	BA_para_set;
	unsigned short	BA_timeout_value;
	unsigned short	BA_starting_seqctrl;
}  __attribute__((packed));



#endif


typedef enum _HT_CAP_AMPDU_FACTOR {
	MAX_AMPDU_FACTOR_8K		= 0,
	MAX_AMPDU_FACTOR_16K	= 1,
	MAX_AMPDU_FACTOR_32K	= 2,
	MAX_AMPDU_FACTOR_64K	= 3,
} HT_CAP_AMPDU_FACTOR;

typedef enum _VHT_CAP_AMPDU_FACTOR {
	MAX_AMPDU_FACTOR_128K = 4,
	MAX_AMPDU_FACTOR_256K = 5,
	MAX_AMPDU_FACTOR_512K = 6,
	MAX_AMPDU_FACTOR_1M = 7,
} VHT_CAP_AMPDU_FACTOR;


typedef enum _HT_CAP_AMPDU_DENSITY {
	AMPDU_DENSITY_VALUE_0 = 0 , /* For no restriction */
	AMPDU_DENSITY_VALUE_1 = 1 , /* For 1/4 us */
	AMPDU_DENSITY_VALUE_2 = 2 , /* For 1/2 us */
	AMPDU_DENSITY_VALUE_3 = 3 , /* For 1 us */
	AMPDU_DENSITY_VALUE_4 = 4 , /* For 2 us */
	AMPDU_DENSITY_VALUE_5 = 5 , /* For 4 us */
	AMPDU_DENSITY_VALUE_6 = 6 , /* For 8 us */
	AMPDU_DENSITY_VALUE_7 = 7 , /* For 16 us */
} HT_CAP_AMPDU_DENSITY;

/* 802.11n HT capabilities masks */
#define IEEE80211_HT_CAP_LDPC_CODING		0x0001
#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
#define IEEE80211_HT_CAP_SM_PS			0x000C
#define IEEE80211_HT_CAP_GRN_FLD		0x0010
#define IEEE80211_HT_CAP_SGI_20			0x0020
#define IEEE80211_HT_CAP_SGI_40			0x0040
#define IEEE80211_HT_CAP_TX_STBC			0x0080
#define IEEE80211_HT_CAP_RX_STBC_1R		0x0100
#define IEEE80211_HT_CAP_RX_STBC_2R		0x0200
#define IEEE80211_HT_CAP_RX_STBC_3R		0x0300
#define IEEE80211_HT_CAP_DELAY_BA		0x0400
#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
#define RTW_IEEE80211_HT_CAP_40MHZ_INTOLERANT	((u16) BIT(14))
/* 802.11n HT capability AMPDU settings */
#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
/* 802.11n HT capability MSC set */
#define IEEE80211_SUPP_MCS_SET_UEQM		4
#define IEEE80211_HT_CAP_MAX_STREAMS		4
#define IEEE80211_SUPP_MCS_SET_LEN		10
/* maximum streams the spec allows */
#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
/* 802.11n HT capability TXBF capability */
#define IEEE80211_HT_CAP_TXBF_RX_NDP		0x00000008
#define IEEE80211_HT_CAP_TXBF_TX_NDP		0x00000010
#define IEEE80211_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP	0x00000400

/* 802.11n HT IE masks */
#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
#define IEEE80211_HT_IE_CHA_SEC_NONE		0x00
#define IEEE80211_HT_IE_CHA_SEC_ABOVE		0x01
#define IEEE80211_HT_IE_CHA_SEC_BELOW		0x03
#define IEEE80211_HT_IE_CHA_WIDTH		0x04
#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010

/* block-ack parameters */
#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800

/*
 * A-PMDU buffer sizes
 * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
 */
#define IEEE80211_MIN_AMPDU_BUF 0x8
#define IEEE80211_MAX_AMPDU_BUF_HT 0x40


/* Spatial Multiplexing Power Save Modes */
#define WLAN_HT_CAP_SM_PS_STATIC		0
#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
#define WLAN_HT_CAP_SM_PS_INVALID	2
#define WLAN_HT_CAP_SM_PS_DISABLED	3


#define OP_MODE_PURE                    0
#define OP_MODE_MAY_BE_LEGACY_STAS      1
#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
#define OP_MODE_MIXED                   3

#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((u8) BIT(2))
#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((u8) BIT(4))
#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((u8) BIT(5))

#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
	((u16) (0x0001 | 0x0002))
#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((u8) BIT(2))
#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((u8) BIT(3))
#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((u8) BIT(4))

#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))



/* #endif */

/*	===============WPS Section=============== */
/*	For WPSv1.0 */
#define WPSOUI							0x0050f204
/*	WPS attribute ID */
#define WPS_ATTR_VER1					0x104A
#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
#define WPS_ATTR_RESP_TYPE			0x103B
#define WPS_ATTR_UUID_E				0x1047
#define WPS_ATTR_MANUFACTURER		0x1021
#define WPS_ATTR_MODEL_NAME			0x1023
#define WPS_ATTR_MODEL_NUMBER		0x1024
#define WPS_ATTR_SERIAL_NUMBER		0x1042
#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
#define WPS_ATTR_DEVICE_NAME			0x1011
#define WPS_ATTR_CONF_METHOD			0x1008
#define WPS_ATTR_RF_BANDS				0x103C
#define WPS_ATTR_DEVICE_PWID			0x1012
#define WPS_ATTR_REQUEST_TYPE			0x103A
#define WPS_ATTR_ASSOCIATION_STATE	0x1002
#define WPS_ATTR_CONFIG_ERROR			0x1009
#define WPS_ATTR_VENDOR_EXT			0x1049
#define WPS_ATTR_SELECTED_REGISTRAR	0x1041

/*	Value of WPS attribute "WPS_ATTR_DEVICE_NAME */
#define WPS_MAX_DEVICE_NAME_LEN		32

/*	Value of WPS Request Type Attribute */
#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
#define WPS_REQ_TYPE_REGISTRAR					0x02
#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03

/*	Value of WPS Response Type Attribute */
#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
#define WPS_RESPONSE_TYPE_8021X		0x01
#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
#define WPS_RESPONSE_TYPE_AP			0x03

/*	Value of WPS WiFi Simple Configuration State Attribute */
#define WPS_WSC_STATE_NOT_CONFIG	0x01
#define WPS_WSC_STATE_CONFIG			0x02

/*	Value of WPS Version Attribute */
#define WPS_VERSION_1					0x10

/*	Value of WPS Configuration Method Attribute */
#define WPS_CONFIG_METHOD_FLASH		0x0001
#define WPS_CONFIG_METHOD_ETHERNET	0x0002
#define WPS_CONFIG_METHOD_LABEL		0x0004
#define WPS_CONFIG_METHOD_DISPLAY	0x0008
#define WPS_CONFIG_METHOD_E_NFC		0x0010
#define WPS_CONFIG_METHOD_I_NFC		0x0020
#define WPS_CONFIG_METHOD_NFC		0x0040
#define WPS_CONFIG_METHOD_PBC		0x0080
#define WPS_CONFIG_METHOD_KEYPAD	0x0100
#define WPS_CONFIG_METHOD_VPBC		0x0280
#define WPS_CONFIG_METHOD_PPBC		0x0480
#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
#define WPS_CONFIG_METHOD_PDISPLAY	0x4008

/*	Value of Category ID of WPS Primary Device Type Attribute */
#define WPS_PDT_CID_DISPLAYS			0x0007
#define WPS_PDT_CID_MULIT_MEDIA		0x0008
#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA

/*	Value of Sub Category ID of WPS Primary Device Type Attribute */
#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER

/*	Value of Device Password ID */
#define WPS_DPID_PIN					0x0000
#define WPS_DPID_USER_SPEC			0x0001
#define WPS_DPID_MACHINE_SPEC			0x0002
#define WPS_DPID_REKEY					0x0003
#define WPS_DPID_PBC					0x0004
#define WPS_DPID_REGISTRAR_SPEC		0x0005

/*	Value of WPS RF Bands Attribute */
#define WPS_RF_BANDS_2_4_GHZ		0x01
#define WPS_RF_BANDS_5_GHZ		0x02

/*	Value of WPS Association State Attribute */
#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
#define WPS_ASSOC_STATE_IP_FAILURE				0x04

/*	=====================P2P Section===================== */
/*	For P2P */
#define	P2POUI							0x506F9A09

/*	P2P Attribute ID */
#define	P2P_ATTR_STATUS					0x00
#define	P2P_ATTR_MINOR_REASON_CODE		0x01
#define	P2P_ATTR_CAPABILITY				0x02
#define	P2P_ATTR_DEVICE_ID				0x03
#define	P2P_ATTR_GO_INTENT				0x04
#define	P2P_ATTR_CONF_TIMEOUT			0x05
#define	P2P_ATTR_LISTEN_CH				0x06
#define	P2P_ATTR_GROUP_BSSID				0x07
#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
#define	P2P_ATTR_INTENDED_IF_ADDR		0x09
#define	P2P_ATTR_MANAGEABILITY			0x0A
#define	P2P_ATTR_CH_LIST					0x0B
#define	P2P_ATTR_NOA						0x0C
#define	P2P_ATTR_DEVICE_INFO				0x0D
#define	P2P_ATTR_GROUP_INFO				0x0E
#define	P2P_ATTR_GROUP_ID					0x0F
#define	P2P_ATTR_INTERFACE				0x10
#define	P2P_ATTR_OPERATING_CH			0x11
#define	P2P_ATTR_INVITATION_FLAGS		0x12

/*	Value of Status Attribute */
#define	P2P_STATUS_SUCCESS						0x00
#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
#define	P2P_STATUS_FAIL_USER_REJECT				0x0B

/*	Value of Inviation Flags Attribute */
#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)

#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
				 P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
				 P2P_DEVCAP_CONCURRENT_OPERATION | \
				 P2P_DEVCAP_INVITATION_PROC)

#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)

/*	Value of Device Capability Bitmap */
#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)

/*	Value of Group Capability Bitmap */
#define	P2P_GRPCAP_GO							BIT(0)
#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
#define	P2P_GRPCAP_INTRABSS					BIT(3)
#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)

/*	P2P Public Action Frame ( Management Frame ) */
#define	P2P_PUB_ACTION_ACTION				0x09

/*	P2P Public Action Frame Type */
#define	P2P_GO_NEGO_REQ						0
#define	P2P_GO_NEGO_RESP						1
#define	P2P_GO_NEGO_CONF						2
#define	P2P_INVIT_REQ							3
#define	P2P_INVIT_RESP							4
#define	P2P_DEVDISC_REQ						5
#define	P2P_DEVDISC_RESP						6
#define	P2P_PROVISION_DISC_REQ				7
#define	P2P_PROVISION_DISC_RESP				8

/*	P2P Action Frame Type */
#define	P2P_NOTICE_OF_ABSENCE	0
#define	P2P_PRESENCE_REQUEST		1
#define	P2P_PRESENCE_RESPONSE	2
#define	P2P_GO_DISC_REQUEST		3


#define	P2P_MAX_PERSISTENT_GROUP_NUM		10

#define	P2P_PROVISIONING_SCAN_CNT			3

#define	P2P_WILDCARD_SSID_LEN				7

#define	P2P_FINDPHASE_EX_NONE				0	/* default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase */
#define	P2P_FINDPHASE_EX_FULL				1	/* used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase */
#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
#define	P2P_FINDPHASE_EX_MAX					4
#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX

#define	P2P_PROVISION_TIMEOUT				5000	/*	5 seconds timeout for sending the provision discovery request */
#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	/*	3 seconds timeout for sending the provision discovery request under concurrent mode */
#define	P2P_GO_NEGO_TIMEOUT					5000	/*	5 seconds timeout for receiving the group negotation response */
#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	/*	3 seconds timeout for sending the negotiation request under concurrent mode */
#define	P2P_TX_PRESCAN_TIMEOUT				100		/*	100ms */
#define	P2P_INVITE_TIMEOUT					5000	/*	5 seconds timeout for sending the invitation request */
#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	/*	3 seconds timeout for sending the invitation request under concurrent mode */
#define	P2P_RESET_SCAN_CH						25000	/*	25 seconds timeout to reset the scan channel (based on channel plan) */
#define	P2P_MAX_INTENT						15

#define	P2P_MAX_NOA_NUM						2

/*	WPS Configuration Method */
#define	WPS_CM_NONE							0x0000
#define	WPS_CM_LABEL							0x0004
#define	WPS_CM_DISPLYA						0x0008
#define	WPS_CM_EXTERNAL_NFC_TOKEN			0x0010
#define	WPS_CM_INTEGRATED_NFC_TOKEN		0x0020
#define	WPS_CM_NFC_INTERFACE					0x0040
#define	WPS_CM_PUSH_BUTTON					0x0080
#define	WPS_CM_KEYPAD						0x0100
#define	WPS_CM_SW_PUHS_BUTTON				0x0280
#define	WPS_CM_HW_PUHS_BUTTON				0x0480
#define	WPS_CM_SW_DISPLAY_PIN				0x2008
#define	WPS_CM_LCD_DISPLAY_PIN				0x4008

enum P2P_ROLE {
	P2P_ROLE_DISABLE = 0,
	P2P_ROLE_DEVICE = 1,
	P2P_ROLE_CLIENT = 2,
	P2P_ROLE_GO = 3
};

enum P2P_STATE {
	P2P_STATE_NONE = 0,							/*	P2P disable */
	P2P_STATE_IDLE = 1,								/*	P2P had enabled and do nothing ,  buddy adapters is linked */
	P2P_STATE_LISTEN = 2,							/*	In pure listen state */
	P2P_STATE_SCAN = 3,							/*	In scan phase */
	P2P_STATE_FIND_PHASE_LISTEN = 4,				/*	In the listen state of find phase */
	P2P_STATE_FIND_PHASE_SEARCH = 5,				/*	In the search state of find phase */
	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			/*	In P2P provisioning discovery */
	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
	P2P_STATE_GONEGO_ING = 9,						/*	Doing the group owner negoitation handshake */
	P2P_STATE_GONEGO_OK = 10,						/*	finish the group negoitation handshake with success */
	P2P_STATE_GONEGO_FAIL = 11,					/*	finish the group negoitation handshake with failure */
	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		/*	receiving the P2P Inviation request and match with the profile. */
	P2P_STATE_PROVISIONING_ING = 13,				/*	Doing the P2P WPS */
	P2P_STATE_PROVISIONING_DONE = 14,			/*	Finish the P2P WPS */
	P2P_STATE_TX_INVITE_REQ = 15,					/*	Transmit the P2P Invitation request */
	P2P_STATE_RX_INVITE_RESP_OK = 16,				/*	Receiving the P2P Invitation response */
	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	/*	receiving the P2P Inviation request and dismatch with the profile. */
	P2P_STATE_RECV_INVITE_REQ_GO = 18,			/*	receiving the P2P Inviation request and this wifi is GO. */
	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			/*	receiving the P2P Inviation request to join an existing P2P Group. */
	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			/*	recveing the P2P Inviation response with failure */
	P2P_STATE_RX_INFOR_NOREADY = 21,			/* receiving p2p negoitation response with information is not available */
	P2P_STATE_TX_INFOR_NOREADY = 22,			/* sending p2p negoitation response with information is not available */
};

enum P2P_WPSINFO {
	P2P_NO_WPSINFO						= 0,
	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
	P2P_GOT_WPSINFO_PBC					= 3,
};

#define	P2P_PRIVATE_IOCTL_SET_LEN		64

enum P2P_PROTO_WK_ID {
	P2P_FIND_PHASE_WK = 0,
	P2P_RESTORE_STATE_WK = 1,
	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
	P2P_AP_P2P_CH_SWITCH_PROCESS_WK = 5,
	P2P_RO_CH_WK = 6,
	P2P_CANCEL_RO_CH_WK = 7,
};

#ifdef CONFIG_P2P_PS
enum P2P_PS_STATE {
	P2P_PS_DISABLE = 0,
	P2P_PS_ENABLE = 1,
	P2P_PS_SCAN = 2,
	P2P_PS_SCAN_DONE = 3,
	P2P_PS_ALLSTASLEEP = 4, /* for P2P GO */
};

enum P2P_PS_MODE {
	P2P_PS_NONE = 0,
	P2P_PS_CTWINDOW = 1,
	P2P_PS_NOA	 = 2,
	P2P_PS_MIX = 3, /* CTWindow and NoA */
};
#endif /* CONFIG_P2P_PS */

/*	=====================WFD Section=====================
 *	For Wi-Fi Display */
#define	WFD_ATTR_DEVICE_INFO			0x00
#define	WFD_ATTR_ASSOC_BSSID			0x01
#define	WFD_ATTR_COUPLED_SINK_INFO	0x06
#define	WFD_ATTR_LOCAL_IP_ADDR		0x08
#define	WFD_ATTR_SESSION_INFO		0x09
#define	WFD_ATTR_ALTER_MAC			0x0a

/*	For WFD Device Information Attribute */
#define	WFD_DEVINFO_SOURCE					0x0000
#define	WFD_DEVINFO_PSINK					0x0001
#define	WFD_DEVINFO_SSINK					0x0002
#define	WFD_DEVINFO_DUAL					0x0003

#define	WFD_DEVINFO_SESSION_AVAIL			0x0010
#define	WFD_DEVINFO_WSD						0x0040
#define	WFD_DEVINFO_PC_TDLS					0x0080
#define	WFD_DEVINFO_HDCP_SUPPORT			0x0100

#define IP_MCAST_MAC(mac)		((mac[0] == 0x01) && (mac[1] == 0x00) && (mac[2] == 0x5e))
#define ICMPV6_MCAST_MAC(mac)	((mac[0] == 0x33) && (mac[1] == 0x33) && (mac[2] != 0xff))

#ifdef CONFIG_IOCTL_CFG80211
/* Regulatroy Domain */
struct regd_pair_mapping {
	u16 reg_dmnenum;
	u16 reg_5ghz_ctl;
	u16 reg_2ghz_ctl;
};

struct rtw_regulatory {
	char alpha2[2];
	u16 country_code;
	u16 max_power_level;
	u32 tp_scale;
	u16 current_rd;
	u16 current_rd_ext;
	int16_t power_limit;
	struct regd_pair_mapping *regpair;
};
#endif

#ifdef CONFIG_WAPI_SUPPORT
#ifndef IW_AUTH_WAPI_VERSION_1
#define IW_AUTH_WAPI_VERSION_1		0x00000008
#endif
#ifndef IW_AUTH_KEY_MGMT_WAPI_PSK
#define IW_AUTH_KEY_MGMT_WAPI_PSK	0x04
#endif
#ifndef IW_AUTH_WAPI_ENABLED
#define IW_AUTH_WAPI_ENABLED		0x20
#endif
#ifndef IW_ENCODE_ALG_SM4
#define IW_ENCODE_ALG_SM4			0x20
#endif
#endif

#endif /* _WIFI_H_ */
                                                                     rtl8822bu/src/include/hal_com_phycfg.h                                                              0000644 0001750 0001750 00000024237 14214766567 016547  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_COM_PHYCFG_H__
#define __HAL_COM_PHYCFG_H__

#ifndef DBG_TX_POWER_IDX
#define DBG_TX_POWER_IDX 0
#endif

#define		PathA                     			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

typedef enum _RF_TX_NUM {
	RF_1TX = 0,
	RF_2TX,
	RF_3TX,
	RF_4TX,
	RF_MAX_TX_NUM,
	RF_TX_NUM_NONIMPLEMENT,
} RF_TX_NUM;

enum txpwr_pg_mode {
	TXPWR_PG_WITH_PWR_IDX,
	TXPWR_PG_WITH_TSSI_OFFSET,
	TXPWR_PG_UNKNOWN, /* keep last */
};

/*------------------------------Define structure----------------------------*/
typedef struct _BB_REGISTER_DEFINITION {
	u32 rfintfs;			/* set software control: */
	/*		0x870~0x877[8 bytes] */

	u32 rfintfo; 			/* output data: */
	/*		0x860~0x86f [16 bytes] */

	u32 rfintfe; 			/* output enable: */
	/*		0x860~0x86f [16 bytes] */

	u32 rf3wireOffset;	/* LSSI data: */
	/*		0x840~0x84f [16 bytes] */

	u32 rfHSSIPara2;	/* wire parameter control2 :  */
	/*		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes] */

	u32 rfLSSIReadBack;	/* LSSI RF readback data SI mode */
	/*		0x8a0~0x8af [16 bytes] */

	u32 rfLSSIReadBackPi;	/* LSSI RF readback data PI mode 0x8b8-8bc for Path A and B */

} BB_REGISTER_DEFINITION_T, *PBB_REGISTER_DEFINITION_T;


/* ---------------------------------------------------------------------- */

extern const char *const _txpwr_pg_mode_str[];
#define txpwr_pg_mode_str(_mode) (((_mode) >= TXPWR_PG_UNKNOWN) ? _txpwr_pg_mode_str[TXPWR_PG_UNKNOWN] : _txpwr_pg_mode_str[(_mode)])

u8 phy_get_target_txpwr(
		PADAPTER		Adapter,
		u8				Band,
		u8				RfPath,
		RATE_SECTION	RateSection
);

void
PHY_GetRateValuesOfTxPowerByRate(
		PADAPTER pAdapter,
		u32 RegAddr,
		u32 BitMask,
		u32 Value,
		u8 *Rate,
		s8 *PwrByRateVal,
		u8 *RateNum
);

u8
PHY_GetRateIndexOfTxPowerByRate(
		u8	Rate
);

void
phy_set_tx_power_index_by_rate_section(
		PADAPTER		pAdapter,
		enum rf_path		RFPath,
		u8				Channel,
		u8				RateSection
);

s8
_PHY_GetTxPowerByRate(
		PADAPTER	pAdapter,
		u8			Band,
		enum rf_path	RFPath,
		u8			RateIndex
);

s8
PHY_GetTxPowerByRate(
		PADAPTER	pAdapter,
		u8			Band,
		enum rf_path	RFPath,
		RATE_SECTION rs,
		enum MGN_RATE rate
);

void
PHY_SetTxPowerByRate(
		PADAPTER	pAdapter,
		u8			Band,
		enum rf_path	RFPath,
		u8			Rate,
		s8			Value
);

void
phy_set_tx_power_level_by_path(
		PADAPTER	Adapter,
		u8			channel,
		u8			path
);

void
PHY_InitTxPowerByRate(
		PADAPTER	pAdapter
);

void
phy_store_tx_power_by_rate(
		PADAPTER	pAdapter,
		u32			Band,
		u32			RfPath,
		u32			TxNum,
		u32			RegAddr,
		u32			BitMask,
		u32			Data
);

void
PHY_TxPowerByRateConfiguration(
	  PADAPTER			pAdapter
);

bool phy_chk_ch_setting_consistency(_adapter *adapter, u8 ch);

#ifdef CONFIG_TXPWR_PG_WITH_PWR_IDX
u8 phy_get_pg_txpwr_idx(_adapter *pAdapter
	, enum rf_path RFPath, RATE_SECTION rs, u8 ntx_idx
	, enum channel_width BandWidth, u8 band, u8 Channel);
#endif

#if CONFIG_TXPWR_LIMIT
s8 phy_get_txpwr_lmt(_adapter *adapter
	, const char *regd_name
	, BAND_TYPE band, enum channel_width bw
	, u8 tlrs, u8 ntx_idx, u8 cch, u8 lock
);

s8 phy_get_txpwr_lmt_diff(_adapter *adapter
	, const char *regd_name
	, BAND_TYPE band, enum channel_width bw
	, u8 rfpath, u8 rs, u8 tlrs, u8 ntx_idx, u8 cch, u8 lock
);

s8 phy_get_txpwr_lmt_sub_chs(_adapter *adapter
	, const char *regd_name
	, BAND_TYPE band, enum channel_width bw
	, u8 rfpath, u8 rate, u8 ntx_idx, u8 cch, u8 opch
);
#else
#define phy_get_txpwr_lmt(adapter, regd_name, band, bw, tlrs, ntx_idx, cch, lock) (GET_HAL_SPEC(adapter)->txgi_max)
#define phy_get_txpwr_lmt_diff(adapter, regd_name, band, bw, rfpath, rs, tlrs, ntx_idx, cch, lock) (GET_HAL_SPEC(adapter)->txgi_max)
#define phy_get_txpwr_lmt_sub_chs(adapter, regd_name, band, bw, rfpath, rate, ntx_idx, cch, opch) (GET_HAL_SPEC(adapter)->txgi_max)
#endif /* CONFIG_TXPWR_LIMIT */

s8 phy_get_txpwr_target(_adapter *adapter, u8 rfpath, RATE_SECTION rs, u8 rate, u8 ntx_idx
	, enum channel_width bw, BAND_TYPE band, u8 cch, u8 opch, struct txpwr_idx_comp *tic);
s8 phy_get_txpwr_amends(_adapter *adapter, u8 rfpath, RATE_SECTION rs, u8 rate, u8 ntx_idx
	, enum channel_width bw, BAND_TYPE band, u8 cch, struct txpwr_idx_comp *tic);
#ifdef CONFIG_TXPWR_PG_WITH_TSSI_OFFSET
s8 phy_get_tssi_txpwr_by_rate_ref(_adapter *adapter, enum rf_path path
	, enum channel_width bw, u8 cch, u8 opch);
#endif
u8 hal_com_get_txpwr_idx(_adapter *adapter, enum rf_path rfpath
	, RATE_SECTION rs, enum MGN_RATE rate, enum channel_width bw, BAND_TYPE band, u8 cch, u8 opch
	, struct txpwr_idx_comp *tic);

s16 phy_get_txpwr_single_mbm(_adapter *adapter, u8 rfpath, RATE_SECTION rs, u8 rate
	, enum channel_width bw, u8 cch, u8 opch, struct txpwr_idx_comp *tic);
s16 phy_get_txpwr_total_mbm(_adapter *adapter, RATE_SECTION rs, u8 rate
	, enum channel_width bw, u8 cch, u8 opch, struct txpwr_idx_comp *tic);

s16 phy_get_txpwr_single_max_mbm(_adapter *adapter, u8 rfpath
	, enum channel_width bw, u8 cch, u8 opch, u16 bmp_cck_ofdm, u32 bmp_ht, u64 bmp_vht);
s16 phy_get_txpwr_total_max_mbm(_adapter *adapter
	, enum channel_width bw, u8 cch, u8 opch, u16 bmp_cck_ofdm, u32 bmp_ht, u64 bmp_vht);

s8
phy_get_tx_power_final_absolute_value(_adapter *adapter, u8 rfpath, u8 rate,
				      enum channel_width bw, u8 channel);

s8
PHY_GetTxPowerTrackingOffset(
	PADAPTER	pAdapter,
	enum rf_path	RFPath,
	u8			Rate
);

struct txpwr_idx_comp {
	u8 ntx_idx;
	s8 target;
	s8 base;

	/* for target */
	s8 by_rate;
	s8 btc;
	s8 extra;
	s8 utarget;
	s8 limit;
	s8 ulimit;

	/* for amends */
	s8 tpt;
	s8 dpd;
};

u8 phy_get_tx_power_index_ex(_adapter *adapter
	, enum rf_path rfpath, RATE_SECTION rs, enum MGN_RATE rate
	, enum channel_width bw, BAND_TYPE band, u8 cch, u8 opch);

u8
phy_get_tx_power_index(
		PADAPTER			pAdapter,
		enum rf_path			RFPath,
		u8					Rate,
		enum channel_width	BandWidth,
		u8					Channel
);

void
PHY_SetTxPowerIndex(
		PADAPTER		pAdapter,
		u32				PowerIndex,
		enum rf_path		RFPath,
		u8				Rate
);

bool phy_is_txpwr_user_mbm_valid(_adapter *adapter, s16 mbm);
bool phy_is_txpwr_user_target_specified(_adapter *adapter);

void dump_tx_power_index_inline(void *sel, _adapter *adapter, u8 rfpath
	, enum channel_width bw, u8 cch, enum MGN_RATE rate, u8 pwr_idx, struct txpwr_idx_comp *tic);
void dump_tx_power_idx_title(void *sel, _adapter *adapter
	, enum channel_width bw, u8 cch, u8 opch);
void dump_tx_power_idx_by_path_rs(void *sel, _adapter *adapter, u8 rfpath
	, RATE_SECTION rs, enum channel_width bw, u8 cch, u8 opch);
void dump_tx_power_idx(void *sel, _adapter *adapter
	, enum channel_width bw, u8 cch, u8 opch);
void dump_txpwr_total_dbm_title(void *sel, _adapter *adapter
	, enum channel_width bw, u8 cch, u8 opch);
void dump_txpwr_total_dbm_by_rs(void *sel, _adapter *adapter, u8 rs
	, enum channel_width bw, u8 cch, u8 opch);
void dump_txpwr_total_dbm(void *sel, _adapter *adapter
	, enum channel_width bw, u8 cch, u8 opch);

bool phy_is_tx_power_limit_needed(_adapter *adapter);
bool phy_is_tx_power_by_rate_needed(_adapter *adapter);
int phy_load_tx_power_by_rate(_adapter *adapter, u8 chk_file);
#if CONFIG_TXPWR_LIMIT
int phy_load_tx_power_limit(_adapter *adapter, u8 chk_file);
#endif
void phy_load_tx_power_ext_info(_adapter *adapter, u8 chk_file);
void phy_reload_tx_power_ext_info(_adapter *adapter);
void phy_reload_default_tx_power_ext_info(_adapter *adapter);

const struct map_t *hal_pg_txpwr_def_info(_adapter *adapter);

#ifdef CONFIG_EFUSE_CONFIG_FILE
int check_phy_efuse_tx_power_info_valid(_adapter *adapter);
#endif

#ifdef CONFIG_TXPWR_PG_WITH_PWR_IDX
void dump_hal_txpwr_info_2g(void *sel, _adapter *adapter, u8 rfpath_num, u8 max_tx_cnt);
void dump_hal_txpwr_info_5g(void *sel, _adapter *adapter, u8 rfpath_num, u8 max_tx_cnt);

void hal_load_txpwr_info(_adapter *adapter);
#endif

void dump_tx_power_ext_info(void *sel, _adapter *adapter);
void dump_target_tx_power(void *sel, _adapter *adapter);
void dump_tx_power_by_rate(void *sel, _adapter *adapter);

int rtw_get_phy_file_path(_adapter *adapter, const char *file_name);

#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
#define MAC_FILE_FW_NIC			"FW_NIC.bin"
#define MAC_FILE_FW_WW_IMG		"FW_WoWLAN.bin"
#define PHY_FILE_MAC_REG		"MAC_REG.txt"

#define PHY_FILE_AGC_TAB		"AGC_TAB.txt"
#define PHY_FILE_PHY_REG		"PHY_REG.txt"
#define PHY_FILE_PHY_REG_MP		"PHY_REG_MP.txt"
#define PHY_FILE_PHY_REG_PG		"PHY_REG_PG.txt"

#define PHY_FILE_RADIO_A		"RadioA.txt"
#define PHY_FILE_RADIO_B		"RadioB.txt"
#define PHY_FILE_RADIO_C		"RadioC.txt"
#define PHY_FILE_RADIO_D		"RadioD.txt"
#define PHY_FILE_TXPWR_TRACK	"TxPowerTrack.txt"
#define PHY_FILE_TXPWR_LMT		"TXPWR_LMT.txt"

#define PHY_FILE_WIFI_ANT_ISOLATION	"wifi_ant_isolation.txt"

#define MAX_PARA_FILE_BUF_LEN	32768 /* 32k */

#define LOAD_MAC_PARA_FILE				BIT0
#define LOAD_BB_PARA_FILE					BIT1
#define LOAD_BB_PG_PARA_FILE				BIT2
#define LOAD_BB_MP_PARA_FILE				BIT3
#define LOAD_RF_PARA_FILE					BIT4
#define LOAD_RF_TXPWR_TRACK_PARA_FILE	BIT5
#define LOAD_RF_TXPWR_LMT_PARA_FILE		BIT6

int phy_ConfigMACWithParaFile(PADAPTER	Adapter, char	*pFileName);
int phy_ConfigBBWithParaFile(PADAPTER	Adapter, char	*pFileName, u32	ConfigType);
int phy_ConfigBBWithPgParaFile(PADAPTER	Adapter, const char *pFileName);
int phy_ConfigBBWithMpParaFile(PADAPTER	Adapter, char	*pFileName);
int PHY_ConfigRFWithParaFile(PADAPTER	Adapter, char	*pFileName, enum rf_path	eRFPath);
int PHY_ConfigRFWithTxPwrTrackParaFile(PADAPTER	Adapter, char	*pFileName);
#if CONFIG_TXPWR_LIMIT
int PHY_ConfigRFWithPowerLimitTableParaFile(PADAPTER	Adapter, const char *pFileName);
#endif
void phy_free_filebuf_mask(_adapter *padapter, u8 mask);
void phy_free_filebuf(_adapter *padapter);
#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
u8 phy_check_under_survey_ch(_adapter *adapter);
#endif /* __HAL_COMMON_H__ */
                                                                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/sdio_ops.h                                                                    0000644 0001750 0001750 00000020401 14214766567 015411  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __SDIO_OPS_H__
#define __SDIO_OPS_H__


/* Follow mac team suggestion, default I/O fail return value is 0xFF */
#define SDIO_ERR_VAL8	0xFF
#define SDIO_ERR_VAL16	0xFFFF
#define SDIO_ERR_VAL32	0xFFFFFFFF

#ifdef PLATFORM_LINUX
#include <sdio_ops_linux.h>
#endif

extern void sdio_set_intf_ops(_adapter *padapter, struct _io_ops *pops);
void dump_sdio_card_info(void *sel, struct dvobj_priv *dvobj);

u32 sdio_init(struct dvobj_priv *dvobj);
void sdio_deinit(struct dvobj_priv *dvobj);
int sdio_alloc_irq(struct dvobj_priv *dvobj);
void sdio_free_irq(struct dvobj_priv *dvobj);
u8 sdio_get_num_of_func(struct dvobj_priv *dvobj);

#if 0
extern void sdio_func1cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
extern void sdio_func1cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
#endif
extern u8 SdioLocalCmd52Read1Byte(PADAPTER padapter, u32 addr);
extern void SdioLocalCmd52Write1Byte(PADAPTER padapter, u32 addr, u8 v);
extern s32 _sdio_local_read(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
extern s32 sdio_local_read(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
extern s32 _sdio_local_write(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
extern s32 sdio_local_write(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);

u32 _sdio_read32(PADAPTER padapter, u32 addr);
s32 _sdio_write32(PADAPTER padapter, u32 addr, u32 val);

extern void sd_int_hdl(PADAPTER padapter);
extern u8 CheckIPSStatus(PADAPTER padapter);

#ifdef CONFIG_RTL8188E
extern void InitInterrupt8188ESdio(PADAPTER padapter);
extern void EnableInterrupt8188ESdio(PADAPTER padapter);
extern void DisableInterrupt8188ESdio(PADAPTER padapter);
extern void UpdateInterruptMask8188ESdio(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
extern u8 HalQueryTxBufferStatus8189ESdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8189ESdio(PADAPTER padapter);
extern void ClearInterrupt8188ESdio(PADAPTER padapter);
#endif /* CONFIG_RTL8188E */

#ifdef CONFIG_RTL8821A
extern void InitInterrupt8821AS(PADAPTER padapter);
extern void EnableInterrupt8821AS(PADAPTER padapter);
extern void DisableInterrupt8821AS(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8821AS(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8821ASdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
void ClearInterrupt8821AS(PADAPTER padapter);
#endif /* defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) */
#endif /* CONFIG_RTL8821A */

#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
#if defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8822C)
u8 rtw_hal_enable_cpwm2(_adapter *adapter);
#endif
extern u8 RecvOnePkt(PADAPTER padapter);
#endif /* CONFIG_WOWLAN */
#ifdef CONFIG_RTL8723B
extern void InitInterrupt8723BSdio(PADAPTER padapter);
extern void InitSysInterrupt8723BSdio(PADAPTER padapter);
extern void EnableInterrupt8723BSdio(PADAPTER padapter);
extern void DisableInterrupt8723BSdio(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8723BSdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8723BSdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
extern void DisableInterruptButCpwm28723BSdio(PADAPTER padapter);
extern void ClearInterrupt8723BSdio(PADAPTER padapter);
#endif /* CONFIG_WOWLAN */
#endif


#ifdef CONFIG_RTL8192E
extern void InitInterrupt8192ESdio(PADAPTER padapter);
extern void EnableInterrupt8192ESdio(PADAPTER padapter);
extern void DisableInterrupt8192ESdio(PADAPTER padapter);
extern void UpdateInterruptMask8192ESdio(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
extern u8 HalQueryTxBufferStatus8192ESdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8192ESdio(PADAPTER padapter);
extern void ClearInterrupt8192ESdio(PADAPTER padapter);
#endif /* CONFIG_RTL8192E */

#ifdef CONFIG_RTL8703B
extern void InitInterrupt8703BSdio(PADAPTER padapter);
extern void InitSysInterrupt8703BSdio(PADAPTER padapter);
extern void EnableInterrupt8703BSdio(PADAPTER padapter);
extern void DisableInterrupt8703BSdio(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8703BSdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8703BSdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
extern void DisableInterruptButCpwm28703BSdio(PADAPTER padapter);
extern void ClearInterrupt8703BSdio(PADAPTER padapter);
#endif /* CONFIG_WOWLAN */
#endif

#ifdef CONFIG_RTL8723D
extern void InitInterrupt8723DSdio(PADAPTER padapter);
extern void InitSysInterrupt8723DSdio(PADAPTER padapter);
extern void EnableInterrupt8723DSdio(PADAPTER padapter);
extern void DisableInterrupt8723DSdio(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8723DSdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8723DSdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
extern void DisableInterruptButCpwm28723dSdio(PADAPTER padapter);
extern void ClearInterrupt8723DSdio(PADAPTER padapter);
#endif /* CONFIG_WOWLAN */
#endif

#ifdef CONFIG_RTL8192F
extern void InitInterrupt8192FSdio(PADAPTER padapter);
extern void InitSysInterrupt8192FSdio(PADAPTER padapter);
extern void EnableInterrupt8192FSdio(PADAPTER padapter);
extern void DisableInterrupt8192FSdio(PADAPTER padapter);
extern void UpdateInterruptMask8192FSdio(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
extern u8 HalQueryTxBufferStatus8192FSdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8192FSdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
extern void DisableInterruptButCpwm2192fSdio(PADAPTER padapter);
extern void ClearInterrupt8192FSdio(PADAPTER padapter);
#endif /* CONFIG_WOWLAN */
#endif

#ifdef CONFIG_RTL8188F
extern void InitInterrupt8188FSdio(PADAPTER padapter);
extern void InitSysInterrupt8188FSdio(PADAPTER padapter);
extern void EnableInterrupt8188FSdio(PADAPTER padapter);
extern void DisableInterrupt8188FSdio(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8188FSdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8188FSdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
extern void DisableInterruptButCpwm28188FSdio(PADAPTER padapter);
extern void ClearInterrupt8188FSdio(PADAPTER padapter);
#endif /* defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) */
#endif

#ifdef CONFIG_RTL8188GTV
extern void InitInterrupt8188GTVSdio(PADAPTER padapter);
extern void InitSysInterrupt8188GTVSdio(PADAPTER padapter);
extern void EnableInterrupt8188GTVSdio(PADAPTER padapter);
extern void DisableInterrupt8188GTVSdio(PADAPTER padapter);
extern u8 HalQueryTxBufferStatus8188GTVSdio(PADAPTER padapter);
extern u8 HalQueryTxOQTBufferStatus8188GTVSdio(PADAPTER padapter);
#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
extern void DisableInterruptButCpwm28188GTVSdio(PADAPTER padapter);
extern void ClearInterrupt8188GTVSdio(PADAPTER padapter);
#endif /* defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) */
#endif

/**
 * rtw_sdio_get_block_size() - Get block size of SDIO transfer
 * @d		struct dvobj_priv*
 *
 * The unit of return value is byte.
 */
static inline u32 rtw_sdio_get_block_size(struct dvobj_priv *d)
{
	return d->intf_data.block_transfer_len;
}

/**
 * rtw_sdio_cmd53_align_size() - Align size to one CMD53 could complete
 * @d		struct dvobj_priv*
 * @len		length to align
 *
 * Adjust len to align block size, and the new size could be transfered by one
 * CMD53.
 * If len < block size, it would keep original value, otherwise the value
 * would be rounded up by block size.
 *
 * Return adjusted length.
 */
static inline size_t rtw_sdio_cmd53_align_size(struct dvobj_priv *d, size_t len)
{
	u32 blk_sz;


	blk_sz = rtw_sdio_get_block_size(d);
	if (len <= blk_sz)
		return len;

	return _RND(len, blk_sz);
}

#endif /* !__SDIO_OPS_H__ */
                                                                                                                                                                                                                                                               rtl8822bu/src/include/rtl8814a_led.h                                                                0000644 0001750 0001750 00000002647 14214766567 015721  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8814A_LED_H__
#define __RTL8814A_LED_H__

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8814au_InitSwLeds(PADAPTER padapter);
	void rtl8814au_DeInitSwLeds(PADAPTER padapter);
#endif /* CONFIG_USB_HCI */
#ifdef CONFIG_PCI_HCI
	void rtl8814ae_InitSwLeds(PADAPTER padapter);
	void rtl8814ae_DeInitSwLeds(PADAPTER padapter);
#endif /* CONFIG_PCI_HCI */
#ifdef CONFIG_SDIO_HCI
	void rtl8814s_InitSwLeds(PADAPTER padapter);
	void rtl8814s_DeInitSwLeds(PADAPTER padapter);
#endif /* CONFIG_SDIO_HCI */

#endif /* __RTL8814A_LED_H__ */
#endif /*CONFIG_RTW_SW_LED*/
                                                                                         rtl8822bu/src/include/drv_types_ce.h                                                                0000644 0001750 0001750 00000004671 14214766567 016273  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_TYPES_CE_H__
#define __DRV_TYPES_CE_H__

#include <drv_conf.h>
#include <osdep_service.h>

#include <Sdcardddk.h>

#define MAX_ACTIVE_REG_PATH 256

#define MAX_MCAST_LIST_NUM					32



/* for ioctl */
#define MAKE_DRIVER_VERSION(_MainVer, _MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)

#define NIC_HEADER_SIZE				14			/* !< can be moved to typedef.h */
#define NIC_MAX_PACKET_SIZE			1514		/* !< can be moved to typedef.h */
#define NIC_MAX_SEND_PACKETS			10		/* max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h */
#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0, 001)	/* !< can be moved to typedef.h */
#define NIC_MAX_PACKET_SIZE			1514		/* !< can be moved to typedef.h */

typedef struct _MP_REG_ENTRY {

	NDIS_STRING		RegName;	/* variable name text */
	BOOLEAN			bRequired;	/* 1->required, 0->optional */

	u8			Type;		/* NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString */
	uint			FieldOffset;	/* offset to MP_ADAPTER field */
	uint			FieldSize;	/* size (in bytes) of the field */

#ifdef UNDER_AMD64
	u64			Default;
#else
	u32			Default;		/* default value to use */
#endif

	u32			Min;			/* minimum value allowed */
	u32			Max;		/* maximum value allowed */
} MP_REG_ENTRY, *PMP_REG_ENTRY;

#ifdef CONFIG_USB_HCI
typedef struct _USB_EXTENSION {
	LPCUSB_FUNCS    _lpUsbFuncs;
	USB_HANDLE	    _hDevice;
	PVOID		    pAdapter;

#if 0
	USB_ENDPOINT_DESCRIPTOR		_endpACLIn;
	USB_ENDPOINT_DESCRIPTOR		_endpACLOutHigh;
	USB_ENDPOINT_DESCRIPTOR		_endpACLOutNormal;

	USB_PIPE        pPipeIn;
	USB_PIPE        pPipeOutNormal;
	USB_PIPE        pPipeOutHigh;
#endif

} USB_EXTENSION, *PUSB_EXTENSION;
#endif


typedef struct _OCTET_STRING {
	u8      *Octet;
	u16      Length;
} OCTET_STRING, *POCTET_STRING;





#endif
                                                                       rtl8822bu/src/include/rtl8192f_led.h                                                                0000644 0001750 0001750 00000002634 14214766567 015721  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_LED_H__
#define __RTL8192F_LED_H__

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
void rtl8192fu_InitSwLeds(PADAPTER padapter);
void rtl8192fu_DeInitSwLeds(PADAPTER padapter);
#endif

#ifdef CONFIG_SDIO_HCI
void rtl8192fs_InitSwLeds(PADAPTER padapter);
void rtl8192fs_DeInitSwLeds(PADAPTER padapter);
#endif

#ifdef CONFIG_PCI_HCI
void rtl8192fe_InitSwLeds(PADAPTER padapter);
void rtl8192fe_DeInitSwLeds(PADAPTER padapter);
#endif
#endif /*#ifdef CONFIG_RTW_SW_LED*/

#endif
                                                                                                    rtl8822bu/src/include/rtw_byteorder.h                                                               0000644 0001750 0001750 00000002171 14214766567 016471  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL871X_BYTEORDER_H_
#define _RTL871X_BYTEORDER_H_


#if defined(CONFIG_LITTLE_ENDIAN) && defined (CONFIG_BIG_ENDIAN)
	#error "Shall be CONFIG_LITTLE_ENDIAN or CONFIG_BIG_ENDIAN, but not both!\n"
#endif

#if defined(CONFIG_LITTLE_ENDIAN)
	#ifndef CONFIG_PLATFORM_MSTAR389
		#include <byteorder/little_endian.h>
	#endif
#elif defined (CONFIG_BIG_ENDIAN)
	#include <byteorder/big_endian.h>
#else
	#  error "Must be LITTLE/BIG Endian Host"
#endif

#endif /* _RTL871X_BYTEORDER_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                       rtl8822bu/src/include/rtl8822c_hal.h                                                                0000755 0001750 0001750 00000022007 14214766567 015715  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822C_HAL_H_
#define _RTL8822C_HAL_H_

#include <osdep_service.h>		/* BIT(x) */
#include <drv_types.h>			/* PADAPTER */
#include "../hal/halmac/halmac_api.h"	/* MAC REG definition */

#ifdef CONFIG_SUPPORT_TRX_SHARED
#define DEF_RECVBUF_SZ		24576	/* RX 24K */
#if (DFT_TRX_SHARE_MODE == 1)
#define RX_FIFO_EXPANDING 40960	/* RX= 24K+40K=64K , TX=256K-40K=216K */
#elif (DFT_TRX_SHARE_MODE == 2)
#define RX_FIFO_EXPANDING 65536	/* RX= 24K+40K+24=88K , TX=256K-40K-24K=192K */
#elif (DFT_TRX_SHARE_MODE ==3)
#define RX_FIFO_EXPANDING 106496	/* RX= 24K+40K+24+40K=128K , TX=256K-40K-24K-40K=152K */
#elif (DFT_TRX_SHARE_MODE ==4)
#define RX_FIFO_EXPANDING 131072	/* RX= 24K+40K+24+40K+24K=128K , TX=256K-40K-24K-40K-24K=128K */
#else
#define RX_FIFO_EXPANDING 0
#endif
#define MAX_RECVBUF_SZ	(DEF_RECVBUF_SZ + RX_FIFO_EXPANDING)	
#else /* !CONFIG_SUPPORT_TRX_SHARED */
#define MAX_RECVBUF_SZ		24576	/* 24KB, TX: 256KB */
#endif /* !CONFIG_SUPPORT_TRX_SHARED */

/*
 * MAC Register definition
 */
#define REG_AFE_XTAL_CTRL	REG_AFE_CTRL1_8822C	/* hal_com.c & phydm */
#define REG_LEDCFG0		REG_LED_CFG_8822C	/* rtw_mp.c */
#define MSR			(REG_CR_8822C + 2)	/* rtw_mp.c & hal_com.c */
#define MSR1			REG_CR_EXT_8822C	/* rtw_mp.c & hal_com.c */
#define REG_C2HEVT_MSG_NORMAL	0x1A0			/* hal_com.c */
#define REG_C2HEVT_CLEAR	0x1AF			/* hal_com.c */
#define REG_BCN_CTRL_1		REG_BCN_CTRL_CLINT0_8822C	/* hal_com.c */

#define REG_WOWLAN_WAKE_REASON	0x01C7 /* hal_com.c */
#define REG_GPIO_PIN_CTRL_2		REG_GPIO_EXT_CTRL_8822C		/* hal_com.c */

/* RXERR_RPT, for rtw_mp.c */
#define RXERR_TYPE_OFDM_PPDU		0
#define RXERR_TYPE_OFDM_FALSE_ALARM	2
#define RXERR_TYPE_OFDM_MPDU_OK		0
#define RXERR_TYPE_OFDM_MPDU_FAIL	1
#define RXERR_TYPE_CCK_PPDU		3
#define RXERR_TYPE_CCK_FALSE_ALARM	5
#define RXERR_TYPE_CCK_MPDU_OK		3
#define RXERR_TYPE_CCK_MPDU_FAIL	4
#define RXERR_TYPE_HT_PPDU		8
#define RXERR_TYPE_HT_FALSE_ALARM	9
#define RXERR_TYPE_HT_MPDU_TOTAL	6
#define RXERR_TYPE_HT_MPDU_OK		6
#define RXERR_TYPE_HT_MPDU_FAIL		7
#define RXERR_TYPE_RX_FULL_DROP		10

#define RXERR_COUNTER_MASK		BIT_MASK_RPT_COUNTER_8822C
#define RXERR_RPT_RST			BIT_RXERR_RPT_RST_8822C
#define _RXERR_RPT_SEL(type)		(BIT_RXERR_RPT_SEL_V1_3_0_8822C(type) \
					| ((type & 0x10) ? BIT_RXERR_RPT_SEL_V1_4_8822C : 0))

/*
 * BB Register definition
 */
#define rPMAC_Reset			0x100	/* hal_mp.c */

#define	rFPGA0_RFMOD			0x800
#define rFPGA0_TxInfo			0x804
#define rOFDMCCKEN_Jaguar		0x808	/* hal_mp.c */
#define rFPGA0_TxGainStage		0x80C	/* phydm only */
#define rFPGA0_XA_HSSIParameter1	0x820	/* hal_mp.c */
#define rFPGA0_XA_HSSIParameter2	0x824	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter1	0x828	/* hal_mp.c */
#define rFPGA0_XB_HSSIParameter2	0x82C	/* hal_mp.c */
#define rTxAGC_B_Rate18_06		0x830
#define rTxAGC_B_Rate54_24		0x834
#define rTxAGC_B_CCK1_55_Mcs32		0x838
#define rCCAonSec_Jaguar		0x838	/* hal_mp.c */
#define rTxAGC_B_Mcs03_Mcs00		0x83C
#define rTxAGC_B_Mcs07_Mcs04		0x848
#define rTxAGC_B_Mcs11_Mcs08		0x84C
#define rFPGA0_XA_RFInterfaceOE		0x860
#define rFPGA0_XB_RFInterfaceOE		0x864
#define rTxAGC_B_Mcs15_Mcs12		0x868
#define rTxAGC_B_CCK11_A_CCK2_11	0x86C
#define rFPGA0_XAB_RFInterfaceSW	0x870
#define rFPGA0_XAB_RFParameter		0x878
#define rFPGA0_AnalogParameter4		0x88C	/* hal_mp.c & phydm */
#define rFPGA0_XB_LSSIReadBack		0x8A4	/* phydm */
#define rHSSIRead_Jaguar		0x8B0	/* RF read addr (rtl8822c_phy.c) */

#define	rC_TxScale_Jaguar2		0x181C  /* Pah_C TX scaling factor (hal_mp.c) */
#define	rC_IGI_Jaguar2			0x1850	/* Initial Gain for path-C (hal_mp.c) */

#define rFPGA1_TxInfo			0x90C	/* hal_mp.c */
#define rSingleTone_ContTx_Jaguar	0x914	/* hal_mp.c */
/* TX BeamForming */
#define REG_BB_TX_PATH_SEL_1_8822C	0x93C	/* rtl8822c_phy.c */
#define REG_BB_TX_PATH_SEL_2_8822C	0x940	/* rtl8822c_phy.c */

/* TX BeamForming */
#define REG_BB_TXBF_ANT_SET_BF1_8822C	0x19AC	/* rtl8822c_phy.c */
#define REG_BB_TXBF_ANT_SET_BF0_8822C	0x19B4	/* rtl8822c_phy.c */

#define rCCK0_System			0xA00
#define rCCK0_AFESetting		0xA04

#define rCCK0_DSPParameter2		0xA1C
#define rCCK0_TxFilter1			0xA20
#define rCCK0_TxFilter2			0xA24
#define rCCK0_DebugPort			0xA28
#define rCCK0_FalseAlarmReport		0xA2C

#define	rD_TxScale_Jaguar2		0x1A1C  /* Path_D TX scaling factor (hal_mp.c) */
#define	rD_IGI_Jaguar2			0x1A50	/* Initial Gain for path-D (hal_mp.c) */

#define rOFDM0_TRxPathEnable		0xC04
#define rOFDM0_TRMuxPar			0xC08
#define rA_TxScale_Jaguar		0xC1C	/* Pah_A TX scaling factor (hal_mp.c) */
#define rOFDM0_RxDetector1		0xC30	/* rtw_mp.c */
#define rOFDM0_ECCAThreshold		0xC4C	/* phydm only */
#define rOFDM0_XAAGCCore1		0xC50	/* phydm only */
#define rA_IGI_Jaguar			0xC50	/* Initial Gain for path-A (hal_mp.c) */
#define rOFDM0_XBAGCCore1		0xC58	/* phydm only */
#define rOFDM0_XATxIQImbalance		0xC80	/* phydm only */
#define rA_LSSIWrite_Jaguar		0xC90	/* RF write addr, LSSI Parameter (rtl8822b_phy.c) */

#define rOFDM1_LSTF			0xD00
#define rOFDM1_TRxPathEnable		0xD04	/* hal_mp.c */
#define rA_PIRead_Jaguar		0xD04	/* RF readback with PI (rtl8822c_phy.c) */
#define rA_SIRead_Jaguar		0xD08	/* RF readback with SI (rtl8822c_phy.c) */
#define rB_PIRead_Jaguar		0xD44	/* RF readback with PI (rtl8822c_phy.c) */
#define rB_SIRead_Jaguar		0xD48	/* RF readback with SI (rtl8822c_phy.c) */

#define rTxAGC_A_Rate18_06		0xE00
#define rTxAGC_A_Rate54_24		0xE04
#define rTxAGC_A_CCK1_Mcs32		0xE08
#define rTxAGC_A_Mcs03_Mcs00		0xE10
#define rTxAGC_A_Mcs07_Mcs04		0xE14
#define rTxAGC_A_Mcs11_Mcs08		0xE18
#define rTxAGC_A_Mcs15_Mcs12		0xE1C
#define rB_TxScale_Jaguar		0xE1C	/* Path_B TX scaling factor (hal_mp.c) */
#define rB_IGI_Jaguar			0xE50	/* Initial Gain for path-B (hal_mp.c) */
#define rB_LSSIWrite_Jaguar		0xE90	/* RF write addr, LSSI Parameter (rtl8822b_phy.c) */
/* RFE */
#define rA_RFE_Pinmux_Jaguar	0xCB0	/* hal_mp.c */
#define	rB_RFE_Pinmux_Jaguar	0xEB0	/* Path_B RFE control pinmux */
#define	rA_RFE_Inv_Jaguar		0xCB4	/* Path_A RFE cotrol */  
#define	rB_RFE_Inv_Jaguar		0xEB4	/* Path_B RFE control */
#define	rA_RFE_Jaguar			0xCB8 	/* Path_A RFE cotrol */  
#define	rB_RFE_Jaguar			0xEB8	/* Path_B RFE control */
#define	rA_RFE_Inverse_Jaguar	0xCBC	/* Path_A RFE control inverse */
#define	rB_RFE_Inverse_Jaguar	0xEBC	/* Path_B RFE control inverse */
#define	r_ANTSEL_SW_Jaguar		0x900	/* ANTSEL SW Control */
#define	bMask_RFEInv_Jaguar	0x3FF00000
#define	bMask_AntselPathFollow_Jaguar 0x00030000

#define		rC_RFE_Pinmux_Jaguar	0x18B4	/* Path_C RFE cotrol pinmux*/
#define		rD_RFE_Pinmux_Jaguar	0x1AB4	/* Path_D RFE cotrol pinmux*/
#define		rA_RFE_Sel_Jaguar2		0x1990

/* Page1(0x100) */
#define bBBResetB			0x100

/* Page8(0x800) */
#define bCCKEn				0x1000000
#define bOFDMEn				0x2000000
/* Reg 0x80C rFPGA0_TxGainStage */
#define bXBTxAGC			0xF00
#define bXCTxAGC			0xF000
#define bXDTxAGC			0xF0000

/* PageA(0xA00) */
#define bCCKBBMode			0x3

#define bCCKScramble			0x8
#define bCCKTxRate			0x3000

/* General */
#define bMaskByte0		0xFF		/* mp, rtw_odm.c & phydm */
#define bMaskByte1		0xFF00		/* hal_mp.c & phydm */
#define bMaskByte2		0xFF0000	/* hal_mp.c & phydm */
#define bMaskByte3		0xFF000000	/* hal_mp.c & phydm */
#define bMaskHWord		0xFFFF0000	/* hal_com.c, rtw_mp.c */
#define bMaskLWord		0x0000FFFF	/* mp, hal_com.c & phydm */
#define bMaskDWord		0xFFFFFFFF	/* mp, hal, rtw_odm.c & phydm */

#define bEnable			0x1		/* hal_mp.c, rtw_mp.c */
#define bDisable		0x0		/* rtw_mp.c */

#define MAX_STALL_TIME		50		/* unit: us, hal_com_phycfg.c */

#define Rx_Smooth_Factor	20		/* phydm only */

/*
 * RF Register definition
 */
#define RF_AC			0x00
#define RF_AC_Jaguar		0x00	/* hal_mp.c */
#define RF_CHNLBW		0x18	/* rtl8822c_phy.c */
#define RF_ModeTableAddr	0x30	/* rtl8822c_phy.c */
#define RF_ModeTableData0	0x31	/* rtl8822c_phy.c */
#define RF_ModeTableData1	0x32	/* rtl8822c_phy.c */
#define RF_0x52			0x52
#define RF_WeLut_Jaguar		0xEF	/* rtl8822c_phy.c */

/* rtw_lps_state_chk()@hal_com.c */
#define BIT_PWRBIT_OW_EN	BIT_WMAC_TCRPWRMGT_HWDATA_EN_8822C 

/* General Functions */
void rtl8822c_init_hal_spec(PADAPTER);				/* hal/hal_com.c */

#ifdef CONFIG_MP_INCLUDED
/* MP Functions */
#include <rtw_mp.h>		/* struct mp_priv */
void rtl8822c_prepare_mp_txdesc(PADAPTER, struct mp_priv *);	/* rtw_mp.c */
void rtl8822c_mp_config_rfpath(PADAPTER);			/* hal_mp.c */
#endif
void hw_var_set_dl_rsvd_page(PADAPTER adapter, u8 mstatus);

#ifdef CONFIG_USB_HCI
#include <rtl8822cu_hal.h>
#elif defined(CONFIG_SDIO_HCI)
#include <rtl8822cs_hal.h>
#elif defined(CONFIG_PCI_HCI)
#include <rtl8822ce_hal.h>
#endif

#endif /* _RTL8822C_HAL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         rtl8822bu/src/include/rtl8821cu_hal.h                                                               0000644 0001750 0001750 00000001576 14214766567 016106  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8821CU_HAL_H_
#define _RTL8821CU_HAL_H_

#include <drv_types.h>		/* PADAPTER */

/* rtl8821cu_ops.c */
u8 rtl8821cu_set_hal_ops(PADAPTER);
void rtl8821cu_set_hw_type(struct dvobj_priv *pdvobj);

#endif /* _RTL8821CU_HAL_H_ */
                                                                                                                                  rtl8822bu/src/include/rtl8822be_hal.h                                                               0000755 0001750 0001750 00000001740 14214766567 016062  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2015 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTL8822BE_HAL_H_
#define _RTL8822BE_HAL_H_

#include <drv_types.h>		/* PADAPTER */

#define RT_BCN_INT_MASKS	(BIT20 | BIT25 | BIT26 | BIT16)

/* rtl8822be_ops.c */
void UpdateInterruptMask8822BE(PADAPTER, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
u16 get_txbd_rw_reg(u16 q_idx);


#endif /* _RTL8822BE_HAL_H_ */
                                rtl8822bu/src/include/rtl8188e_xmit.h                                                               0000644 0001750 0001750 00000016676 14214766567 016155  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188E_XMIT_H__
#define __RTL8188E_XMIT_H__




/* For 88e early mode */
#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)

/*
 * defined for TX DESC Operation
 *   */

#define MAX_TID (15)

/* OFFSET 0 */
#define OFFSET_SZ	0
#define OFFSET_SHT	16
#define BMC		BIT(24)
#define LSG		BIT(26)
#define FSG		BIT(27)
#define OWN		BIT(31)


/* OFFSET 4 */
#define PKT_OFFSET_SZ		0
#define QSEL_SHT			8
#define RATE_ID_SHT			16
#define NAVUSEHDR			BIT(20)
#define SEC_TYPE_SHT		22
#define PKT_OFFSET_SHT		26

/* OFFSET 8 */
#define AGG_EN				BIT(12)
#define AGG_BK					BIT(16)
#define AMPDU_DENSITY_SHT	20
#define ANTSEL_A			BIT(24)
#define ANTSEL_B			BIT(25)
#define TX_ANT_CCK_SHT		26
#define TX_ANTL_SHT			28
#define TX_ANT_HT_SHT		30

/* OFFSET 12 */
#define SEQ_SHT				16
#define EN_HWSEQ			BIT(31)

/* OFFSET 16 */
#define	QOS                          BIT(6)
#define	HW_SSN				BIT(7)
#define	USERATE			BIT(8)
#define	DISDATAFB			BIT(10)
#define   CTS_2_SELF			BIT(11)
#define	RTS_EN				BIT(12)
#define	HW_RTS_EN			BIT(13)
#define	DATA_SHORT			BIT(24)
#define	PWR_STATUS_SHT	15
#define	DATA_SC_SHT		20
#define	DATA_BW			BIT(25)

/* OFFSET 20 */
#define	RTY_LMT_EN			BIT(17)


/* OFFSET 20 */
#define SGI					BIT(6)
#define USB_TXAGG_NUM_SHT	24

typedef struct txdesc_88e {
	/* Offset 0 */
	u32 pktlen:16;
	u32 offset:8;
	u32 bmc:1;
	u32 htc:1;
	u32 ls:1;
	u32 fs:1;
	u32 linip:1;
	u32 noacm:1;
	u32 gf:1;
	u32 own:1;

	/* Offset 4 */
	u32 macid:6;
	u32 rsvd0406:2;
	u32 qsel:5;
	u32 rd_nav_ext:1;
	u32 lsig_txop_en:1;
	u32 pifs:1;
	u32 rate_id:4;
	u32 navusehdr:1;
	u32 en_desc_id:1;
	u32 sectype:2;
	u32 rsvd0424:2;
	u32 pkt_offset:5;	/* unit: 8 bytes */
	u32 rsvd0431:1;

	/* Offset 8 */
	u32 rts_rc:6;
	u32 data_rc:6;
	u32 agg_en:1;
	u32 rd_en:1;
	u32 bar_rty_th:2;
	u32 bk:1;
	u32 morefrag:1;
	u32 raw:1;
	u32 ccx:1;
	u32 ampdu_density:3;
	u32 bt_null:1;
	u32 ant_sel_a:1;
	u32 ant_sel_b:1;
	u32 tx_ant_cck:2;
	u32 tx_antl:2;
	u32 tx_ant_ht:2;

	/* Offset 12 */
	u32 nextheadpage:8;
	u32 tailpage:8;
	u32 seq:12;
	u32 cpu_handle:1;
	u32 tag1:1;
	u32 trigger_int:1;
	u32 hwseq_en:1;

	/* Offset 16 */
	u32 rtsrate:5;
	u32 ap_dcfe:1;
	u32 hwseq_sel:2;
	u32 userate:1;
	u32 disrtsfb:1;
	u32 disdatafb:1;
	u32 cts2self:1;
	u32 rtsen:1;
	u32 hw_rts_en:1;
	u32 port_id:1;
	u32 pwr_status:3;
	u32 wait_dcts:1;
	u32 cts2ap_en:1;
	u32 data_sc:2;
	u32 data_stbc:2;
	u32 data_short:1;
	u32 data_bw:1;
	u32 rts_short:1;
	u32 rts_bw:1;
	u32 rts_sc:2;
	u32 vcs_stbc:2;

	/* Offset 20 */
	u32 datarate:6;
	u32 sgi:1;
	u32 try_rate:1;
	u32 data_ratefb_lmt:5;
	u32 rts_ratefb_lmt:4;
	u32 rty_lmt_en:1;
	u32 data_rt_lmt:6;
	u32 usb_txagg_num:8;

	/* Offset 24 */
	u32 txagg_a:5;
	u32 txagg_b:5;
	u32 use_max_len:1;
	u32 max_agg_num:5;
	u32 mcsg1_max_len:4;
	u32 mcsg2_max_len:4;
	u32 mcsg3_max_len:4;
	u32 mcs7_sgi_max_len:4;

	/* Offset 28 */
	u32 checksum:16;	/* TxBuffSize(PCIe)/CheckSum(USB) */
	u32 sw0:8; /* offset 30 */
	u32 sw1:4;
	u32 mcs15_sgi_max_len:4;
} TXDESC_8188E, *PTXDESC_8188E;

#define txdesc_set_ccx_sw_88e(txdesc, value) \
	do { \
		((struct txdesc_88e *)(txdesc))->sw1 = (((value)>>8) & 0x0f); \
		((struct txdesc_88e *)(txdesc))->sw0 = ((value) & 0xff); \
	} while (0)

struct txrpt_ccx_88e {
	/* offset 0 */
	u8 tag1:1;
	u8 pkt_num:3;
	u8 txdma_underflow:1;
	u8 int_bt:1;
	u8 int_tri:1;
	u8 int_ccx:1;

	/* offset 1 */
	u8 mac_id:6;
	u8 pkt_ok:1;
	u8 bmc:1;

	/* offset 2 */
	u8 retry_cnt:6;
	u8 lifetime_over:1;
	u8 retry_over:1;

	/* offset 3 */
	u8 ccx_qtime0;
	u8 ccx_qtime1;

	/* offset 5 */
	u8 final_data_rate;

	/* offset 6 */
	u8 sw1:4;
	u8 qsel:4;

	/* offset 7 */
	u8 sw0;
};

#define txrpt_ccx_sw_88e(txrpt_ccx) ((txrpt_ccx)->sw0 + ((txrpt_ccx)->sw1<<8))
#define txrpt_ccx_qtime_88e(txrpt_ccx) ((txrpt_ccx)->ccx_qtime0+((txrpt_ccx)->ccx_qtime1<<8))

#define SET_TX_DESC_SEC_TYPE_8188E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)

void rtl8188e_fill_fake_txdesc(PADAPTER	padapter, u8 *pDesc, u32 BufferLen,
			       u8 IsPsPoll, u8	IsBTQosNull, u8 bDataFrame);
void rtl8188e_cal_txdesc_chksum(struct tx_desc	*ptxdesc);
#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8188es_init_xmit_priv(PADAPTER padapter);
	void rtl8188es_free_xmit_priv(PADAPTER padapter);
	s32 rtl8188es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8188es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8188es_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	thread_return rtl8188es_xmit_thread(thread_context context);
	s32 rtl8188es_xmit_buf_handler(PADAPTER padapter);

	#ifdef CONFIG_SDIO_TX_TASKLET
		void rtl8188es_xmit_tasklet(void *priv);
	#endif
#endif

#ifdef CONFIG_USB_HCI
	s32 rtl8188eu_init_xmit_priv(PADAPTER padapter);
	void rtl8188eu_free_xmit_priv(PADAPTER padapter);
	s32 rtl8188eu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8188eu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8188eu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8188eu_xmit_buf_handler(PADAPTER padapter);
	void rtl8188eu_xmit_tasklet(void *priv);
	s32 rtl8188eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8188ee_init_xmit_priv(PADAPTER padapter);
	void rtl8188ee_free_xmit_priv(PADAPTER padapter);
	void	rtl8188ee_xmitframe_resume(_adapter *padapter);
	s32 rtl8188ee_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8188ee_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8188ee_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void rtl8188ee_xmit_tasklet(void *priv);
#endif



#ifdef CONFIG_TX_EARLY_MODE
	void UpdateEarlyModeInfo8188E(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif

#ifdef CONFIG_XMIT_ACK
	void dump_txrpt_ccx_88e(void *buf);
	void handle_txrpt_ccx_88e(_adapter *adapter, u8 *buf);
#else
	#define dump_txrpt_ccx_88e(buf) do {} while (0)
	#define handle_txrpt_ccx_88e(adapter, buf) do {} while (0)
#endif /* CONFIG_XMIT_ACK */

void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
#endif /* __RTL8188E_XMIT_H__ */
                                                                  rtl8822bu/src/include/rtl8192f_recv.h                                                               0000644 0001750 0001750 00000007755 14214766567 016125  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_RECV_H__
#define __RTL8192F_RECV_H__

#define RECV_BLK_SZ 512
#define RECV_BLK_CNT 16
#define RECV_BLK_TH RECV_BLK_CNT

#if defined(CONFIG_USB_HCI)

	#ifndef MAX_RECVBUF_SZ
		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
			/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
			/* #define MAX_RECVBUF_SZ (16384) */ /* 16K */
			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
			#ifdef CONFIG_PLATFORM_MSTAR
				#define MAX_RECVBUF_SZ (8192) /* 8K */
			#else
				#define MAX_RECVBUF_SZ (32768) /* 32k */
			#endif
			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
		#else
			#define MAX_RECVBUF_SZ (4000) /* about 4K */
		#endif
	#endif /* !MAX_RECVBUF_SZ */

#elif defined(CONFIG_PCI_HCI)
	#define MAX_RECVBUF_SZ (4000) /* about 4K */

#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)

	#define MAX_RECVBUF_SZ (RX_DMA_BOUNDARY_8192F + 1)

#endif

/* Rx smooth factor */
#define	Rx_Smooth_Factor (20)

#ifdef CONFIG_SDIO_HCI
	#ifndef CONFIG_SDIO_RX_COPY
		#undef MAX_RECVBUF_SZ
		#define MAX_RECVBUF_SZ	(RX_DMA_SIZE_8192F - RX_DMA_RESERVED_SIZE_8192F)
	#endif /* !CONFIG_SDIO_RX_COPY */
#endif /* CONFIG_SDIO_HCI */

/*-----------------------------------------------------------------*/
/*	RTL8192F RX BUFFER DESC                                      */
/*-----------------------------------------------------------------*/
/*DWORD 0*/
#define SET_RX_BUFFER_DESC_DATA_LENGTH_8192F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
#define SET_RX_BUFFER_DESC_LS_8192F(__pRxStatusDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 15, 1, __Value)
#define SET_RX_BUFFER_DESC_FS_8192F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 1, __Value)
#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_8192F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 15, __Value)

#define GET_RX_BUFFER_DESC_OWN_8192F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)
#define GET_RX_BUFFER_DESC_LS_8192F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
#define GET_RX_BUFFER_DESC_FS_8192F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 1)
#ifdef USING_RX_TAG
	#define GET_RX_BUFFER_DESC_RX_TAG_8192F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 13)
#else
	#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_8192F(__pRxStatusDesc)		LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 15)
#endif

/*DWORD 1*/
#define SET_RX_BUFFER_PHYSICAL_LOW_8192F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+4, 0, 32, __Value)

/*DWORD 2*/
#ifdef CONFIG_64BIT_DMA
	#define SET_RX_BUFFER_PHYSICAL_HIGH_8192F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+8, 0, 32, __Value)
#else
	#define SET_RX_BUFFER_PHYSICAL_HIGH_8192F(__pRxStatusDesc, __Value)
#endif


#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8192fs_init_recv_priv(PADAPTER padapter);
	void rtl8192fs_free_recv_priv(PADAPTER padapter);
	s32 rtl8192fs_recv_hdl(_adapter *padapter);
#endif

#ifdef CONFIG_USB_HCI
	int rtl8192fu_init_recv_priv(_adapter *padapter);
	void rtl8192fu_free_recv_priv(_adapter *padapter);
	void rtl8192fu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8192fe_init_recv_priv(_adapter *padapter);
	void rtl8192fe_free_recv_priv(_adapter *padapter);
#endif

void rtl8192f_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);

#endif /* __RTL8192F_RECV_H__ */
                   rtl8822bu/src/include/rtw_event.h                                                                   0000644 0001750 0001750 00000004645 14214766567 015623  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef _RTW_EVENT_H_
#define _RTW_EVENT_H_

#ifdef CONFIG_H2CLBK
	#include <h2clbk.h>
#endif

/*
Used to report a bss has been scanned

*/
struct survey_event	{
	WLAN_BSSID_EX bss;
};

/*
Used to report that the requested site survey has been done.

bss_cnt indicates the number of bss that has been reported.


*/
struct surveydone_event {
	unsigned int	bss_cnt;
	bool acs; /* aim to trigger channel selection */
};

/*
Used to report the link result of joinning the given bss


join_res:
-1: authentication fail
-2: association fail
> 0: TID

*/
struct joinbss_event {
	struct	wlan_network	network;
};

/*
Used to report a given STA has joinned the created BSS.
It is used in AP/Ad-HoC(M) mode.


*/
struct stassoc_event {
	unsigned char macaddr[6];
};

struct stadel_event {
	unsigned char macaddr[6];
	unsigned char rsvd[2]; /* for reason */
	unsigned char locally_generated;
	int mac_id;
};

struct addba_event {
	unsigned int tid;
};

struct wmm_event {
	unsigned char wmm;
};

#ifdef CONFIG_H2CLBK
struct c2hlbk_event {
	unsigned char mac[6];
	unsigned short	s0;
	unsigned short	s1;
	unsigned int	w0;
	unsigned char	b0;
	unsigned short  s2;
	unsigned char	b1;
	unsigned int	w1;
};
#endif/* CONFIG_H2CLBK */

#define GEN_EVT_CODE(event)	event ## _EVT_



struct fwevent {
	u32	parmsize;
	void (*event_callback)(_adapter *dev, u8 *pbuf);
};


#define C2HEVENT_SZ			32

struct event_node {
	unsigned char *node;
	unsigned char evt_code;
	unsigned short evt_sz;
	volatile int	*caller_ff_tail;
	int	caller_ff_sz;
};

struct c2hevent_queue {
	volatile int	head;
	volatile int	tail;
	struct	event_node	nodes[C2HEVENT_SZ];
	unsigned char	seq;
};

#define NETWORK_QUEUE_SZ	4

struct network_queue {
	volatile int	head;
	volatile int	tail;
	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];
};


#endif /* _WLANEVENT_H_ */
                                                                                           rtl8822bu/src/include/circ_buf.h                                                                    0000644 0001750 0001750 00000001540 14214766567 015351  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __CIRC_BUF_H_
#define __CIRC_BUF_H_ 1

#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))

#define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))

#endif //_CIRC_BUF_H_

                                                                                                                                                                rtl8822bu/src/include/rtl8723b_led.h                                                                0000755 0001750 0001750 00000003026 14214766567 015714  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8723B_LED_H__
#define __RTL8723B_LED_H__

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8723bu_InitSwLeds(PADAPTER padapter);
	void rtl8723bu_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
	void rtl8723bs_InitSwLeds(PADAPTER padapter);
	void rtl8723bs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_GSPI_HCI
	void rtl8723bs_InitSwLeds(PADAPTER padapter);
	void rtl8723bs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
	void rtl8723be_InitSwLeds(PADAPTER padapter);
	void rtl8723be_DeInitSwLeds(PADAPTER padapter);
#endif

#endif
#endif/*CONFIG_RTW_SW_LED*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          rtl8822bu/src/include/drv_types_linux.h                                                             0000644 0001750 0001750 00000001325 14214766567 017034  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_TYPES_LINUX_H__
#define __DRV_TYPES_LINUX_H__


#endif
                                                                                                                                                                                                                                                                                                           rtl8822bu/src/include/Hal8188FPwrSeq.h                                                              0000644 0001750 0001750 00000043566 14214766567 016120  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2016 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef REALTEK_POWER_SEQUENCE_8188F
#define REALTEK_POWER_SEQUENCE_8188F

#include "HalPwrSeqCmd.h"

/*
	Check document WM-20130815-JackieLau-RTL8188F_Power_Architecture v08.vsd
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8188F_TRANS_CARDEMU_TO_ACT_STEPS	13
#define	RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS	15
#define	RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS	14
#define	RTL8188F_TRANS_SUS_TO_CARDEMU_STEPS	15
#define	RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS	15
#define	RTL8188F_TRANS_PDN_TO_CARDEMU_STEPS	15
#define	RTL8188F_TRANS_ACT_TO_LPS_STEPS		11
#define	RTL8188F_TRANS_LPS_TO_ACT_STEPS		13
#define	RTL8188F_TRANS_ACT_TO_SWLPS_STEPS		21
#define	RTL8188F_TRANS_SWLPS_TO_ACT_STEPS		14
#define	RTL8188F_TRANS_END_STEPS		1


#define RTL8188F_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT3), 0},/*  0x4[11]=1'b0 disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* 0x4[8]=1 polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	 \
	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x35}, /*0x27<=35 to reduce RF noise*/

#define RTL8188F_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x34}, /*0x27 <= 34, xtal_qsel = 0 to xtal bring up*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\

#define RTL8188F_TRANS_CARDEMU_TO_SUS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00}, /*0x07 = 0x00 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/ \
	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/

#define RTL8188F_TRANS_SUS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/

#define RTL8188F_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00}, /*0x07 = 0x00 , SOP option to disable BG/MB*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/ \
	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/

#define RTL8188F_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/


#define RTL8188F_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8188F_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8188F_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*set RPWM IMR*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/


#define RTL8188F_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84},  /*SDIO RPWM*/\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x35},/*xtal_qsel = 1 for low noise*/	\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
	{0x002B, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x1c, 0x1c},   /*.	0x2b[4:2] = 3b'111	to enable BB, AFE clock*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0},  /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/


#define RTL8188F_TRANS_ACT_TO_SWLPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*set RPWM IMR*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
	{0x002b, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x1C, 0x00},/*0x2b[4:2]<=0 to gated BB, AFE clock*/	\
	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x34},/*xtal_qsel = 0 for bring up*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x00},/* sdio LPS option*/	\
	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x83},/* usb LPS option, open bandgap, xtal*/	\
	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /* 0xC4[5]<=0, digital LDO no standby mode*/	\
	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /* 0xC4[7]<=1, on domain voltage adjust*/	\
	{0x00a7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0xe0}, /* low power LPS enable for sdio*/	\
	{0x00a7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0xe4}, /* low power LPS enable for usb*/	\
	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /* enable WL_LPS_EN*/


#define RTL8188F_TRANS_SWLPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*polling TSF stable*/\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1, enable security engine*/\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
	{0x06B7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x09}, /*.	reset MAC rx state machine*/\
	{0x06B4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x86}, /*.	reset MAC rx state machine*/\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/* set CPU RAM code ready*/	\
	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* Enable CPU*/	\
	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*enable CPU IO Wrapper*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2},/* Enable CPU*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, BIT7},/*polling FW init ready */	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT6, BIT6},/*polling FW init ready */	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8188F_TRANS_END															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


	extern WLAN_PWR_CFG rtl8188F_power_on_flow[RTL8188F_TRANS_CARDEMU_TO_ACT_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_radio_off_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_card_disable_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_card_enable_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_suspend_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_resume_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_hwpdn_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_enter_lps_flow[RTL8188F_TRANS_ACT_TO_LPS_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_leave_lps_flow[RTL8188F_TRANS_LPS_TO_ACT_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_enter_swlps_flow[RTL8188F_TRANS_ACT_TO_SWLPS_STEPS + RTL8188F_TRANS_END_STEPS];
	extern WLAN_PWR_CFG rtl8188F_leave_swlps_flow[RTL8188F_TRANS_SWLPS_TO_ACT_STEPS + RTL8188F_TRANS_END_STEPS];
#endif
                                                                                                                                          rtl8822bu/src/include/drv_types_sdio.h                                                              0000644 0001750 0001750 00000005571 14214766567 016642  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2019 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_TYPES_SDIO_H__
#define __DRV_TYPES_SDIO_H__

/* SDIO Header Files */
#ifdef PLATFORM_LINUX
	#include <linux/mmc/sdio_func.h>
	#include <linux/mmc/sdio_ids.h>
	#include <linux/mmc/host.h>
	#include <linux/mmc/card.h>

	#ifdef CONFIG_PLATFORM_SPRD
		#include <linux/gpio.h>
		#include <custom_gpio.h>
	#endif /* CONFIG_PLATFORM_SPRD */
#endif

#define RTW_SDIO_CLK_33M	33000000
#define RTW_SDIO_CLK_40M	40000000
#define RTW_SDIO_CLK_80M	80000000
#define RTW_SDIO_CLK_160M	160000000

typedef struct sdio_data {
	u8  func_number;

	u8  tx_block_mode;
	u8  rx_block_mode;
	u32 block_transfer_len;

#ifdef PLATFORM_LINUX
	struct mmc_card *card;
	struct sdio_func	*func;
	_thread_hdl_ sys_sdio_irq_thd;
	unsigned int clock;
	unsigned int timing;
	u8	sd3_bus_mode;
#endif

#ifdef DBG_SDIO
#ifdef PLATFORM_LINUX
	struct proc_dir_entry *proc_sdio_dbg;
#endif /* PLATFORM_LINUX */

	u32 cmd52_err_cnt;	/* CMD52 I/O error count */
	u32 cmd53_err_cnt;	/* CMD53 I/O error count */

#if (DBG_SDIO >= 1)
	u32 reg_dump_mark;	/* reg dump at specific error count */
#endif /* DBG_SDIO >= 1 */

#if (DBG_SDIO >= 2)
	u8 *dbg_msg;		/* Messages for debug */
	u8 dbg_msg_size;
	u8 *reg_mac;		/* Device MAC register, 0x0~0x800 */
	u8 *reg_mac_ext;	/* Device MAC extend register, 0x1000~0x1800 */
	u8 *reg_local;		/* Device SDIO local register, 0x0~0xFF */
	u8 *reg_cia;		/* SDIO CIA(CCCR, FBR and etc.), 0x0~0x1FF */
#endif /* DBG_SDIO >= 2 */

#if (DBG_SDIO >= 3)
	u8 dbg_enable;		/* 0/1: disable/enable debug mode */
	u8 err_stop;		/* Stop(surprise remove) when I/O error happen */
	u8 err_test;		/* Simulate error happen */
	u8 err_test_triggered;	/* Simulate error already triggered */
#endif /* DBG_SDIO >= 3 */
#endif /* DBG_SDIO */
} SDIO_DATA, *PSDIO_DATA;

#define dvobj_to_sdio_func(d)	((d)->intf_data.func)

#define RTW_SDIO_ADDR_CMD52_BIT		(1<<17)
#define RTW_SDIO_ADDR_CMD52_GEN(a)	(a | RTW_SDIO_ADDR_CMD52_BIT)
#define RTW_SDIO_ADDR_CMD52_CLR(a)	(a&~RTW_SDIO_ADDR_CMD52_BIT)
#define RTW_SDIO_ADDR_CMD52_CHK(a)	(a&RTW_SDIO_ADDR_CMD52_BIT ? 1 : 0)

#define RTW_SDIO_ADDR_F0_BIT		(1<<18)
#define RTW_SDIO_ADDR_F0_GEN(a)		(a | RTW_SDIO_ADDR_F0_BIT)
#define RTW_SDIO_ADDR_F0_CLR(a)		(a&~RTW_SDIO_ADDR_F0_BIT)
#define RTW_SDIO_ADDR_F0_CHK(a)		(a&RTW_SDIO_ADDR_F0_BIT ? 1 : 0)

#endif
                                                                                                                                       rtl8822bu/src/include/recv_osdep.h                                                                  0000644 0001750 0001750 00000005201 14214766567 015724  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RECV_OSDEP_H_
#define __RECV_OSDEP_H_


extern sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
extern void _rtw_free_recv_priv(struct recv_priv *precvpriv);


extern s32  rtw_recv_entry(union recv_frame *precv_frame);
void rtw_rframe_set_os_pkt(union recv_frame *rframe);
extern int rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
extern void rtw_recv_returnpacket(_nic_hdl cnxt, _pkt *preturnedpkt);

extern int rtw_recv_monitor(_adapter *padapter, union recv_frame *precv_frame);

#ifdef CONFIG_HOSTAPD_MLME
extern void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
#endif

struct sta_info;
extern void rtw_handle_tkip_mic_err(_adapter *padapter, struct sta_info *sta, u8 bgroup);


int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter);
int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe);
void rtw_os_recv_resource_free(struct recv_priv *precvpriv);


int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8 *pdata, _pkt *pskb);
int rtw_os_recvframe_duplicate_skb(_adapter *padapter, union recv_frame *pcloneframe, _pkt *pskb);
void rtw_os_free_recvframe(union recv_frame *precvframe);


int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf);
int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf);

_pkt *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, const u8 *da, const u8 *sa, u8 *msdu ,u16 msdu_len);
void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, union recv_frame *rframe);

void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf);

#ifdef PLATFORM_LINUX
#ifdef CONFIG_RTW_NAPI
#include <linux/netdevice.h>	/* struct napi_struct */

int rtw_recv_napi_poll(struct napi_struct *, int budget);
#ifdef CONFIG_RTW_NAPI_DYNAMIC
void dynamic_napi_th_chk (_adapter *adapter);
#endif /* CONFIG_RTW_NAPI_DYNAMIC */
#endif /* CONFIG_RTW_NAPI */
#endif /* PLATFORM_LINUX */

#endif /*  */
                                                                                                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/Hal8192FPhyReg.h                                                              0000644 0001750 0001750 00000106034 14214766567 016056  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8192FPHYREG_H__
#define __INC_HAL8192FPHYREG_H__

#define		rSYM_WLBT_PAPE_SEL		0x64
/*
 * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
 * 3. RF register 0x00-2E
 * 4. Bit Mask for BB/RF register
 * 5. Other definition for BB/RF R/W
 *   */


/*
 * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
 * 1. Page1(0x100)
 *   */
#define		rPMAC_Reset					0x100
#define		rPMAC_TxStart					0x104
#define		rPMAC_TxLegacySIG				0x108
#define		rPMAC_TxHTSIG1				0x10c
#define		rPMAC_TxHTSIG2				0x110
#define		rPMAC_PHYDebug				0x114
#define		rPMAC_TxPacketNum				0x118
#define		rPMAC_TxIdle					0x11c
#define		rPMAC_TxMACHeader0			0x120
#define		rPMAC_TxMACHeader1			0x124
#define		rPMAC_TxMACHeader2			0x128
#define		rPMAC_TxMACHeader3			0x12c
#define		rPMAC_TxMACHeader4			0x130
#define		rPMAC_TxMACHeader5			0x134
#define		rPMAC_TxDataType				0x138
#define		rPMAC_TxRandomSeed			0x13c
#define		rPMAC_CCKPLCPPreamble			0x140
#define		rPMAC_CCKPLCPHeader			0x144
#define		rPMAC_CCKCRC16				0x148
#define		rPMAC_OFDMRxCRC32OK			0x170
#define		rPMAC_OFDMRxCRC32Er			0x174
#define		rPMAC_OFDMRxParityEr			0x178
#define		rPMAC_OFDMRxCRC8Er			0x17c
#define		rPMAC_CCKCRxRC16Er			0x180
#define		rPMAC_CCKCRxRC32Er			0x184
#define		rPMAC_CCKCRxRC32OK			0x188
#define		rPMAC_TxStatus					0x18c

/*
 * 2. Page2(0x200)
 *
 * The following two definition are only used for USB interface. */
#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */

/*
 * 3. Page8(0x800)
 *   */
#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC // RF BW Setting?? */

#define		rFPGA0_TxInfo				0x804	/* Status report?? */
#define		rFPGA0_PSDFunction			0x808

#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */

#define		rFPGA0_RFTiming1			0x810	/* Useless now */
#define		rFPGA0_RFTiming2			0x814

#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
#define		rFPGA0_XA_HSSIParameter2		0x824
#define		rFPGA0_XB_HSSIParameter1		0x828
#define		rFPGA0_XB_HSSIParameter2		0x82c
#define		rTxAGC_B_Rate18_06				0x830
#define		rTxAGC_B_Rate54_24				0x834
#define		rTxAGC_B_CCK1_55_Mcs32		0x838
#define		rTxAGC_B_Mcs03_Mcs00			0x83c

#define		rTxAGC_B_Mcs07_Mcs04			0x848
#define		rTxAGC_B_Mcs11_Mcs08			0x84c

#define		rFPGA0_XA_LSSIParameter		0x840
#define		rFPGA0_XB_LSSIParameter		0x844

#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
#define		rFPGA0_RFSleepUpParameter		0x854

#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
#define		rFPGA0_XCD_SwitchControl		0x85c

#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
#define		rFPGA0_XB_RFInterfaceOE		0x864

#define		rTxAGC_B_Mcs15_Mcs12			0x868
#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c

#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
#define		rFPGA0_XCD_RFInterfaceSW		0x874

#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
#define		rFPGA0_XCD_RFParameter		0x87c

#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
#define		rFPGA0_AnalogParameter2		0x884
#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
#define		rFPGA0_AnalogParameter4		0x88c

#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
#define		rFPGA0_XB_LSSIReadBack		0x8a4
#define		rFPGA0_XC_LSSIReadBack		0x8a8
#define		rFPGA0_XD_LSSIReadBack		0x8ac

#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now // RF Interface Readback Value */
#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */

/*
 * 4. Page9(0x900)
 *   */
#define	rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC // RF BW Setting?? */
#define	rFPGA1_TxBlock				0x904	/* Useless now */
#define	rFPGA1_DebugSelect			0x908	/* Useless now */
#define	rFPGA1_TxInfo				0x90c	/* Useless now // Status report?? */
#define	rDPDT_control				0x92c
#define	rfe_ctrl_anta_src				0x930
#define	rS0S1_PathSwitch			0x948
#define	rBBrx_DFIR					0x954

/*
 * 5. PageA(0xA00)
 *
 * Set Control channel to upper or lower. These settings are required only for 40MHz */
#define		rCCK0_System				0xa00

#define		rCCK0_AFESetting			0xa04	/* Disable init gain now // Select RX path by RSSI */
#define		rCCK0_CCA					0xa08	/* Disable init gain now // Init gain */

#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */

#define		rCCK0_RxHP					0xa14

#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */

#define		rCCK0_TxFilter1				0xa20
#define		rCCK0_TxFilter2				0xa24
#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
#define		rCCK0_TRSSIReport		0xa50
#define		rCCK0_RxReport			0xa54  /* 0xa57 */
#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */

/*
 * PageB(0xB00)
 *   */
#define rPdp_AntA						0xb00
#define rPdp_AntA_4						0xb04
#define rPdp_AntA_8						0xb08
#define rPdp_AntA_C						0xb0c
#define rPdp_AntA_10					0xb10
#define rPdp_AntA_14					0xb14
#define rPdp_AntA_18					0xb18
#define rPdp_AntA_1C					0xb1c
#define rPdp_AntA_20					0xb20
#define rPdp_AntA_24					0xb24

#define rConfig_Pmpd_AntA				0xb28
#define rConfig_ram64x16				0xb2c

#define rBndA							0xb30
#define rHssiPar						0xb34

#define rConfig_AntA					0xb68
#define rConfig_AntB					0xb6c

#define rPdp_AntB						0xb70
#define rPdp_AntB_4						0xb74
#define rPdp_AntB_8						0xb78
#define rPdp_AntB_C						0xb7c
#define rPdp_AntB_10					0xb80
#define rPdp_AntB_14					0xb84
#define rPdp_AntB_18					0xb88
#define rPdp_AntB_1C					0xb8c
#define rPdp_AntB_20					0xb90
#define rPdp_AntB_24					0xb94

#define rConfig_Pmpd_AntB				0xb98

#define rBndB							0xba0

#define rAPK							0xbd8
#define rPm_Rx0_AntA					0xbdc
#define rPm_Rx1_AntA					0xbe0
#define rPm_Rx2_AntA					0xbe4
#define rPm_Rx3_AntA					0xbe8
#define rPm_Rx0_AntB					0xbec
#define rPm_Rx1_AntB					0xbf0
#define rPm_Rx2_AntB					0xbf4
#define rPm_Rx3_AntB					0xbf8
/*
 * 6. PageC(0xC00)
 *   */
#define		rOFDM0_LSTF				0xc00

#define		rOFDM0_TRxPathEnable		0xc04
#define		rOFDM0_TRMuxPar			0xc08
#define		rOFDM0_TRSWIsolation		0xc0c

#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imbalance matrix */
#define		rOFDM0_XBRxAFE		0xc18
#define		rOFDM0_XBRxIQImbalance	0xc1c
#define		rOFDM0_XCRxAFE		0xc20
#define		rOFDM0_XCRxIQImbalance	0xc24
#define		rOFDM0_XDRxAFE		0xc28
#define		rOFDM0_XDRxIQImbalance	0xc2c

#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	// DM tune init gain */
#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */

#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */

#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
#define		rOFDM0_XAAGCCore2			0xc54
#define		rOFDM0_XBAGCCore1			0xc58
#define		rOFDM0_XBAGCCore2			0xc5c
#define		rOFDM0_XCAGCCore1			0xc60
#define		rOFDM0_XCAGCCore2			0xc64
#define		rOFDM0_XDAGCCore1			0xc68
#define		rOFDM0_XDAGCCore2			0xc6c

#define		rOFDM0_AGCParameter1			0xc70
#define		rOFDM0_AGCParameter2			0xc74
#define		rOFDM0_AGCRSSITable			0xc78
#define		rOFDM0_HTSTFAGC				0xc7c

#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
#define		rOFDM0_XATxAFE				0xc84
#define		rOFDM0_XBTxIQImbalance		0xc88
#define		rOFDM0_XBTxAFE				0xc8c
#define		rOFDM0_XCTxIQImbalance		0xc90
#define		rOFDM0_XCTxAFE			0xc94
#define		rOFDM0_XDTxIQImbalance		0xc98
#define		rOFDM0_XDTxAFE				0xc9c

#define		rOFDM0_RxIQExtAnta			0xca0
#define		rOFDM0_TxCoeff1				0xca4
#define		rOFDM0_TxCoeff2				0xca8
#define		rOFDM0_TxCoeff3				0xcac
#define		rOFDM0_TxCoeff4				0xcb0
#define		rOFDM0_TxCoeff5				0xcb4
#define		rOFDM0_TxCoeff6				0xcb8
#define		rOFDM0_RxHPParameter			0xce0
#define		rOFDM0_TxPseudoNoiseWgt		0xce4
#define		rOFDM0_FrameSync				0xcf0
#define		rOFDM0_DFSReport				0xcf4

/*
 * 7. PageD(0xD00)
 *   */
#define		rOFDM1_LSTF					0xd00
#define		rOFDM1_TRxPathEnable			0xd04

#define		rOFDM1_CFO						0xd08	/* No setting now */
#define		rOFDM1_CSI1					0xd10
#define		rOFDM1_SBD						0xd14
#define		rOFDM1_CSI2					0xd18
#define		rOFDM1_CFOTracking			0xd2c
#define		rOFDM1_TRxMesaure1			0xd34
#define		rOFDM1_IntfDet					0xd3c
#define		rOFDM1_PseudoNoiseStateAB		0xd50
#define		rOFDM1_PseudoNoiseStateCD		0xd54
#define		rOFDM1_RxPseudoNoiseWgt		0xd58

#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */

#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
#define		rOFDM_ShortCFOCD				0xdb0
#define		rOFDM_LongCFOAB				0xdb4
#define		rOFDM_LongCFOCD				0xdb8
#define		rOFDM_TailCFOAB				0xdbc
#define		rOFDM_TailCFOCD				0xdc0
#define		rOFDM_PWMeasure1		0xdc4
#define		rOFDM_PWMeasure2		0xdc8
#define		rOFDM_BWReport				0xdcc
#define		rOFDM_AGCReport				0xdd0
#define		rOFDM_RxSNR					0xdd4
#define		rOFDM_RxEVMCSI				0xdd8
#define		rOFDM_SIGReport				0xddc


/*
 * 8. PageE(0xE00)
 *   */
#define		rTxAGC_A_Rate18_06			0xe00
#define		rTxAGC_A_Rate54_24			0xe04
#define		rTxAGC_A_CCK1_Mcs32			0xe08
#define		rTxAGC_A_Mcs03_Mcs00			0xe10
#define		rTxAGC_A_Mcs07_Mcs04			0xe14
#define		rTxAGC_A_Mcs11_Mcs08			0xe18
#define		rTxAGC_A_Mcs15_Mcs12			0xe1c

#define		rFPGA0_IQK					0xe28
#define		rTx_IQK_Tone_A				0xe30
#define		rRx_IQK_Tone_A				0xe34
#define		rTx_IQK_PI_A					0xe38
#define		rRx_IQK_PI_A					0xe3c

#define		rTx_IQK						0xe40
#define		rRx_IQK						0xe44
#define		rIQK_AGC_Pts					0xe48
#define		rIQK_AGC_Rsp					0xe4c
#define		rTx_IQK_Tone_B				0xe50
#define		rRx_IQK_Tone_B				0xe54
#define		rTx_IQK_PI_B					0xe58
#define		rRx_IQK_PI_B					0xe5c
#define		rIQK_AGC_Cont				0xe60

#define		rBlue_Tooth					0xe6c
#define		rRx_Wait_CCA					0xe70
#define		rTx_CCK_RFON					0xe74
#define		rTx_CCK_BBON				0xe78
#define		rTx_OFDM_RFON				0xe7c
#define		rTx_OFDM_BBON				0xe80
#define		rTx_To_Rx					0xe84
#define		rTx_To_Tx					0xe88
#define		rRx_CCK						0xe8c

#define		rTx_Power_Before_IQK_A		0xe94
#define		rTx_Power_After_IQK_A			0xe9c

#define		rRx_Power_Before_IQK_A		0xea0
#define		rRx_Power_Before_IQK_A_2		0xea4
#define		rRx_Power_After_IQK_A			0xea8
#define		rRx_Power_After_IQK_A_2		0xeac

#define		rTx_Power_Before_IQK_B		0xeb4
#define		rTx_Power_After_IQK_B			0xebc

#define		rRx_Power_Before_IQK_B		0xec0
#define		rRx_Power_Before_IQK_B_2		0xec4
#define		rRx_Power_After_IQK_B			0xec8
#define		rRx_Power_After_IQK_B_2		0xecc

#define		rRx_OFDM					0xed0
#define		rRx_Wait_RIFS				0xed4
#define		rRx_TO_Rx					0xed8
#define		rStandby						0xedc
#define		rSleep						0xee0
#define		rPMPD_ANAEN				0xeec

/*
 * 7. RF Register 0x00-0x2E (RF 8256)
 * RF-0222D 0x00-3F
 *
 * Zebra1 */
#define		rZebra1_HSSIEnable				0x0	/* Useless now */
#define		rZebra1_TRxEnable1				0x1
#define		rZebra1_TRxEnable2				0x2
#define		rZebra1_AGC					0x4
#define		rZebra1_ChargePump			0x5
#define		rZebra1_Channel				0x7	/* RF channel switch */

/* #endif */
#define		rZebra1_TxGain					0x8	/* Useless now */
#define		rZebra1_TxLPF					0x9
#define		rZebra1_RxLPF					0xb
#define		rZebra1_RxHPFCorner			0xc

/* Zebra4 */
#define		rGlobalCtrl						0	/* Useless now */
#define		rRTL8256_TxLPF					19
#define		rRTL8256_RxLPF					11

/* RTL8258 */
#define		rRTL8258_TxLPF					0x11	/* Useless now */
#define		rRTL8258_RxLPF					0x13
#define		rRTL8258_RSSILPF				0xa

/*
 * RL6052 Register definition
 *   */
#define		RF_AC						0x00	/* */

#define		RF_IQADJ_G1				0x01	/* */
#define		RF_IQADJ_G2				0x02	/* */
#define		RF_BS_PA_APSET_G1_G4		0x03
#define		RF_BS_PA_APSET_G5_G8		0x04
#define		RF_POW_TRSW				0x05	/* */

#define		RF_GAIN_RX					0x06	/* */
#define		RF_GAIN_TX					0x07	/* */

#define		RF_TXM_IDAC				0x08	/* */
#define		RF_IPA_G					0x09	/* */
#define		RF_TXBIAS_G				0x0A
#define		RF_TXPA_AG					0x0B
#define		RF_IPA_A					0x0C	/* */
#define		RF_TXBIAS_A				0x0D
#define		RF_BS_PA_APSET_G9_G11	0x0E
#define		RF_BS_IQGEN				0x0F	/* */

#define		RF_MODE1					0x10	/* */
#define		RF_MODE2					0x11	/* */

#define		RF_RX_AGC_HP				0x12	/* */
#define		RF_TX_AGC					0x13	/* */
#define		RF_BIAS						0x14	/* */
#define		RF_IPA						0x15	/* */
#define		RF_TXBIAS					0x16
#define		RF_POW_ABILITY			0x17	/* */
#define		RF_MODE_AG				0x18	/* */
#define		rRfChannel					0x18	/* RF channel and BW switch */
#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
#define		RF_TOP						0x19	/* */

#define		RF_RX_G1					0x1A	/* */
#define		RF_RX_G2					0x1B	/* */

#define		RF_RX_BB2					0x1C	/* */
#define		RF_RX_BB1					0x1D	/* */

#define		RF_RCK1					0x1E	/* */
#define		RF_RCK2					0x1F	/* */

#define		RF_TX_G1					0x20	/* */
#define		RF_TX_G2					0x21	/* */
#define		RF_TX_G3					0x22	/* */

#define		RF_TX_BB1					0x23	/* */

#define		RF_T_METER					0x24	/* */

#define		RF_SYN_G1					0x25	/* RF TX Power control */
#define		RF_SYN_G2					0x26	/* RF TX Power control */
#define		RF_SYN_G3					0x27	/* RF TX Power control */
#define		RF_SYN_G4					0x28	/* RF TX Power control */
#define		RF_SYN_G5					0x29	/* RF TX Power control */
#define		RF_SYN_G6					0x2A	/* RF TX Power control */
#define		RF_SYN_G7					0x2B	/* RF TX Power control */
#define		RF_SYN_G8					0x2C	/* RF TX Power control */

#define		RF_RCK_OS					0x30	/* RF TX PA control */

#define		RF_TXPA_G1					0x31	/* RF TX PA control */
#define		RF_TXPA_G2					0x32	/* RF TX PA control */
#define		RF_TXPA_G3					0x33	/* RF TX PA control */
#define	RF_TX_BIAS_A				0x35
#define	RF_TX_BIAS_D				0x36
#define	RF_LOBF_9					0x38
#define	RF_RXRF_A3					0x3C	/*	 */
#define	RF_TRSW					0x3F

#define	RF_TXRF_A2					0x41
#define	RF_T_METER_88E				0x42
#define	RF_TXPA_G4					0x46
#define	RF_TXPA_A4					0x4B
#define	RF_0x52					0x52
#define	RF_WE_LUT					0xEF
#define	RF_S0S1					0xB0

/*
 * Bit Mask
 *
 * 1. Page1(0x100) */
#define		bBBResetB						0x100	/* Useless now? */
#define		bGlobalResetB					0x200
#define		bOFDMTxStart					0x4
#define		bCCKTxStart						0x8
#define		bCRC32Debug					0x100
#define		bPMACLoopback					0x10
#define		bTxLSIG							0xffffff
#define		bOFDMTxRate					0xf
#define		bOFDMTxReserved				0x10
#define		bOFDMTxLength					0x1ffe0
#define		bOFDMTxParity					0x20000
#define		bTxHTSIG1						0xffffff
#define		bTxHTMCSRate					0x7f
#define		bTxHTBW						0x80
#define		bTxHTLength					0xffff00
#define		bTxHTSIG2						0xffffff
#define		bTxHTSmoothing					0x1
#define		bTxHTSounding					0x2
#define		bTxHTReserved					0x4
#define		bTxHTAggreation				0x8
#define		bTxHTSTBC						0x30
#define		bTxHTAdvanceCoding			0x40
#define		bTxHTShortGI					0x80
#define		bTxHTNumberHT_LTF			0x300
#define		bTxHTCRC8						0x3fc00
#define		bCounterReset					0x10000
#define		bNumOfOFDMTx					0xffff
#define		bNumOfCCKTx					0xffff0000
#define		bTxIdleInterval					0xffff
#define		bOFDMService					0xffff0000
#define		bTxMACHeader					0xffffffff
#define		bTxDataInit						0xff
#define		bTxHTMode						0x100
#define		bTxDataType					0x30000
#define		bTxRandomSeed					0xffffffff
#define		bCCKTxPreamble					0x1
#define		bCCKTxSFD						0xffff0000
#define		bCCKTxSIG						0xff
#define		bCCKTxService					0xff00
#define		bCCKLengthExt					0x8000
#define		bCCKTxLength					0xffff0000
#define		bCCKTxCRC16					0xffff
#define		bCCKTxStatus					0x1
#define		bOFDMTxStatus					0x2

#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
#define		RF_TX_GAIN_OFFSET_8192F(_val) (abs((_val)) | (((_val) > 0) ? BIT(4) : 0))

/* 2. Page8(0x800) */
#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
#define		bJapanMode						0x2
#define		bCCKTxSC						0x30
#define		bCCKEn							0x1000000
#define		bOFDMEn						0x2000000

#define		bOFDMRxADCPhase           0x10000	/* Useless now */
#define		bOFDMTxDACPhase		0x40000
#define		bXATxAGC			0x3f

#define		bAntennaSelect		0x0300

#define		bXBTxAGC                 0xf00	/* Reg 80c rFPGA0_TxGainStage */
#define		bXCTxAGC			0xf000
#define		bXDTxAGC			0xf0000

#define		bPAStart                 0xf0000000	/* Useless now */
#define		bTRStart			0x00f00000
#define		bRFStart			0x0000f000
#define		bBBStart			0x000000f0
#define		bBBCCKStart		0x0000000f
#define		bPAEnd                    0xf          /* Reg0x814 */
#define		bTREnd			0x0f000000
#define		bRFEnd			0x000f0000
#define		bCCAMask                  0x000000f0   /* T2R */
#define		bR2RCCAMask		0x00000f00
#define		bHSSI_R2TDelay		0xf8000000
#define		bHSSI_T2RDelay		0xf80000
#define		bContTxHSSI              0x400     /* chane gain at continue Tx */
#define		bIGFromCCK		0x200
#define		bAGCAddress		0x3f
#define		bRxHPTx			0x7000
#define		bRxHPT2R			0x38000
#define		bRxHPCCKIni		0xc0000
#define		bAGCTxCode		0xc00000
#define		bAGCRxCode		0x300000

#define		b3WireDataLength         0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
#define		b3WireAddressLength		0x400

#define		b3WireRFPowerDown         0x1	/* Useless now
 * #define bHWSISelect		0x8 */
#define		b5GPAPEPolarity		0x40000000
#define		b2GPAPEPolarity		0x80000000
#define		bRFSW_TxDefaultAnt		0x3
#define		bRFSW_TxOptionAnt		0x30
#define		bRFSW_RxDefaultAnt		0x300
#define		bRFSW_RxOptionAnt		0x3000
#define		bRFSI_3WireData		0x1
#define		bRFSI_3WireClock		0x2
#define		bRFSI_3WireLoad		0x4
#define		bRFSI_3WireRW		0x8
#define		bRFSI_3Wire			0xf

#define		bRFSI_RFENV              0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */

#define		bRFSI_TRSW               0x20	/* Useless now */
#define		bRFSI_TRSWB		0x40
#define		bRFSI_ANTSW		0x100
#define		bRFSI_ANTSWB		0x200
#define		bRFSI_PAPE			0x400
#define		bRFSI_PAPE5G		0x800
#define		bBandSelect			0x1
#define		bHTSIG2_GI			0x80
#define		bHTSIG2_Smoothing		0x01
#define		bHTSIG2_Sounding		0x02
#define		bHTSIG2_Aggreaton		0x08
#define		bHTSIG2_STBC		0x30
#define		bHTSIG2_AdvCoding		0x40
#define		bHTSIG2_NumOfHTLTF	0x300
#define		bHTSIG2_CRC8		0x3fc
#define		bHTSIG1_MCS		0x7f
#define		bHTSIG1_BandWidth		0x80
#define		bHTSIG1_HTLength		0xffff
#define		bLSIG_Rate			0xf
#define		bLSIG_Reserved		0x10
#define		bLSIG_Length		0x1fffe
#define		bLSIG_Parity			0x20
#define		bCCKRxPhase		0x4

#define		bLSSIReadAddress          0x7f800000   /* T65 RF */

#define		bLSSIReadEdge             0x80000000   /* LSSI "Read" edge signal */

#define		bLSSIReadBackData         0xfffff		/* T65 RF */

#define		bLSSIReadOKFlag           0x1000	/* Useless now */
#define		bCCKSampleRate            0x8       /* 0: 44MHz, 1:88MHz     */
#define		bRegulator0Standby		0x1
#define		bRegulatorPLLStandby		0x2
#define		bRegulator1Standby		0x4
#define		bPLLPowerUp		0x8
#define		bDPLLPowerUp		0x10
#define		bDA10PowerUp		0x20
#define		bAD7PowerUp		0x200
#define		bDA6PowerUp		0x2000
#define		bXtalPowerUp		0x4000
#define		b40MDClkPowerUP		0x8000
#define		bDA6DebugMode		0x20000
#define		bDA6Swing			0x380000

#define		bADClkPhase               0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */

#define		b80MClkDelay              0x18000000	/* Useless */
#define		bAFEWatchDogEnable		0x20000000

#define		bXtalCap01                0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
#define		bXtalCap23			0x3
#define		bXtalCap92x					0x0f000000
#define		bXtalCap			0x0f000000

#define		bIntDifClkEnable          0x400	/* Useless */
#define		bExtSigClkEnable		0x800
#define		bBandgapMbiasPowerUp	0x10000
#define		bAD11SHGain		0xc0000
#define		bAD11InputRange		0x700000
#define		bAD11OPCurrent		0x3800000
#define		bIPathLoopback		0x4000000
#define		bQPathLoopback		0x8000000
#define		bAFELoopback		0x10000000
#define		bDA10Swing		0x7e0
#define		bDA10Reverse		0x800
#define		bDAClkSource		0x1000
#define		bAD7InputRange		0x6000
#define		bAD7Gain			0x38000
#define		bAD7OutputCMMode		0x40000
#define		bAD7InputCMMode		0x380000
#define		bAD7Current			0xc00000
#define		bRegulatorAdjust		0x7000000
#define		bAD11PowerUpAtTx		0x1
#define		bDA10PSAtTx		0x10
#define		bAD11PowerUpAtRx		0x100
#define		bDA10PSAtRx		0x1000
#define		bCCKRxAGCFormat		0x200
#define		bPSDFFTSamplepPoint		0xc000
#define		bPSDAverageNum		0x3000
#define		bIQPathControl		0xc00
#define		bPSDFreq			0x3ff
#define		bPSDAntennaPath		0x30
#define		bPSDIQSwitch		0x40
#define		bPSDRxTrigger		0x400000
#define		bPSDTxTrigger		0x80000000
#define		bPSDSineToneScale		0x7f000000
#define		bPSDReport			0xffff

/* 3. Page9(0x900) */
#define		bOFDMTxSC                 0x30000000	/* Useless */
#define		bCCKTxOn			0x1
#define		bOFDMTxOn		0x2
#define		bDebugPage                0xfff  /* reset debug page and also HWord, LWord */
#define		bDebugItem                0xff   /* reset debug page and LWord */
#define		bAntL			0x10
#define		bAntNonHT				0x100
#define		bAntHT1			0x1000
#define		bAntHT2			0x10000
#define		bAntHT1S1			0x100000
#define		bAntNonHTS1		0x1000000

/* 4. PageA(0xA00) */
#define		bCCKBBMode				0x3	/* Useless */
#define		bCCKTxPowerSaving		0x80
#define		bCCKRxPowerSaving		0x40

#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */

#define		bCCKScramble			0x8	/* Useless */
#define		bCCKAntDiversity		0x8000
#define		bCCKCarrierRecovery		0x4000
#define		bCCKTxRate				0x3000
#define		bCCKDCCancel			0x0800
#define		bCCKISICancel			0x0400
#define		bCCKMatchFilter			0x0200
#define		bCCKEqualizer			0x0100
#define		bCCKPreambleDetect		0x800000
#define		bCCKFastFalseCCA		0x400000
#define		bCCKChEstStart			0x300000
#define		bCCKCCACount			0x080000
#define		bCCKcs_lim				0x070000
#define		bCCKBistMode			0x80000000
#define		bCCKCCAMask			0x40000000
#define		bCCKTxDACPhase		0x4
#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
#define		bCCKr_cp_mode0		0x0100
#define		bCCKTxDCOffset			0xf0
#define		bCCKRxDCOffset			0xf
#define		bCCKCCAMode			0xc000
#define		bCCKFalseCS_lim			0x3f00
#define		bCCKCS_ratio			0xc00000
#define		bCCKCorgBit_sel			0x300000
#define		bCCKPD_lim				0x0f0000
#define		bCCKNewCCA			0x80000000
#define		bCCKRxHPofIG			0x8000
#define		bCCKRxIG				0x7f00
#define		bCCKLNAPolarity			0x800000
#define		bCCKRx1stGain			0x7f0000
#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
#define		bCCKRxAGCSatLevel		0x1f000000
#define		bCCKRxAGCSatCount		0xe0
#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
#define		bCCKFixedRxAGC			0x8000
/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
#define		bCCKAntennaPolarity		0x2000
#define		bCCKTxFilterType		0x0c00
#define		bCCKRxAGCReportType	0x0300
#define		bCCKRxDAGCEn			0x80000000
#define		bCCKRxDAGCPeriod		0x20000000
#define		bCCKRxDAGCSatLevel		0x1f000000
#define		bCCKTimingRecovery		0x800000
#define		bCCKTxC0				0x3f0000
#define		bCCKTxC1				0x3f000000
#define		bCCKTxC2				0x3f
#define		bCCKTxC3				0x3f00
#define		bCCKTxC4				0x3f0000
#define		bCCKTxC5				0x3f000000
#define		bCCKTxC6				0x3f
#define		bCCKTxC7				0x3f00
#define		bCCKDebugPort			0xff0000
#define		bCCKDACDebug			0x0f000000
#define		bCCKFalseAlarmEnable	0x8000
#define		bCCKFalseAlarmRead		0x4000
#define		bCCKTRSSI				0x7f
#define		bCCKRxAGCReport		0xfe
#define		bCCKRxReport_AntSel	0x80000000
#define		bCCKRxReport_MFOff		0x40000000
#define		bCCKRxRxReport_SQLoss	0x20000000
#define		bCCKRxReport_Pktloss	0x10000000
#define		bCCKRxReport_Lockedbit	0x08000000
#define		bCCKRxReport_RateError	0x04000000
#define		bCCKRxReport_RxRate	0x03000000
#define		bCCKRxFACounterLower	0xff
#define		bCCKRxFACounterUpper	0xff000000
#define		bCCKRxHPAGCStart		0xe000
#define		bCCKRxHPAGCFinal		0x1c00
#define		bCCKRxFalseAlarmEnable	0x8000
#define		bCCKFACounterFreeze	0x4000
#define		bCCKTxPathSel			0x10000000
#define		bCCKDefaultRxPath		0xc000000
#define		bCCKOptionRxPath		0x3000000

/* 5. PageC(0xC00) */
#define		bNumOfSTF				0x3	/* Useless */
#define		bShift_L					0xc0
#define		bGI_TH					0xc
#define		bRxPathA				0x1
#define		bRxPathB				0x2
#define		bRxPathC				0x4
#define		bRxPathD				0x8
#define		bTxPathA				0x1
#define		bTxPathB				0x2
#define		bTxPathC				0x4
#define		bTxPathD				0x8
#define		bTRSSIFreq				0x200
#define		bADCBackoff				0x3000
#define		bDFIRBackoff			0xc000
#define		bTRSSILatchPhase		0x10000
#define		bRxIDCOffset			0xff
#define		bRxQDCOffset			0xff00
#define		bRxDFIRMode			0x1800000
#define		bRxDCNFType			0xe000000
#define		bRXIQImb_A				0x3ff
#define		bRXIQImb_B				0xfc00
#define		bRXIQImb_C				0x3f0000
#define		bRXIQImb_D				0xffc00000
#define		bDC_dc_Notch			0x60000
#define		bRxNBINotch			0x1f000000
#define		bPD_TH					0xf
#define		bPD_TH_Opt2			0xc000
#define		bPWED_TH				0x700
#define		bIfMF_Win_L			0x800
#define		bPD_Option				0x1000
#define		bMF_Win_L				0xe000
#define		bBW_Search_L			0x30000
#define		bwin_enh_L				0xc0000
#define		bBW_TH					0x700000
#define		bED_TH2				0x3800000
#define		bBW_option				0x4000000
#define		bRatio_TH				0x18000000
#define		bWindow_L				0xe0000000
#define		bSBD_Option				0x1
#define		bFrame_TH				0x1c
#define		bFS_Option				0x60
#define		bDC_Slope_check		0x80
#define		bFGuard_Counter_DC_L	0xe00
#define		bFrame_Weight_Short	0x7000
#define		bSub_Tune				0xe00000
#define		bFrame_DC_Length		0xe000000
#define		bSBD_start_offset		0x30000000
#define		bFrame_TH_2			0x7
#define		bFrame_GI2_TH			0x38
#define		bGI2_Sync_en			0x40
#define		bSarch_Short_Early		0x300
#define		bSarch_Short_Late		0xc00
#define		bSarch_GI2_Late		0x70000
#define		bCFOAntSum				0x1
#define		bCFOAcc				0x2
#define		bCFOStartOffset			0xc
#define		bCFOLookBack			0x70
#define		bCFOSumWeight			0x80
#define		bDAGCEnable			0x10000
#define		bTXIQImb_A				0x3ff
#define		bTXIQImb_B				0xfc00
#define		bTXIQImb_C				0x3f0000
#define		bTXIQImb_D				0xffc00000
#define		bTxIDCOffset			0xff
#define		bTxQDCOffset			0xff00
#define		bTxDFIRMode			0x10000
#define		bTxPesudoNoiseOn		0x4000000
#define		bTxPesudoNoise_A		0xff
#define		bTxPesudoNoise_B		0xff00
#define		bTxPesudoNoise_C		0xff0000
#define		bTxPesudoNoise_D		0xff000000
#define		bCCADropOption			0x20000
#define		bCCADropThres			0xfff00000
#define		bEDCCA_H				0xf
#define		bEDCCA_L				0xf0
#define		bLambda_ED			0x300
#define		bRxInitialGain			0x7f
#define		bRxAntDivEn				0x80
#define		bRxAGCAddressForLNA	0x7f00
#define		bRxHighPowerFlow		0x8000
#define		bRxAGCFreezeThres		0xc0000
#define		bRxFreezeStep_AGC1	0x300000
#define		bRxFreezeStep_AGC2	0xc00000
#define		bRxFreezeStep_AGC3	0x3000000
#define		bRxFreezeStep_AGC0	0xc000000
#define		bRxRssi_Cmp_En			0x10000000
#define		bRxQuickAGCEn			0x20000000
#define		bRxAGCFreezeThresMode	0x40000000
#define		bRxOverFlowCheckType	0x80000000
#define		bRxAGCShift				0x7f
#define		bTRSW_Tri_Only			0x80
#define		bPowerThres			0x300
#define		bRxAGCEn				0x1
#define		bRxAGCTogetherEn		0x2
#define		bRxAGCMin				0x4
#define		bRxHP_Ini				0x7
#define		bRxHP_TRLNA			0x70
#define		bRxHP_RSSI				0x700
#define		bRxHP_BBP1				0x7000
#define		bRxHP_BBP2				0x70000
#define		bRxHP_BBP3				0x700000
#define		bRSSI_H					0x7f0000     /* the threshold for high power */
#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
#define		bRxSettle_TRSW			0x7
#define		bRxSettle_LNA			0x38
#define		bRxSettle_RSSI			0x1c0
#define		bRxSettle_BBP			0xe00
#define		bRxSettle_RxHP			0x7000
#define		bRxSettle_AntSW_RSSI	0x38000
#define		bRxSettle_AntSW		0xc0000
#define		bRxProcessTime_DAGC	0x300000
#define		bRxSettle_HSSI			0x400000
#define		bRxProcessTime_BBPPW	0x800000
#define		bRxAntennaPowerShift	0x3000000
#define		bRSSITableSelect		0xc000000
#define		bRxHP_Final				0x7000000
#define		bRxHTSettle_BBP			0x7
#define		bRxHTSettle_HSSI		0x8
#define		bRxHTSettle_RxHP		0x70
#define		bRxHTSettle_BBPPW		0x80
#define		bRxHTSettle_Idle		0x300
#define		bRxHTSettle_Reserved	0x1c00
#define		bRxHTRxHPEn			0x8000
#define		bRxHTAGCFreezeThres	0x30000
#define		bRxHTAGCTogetherEn	0x40000
#define		bRxHTAGCMin			0x80000
#define		bRxHTAGCEn				0x100000
#define		bRxHTDAGCEn			0x200000
#define		bRxHTRxHP_BBP			0x1c00000
#define		bRxHTRxHP_Final		0xe0000000
#define		bRxPWRatioTH			0x3
#define		bRxPWRatioEn			0x4
#define		bRxMFHold				0x3800
#define		bRxPD_Delay_TH1		0x38
#define		bRxPD_Delay_TH2		0x1c0
#define		bRxPD_DC_COUNT_MAX	0x600
/* #define bRxMF_Hold               0x3800 */
#define		bRxPD_Delay_TH			0x8000
#define		bRxProcess_Delay		0xf0000
#define		bRxSearchrange_GI2_Early	0x700000
#define		bRxFrame_Guard_Counter_L	0x3800000
#define		bRxSGI_Guard_L			0xc000000
#define		bRxSGI_Search_L		0x30000000
#define		bRxSGI_TH				0xc0000000
#define		bDFSCnt0				0xff
#define		bDFSCnt1				0xff00
#define		bDFSFlag				0xf0000
#define		bMFWeightSum			0x300000
#define		bMinIdxTH				0x7f000000
#define		bDAFormat				0x40000
#define		bTxChEmuEnable		0x01000000
#define		bTRSWIsolation_A		0x7f
#define		bTRSWIsolation_B		0x7f00
#define		bTRSWIsolation_C		0x7f0000
#define		bTRSWIsolation_D		0x7f000000
#define		bExtLNAGain				0x7c00

/* 6. PageE(0xE00) */
#define		bSTBCEn				0x4	/* Useless */
#define		bAntennaMapping		0x10
#define		bNss					0x20
#define		bCFOAntSumD			0x200
#define		bPHYCounterReset		0x8000000
#define		bCFOReportGet			0x4000000
#define		bOFDMContinueTx		0x10000000
#define		bOFDMSingleCarrier		0x20000000
#define		bOFDMSingleTone		0x40000000
/* #define bRxPath1                 0x01 */
/* #define bRxPath2                 0x02 */
/* #define bRxPath3                 0x04 */
/* #define bRxPath4                 0x08 */
/* #define bTxPath1                 0x10 */
/* #define bTxPath2                 0x20 */
#define		bHTDetect			0x100
#define		bCFOEn				0x10000
#define		bCFOValue			0xfff00000
#define		bSigTone_Re		0x3f
#define		bSigTone_Im		0x7f00
#define		bCounter_CCA		0xffff
#define		bCounter_ParityFail	0xffff0000
#define		bCounter_RateIllegal		0xffff
#define		bCounter_CRC8Fail	0xffff0000
#define		bCounter_MCSNoSupport	0xffff
#define		bCounter_FastSync	0xffff
#define		bShortCFO			0xfff
#define		bShortCFOTLength	12   /* total */
#define		bShortCFOFLength	11   /* fraction */
#define		bLongCFO			0x7ff
#define		bLongCFOTLength	11
#define		bLongCFOFLength	11
#define		bTailCFO			0x1fff
#define		bTailCFOTLength		13
#define		bTailCFOFLength		12
#define		bmax_en_pwdB		0xffff
#define		bCC_power_dB		0xffff0000
#define		bnoise_pwdB		0xffff
#define		bPowerMeasTLength	10
#define		bPowerMeasFLength	3
#define		bRx_HT_BW			0x1
#define		bRxSC				0x6
#define		bRx_HT				0x8
#define		bNB_intf_det_on		0x1
#define		bIntf_win_len_cfg	0x30
#define		bNB_Intf_TH_cfg		0x1c0
#define		bRFGain				0x3f
#define		bTableSel			0x40
#define		bTRSW				0x80
#define		bRxSNR_A			0xff
#define		bRxSNR_B			0xff00
#define		bRxSNR_C			0xff0000
#define		bRxSNR_D			0xff000000
#define		bSNREVMTLength		8
#define		bSNREVMFLength		1
#define		bCSI1st				0xff
#define		bCSI2nd				0xff00
#define		bRxEVM1st			0xff0000
#define		bRxEVM2nd			0xff000000
#define		bSIGEVM			0xff
#define		bPWDB				0xff00
#define		bSGIEN				0x10000

#define		bSFactorQAM1		0xf	/* Useless */
#define		bSFactorQAM2		0xf0
#define		bSFactorQAM3		0xf00
#define		bSFactorQAM4		0xf000
#define		bSFactorQAM5		0xf0000
#define		bSFactorQAM6		0xf0000
#define		bSFactorQAM7		0xf00000
#define		bSFactorQAM8		0xf000000
#define		bSFactorQAM9		0xf0000000
#define		bCSIScheme			0x100000

#define		bNoiseLvlTopSet		0x3	/* Useless */
#define		bChSmooth			0x4
#define		bChSmoothCfg1		0x38
#define		bChSmoothCfg2		0x1c0
#define		bChSmoothCfg3		0xe00
#define		bChSmoothCfg4		0x7000
#define		bMRCMode			0x800000
#define		bTHEVMCfg			0x7000000

#define		bLoopFitType		0x1	/* Useless */
#define		bUpdCFO			0x40
#define		bUpdCFOOffData		0x80
#define		bAdvUpdCFO			0x100
#define		bAdvTimeCtrl		0x800
#define		bUpdClko			0x1000
#define		bFC					0x6000
#define		bTrackingMode		0x8000
#define		bPhCmpEnable		0x10000
#define		bUpdClkoLTF		0x20000
#define		bComChCFO			0x40000
#define		bCSIEstiMode		0x80000
#define		bAdvUpdEqz			0x100000
#define		bUChCfg				0x7000000
#define		bUpdEqz			0x8000000

/* Rx Pseduo noise */
#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
#define		bRxPesudoNoise_A		0xff
#define		bRxPesudoNoise_B		0xff00
#define		bRxPesudoNoise_C		0xff0000
#define		bRxPesudoNoise_D		0xff000000
#define		bPesudoNoiseState_A	0xffff
#define		bPesudoNoiseState_B	0xffff0000
#define		bPesudoNoiseState_C	0xffff
#define		bPesudoNoiseState_D	0xffff0000

/* 7. RF Register
 * Zebra1 */
#define		bZebra1_HSSIEnable		0x8		/* Useless */
#define		bZebra1_TRxControl		0xc00
#define		bZebra1_TRxGainSetting	0x07f
#define		bZebra1_RxCorner		0xc00
#define		bZebra1_TxChargePump	0x38
#define		bZebra1_RxChargePump	0x7
#define		bZebra1_ChannelNum	0xf80
#define		bZebra1_TxLPFBW		0x400
#define		bZebra1_RxLPFBW		0x600

/* Zebra4 */
#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
#define		bRTL8256RegModeCtrl0	0x40
#define		bRTL8256_TxLPFBW		0x18
#define		bRTL8256_RxLPFBW		0x600

/* RTL8258 */
#define		bRTL8258_TxLPFBW		0xc	/* Useless */
#define		bRTL8258_RxLPFBW		0xc00
#define		bRTL8258_RSSILPFBW	0xc0


/*
 * Other Definition
 *   */

/* byte endable for sb_write */
#define		bByte0				0x1	/* Useless */
#define		bByte1				0x2
#define		bByte2				0x4
#define		bByte3				0x8
#define		bWord0				0x3
#define		bWord1				0xc
#define		bDWord				0xf

/* for PutRegsetting & GetRegSetting BitMask */
#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
#define		bMaskByte1			0xff00
#define		bMaskByte2			0xff0000
#define		bMaskByte3			0xff000000
#define		bMaskHWord		0xffff0000
#define		bMaskLWord			0x0000ffff
#define		bMaskDWord		0xffffffff
#define		bMaskH3Bytes		0xffffff00
#define		bMask12Bits			0xfff
#define		bMaskH4Bits			0xf0000000
#define		bMaskOFDM_D		0xffc00000
#define		bMaskCCK			0x3f3f3f3f


#define		bEnable			0x1	/* Useless */
#define		bDisable		0x0

#define		LeftAntenna		0x0	/* Useless */
#define		RightAntenna	0x1

#define		tCheckTxStatus		500   /* 500ms // Useless */
#define		tUpdateRxCounter	100   /* 100ms */

#define		rateCCK		0	/* Useless */
#define		rateOFDM	1
#define		rateHT		2

/* define Register-End */
#define		bPMAC_End			0x1ff	/* Useless */
#define		bFPGAPHY0_End		0x8ff
#define		bFPGAPHY1_End		0x9ff
#define		bCCKPHY0_End		0xaff
#define		bOFDMPHY0_End		0xcff
#define		bOFDMPHY1_End		0xdff

/* define max debug item in each debug page
 * #define bMaxItem_FPGA_PHY0        0x9
 * #define bMaxItem_FPGA_PHY1        0x3
 * #define bMaxItem_PHY_11B          0x16
 * #define bMaxItem_OFDM_PHY0        0x29
 * #define bMaxItem_OFDM_PHY1        0x0 */

#define		bPMACControl		0x0		/* Useless */
#define		bWMACControl		0x1
#define		bWNICControl		0x2

#define		PathA			0x0	/* Useless */
#define		PathB			0x1
#define		PathC			0x2
#define		PathD			0x3

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    rtl8822bu/src/include/rtl8188f_led.h                                                                0000644 0001750 0001750 00000003017 14214766567 015722  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8188F_LED_H__
#define __RTL8188F_LED_H__
#ifdef CONFIG_RTW_SW_LED

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>


/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
void rtl8188fu_InitSwLeds(PADAPTER padapter);
void rtl8188fu_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
void rtl8188fs_InitSwLeds(PADAPTER padapter);
void rtl8188fs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_GSPI_HCI
void rtl8188fs_InitSwLeds(PADAPTER padapter);
void rtl8188fs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
void rtl8188fe_InitSwLeds(PADAPTER padapter);
void rtl8188fe_DeInitSwLeds(PADAPTER padapter);
#endif

#endif
#endif/*CONFIG_RTW_SW_LED*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 rtl8822bu/src/include/rtl8812a_rf.h                                                                 0000644 0001750 0001750 00000001561 14214766567 015554  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8812A_RF_H__
#define __RTL8812A_RF_H__

void
PHY_RF6052SetBandwidth8812(
		PADAPTER				Adapter,
		enum channel_width		Bandwidth);


int
PHY_RF6052_Config_8812(
		PADAPTER	Adapter);

#endif/* __RTL8188E_RF_H__ */
                                                                                                                                               rtl8822bu/src/include/Hal8812PwrSeq.h                                                               0000644 0001750 0001750 00000044241 14214766567 015773  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/


#ifndef __HAL8812PWRSEQ_H__
#define __HAL8812PWRSEQ_H__

#include "HalPwrSeqCmd.h"

/*
	Check document WB-110628-DZ-RTL8195 (Jaguar) Power Architecture-R04.pdf
	There are 6 HW Power States:
	0: POFF--Power Off
	1: PDN--Power Down
	2: CARDEMU--Card Emulation
	3: ACT--Active Mode
	4: LPS--Low Power State
	5: SUS--Suspend

	The transision from different states are defined below
	TRANS_CARDEMU_TO_ACT
	TRANS_ACT_TO_CARDEMU
	TRANS_CARDEMU_TO_SUS
	TRANS_SUS_TO_CARDEMU
	TRANS_CARDEMU_TO_PDN
	TRANS_ACT_TO_LPS
	TRANS_LPS_TO_ACT

	TRANS_END
*/
#define	RTL8812_TRANS_CARDEMU_TO_ACT_STEPS	15
#define	RTL8812_TRANS_ACT_TO_CARDEMU_STEPS	15
#define	RTL8812_TRANS_CARDEMU_TO_SUS_STEPS	15
#define	RTL8812_TRANS_SUS_TO_CARDEMU_STEPS	15
#define	RTL8812_TRANS_CARDEMU_TO_PDN_STEPS	15
#define	RTL8812_TRANS_PDN_TO_CARDEMU_STEPS	15
#define	RTL8812_TRANS_ACT_TO_LPS_STEPS	15
#define	RTL8812_TRANS_LPS_TO_ACT_STEPS	15
#define	RTL8812_TRANS_END_STEPS	1


#define RTL8812_TRANS_CARDEMU_TO_ACT														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
	/*{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0}, disable HWPDN 0x04[15]=0*/ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, 0},/* disable WL suspend*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/   \
	{0x0024, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /* 0x24[1] Choose the type of buffer after xosc: nand*/   \
	{0x0028, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0}, /* 0x28[33] Choose the type of buffer after xosc: nand*/

#define RTL8812_TRANS_ACT_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},//0x1F[7:0] = 0 turn off RF*/	\
	/*{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},//0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x2A}, /* 0x07[7:0] = 0x28 sps pwm mode 0x2a for BT coex*/	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk = 500k */	\
	/*{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 | BIT1, 0}, //  0x02[1:0] = 0	reset BB */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/

#define RTL8812_TRANS_CARDEMU_TO_SUS													\
	/* format */								\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xF0, 0xcc},\
	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xF0, 0xEC},\
	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/* suspend option all off */	\
	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x80, BIT7},/*0x14[7] = 1 turn on ZCD */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x01, BIT0},/* 0x15[0] =1 trun on ZCD */	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x10, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk = 500k */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 2b'11 enable WL suspend for PCIe*/

#define RTL8812_TRANS_SUS_TO_CARDEMU													\
	/* format */								\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 2b'01enable WL suspend*/   \
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO sleep mode leave */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x01, 0},/* 0x15[0] =0 trun off ZCD */	\
	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x80, 0},/*0x14[7] = 0 turn off ZCD */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */

#define RTL8812_TRANS_CARDEMU_TO_CARDDIS													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	/**{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0}, //0x194[0]=0 , disable 32K clock*/	\
	/**{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x94}, //0x93 = 0x94 , 90[30] =0 enable 500k ANA clock .switch clock from 12M to 500K , 90 [26] =0 disable EEprom loader clock*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0}, /*0x03[2] = 0, reset 8051*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x05}, /*0x80 = 05h if reload fw, fill the default value of host_CPU handshake field*/	\
	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xF0, 0xcc},\
	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xF0, 0xEC},\
	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x80, BIT7},/*0x14[7] = 1 turn on ZCD */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x01, BIT0},/* 0x15[0] =1 trun on ZCD */	\
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x01, 0},/*0x12[0] = 0 force PFM mode */	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x10, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk = 500k */	\
	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07 = 0x20 , SOP option to disable BG/MB*/	\
	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0}, /*0x01f[1]=0 , disable RFC_0  control  REG_RF_CTRL_8812 */	\
	{0x0076, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0}, /*0x076[1]=0 , disable RFC_1  control REG_OPT_CTRL_8812 +2 */	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 2b'01 enable WL suspend*/

#define RTL8812_TRANS_CARDDIS_TO_CARDEMU													\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/                       \
	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*0x12[0] = 1 force PWM mode */	\
	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x80, 0},/*0x14[7] = 0 turn off ZCD */	\
	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x01, 0},/* 0x15[0] =0 trun off ZCD */	\
	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO leave sleep mode */	\
	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */ \
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0}, /*0x04[10] = 0, enable SW LPS PCIE only*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 2b'01enable WL suspend*/	\
	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2}, /*0x03[2] = 1, enable 8051*/	\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/  \
	{0x0024, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /* 0x24[1] Choose the type of buffer after xosc: schmitt trigger*/ \
	{0x0028, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /* 0x28[33] Choose the type of buffer after xosc: schmitt trigger*/


#define RTL8812_TRANS_CARDEMU_TO_PDN												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/

#define RTL8812_TRANS_PDN_TO_CARDEMU												\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/

#define RTL8812_TRANS_ACT_TO_LPS														\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/		\
	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated, and RF closed*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/			\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/		\
	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/


#define RTL8812_TRANS_LPS_TO_ACT															\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/	\
	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/	\
	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/	\
	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/	\
	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/			\
	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/	\
	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/					\
	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/	\
	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/	\
	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/

#define RTL8812_TRANS_END																\
	/* format */																\
	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/		\
	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},


extern WLAN_PWR_CFG rtl8812_power_on_flow[RTL8812_TRANS_CARDEMU_TO_ACT_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_radio_off_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_card_disable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS + RTL8812_TRANS_CARDEMU_TO_PDN_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_card_enable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS + RTL8812_TRANS_CARDEMU_TO_PDN_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_suspend_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS + RTL8812_TRANS_CARDEMU_TO_SUS_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_resume_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS + RTL8812_TRANS_CARDEMU_TO_SUS_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_hwpdn_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS + RTL8812_TRANS_CARDEMU_TO_PDN_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_enter_lps_flow[RTL8812_TRANS_ACT_TO_LPS_STEPS + RTL8812_TRANS_END_STEPS];
extern WLAN_PWR_CFG rtl8812_leave_lps_flow[RTL8812_TRANS_LPS_TO_ACT_STEPS + RTL8812_TRANS_END_STEPS];

#endif /* __HAL8812PWRSEQ_H__ */
                                                                                                                                                                                                                                                                                                                                                               rtl8822bu/src/include/rtl8192f_rf.h                                                                 0000644 0001750 0001750 00000005153 14214766567 015563  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_RF_H__
#define __RTL8192F_RF_H__

/*default*/
/*#define CONFIG_8192F_DRV_DIS*/
/*AP*/
#define CONFIG_8192F_TYPE3_DRV_DIS
#define CONFIG_8192F_TYPE4_DRV_DIS
/*unused*/
#define CONFIG_8192F_TYPE13_DRV_DIS
#define CONFIG_8192F_TYPE14_DRV_DIS
#define CONFIG_8192F_TYPE15_DRV_DIS
#define CONFIG_8192F_TYPE16_DRV_DIS
#define CONFIG_8192F_TYPE17_DRV_DIS
#define CONFIG_8192F_TYPE18_DRV_DIS
#define CONFIG_8192F_TYPE19_DRV_DIS
#define CONFIG_8192F_TYPE20_DRV_DIS
#define CONFIG_8192F_TYPE21_DRV_DIS
#define CONFIG_8192F_TYPE22_DRV_DIS
#define CONFIG_8192F_TYPE23_DRV_DIS
#define CONFIG_8192F_TYPE24_DRV_DIS
#define CONFIG_8192F_TYPE25_DRV_DIS
#define CONFIG_8192F_TYPE26_DRV_DIS
#define CONFIG_8192F_TYPE27_DRV_DIS
#define CONFIG_8192F_TYPE28_DRV_DIS
#define CONFIG_8192F_TYPE29_DRV_DIS
#define CONFIG_8192F_TYPE30_DRV_DIS
#define CONFIG_8192F_TYPE31_DRV_DIS


#ifdef CONFIG_SDIO_HCI /**/
/*usb*/
#define CONFIG_8192F_TYPE1_DRV_DIS
#define CONFIG_8192F_TYPE5_DRV_DIS
#define CONFIG_8192F_TYPE10_DRV_DIS
/*pcie*/
#define CONFIG_8192F_TYPE0_DRV_DIS
#define CONFIG_8192F_TYPE6_DRV_DIS
#define CONFIG_8192F_TYPE7_DRV_DIS
#define CONFIG_8192F_TYPE8_DRV_DIS
#define CONFIG_8192F_TYPE9_DRV_DIS
#define CONFIG_8192F_TYPE12_DRV_DIS
#endif/*CONFIG_SDIO_HCI*/

#ifdef CONFIG_USB_HCI
/*sdio*/
#define CONFIG_8192F_TYPE2_DRV_DIS
#define CONFIG_8192F_TYPE11_DRV_DIS
/*pcie*/
#define CONFIG_8192F_TYPE0_DRV_DIS
#define CONFIG_8192F_TYPE6_DRV_DIS
#define CONFIG_8192F_TYPE7_DRV_DIS
#define CONFIG_8192F_TYPE8_DRV_DIS
#define CONFIG_8192F_TYPE9_DRV_DIS
#define CONFIG_8192F_TYPE12_DRV_DIS
#endif/*CONFIG_USB_HCI*/

#ifdef CONFIG_PCI_HCI
/*sdio*/
#define CONFIG_8192F_TYPE2_DRV_DIS
#define CONFIG_8192F_TYPE11_DRV_DIS
/*usb*/
#define CONFIG_8192F_TYPE1_DRV_DIS
#define CONFIG_8192F_TYPE5_DRV_DIS
#define CONFIG_8192F_TYPE10_DRV_DIS
#endif/*CONFIG_PCI_HCI*/

int PHY_RF6052_Config8192F(PADAPTER pdapter);

void PHY_RF6052SetBandwidth8192F(PADAPTER Adapter, enum channel_width Bandwidth);

#endif/* __RTL8192F_RF_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                     rtl8822bu/src/include/rtl8192e_xmit.h                                                               0000644 0001750 0001750 00000046736 14214766567 016150  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2012 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192E_XMIT_H__
#define __RTL8192E_XMIT_H__

typedef struct txdescriptor_8192e {
	/* Offset 0 */
	u32 pktlen:16;
	u32 offset:8;
	u32 bmc:1;
	u32 htc:1;
	u32 ls:1;
	u32 fs:1;
	u32 linip:1;
	u32 noacm:1;
	u32 gf:1;
	u32 own:1;

	/* Offset 4 */
	u32 macid:6;
	u32 rsvd0406:2;
	u32 qsel:5;
	u32 rd_nav_ext:1;
	u32 lsig_txop_en:1;
	u32 pifs:1;
	u32 rate_id:4;
	u32 navusehdr:1;
	u32 en_desc_id:1;
	u32 sectype:2;
	u32 rsvd0424:2;
	u32 pkt_offset:5;	/* unit: 8 bytes */
	u32 rsvd0431:1;

	/* Offset 8 */
	u32 rts_rc:6;
	u32 data_rc:6;
	u32 agg_en:1;
	u32 rd_en:1;
	u32 bar_rty_th:2;
	u32 bk:1;
	u32 morefrag:1;
	u32 raw:1;
	u32 ccx:1;
	u32 ampdu_density:3;
	u32 bt_null:1;
	u32 ant_sel_a:1;
	u32 ant_sel_b:1;
	u32 tx_ant_cck:2;
	u32 tx_antl:2;
	u32 tx_ant_ht:2;

	/* Offset 12 */
	u32 nextheadpage:8;
	u32 tailpage:8;
	u32 seq:12;
	u32 cpu_handle:1;
	u32 tag1:1;
	u32 trigger_int:1;
	u32 hwseq_en:1;

	/* Offset 16 */
	u32 rtsrate:5;
	u32 ap_dcfe:1;
	u32 hwseq_sel:2;
	u32 userate:1;
	u32 disrtsfb:1;
	u32 disdatafb:1;
	u32 cts2self:1;
	u32 rtsen:1;
	u32 hw_rts_en:1;
	u32 port_id:1;
	u32 pwr_status:3;
	u32 wait_dcts:1;
	u32 cts2ap_en:1;
	u32 data_sc:2;
	u32 data_stbc:2;
	u32 data_short:1;
	u32 data_bw:1;
	u32 rts_short:1;
	u32 rts_bw:1;
	u32 rts_sc:2;
	u32 vcs_stbc:2;

	/* Offset 20 */
	u32 datarate:6;
	u32 sgi:1;
	u32 try_rate:1;
	u32 data_ratefb_lmt:5;
	u32 rts_ratefb_lmt:4;
	u32 rty_lmt_en:1;
	u32 data_rt_lmt:6;
	u32 usb_txagg_num:8;

	/* Offset 24 */
	u32 txagg_a:5;
	u32 txagg_b:5;
	u32 use_max_len:1;
	u32 max_agg_num:5;
	u32 mcsg1_max_len:4;
	u32 mcsg2_max_len:4;
	u32 mcsg3_max_len:4;
	u32 mcs7_sgi_max_len:4;

	/* Offset 28 */
	u32 checksum:16;	/* TxBuffSize(PCIe)/CheckSum(USB) */
	u32 mcsg4_max_len:4;
	u32 mcsg5_max_len:4;
	u32 mcsg6_max_len:4;
	u32 mcs15_sgi_max_len:4;
} TXDESC_8192E, *PTXDESC_8192E;



/* For 88e early mode */
#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)

/*
 * defined for TX DESC Operation
 *   */

#define MAX_TID (15)

/* OFFSET 0 */
#define OFFSET_SZ	0
#define OFFSET_SHT	16
#define BMC		BIT(24)
#define LSG		BIT(26)
#define FSG		BIT(27)
#define OWN		BIT(31)


/* OFFSET 4 */
#define PKT_OFFSET_SZ		0
#define QSEL_SHT			8
#define RATE_ID_SHT			16
#define NAVUSEHDR			BIT(20)
#define SEC_TYPE_SHT		22
#define PKT_OFFSET_SHT		26

/* OFFSET 8 */
#define AGG_EN				BIT(12)
#define AGG_BK					BIT(16)
#define AMPDU_DENSITY_SHT	20
#define ANTSEL_A			BIT(24)
#define ANTSEL_B			BIT(25)
#define TX_ANT_CCK_SHT		26
#define TX_ANTL_SHT			28
#define TX_ANT_HT_SHT		30

/* OFFSET 12 */
#define SEQ_SHT				16
#define EN_HWSEQ			BIT(31)

/* OFFSET 16 */
#define	QOS                          BIT(6)
#define	HW_SSN				BIT(7)
#define	USERATE			BIT(8)
#define	DISDATAFB			BIT(10)
#define   CTS_2_SELF			BIT(11)
#define	RTS_EN				BIT(12)
#define	HW_RTS_EN			BIT(13)
#define	DATA_SHORT			BIT(24)
#define	PWR_STATUS_SHT	15
#define	DATA_SC_SHT		20
#define	DATA_BW			BIT(25)

/* OFFSET 20 */
#define	RTY_LMT_EN			BIT(17)


/* OFFSET 20 */
#define SGI					BIT(6)
#define USB_TXAGG_NUM_SHT	24


/* *****Tx Desc Buffer content */

/* config element for each tx buffer
 *
#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 0, 16, __Valeu)
#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 31, 1, __Valeu)
#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+4, 0, 32, __Valeu)
#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
*/
#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)


/* Dword 0 */
#define SET_TX_BUFF_DESC_LEN_0_92E(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 14, __Valeu)
#define SET_TX_BUFF_DESC_PSB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
#define SET_TX_BUFF_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
/* Dword 1 */
#define SET_TX_BUFF_DESC_ADDR_LOW_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
#define GET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0, 32)


/* Dword 2 */
#define SET_TX_BUFF_DESC_ADDR_HIGH_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
/* Dword 3, RESERVED */


/* *****Tx Desc content
 * Dword 0 */
#define SET_TX_DESC_PKT_SIZE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
#define SET_TX_DESC_OFFSET_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
#define SET_TX_DESC_BMC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
#define SET_TX_DESC_HTC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
#define SET_TX_DESC_LAST_SEG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
#define SET_TX_DESC_FIRST_SEG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
#define SET_TX_DESC_LINIP_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
#define SET_TX_DESC_NO_ACM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
#define SET_TX_DESC_GF_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
#define SET_TX_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
#define GET_TX_DESC_OWN_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)

/* Dword 1 */
#define SET_TX_DESC_MACID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
#define SET_TX_DESC_QUEUE_SEL_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
#define SET_TX_DESC_RDG_NAV_EXT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
#define SET_TX_DESC_LSIG_TXOP_EN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
#define SET_TX_DESC_PIFS_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
#define SET_TX_DESC_RATE_ID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
#define SET_TX_DESC_EN_DESC_ID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
#define SET_TX_DESC_SEC_TYPE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
#define SET_TX_DESC_PKT_OFFSET_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
#define SET_TX_DESC_MORE_DATA_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)
#define SET_TX_DESC_TXOP_PS_CAP_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 30, 1, __Value)
#define SET_TX_DESC_TXOP_PS_MODE_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 31, 1, __Value)


/* Dword 2 */
#define SET_TX_DESC_PAID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
#define SET_TX_DESC_CCA_RTS_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
#define SET_TX_DESC_AGG_ENABLE_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
#define SET_TX_DESC_RDG_ENABLE_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
#define SET_TX_DESC_NULL_0_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
#define SET_TX_DESC_NULL_1_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
#define SET_TX_DESC_BK_92E(__pTxDesc, __Value)				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
#define SET_TX_DESC_MORE_FRAG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
#define SET_TX_DESC_RAW_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
#define GET_TX_DESC_MORE_FRAG_92E(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc+8, 17, 1)
#define SET_TX_DESC_SPE_RPT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
#define SET_TX_DESC_AMPDU_DENSITY_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
#define SET_TX_DESC_BT_NULL_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
#define SET_TX_DESC_GID_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)


/* Dword 3 */
#define SET_TX_DESC_WHEADER_LEN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
#define SET_TX_DESC_CHK_EN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
#define SET_TX_DESC_EARLY_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
#define SET_TX_DESC_HWSEQ_SEL_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
#define SET_TX_DESC_USE_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
#define SET_TX_DESC_DISABLE_RTS_FB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
#define SET_TX_DESC_DISABLE_FB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
#define SET_TX_DESC_CTS2SELF_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
#define SET_TX_DESC_RTS_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
#define SET_TX_DESC_HW_RTS_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
#define SET_TX_DESC_HW_PORT_ID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 1, __Value)
#define SET_TX_DESC_NAV_USE_HDR_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
#define SET_TX_DESC_USE_MAX_LEN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
#define SET_TX_DESC_MAX_AGG_NUM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
#define SET_TX_DESC_NDPA_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
#define SET_TX_DESC_AMPDU_MAX_TIME_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)

/* Dword 4 */
#define SET_TX_DESC_TX_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
#define SET_TX_DESC_TRY_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
#define SET_TX_DESC_DATA_RATE_FB_LIMIT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
#define SET_TX_DESC_RTS_RATE_FB_LIMIT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
#define SET_TX_DESC_RETRY_LIMIT_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
#define SET_TX_DESC_DATA_RETRY_LIMIT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
#define SET_TX_DESC_RTS_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
#define SET_TX_DESC_PCTS_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
#define SET_TX_DESC_PCTS_MASK_IDX_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)


/* Dword 5 */
#define SET_TX_DESC_DATA_SC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
#define SET_TX_DESC_DATA_SHORT_92E(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
#define SET_TX_DESC_DATA_BW_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
#define SET_TX_DESC_DATA_LDPC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
#define SET_TX_DESC_DATA_STBC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
#define SET_TX_DESC_VCS_STBC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
#define SET_TX_DESC_RTS_SHORT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
#define SET_TX_DESC_RTS_SC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
#define SET_TX_DESC_TX_ANT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 4, __Value)
#define SET_TX_DESC_TX_POWER_0_PSET_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)

/* Dword 6 */
#define SET_TX_DESC_SW_DEFINE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
#define SET_TX_DESC_MBSSID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
#define SET_TX_DESC_ANTSEL_A_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
#define SET_TX_DESC_ANTSEL_B_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
#define SET_TX_DESC_ANTSEL_C_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
#define SET_TX_DESC_ANTSEL_D_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)

/* Dword 7 */
#ifdef CONFIG_PCI_HCI
	#define SET_TX_DESC_TX_BUFFER_SIZE_92E(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
	#define SET_TX_DESC_TX_DESC_CHECKSUM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
#endif
#define SET_TX_DESC_USB_TXAGG_NUM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)


/* #define SET_TX_DESC_HWSEQ_EN_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value) */
/* Dword 8 */

#define SET_TX_DESC_RTS_RC_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
#define SET_TX_DESC_BAR_RTY_TH_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
#define SET_TX_DESC_DATA_RC_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
#define SET_TX_DESC_EN_HWSEQ_92E(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
#define SET_TX_DESC_NEXT_HEAD_PAGE_92E(__pTxDesc, __Value)(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
#define SET_TX_DESC_TAIL_PAGE_92E(__pTxDesc, __Value)(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)

/* Dword 9 */
#define SET_TX_DESC_PADDING_LENGTH_92E(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
#define SET_TX_DESC_TXBF_PATH_92E(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 11, 1, __Value)
#define SET_TX_DESC_SEQ_92E(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
#define SET_TX_DESC_FINAL_DATA_RATE_92E(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 8, __Value)


#define SET_EARLYMODE_PKTNUM_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
#define SET_EARLYMODE_LEN0_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
#define SET_EARLYMODE_LEN1_1_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
#define SET_EARLYMODE_LEN1_2_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
#define SET_EARLYMODE_LEN2_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
#define SET_EARLYMODE_LEN3_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)

void rtl8192e_cal_txdesc_chksum(u8 *ptxdesc);

#ifdef CONFIG_USB_HCI
	s32 rtl8192eu_init_xmit_priv(PADAPTER padapter);
	void rtl8192eu_free_xmit_priv(PADAPTER padapter);
	s32 rtl8192eu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192eu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8192eu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192eu_xmit_buf_handler(PADAPTER padapter);
	#define hal_xmit_handler rtl8192eu_xmit_buf_handler
	void rtl8192eu_xmit_tasklet(void *priv);
	s32 rtl8192eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif

#ifdef CONFIG_PCI_HCI
	s32 rtl8192ee_init_xmit_priv(PADAPTER padapter);
	void rtl8192ee_free_xmit_priv(PADAPTER padapter);
	struct xmit_buf *rtl8192ee_dequeue_xmitbuf(struct rtw_tx_ring *ring);
	s32	rtl8192ee_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	void	rtl8192ee_xmitframe_resume(_adapter *padapter);
	s32 rtl8192ee_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192ee_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	void rtl8192ee_xmit_tasklet(void *priv);
#endif

#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
	s32 rtl8192es_init_xmit_priv(PADAPTER padapter);
	void rtl8192es_free_xmit_priv(PADAPTER padapter);

	s32 rtl8192es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
	s32 rtl8192es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
	s32	rtl8192es_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
	thread_return rtl8192es_xmit_thread(thread_context context);
	s32 rtl8192es_xmit_buf_handler(PADAPTER padapter);

	#ifdef CONFIG_SDIO_TX_TASKLET
		void rtl8192es_xmit_tasklet(void *priv);
	#endif
#endif

struct txrpt_ccx_92e {
	/* offset 0 */
	u8 tag1:1;
	u8 pkt_num:3;
	u8 txdma_underflow:1;
	u8 int_bt:1;
	u8 int_tri:1;
	u8 int_ccx:1;

	/* offset 1 */
	u8 mac_id:6;
	u8 pkt_ok:1;
	u8 bmc:1;

	/* offset 2 */
	u8 retry_cnt:6;
	u8 lifetime_over:1;
	u8 retry_over:1;

	/* offset 3 */
	u8 ccx_qtime0;
	u8 ccx_qtime1;

	/* offset 5 */
	u8 final_data_rate;

	/* offset 6 */
	u8 sw1:4;
	u8 qsel:4;

	/* offset 7 */
	u8 sw0;
};

#ifdef CONFIG_TX_EARLY_MODE
	void UpdateEarlyModeInfo8192E(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
#endif
s32	rtl8192e_init_xmit_priv(_adapter *padapter);
void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, u8 *ptxdesc);

void rtl8192e_fill_fake_txdesc(PADAPTER	padapter, u8 *pDesc, u32 BufferLen,
			       u8 IsPsPoll, u8	IsBTQosNull, u8 bDataFrame);
void rtl8192e_cal_txdesc_chksum(u8 *ptxdesc);

u8	BWMapping_92E(PADAPTER Adapter, struct pkt_attrib *pattrib);
u8	SCMapping_92E(PADAPTER Adapter, struct pkt_attrib	*pattrib);
void fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
void fill_txdesc_vcs(struct pkt_attrib *pattrib, u8 *ptxdesc);
#if defined(CONFIG_CONCURRENT_MODE)
	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, u8 *ptxdesc);
#endif
void fill_txdesc_bmc_tx_rate(struct pkt_attrib *pattrib, u8 *ptxdesc);

void fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
void rtl8192e_fixed_rate(_adapter *padapter, u8 *ptxdesc);

#endif /* __RTL8192E_XMIT_H__ */
                                  rtl8822bu/src/include/rtl8192f_spec.h                                                               0000644 0001750 0001750 00000052646 14214766567 016117  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8192F_SPEC_H__
#define __RTL8192F_SPEC_H__

#include <drv_conf.h>


#define HAL_NAV_UPPER_UNIT_8192F		128		/* micro-second */

/* -----------------------------------------------------
 *
 *	0x0000h ~ 0x00FFh	System Configuration
 *
 * ----------------------------------------------------- */
#define REG_SYS_ISO_CTRL_8192F			0x0000	/* 2 Byte */
#define REG_SYS_FUNC_EN_8192F			0x0002	/* 2 Byte */
#define REG_APS_FSMCO_8192F			0x0004	/* 4 Byte */
#define REG_SYS_CLKR_8192F				0x0008	/* 2 Byte */
#define REG_9346CR_8192F				0x000A	/* 2 Byte */
#define REG_EE_VPD_8192F				0x000C	/* 2 Byte */
#define REG_AFE_MISC_8192F				0x0010	/* 1 Byte */
#define REG_SPS0_CTRL_8192F				0x0011	/* 7 Byte */
#define REG_SPS_OCP_CFG_8192F			0x0018	/* 4 Byte */
#define REG_RSV_CTRL_8192F				0x001C	/* 3 Byte */
#define REG_RF_CTRL_8192F				0x001F	/* 1 Byte */
#define REG_LPLDO_CTRL_8192F			0x0023	/* 1 Byte */
#define REG_AFE_XTAL_CTRL_8192F		0x0024	/* 4 Byte */
#define REG_AFE_PLL_CTRL_8192F			0x0028	/* 4 Byte */
#define REG_MAC_PLL_CTRL_EXT_8192F		0x002c	/* 4 Byte */
#define REG_EFUSE_CTRL_8192F			0x0030
#define REG_EFUSE_TEST_8192F			0x0034
#define REG_PWR_DATA_8192F				0x0038
#define REG_CAL_TIMER_8192F				0x003C
#define REG_ACLK_MON_8192F				0x003E
#define REG_GPIO_MUXCFG_8192F			0x0040
#define REG_GPIO_IO_SEL_8192F			0x0042
#define REG_MAC_PINMUX_CFG_8192F		0x0043
#define REG_GPIO_PIN_CTRL_8192F			0x0044
#define REG_GPIO_INTM_8192F				0x0048
#define REG_LEDCFG0_8192F				0x004C
#define REG_LEDCFG1_8192F				0x004D
#define REG_LEDCFG2_8192F				0x004E
#define REG_LEDCFG3_8192F				0x004F
#define REG_FSIMR_8192F					0x0050
#define REG_FSISR_8192F					0x0054
#define REG_HSIMR_8192F					0x0058
#define REG_HSISR_8192F					0x005c
#define REG_GPIO_EXT_CTRL				0x0060
#define REG_PAD_CTRL1_8192F		0x0064
#define REG_MULTI_FUNC_CTRL_8192F		0x0068
#define REG_GPIO_STATUS_8192F			0x006C
#define REG_SDIO_CTRL_8192F				0x0070
#define REG_OPT_CTRL_8192F				0x0074
#define REG_AFE_CTRL_4_8192F		0x0078
#define REG_MCUFWDL_8192F				0x0080
#define REG_8051FW_CTRL_8192F			0x0080
#define REG_HMEBOX_DBG_0_8192F	0x0088
#define REG_HMEBOX_DBG_1_8192F	0x008A
#define REG_HMEBOX_DBG_2_8192F	0x008C
#define REG_HMEBOX_DBG_3_8192F	0x008E
#define REG_WLLPS_CTRL		0x0090
#define REG_HIMR0_8192F					0x00B0
#define REG_HISR0_8192F				0x00B4
#define REG_HIMR1_8192F					0x00B8
#define REG_HISR1_8192F					0x00BC
#define REG_PMC_DBG_CTRL2_8192F			0x00CC
#define	REG_EFUSE_BURN_GNT_8192F		0x00CF
#define REG_HPON_FSM_8192F				0x00EC
#define REG_SYS_CFG1_8192F				0x00F0
#define REG_SYS_CFG2_8192F				0x00FC
#define REG_ROM_VERSION					0x00FD

/* -----------------------------------------------------
 *
 *	0x0100h ~ 0x01FFh	MACTOP General Configuration
 *
 * ----------------------------------------------------- */
#define REG_CR_8192F						0x0100
#define REG_PBP_8192F					0x0104
#define REG_PKT_BUFF_ACCESS_CTRL_8192F	0x0106
#define REG_TRXDMA_CTRL_8192F			0x010C
#define REG_TRXFF_BNDY_8192F			0x0114
#define REG_TRXFF_STATUS_8192F			0x0118
#define REG_RXFF_PTR_8192F				0x011C
#define REG_CPWM_8192F					0x012C
#define REG_FWIMR_8192F					0x0130
#define REG_FWISR_8192F					0x0134
#define REG_FTIMR_8192F					0x0138
#define REG_PKTBUF_DBG_CTRL_8192F		0x0140
#define REG_RXPKTBUF_CTRL_8192F		0x0142
#define REG_PKTBUF_DBG_DATA_L_8192F	0x0144
#define REG_PKTBUF_DBG_DATA_H_8192F	0x0148

#define REG_TC0_CTRL_8192F				0x0150
#define REG_TC1_CTRL_8192F				0x0154
#define REG_TC2_CTRL_8192F				0x0158
#define REG_TC3_CTRL_8192F				0x015C
#define REG_TC4_CTRL_8192F				0x0160
#define REG_TCUNIT_BASE_8192F			0x0164
#define REG_RSVD3_8192F					0x0168
#define REG_C2HEVT_CMD_ID_8192F	0x01A0
#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
#define REG_C2HEVT_CMD_LEN_8192F        0x01AE
#define REG_C2HEVT_CLEAR_8192F			0x01AF
#define REG_TXBUF_WKCAM_OFFSET			0x01B1  /* RTL8192F */
#define REG_MCUTST_1_8192F				0x01C0
#define REG_WOWLAN_WAKE_REASON 0x01C7
#define REG_FMETHR_8192F				0x01C8
#define REG_HMETFR_8192F				0x01CC
#define REG_HMEBOX_0_8192F				0x01D0
#define REG_HMEBOX_1_8192F				0x01D4
#define REG_HMEBOX_2_8192F				0x01D8
#define REG_HMEBOX_3_8192F				0x01DC
#define REG_LLT_INIT_8192F				0x01E0
#define REG_HMEBOX_EXT0_8192F			0x01F0
#define REG_HMEBOX_EXT1_8192F			0x01F4
#define REG_HMEBOX_EXT2_8192F			0x01F8
#define REG_HMEBOX_EXT3_8192F			0x01FC

/* -----------------------------------------------------
 *
 *	0x0200h ~ 0x027Fh	TXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RQPN_8192F					0x0200
#define REG_FIFOPAGE_8192F				0x0204
#define REG_DWBCN0_CTRL_8192F			REG_TDECTRL
#define REG_TXDMA_OFFSET_CHK_8192F	0x020C
#define REG_TXDMA_STATUS_8192F		0x0210
#define REG_RQPN_NPQ_8192F			0x0214
#define REG_DWBCN1_CTRL_8192F			0x0228
#define REG_RQPN_EXQ1_EXQ2			0x0230

/* -----------------------------------------------------
 *
 *	0x0280h ~ 0x02FFh	RXDMA Configuration
 *
 * ----------------------------------------------------- */
#define REG_RXDMA_AGG_PG_TH_8192F		0x0280
#define REG_FW_UPD_RDPTR_8192F		0x0284 /* FW shall update this register before FW write RXPKT_RELEASE_POLL to 1 */
#define REG_RXDMA_CONTROL_8192F		0x0286 /* Control the RX DMA. */
#define REG_RXDMA_STATUS_8192F			0x0288
#define REG_RXDMA_MODE_CTRL_8192F		0x0290
#define REG_EARLY_MODE_CONTROL_8192F	0x02BC
#define REG_RSVD5_8192F					0x02F0
#define REG_RSVD6_8192F					0x02F4

/* -----------------------------------------------------
 *
 *	0x0300h ~ 0x03FFh	PCIe
 *
 * ----------------------------------------------------- */
#define	REG_PCIE_CTRL_REG_8192F		0x0300
#define	REG_INT_MIG_8192F				0x0304	/* Interrupt Migration */
#define	REG_BCNQ_TXBD_DESA_8192F		0x0308	/* TX Beacon Descriptor Address */
#define	REG_MGQ_TXBD_DESA_8192F			0x0310	/* TX Manage Queue Descriptor Address */
#define	REG_VOQ_TXBD_DESA_8192F			0x0318	/* TX VO Queue Descriptor Address */
#define	REG_VIQ_TXBD_DESA_8192F			0x0320	/* TX VI Queue Descriptor Address */
#define	REG_BEQ_TXBD_DESA_8192F			0x0328	/* TX BE Queue Descriptor Address */
#define	REG_BKQ_TXBD_DESA_8192F			0x0330	/* TX BK Queue Descriptor Address */
#define	REG_RXQ_RXBD_DESA_8192F			0x0338	/* RX Queue	Descriptor Address */
#define REG_HI0Q_TXBD_DESA_8192F		0x0340
#define REG_HI1Q_TXBD_DESA_8192F		0x0348
#define REG_HI2Q_TXBD_DESA_8192F		0x0350
#define REG_HI3Q_TXBD_DESA_8192F		0x0358
#define REG_HI4Q_TXBD_DESA_8192F		0x0360
#define REG_HI5Q_TXBD_DESA_8192F		0x0368
#define REG_HI6Q_TXBD_DESA_8192F		0x0370
#define REG_HI7Q_TXBD_DESA_8192F		0x0378
#define	REG_MGQ_TXBD_NUM_8192F			0x0380
#define	REG_RX_RXBD_NUM_8192F			0x0382
#define	REG_VOQ_TXBD_NUM_8192F			0x0384
#define	REG_VIQ_TXBD_NUM_8192F			0x0386
#define	REG_BEQ_TXBD_NUM_8192F			0x0388
#define	REG_BKQ_TXBD_NUM_8192F			0x038A
#define	REG_HI0Q_TXBD_NUM_8192F			0x038C
#define	REG_HI1Q_TXBD_NUM_8192F			0x038E
#define	REG_HI2Q_TXBD_NUM_8192F			0x0390
#define	REG_HI3Q_TXBD_NUM_8192F			0x0392
#define	REG_HI4Q_TXBD_NUM_8192F			0x0394
#define	REG_HI5Q_TXBD_NUM_8192F			0x0396
#define	REG_HI6Q_TXBD_NUM_8192F			0x0398
#define	REG_HI7Q_TXBD_NUM_8192F			0x039A
#define	REG_TSFTIMER_HCI_8192F			0x039C
#define	REG_BD_RW_PTR_CLR_8192F			0x039C

/* Read Write Point */
#define	REG_VOQ_TXBD_IDX_8192F			0x03A0
#define	REG_VIQ_TXBD_IDX_8192F			0x03A4
#define	REG_BEQ_TXBD_IDX_8192F			0x03A8
#define	REG_BKQ_TXBD_IDX_8192F			0x03AC
#define	REG_MGQ_TXBD_IDX_8192F			0x03B0
#define	REG_RXQ_TXBD_IDX_8192F			0x03B4
#define	REG_HI0Q_TXBD_IDX_8192F			0x03B8
#define	REG_HI1Q_TXBD_IDX_8192F			0x03BC
#define	REG_HI2Q_TXBD_IDX_8192F			0x03C0
#define	REG_HI3Q_TXBD_IDX_8192F			0x03C4
#define	REG_HI4Q_TXBD_IDX_8192F			0x03C8
#define	REG_HI5Q_TXBD_IDX_8192F			0x03CC
#define	REG_HI6Q_TXBD_IDX_8192F			0x03D0
#define	REG_HI7Q_TXBD_IDX_8192F			0x03D4
#define	REG_DBI_WDATA_V1_8192F			0x03E8
#define	REG_DBI_RDATA_V1_8192F			0x03EC
#define	REG_DBI_FLAG_V1_8192F			0x03F0
#define REG_MDIO_V1_8192F			0x03F4
#define REG_HCI_MIX_CFG_8192F			0x03FC
#define REG_PCIE_HCPWM_8192FE				0x03D8
#define REG_PCIE_HRPWM_8192FE				0x03DC
#define REG_PCIE_MIX_CFG_8192F				0x03F8

/* -----------------------------------------------------
 *
 *	0x0400h ~ 0x047Fh	Protocol Configuration
 *
 * ----------------------------------------------------- */
#define REG_QUEUELIST_INFO0_8192F		0x0400
#define REG_QUEUELIST_INFO1_8192F		0x0404
#define REG_QUEUELIST_INFO2_8192F		0x0414
#define REG_TXPKT_EMPTY_8192F			0x0418

#define REG_FWHW_TXQ_CTRL_8192F		0x0420
#define REG_HWSEQ_CTRL_8192F			0x0423
#define REG_TXPKTBUF_BCNQ_BDNY_8192F	0x0424
#define REG_TXPKTBUF_MGQ_BDNY_8192F	0x0425
#define REG_LIFECTRL_CTRL_8192F			0x0426
#define REG_MULTI_BCNQ_OFFSET_8192F	0x0427
#define REG_SPEC_SIFS_8192F				0x0428
#define REG_RL_8192F						0x042A
#define REG_TXBF_CTRL_8192F				0x042C
#define REG_DARFRC_8192F				0x0430
#define REG_RARFRC_8192F				0x0438
#define REG_RRSR_8192F					0x0440
#define REG_ARFR0_8192F					0x0444
#define REG_ARFR1_8192F					0x044C
#define REG_CCK_CHECK_8192F				0x0454
#define REG_AMPDU_MAX_TIME_8192F		0x0456
#define REG_TXPKTBUF_BCNQ_BDNY1_8192F	0x0457

#define REG_AMPDU_MAX_LENGTH_8192F	0x0458
#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8192F	0x045D
#define REG_NDPA_OPT_CTRL_8192F		0x045F
#define REG_FAST_EDCA_CTRL_8192F		0x0460
#define REG_RD_RESP_PKT_TH_8192F		0x0463
#define REG_DATA_SC_8192F				0x0483
#define REG_TXRPT_START_OFFSET		0x04AC
#define REG_POWER_STAGE1_8192F		0x04B4
#define REG_POWER_STAGE2_8192F		0x04B8
#define REG_AMPDU_BURST_MODE_8192F	0x04BC
#define REG_PKT_VO_VI_LIFE_TIME_8192F	0x04C0
#define REG_PKT_BE_BK_LIFE_TIME_8192F	0x04C2
#define REG_STBC_SETTING_8192F			0x04C4
#define REG_HT_SINGLE_AMPDU_8192F		0x04C7
#define REG_PROT_MODE_CTRL_8192F		0x04C8
#define REG_MAX_AGGR_NUM_8192F		0x04CA
#define REG_RTS_MAX_AGGR_NUM_8192F	0x04CB
#define REG_BAR_MODE_CTRL_8192F		0x04CC
#define REG_RA_TRY_RATE_AGG_LMT_8192F	0x04CF
#define REG_MACID_PKT_DROP0_8192F		0x04D0
#define REG_MACID_PKT_SLEEP_8192F		0x04D4
#define REG_PRECNT_CTRL_8192F			0x04E5
/* -----------------------------------------------------
 *
 *	0x0500h ~ 0x05FFh	EDCA Configuration
 *
 * ----------------------------------------------------- */
#define REG_EDCA_VO_PARAM_8192F		0x0500
#define REG_EDCA_VI_PARAM_8192F		0x0504
#define REG_EDCA_BE_PARAM_8192F		0x0508
#define REG_EDCA_BK_PARAM_8192F		0x050C
#define REG_BCNTCFG_8192F				0x0510
#define REG_PIFS_8192F					0x0512
#define REG_RDG_PIFS_8192F				0x0513
#define REG_SIFS_CTX_8192F				0x0514
#define REG_SIFS_TRX_8192F				0x0516
#define REG_AGGR_BREAK_TIME_8192F		0x051A
#define REG_SLOT_8192F					0x051B
#define REG_TX_PTCL_CTRL_8192F			0x0520
#define REG_TXPAUSE_8192F				0x0522
#define REG_DIS_TXREQ_CLR_8192F		0x0523
#define REG_RD_CTRL_8192F				0x0524
/*
 * Format for offset 540h-542h:
 *	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
 *	[7:4]:   Reserved.
 *	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
 *	[23:20]: Reserved
 * Description:
 *	              |
 * |<--Setup--|--Hold------------>|
 *	--------------|----------------------
 * |
 * TBTT
 * Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
 * Described by Designer Tim and Bruce, 2011-01-14.
 *   */
#define REG_TBTT_PROHIBIT_8192F			0x0540
#define REG_RD_NAV_NXT_8192F			0x0544
#define REG_NAV_PROT_LEN_8192F			0x0546
#define REG_BCN_CTRL_8192F				0x0550
#define REG_BCN_CTRL_1_8192F			0x0551
#define REG_MBID_NUM_8192F				0x0552
#define REG_DUAL_TSF_RST_8192F			0x0553
#define REG_BCN_INTERVAL_8192F			0x0554
#define REG_DRVERLYINT_8192F			0x0558
#define REG_BCNDMATIM_8192F			0x0559
#define REG_ATIMWND_8192F				0x055A
#define REG_USTIME_TSF_8192F			0x055C
#define REG_BCN_MAX_ERR_8192F			0x055D
#define REG_RXTSF_OFFSET_CCK_8192F		0x055E
#define REG_RXTSF_OFFSET_OFDM_8192F	0x055F	
#define REG_TSFTR_8192F					0x0560
#define REG_CTWND_8192F					0x0572
#define REG_SECONDARY_CCA_CTRL_8192F	0x0577
#define REG_PSTIMER_8192F				0x0580
#define REG_TIMER0_8192F				0x0584
#define REG_TIMER1_8192F				0x0588
#define REG_ACMHWCTRL_8192F			0x05C0
#define REG_SCH_TXCMD_8192F			0x05F8

/* -----------------------------------------------------
 *
 *	0x0600h ~ 0x07FFh	WMAC Configuration
 *
 * ----------------------------------------------------- */
#define REG_MAC_CR_8192F				0x0600
#define REG_TCR_8192F					0x0604
#define REG_RCR_8192F					0x0608
#define REG_RX_PKT_LIMIT_8192F			0x060C
#define REG_RX_DLK_TIME_8192F			0x060D
#define REG_RX_DRVINFO_SZ_8192F	0x060F

#define REG_MACID_8192F					0x0610
#define REG_BSSID_8192F					0x0618
#define REG_MAR_8192F					0x0620
#define REG_MBIDCAMCFG_8192F			0x0628


#define REG_USTIME_EDCA_8192F			0x0638
#define REG_MAC_SPEC_SIFS_8192F		0x063A
#define REG_RESP_SIFP_CCK_8192F			0x063C
#define REG_RESP_SIFS_OFDM_8192F		0x063E
#define REG_ACKTO_8192F					0x0640
#define REG_CTS2TO_8192F				0x0641
#define REG_EIFS_8192F					0x0642

#define REG_NAV_UPPER_8192F			0x0652	/* unit of 128*/
#define REG_TRXPTCL_CTL_8192F			0x0668

/* Security*/
#define REG_CAMCMD_8192F				0x0670
#define REG_CAMWRITE_8192F				0x0674
#define REG_CAMREAD_8192F				0x0678
#define REG_CAMDBG_8192F				0x067C
#define REG_SECCFG_8192F				0x0680

/* Power */
#define REG_WOW_CTRL_8192F				0x0690
#define REG_PS_RX_INFO_8192F			0x0692
#define REG_UAPSD_TID_8192F				0x0693
#define REG_WKFMCAM_CMD_8192F			0x0698
#define REG_WKFMCAM_NUM_8192F			0x0698
#define REG_WKFMCAM_RWD_8192F			0x069C
#define REG_RXFLTMAP0_8192F				0x06A0
#define REG_RXFLTMAP1_8192F				0x06A2
#define REG_RXFLTMAP2_8192F				0x06A4
#define REG_BCN_PSR_RPT_8192F			0x06A8
#define REG_BT_COEX_TABLE_8192F		0x06C0
#define REG_BFMER0_INFO_8192F			0x06E4
#define REG_BFMER1_INFO_8192F			0x06EC
#define REG_CSI_RPT_PARAM_BW20_8192F	0x06F4
#define REG_CSI_RPT_PARAM_BW40_8192F	0x06F8
#define REG_CSI_RPT_PARAM_BW80_8192F	0x06FC

/* Hardware Port 2 */
#define REG_MACID1_8192F				0x0700
#define REG_BSSID1_8192F				0x0708
#define REG_BFMEE_SEL_8192F				0x0714
#define REG_SND_PTCL_CTRL_8192F		0x0718

/* LTR */
#define REG_LTR_CTRL_BASIC_8192F		0x07A4
#define REG_LTR_IDLE_LATENCY_V1_8192F		0x0798
#define REG_LTR_ACTIVE_LATENCY_V1_8192F	0x079C

/* GPIO Control */
#define REG_SW_GPIO_SHARE_CTRL_8192F	0x1038
#define REG_SW_GPIO_A_OUT_8192F			0x1040
#define REG_SW_GPIO_A_OEN_8192F			0x1044

/* ************************************************************
 * SDIO Bus Specification
 * ************************************************************ */

/* -----------------------------------------------------
 * SDIO CMD Address Mapping
 * ----------------------------------------------------- */

/* -----------------------------------------------------
 * I/O bus domain (Host)
 * ----------------------------------------------------- */
/*SDIO Host Interrupt Mask Register */
#define SDIO_HIMR_CRCERR_MSK			BIT(31)
/* SDIO Host Interrupt Service Routine */
#define SDIO_HISR_HEISR_IND_INT		BIT(28)
#define SDIO_HISR_HSISR2_IND_INT		BIT(29)
#define SDIO_HISR_HSISR3_IND_INT		BIT(30)
#define SDIO_HISR_SDIO_CRCERR			BIT(31)
/* -----------------------------------------------------
 * SDIO register
 * ----------------------------------------------------- */
#define SDIO_REG_HCPWM1_8192F	0x038/* HCI Current Power Mode 1 */
#define SDIO_REG_FREE_TXPG1_8192F		0x0020 /* Free Tx Buffer Page1*/
#define SDIO_REG_FREE_TXPG2_8192F		0x0024 /* Free Tx Buffer Page1*/
#define SDIO_REG_FREE_TXPG3_8192F		0x0028
#define SDIO_REG_AC_OQT_FREEPG_8192F		0x002A
#define SDIO_REG_NOAC_OQT_FREEPG_8192F		0x002B
/* ****************************************************************************
 *	8192F Regsiter Bit and Content definition
 * **************************************************************************** */

#define BIT_USB_RXDMA_AGG_EN	BIT(31)
#define RXDMA_AGG_MODE_EN		BIT(1)

#ifdef CONFIG_WOWLAN
	#define RXPKT_RELEASE_POLL		BIT(16)
	#define RXDMA_IDLE				BIT(17)
	#define RW_RELEASE_EN			BIT(18)
#endif

#ifdef CONFIG_AMPDU_PRETX_CD
/*#define BIT_ERRORHDL_INT			BIT(2)*/
/*#define BIT_MACTX_ERR_3			BIT(4)*/
#define BIT_PRE_TX_CMD_8192F		BIT(6)
#define BIT_EN_PRECNT_8192F		BIT(11)
#endif
/* SDIO Host Interrupt Service Routine */
#define SDIO_HISR_HEISR_IND_INT	BIT(28)
#define SDIO_HISR_HSISR2_IND_INT	BIT(29)
#define SDIO_HISR_HSISR3_IND_INT	BIT(30)
#define SDIO_HISR_SDIO_CRCERR		BIT(31)

/* PCIE Host Interrupt Mask Register (HIMR) */
#ifdef CONFIG_PCI_HCI
/* ----------------------------------------------------------------------------
 *   * 8192F IMR/ISR bits							(offset 0xB0,  8bits)
 *     * ---------------------------------------------------------------------------- */

#define IMR_DISABLED_8192F					0
/* IMR DW0(0x00B0-00B3) Bit 0-31 */
#define IMR_TIMER2_8192F					BIT(31)         /* Timeout interrupt 2 */
#define IMR_TIMER1_8192F					BIT(30)		/* Timeout interrupt 1 */
#define IMR_PSTIMEOUT_8192F				BIT(29)		/* Power Save Time Out Interrupt */
#define IMR_GTINT4_8192F					BIT(28)		/* When GTIMER4 expires, this bit is set to 1 */
#define IMR_GTINT3_8192F					BIT(27)		/* When GTIMER3 expires, this bit is set to 1 */
#define IMR_TXBCN0ERR_8192F				BIT(26)		/* Transmit Beacon0 Error */
#define IMR_TXBCN0OK_8192F				BIT(25)		/* Transmit Beacon0 OK */
#define IMR_TSF_BIT32_TOGGLE_8192F		BIT(24)		/* TSF Timer BIT32 toggle indication interrupt */
#define IMR_BCNDMAINT0_8192F				BIT(20)		/* Beacon DMA Interrupt 0 */
#define IMR_BCNDERR0_8192F				BIT(16)		/* Beacon Queue DMA OK0 */
#define IMR_HSISR_IND_ON_INT_8192F		BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1) */
#define IMR_BCNDMAINT_E_8192F				BIT(14)		/* Beacon DMA Interrupt Extension for Win7 */
#define IMR_ATIMEND_8192F					BIT(12)         /* CTWidnow End or ATIM Window End */
#define IMR_C2HCMD_8192F					BIT(10)		/* CPU to Host Command INT status, Write 1 clear */
#define IMR_CPWM2_8192F					BIT(9)          /* CPU power mode exchange INT status, Write 1 clear */
#define IMR_CPWM_8192F						BIT(8)		/* CPU power mode exchange INT status, Write 1 clear */
#define IMR_HIGHDOK_8192F					BIT(7)		/* High Queue DMA OK */
#define IMR_MGNTDOK_8192F					BIT(6)		/* Management Queue DMA OK */
#define IMR_BKDOK_8192F					BIT(5)		/* AC_BK DMA OK */
#define IMR_BEDOK_8192F					BIT(4)		/* AC_BE DMA OK */
#define IMR_VIDOK_8192F					BIT(3)		/* AC_VI DMA OK */
#define IMR_VODOK_8192F					BIT(2)		/* AC_VO DMA OK */
#define IMR_RDU_8192F						BIT(1)		/* Rx Descriptor Unavailable */
#define IMR_ROK_8192F						BIT(0)		/* Receive DMA OK */

/* IMR DW1(0x00B4-00B7) Bit 0-31 */
#define IMR_MCUERR_8192F					BIT(28)
#define IMR_BCNDMAINT7_8192F				BIT(27) 		/* Beacon DMA Interrupt 7 */
#define IMR_BCNDMAINT6_8192F				BIT(26)		/* Beacon DMA Interrupt 6 */
#define IMR_BCNDMAINT5_8192F				BIT(25)		/* Beacon DMA Interrupt 5 */
#define IMR_BCNDMAINT4_8192F				BIT(24)		/* Beacon DMA Interrupt 4 */
#define IMR_BCNDMAINT3_8192F				BIT(23)		/* Beacon DMA Interrupt 3 */
#define IMR_BCNDMAINT2_8192F				BIT(22)		/* Beacon DMA Interrupt 2 */
#define IMR_BCNDMAINT1_8192F 				BIT(21)		/* Beacon DMA Interrupt 1 */
#define IMR_BCNDOK7_8192F 					BIT(20)		/* Beacon Queue DMA OK Interrup 7 */
#define IMR_BCNDOK6_8192F					BIT(19) 		/* Beacon Queue DMA OK Interrup 6 */
#define IMR_BCNDOK5_8192F					BIT(18)		/* Beacon Queue DMA OK Interrup 5 */
#define IMR_BCNDOK4_8192F					BIT(17)		/* Beacon Queue DMA OK Interrup 4 */
#define IMR_BCNDOK3_8192F					BIT(16)		/* Beacon Queue DMA OK Interrup 3 */
#define IMR_BCNDOK2_8192F					BIT(15)		/* Beacon Queue DMA OK Interrup 2 */
#define IMR_BCNDOK1_8192F					BIT(14)		/* Beacon Queue DMA OK Interrup 1 */
#define IMR_ATIMEND_E_8192F				BIT(13)		/* ATIM Window End Extension for Win7 */
#define IMR_TXERR_8192F					BIT(11)		/* Tx Error Flag Interrupt status, write 1 clear. */
#define IMR_RXERR_8192F					BIT(10)		/* Rx Error Flag INT status, Write 1 clear */
#define IMR_TXFOVW_8192F					BIT(9)		/* Transmit FIFO Overflow */
#define IMR_RXFOVW_8192F 					BIT(8)		/* Receive FIFO Overflow */

/* #define IMR_RX_MASK			(IMR_ROK_8192F|IMR_RDU_8192F|IMR_RXFOVW_8192F) */
#define IMR_TX_MASK			(IMR_VODOK_8192F | IMR_VIDOK_8192F | IMR_BEDOK_8192F | IMR_BKDOK_8192F | IMR_MGNTDOK_8192F | IMR_HIGHDOK_8192F)
#define RT_BCN_INT_MASKS		(IMR_BCNDMAINT0_8192F | IMR_TXBCN0OK_8192F | IMR_TXBCN0ERR_8192F | IMR_BCNDERR0_8192F)
#define RT_AC_INT_MASKS		(IMR_VIDOK_8192F | IMR_VODOK_8192F | IMR_BEDOK_8192F | IMR_BKDOK_8192F)
#endif /* CONFIG_PCI_HCI */

/* 2 HSISR
 * interrupt mask which needs to clear */
#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
		HSISR_SPS_OCP_INT |\
		HSISR_RON_INT |\
		HSISR_PDNINT |\
		HSISR_GPIO9_INT)

#define _TXDMA_HIQ_MAP_8192F(x)			(((x) & 0x7) << 19)
#define _TXDMA_MGQ_MAP_8192F(x)			(((x) & 0x7) << 16)
#define _TXDMA_BKQ_MAP_8192F(x)			(((x) & 0x7) << 13)
#define _TXDMA_BEQ_MAP_8192F(x)			(((x) & 0x7) << 10)
#define _TXDMA_VIQ_MAP_8192F(x)			(((x) & 0x7) << 7)
#define _TXDMA_VOQ_MAP_8192F(x)			(((x) & 0x7) << 4)

/*mac queue info*/
#define QUEUE_TOTAL_NUM	20/*reg414h : 0~f ac queue 0x10~0x13MGQ HIQ BCNQ CMDQ*/
#define QUEUE_ACQ_NUM		16 
#define QUEUE_INDEX_MGQ		0x10
#define QUEUE_INDEX_HIQ		0x11
#define QUEUE_INDEX_BCNQ	0x12
#define QUEUE_INDEX_CMDQ	0x13
#endif /* __RTL8192F_SPEC_H__ */
                                                                                          rtl8822bu/src/include/HalVerDef.h                                                                   0000644 0001750 0001750 00000025414 14214766567 015403  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __HAL_VERSION_DEF_H__
#define __HAL_VERSION_DEF_H__

#define TRUE	_TRUE
#define FALSE	_FALSE

/* HAL_IC_TYPE_E */
typedef enum tag_HAL_IC_Type_Definition {
	CHIP_8192S	=	0,
	CHIP_8188C	=	1,
	CHIP_8192C	=	2,
	CHIP_8192D	=	3,
	CHIP_8723A	=	4,
	CHIP_8188E	=	5,
	CHIP_8812	=	6,
	CHIP_8821	=	7,
	CHIP_8723B	=	8,
	CHIP_8192E	=	9,
	CHIP_8814A	=	10,
	CHIP_8703B	=	11,
	CHIP_8188F	=	12,
	CHIP_8822B	=	13,
	CHIP_8723D	=	14,
	CHIP_8821C	=	15,
	CHIP_8710B	=	16,
	CHIP_8192F	=	17,
	CHIP_8188GTV =	18,
	CHIP_8822C	=	19,
	CHIP_8814B	=	20,
} HAL_IC_TYPE_E;

/* HAL_CHIP_TYPE_E */
typedef enum tag_HAL_CHIP_Type_Definition {
	TEST_CHIP		=	0,
	NORMAL_CHIP	=	1,
	FPGA			=	2,
} HAL_CHIP_TYPE_E;

/* HAL_CUT_VERSION_E */
typedef enum tag_HAL_Cut_Version_Definition {
	A_CUT_VERSION		=	0,
	B_CUT_VERSION		=	1,
	C_CUT_VERSION		=	2,
	D_CUT_VERSION		=	3,
	E_CUT_VERSION		=	4,
	F_CUT_VERSION		=	5,
	G_CUT_VERSION		=	6,
	H_CUT_VERSION		=	7,
	I_CUT_VERSION		=	8,
	J_CUT_VERSION		=	9,
	K_CUT_VERSION		=	10,
} HAL_CUT_VERSION_E;

/* HAL_Manufacturer */
typedef enum tag_HAL_Manufacturer_Version_Definition {
	CHIP_VENDOR_TSMC	=	0,
	CHIP_VENDOR_UMC	=	1,
	CHIP_VENDOR_SMIC	=	2,
} HAL_VENDOR_E;

typedef enum tag_HAL_RF_Type_Definition {
	RF_TYPE_1T1R	=	0,
	RF_TYPE_1T2R	=	1,
	RF_TYPE_2T2R	=	2,
	RF_TYPE_2T3R	=	3,
	RF_TYPE_2T4R	=	4,
	RF_TYPE_3T3R	=	5,
	RF_TYPE_3T4R	=	6,
	RF_TYPE_4T4R	=	7,
} HAL_RF_TYPE_E;

typedef	struct tag_HAL_VERSION {
	HAL_IC_TYPE_E		ICType;
	HAL_CHIP_TYPE_E		ChipType;
	HAL_CUT_VERSION_E	CUTVersion;
	HAL_VENDOR_E		VendorType;
	HAL_RF_TYPE_E		RFType;
	u8					ROMVer;
} HAL_VERSION, *PHAL_VERSION;

/* VERSION_8192C			VersionID;
 * HAL_VERSION			VersionID; */

/* Get element */
#define GET_CVID_IC_TYPE(version)			((HAL_IC_TYPE_E)(((HAL_VERSION)version).ICType))
#define GET_CVID_CHIP_TYPE(version)			((HAL_CHIP_TYPE_E)(((HAL_VERSION)version).ChipType))
#define GET_CVID_RF_TYPE(version)			((HAL_RF_TYPE_E)(((HAL_VERSION)version).RFType))
#define GET_CVID_MANUFACTUER(version)		((HAL_VENDOR_E)(((HAL_VERSION)version).VendorType))
#define GET_CVID_CUT_VERSION(version)		((HAL_CUT_VERSION_E)(((HAL_VERSION)version).CUTVersion))
#define GET_CVID_ROM_VERSION(version)		((((HAL_VERSION)version).ROMVer) & ROM_VERSION_MASK)

/* ----------------------------------------------------------------------------
 * Common Macro. --
 * ----------------------------------------------------------------------------
 * HAL_VERSION VersionID */

/* HAL_IC_TYPE_E */
#if 0
	#define IS_81XXC(version)				(((GET_CVID_IC_TYPE(version) == CHIP_8192C) || (GET_CVID_IC_TYPE(version) == CHIP_8188C)) ? TRUE : FALSE)
	#define IS_8723_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723A) ? TRUE : FALSE)
	#define IS_92D(version)					((GET_CVID_IC_TYPE(version) == CHIP_8192D) ? TRUE : FALSE)
#endif

#define IS_8188E(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188E) ? TRUE : FALSE)
#define IS_8188F(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188F) ? TRUE : FALSE)
#define IS_8188GTV(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188GTV) ? TRUE : FALSE)
#define IS_8192E(version)					((GET_CVID_IC_TYPE(version) == CHIP_8192E) ? TRUE : FALSE)
#define IS_8812_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8812) ? TRUE : FALSE)
#define IS_8821_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8821) ? TRUE : FALSE)
#define IS_8814A_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8814A) ? TRUE : FALSE)
#define IS_8723B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723B) ? TRUE : FALSE)
#define IS_8703B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8703B) ? TRUE : FALSE)
#define IS_8822B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8822B) ? TRUE : FALSE)
#define IS_8821C_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8821C) ? TRUE : FALSE)
#define IS_8723D_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723D) ? TRUE : FALSE)
#define IS_8710B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8710B) ? TRUE : FALSE)
#define IS_8822C_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8822C) ? TRUE : FALSE)
#define IS_8814B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8814B) ? TRUE : FALSE)

#define IS_8192F_SERIES(version)\
	((GET_CVID_IC_TYPE(version) == CHIP_8192F) ? TRUE : FALSE)
/* HAL_CHIP_TYPE_E */
#define IS_TEST_CHIP(version)			((GET_CVID_CHIP_TYPE(version) == TEST_CHIP) ? TRUE : FALSE)
#define IS_NORMAL_CHIP(version)			((GET_CVID_CHIP_TYPE(version) == NORMAL_CHIP) ? TRUE : FALSE)

/* HAL_CUT_VERSION_E */
#define IS_A_CUT(version)				((GET_CVID_CUT_VERSION(version) == A_CUT_VERSION) ? TRUE : FALSE)
#define IS_B_CUT(version)				((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? TRUE : FALSE)
#define IS_C_CUT(version)				((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? TRUE : FALSE)
#define IS_D_CUT(version)				((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? TRUE : FALSE)
#define IS_E_CUT(version)				((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? TRUE : FALSE)
#define IS_F_CUT(version)				((GET_CVID_CUT_VERSION(version) == F_CUT_VERSION) ? TRUE : FALSE)
#define IS_I_CUT(version)				((GET_CVID_CUT_VERSION(version) == I_CUT_VERSION) ? TRUE : FALSE)
#define IS_J_CUT(version)				((GET_CVID_CUT_VERSION(version) == J_CUT_VERSION) ? TRUE : FALSE)
#define IS_K_CUT(version)				((GET_CVID_CUT_VERSION(version) == K_CUT_VERSION) ? TRUE : FALSE)

/* HAL_VENDOR_E */
#define IS_CHIP_VENDOR_TSMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_TSMC) ? TRUE : FALSE)
#define IS_CHIP_VENDOR_UMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_UMC) ? TRUE : FALSE)
#define IS_CHIP_VENDOR_SMIC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_SMIC) ? TRUE : FALSE)

/* HAL_RF_TYPE_E */
#define IS_1T1R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T1R) ? TRUE : FALSE)
#define IS_1T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R) ? TRUE : FALSE)
#define IS_2T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R) ? TRUE : FALSE)
#define IS_2T3R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T3R) ? TRUE : FALSE)
#define IS_2T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T4R) ? TRUE : FALSE)
#define IS_3T3R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T3R) ? TRUE : FALSE)
#define IS_3T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T4R) ? TRUE : FALSE)
#define IS_4T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_4T4R) ? TRUE : FALSE)



/* ----------------------------------------------------------------------------
 * Chip version Macro. --
 * ---------------------------------------------------------------------------- */
#if 0
	#define IS_81XXC_TEST_CHIP(version)		((IS_81XXC(version) && (!IS_NORMAL_CHIP(version))) ? TRUE : FALSE)

	#define IS_92C_SERIAL(version)					((IS_81XXC(version) && IS_2T2R(version)) ? TRUE : FALSE)
	#define IS_81xxC_VENDOR_UMC_A_CUT(version)	(IS_81XXC(version) ? (IS_CHIP_VENDOR_UMC(version) ? (IS_A_CUT(version) ? TRUE : FALSE) : FALSE) : FALSE)
	#define IS_81xxC_VENDOR_UMC_B_CUT(version)	(IS_81XXC(version) ? (IS_CHIP_VENDOR_UMC(version) ? (IS_B_CUT(version) ? TRUE : FALSE) : FALSE) : FALSE)
	#define IS_81xxC_VENDOR_UMC_C_CUT(version)	(IS_81XXC(version) ? (IS_CHIP_VENDOR_UMC(version) ? (IS_C_CUT(version) ? TRUE : FALSE) : FALSE) : FALSE)

	#define IS_NORMAL_CHIP92D(version)		((IS_92D(version)) ? ((GET_CVID_CHIP_TYPE(version) == NORMAL_CHIP) ? TRUE : FALSE) : FALSE)

	#define IS_92D_SINGLEPHY(version)		((IS_92D(version)) ? (IS_2T2R(version) ? TRUE : FALSE) : FALSE)
	#define IS_92D_C_CUT(version)			((IS_92D(version)) ? (IS_C_CUT(version) ? TRUE : FALSE) : FALSE)
	#define IS_92D_D_CUT(version)			((IS_92D(version)) ? (IS_D_CUT(version) ? TRUE : FALSE) : FALSE)
	#define IS_92D_E_CUT(version)			((IS_92D(version)) ? (IS_E_CUT(version) ? TRUE : FALSE) : FALSE)

	#define IS_8723A_A_CUT(version)				((IS_8723_SERIES(version)) ? (IS_A_CUT(version) ? TRUE : FALSE) : FALSE)
	#define IS_8723A_B_CUT(version)				((IS_8723_SERIES(version)) ? (IS_B_CUT(version) ? TRUE : FALSE) : FALSE)
#endif
#define IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)		((IS_8188E(GET_HAL_DATA(_Adapter)->version_id)) ? ((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->version_id) >= I_CUT_VERSION) ? TRUE : FALSE) : FALSE)
#define IS_VENDOR_8812A_TEST_CHIP(_Adapter)		((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? FALSE : TRUE) : FALSE)
#define IS_VENDOR_8812A_MP_CHIP(_Adapter)		((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? TRUE : FALSE) : FALSE)
#define IS_VENDOR_8812A_C_CUT(_Adapter)			((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->version_id) == C_CUT_VERSION) ? TRUE : FALSE) : FALSE)

#define IS_VENDOR_8821A_TEST_CHIP(_Adapter)	((IS_8821_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? FALSE : TRUE) : FALSE)
#define IS_VENDOR_8821A_MP_CHIP(_Adapter)		((IS_8821_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? TRUE : FALSE) : FALSE)

#define IS_VENDOR_8192E_B_CUT(_Adapter)		((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->version_id) == B_CUT_VERSION) ? TRUE : FALSE)

#define IS_VENDOR_8723B_TEST_CHIP(_Adapter)	((IS_8723B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? FALSE : TRUE) : FALSE)
#define IS_VENDOR_8723B_MP_CHIP(_Adapter)		((IS_8723B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? TRUE : FALSE) : FALSE)

#define IS_VENDOR_8703B_TEST_CHIP(_Adapter)	((IS_8703B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? FALSE : TRUE) : FALSE)
#define IS_VENDOR_8703B_MP_CHIP(_Adapter)		((IS_8703B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? TRUE : FALSE) : FALSE)
#define IS_VENDOR_8814A_TEST_CHIP(_Adapter)	((IS_8814A_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? FALSE : TRUE) : FALSE)
#define IS_VENDOR_8814A_MP_CHIP(_Adapter)		((IS_8814A_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? TRUE : FALSE) : FALSE)

#endif
                                                                                                                                                                                                                                                    rtl8822bu/src/include/drv_types_xp.h                                                                0000644 0001750 0001750 00000004756 14214766567 016337  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __DRV_TYPES_XP_H__
#define __DRV_TYPES_XP_H__

#include <drv_conf.h>
#include <osdep_service.h>



#define MAX_MCAST_LIST_NUM					32



/* for ioctl */
#define MAKE_DRIVER_VERSION(_MainVer, _MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)

#define NIC_HEADER_SIZE				14			/* !< can be moved to typedef.h */
#define NIC_MAX_PACKET_SIZE			1514		/* !< can be moved to typedef.h */
#define NIC_MAX_SEND_PACKETS			10		/* max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h */
#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0, 001)	/* !< can be moved to typedef.h */
#define NIC_MAX_PACKET_SIZE			1514		/* !< can be moved to typedef.h */


#undef ON_VISTA
/* added by Jackson */
#ifndef ON_VISTA
	/*
	* Bus driver versions
	*   */

	#define SDBUS_DRIVER_VERSION_1          0x100
	#define SDBUS_DRIVER_VERSION_2          0x200

	#define    SDP_FUNCTION_TYPE	4
	#define    SDP_BUS_DRIVER_VERSION 5
	#define    SDP_BUS_WIDTH 6
	#define    SDP_BUS_CLOCK 7
	#define    SDP_BUS_INTERFACE_CONTROL 8
	#define    SDP_HOST_BLOCK_LENGTH 9
	#define    SDP_FUNCTION_BLOCK_LENGTH 10
	#define    SDP_FN0_BLOCK_LENGTH 11
	#define    SDP_FUNCTION_INT_ENABLE 12
#endif


typedef struct _MP_REG_ENTRY {

	NDIS_STRING		RegName;	/* variable name text */
	BOOLEAN			bRequired;	/* 1->required, 0->optional */

	u8			Type;		/* NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString */
	uint			FieldOffset;	/* offset to MP_ADAPTER field */
	uint			FieldSize;	/* size (in bytes) of the field */

#ifdef UNDER_AMD64
	u64			Default;
#else
	u32			Default;		/* default value to use */
#endif

	u32			Min;			/* minimum value allowed */
	u32			Max;		/* maximum value allowed */
} MP_REG_ENTRY, *PMP_REG_ENTRY;


typedef struct _OCTET_STRING {
	u8      *Octet;
	u16      Length;
} OCTET_STRING, *POCTET_STRING;





#endif
                  rtl8822bu/src/include/h2clbk.h                                                                      0000644 0001750 0001750 00000001517 14214766567 014746  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/


#define _H2CLBK_H_


void _lbk_cmd(PADAPTER Adapter);

void _lbk_rsp(PADAPTER Adapter);

void _lbk_evt(PADAPTER Adapter);

void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
                                                                                                                                                                                 rtl8822bu/src/include/Hal8812PhyCfg.h                                                               0000644 0001750 0001750 00000006463 14214766567 015736  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __INC_HAL8812PHYCFG_H__
#define __INC_HAL8812PHYCFG_H__


/*--------------------------Define Parameters-------------------------------*/
#define LOOP_LIMIT				5
#define MAX_STALL_TIME			50		/* us */
#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
#define MAX_TXPWR_IDX_NMODE_92S	63
#define Reset_Cnt_Limit			3


#ifdef CONFIG_PCI_HCI
	#define MAX_AGGR_NUM	0x0B
#else
	#define MAX_AGGR_NUM	0x07
#endif /* CONFIG_PCI_HCI */


/*--------------------------Define Parameters-------------------------------*/

/*------------------------------Define structure----------------------------*/


/* BB/RF related */

/*------------------------------Define structure----------------------------*/


/*------------------------Export global variable----------------------------*/
/*------------------------Export global variable----------------------------*/


/*------------------------Export Marco Definition---------------------------*/
/*------------------------Export Marco Definition---------------------------*/


/*--------------------------Exported Function prototype---------------------*/
/*
 * BB and RF register read/write
 *   */
u32	PHY_QueryBBReg8812(PADAPTER	Adapter,
				u32			RegAddr,
				u32			BitMask);
void	PHY_SetBBReg8812(PADAPTER		Adapter,
				u32			RegAddr,
				u32			BitMask,
				u32			Data);
u32	PHY_QueryRFReg8812(PADAPTER	Adapter,
				enum rf_path	eRFPath,
				u32			RegAddr,
				u32			BitMask);
void	PHY_SetRFReg8812(PADAPTER		Adapter,
				enum rf_path	eRFPath,
				u32			RegAddr,
				u32			BitMask,
				u32			Data);

/*
 * Initialization related function
 *
 * MAC/BB/RF HAL config */
int	PHY_MACConfig8812(PADAPTER	Adapter);
int	PHY_BBConfig8812(PADAPTER	Adapter);
void	PHY_BB8812_Config_1T(PADAPTER	Adapter);
int	PHY_RFConfig8812(PADAPTER	Adapter);

/* RF config */

s32
PHY_SwitchWirelessBand8812(
		PADAPTER		Adapter,
		u8			Band
);

/*
 * BB TX Power R/W
 *   */
void	PHY_SetTxPowerLevel8812(PADAPTER	Adapter, u8	Channel);

bool phy_get_txpwr_target_skip_by_rate_8812a(_adapter *adapter, enum MGN_RATE rate);

u32 phy_get_tx_bb_swing_8812a(
		PADAPTER	Adapter,
		BAND_TYPE	Band,
		enum rf_path	RFPath
);

void
PHY_SetTxPowerIndex_8812A(
		PADAPTER		Adapter,
		u32				PowerIndex,
		enum rf_path		RFPath,
		u8				Rate
);

/*
 * channel switch related funciton
 *   */
void
PHY_SetSwChnlBWMode8812(
		PADAPTER			Adapter,
		u8					channel,
		enum channel_width	Bandwidth,
		u8					Offset40,
		u8					Offset80
);

/*
 * BB/MAC/RF other monitor API
 *   */

void
phy_set_rf_path_switch_8812a(
		struct dm_struct		*phydm,
		bool		bMain
);

/*--------------------------Exported Function prototype---------------------*/
#endif /* __INC_HAL8192CPHYCFG_H */
                                                                                                                                                                                                             rtl8822bu/src/include/rtl8710b_led.h                                                                0000644 0001750 0001750 00000003036 14214766567 015706  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 /******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 *****************************************************************************/
#ifndef __RTL8710B_LED_H__
#define __RTL8710B_LED_H__

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#ifdef CONFIG_RTW_SW_LED
/* ********************************************************************************
 * Interface to manipulate LED objects.
 * ******************************************************************************** */
#ifdef CONFIG_USB_HCI
	void rtl8710bu_InitSwLeds(PADAPTER padapter);
	void rtl8710bu_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_SDIO_HCI
	void rtl8710bs_InitSwLeds(PADAPTER padapter);
	void rtl8710bs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_GSPI_HCI
	void rtl8710bs_InitSwLeds(PADAPTER padapter);
	void rtl8710bs_DeInitSwLeds(PADAPTER padapter);
#endif
#ifdef CONFIG_PCI_HCI
	void rtl8710be_InitSwLeds(PADAPTER padapter);
	void rtl8710be_DeInitSwLeds(PADAPTER padapter);
#endif

#endif /*#ifdef CONFIG_RTW_SW_LED*/
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  rtl8822bu/src/halmac.mk                                                                             0000644 0001750 0001750 00000003721 14214766567 013562  0                                                                                                    ustar   ai7688                          ai7688                                                                                                                                                                                                                 # All needed files would be added to _HAL_INTFS_FILES, and it would include
# hal/hal_halmac.c and all related files in directory hal/halmac/.
# Before include this makefile, be sure interface (CONFIG_*_HCI) and IC
# (CONFIG_RTL*) setting are all ready!

# Base directory
path_hm := hal/halmac
# Level 1 directory
path_hm_d1 := $(path_hm)/halmac_88xx

ifeq ($(CONFIG_PCI_HCI), y)
pci := y
endif
ifeq ($(CONFIG_SDIO_HCI), y)
sdio := y
endif
ifeq ($(CONFIG_USB_HCI), y)
usb := y
endif

ifeq ($(CONFIG_RTL8822B), y)
ic := 8822b
endif

ifeq ($(CONFIG_RTL8822C), y)
ic := 8822c
endif

ifeq ($(CONFIG_RTL8821C), y)
ic := 8821c
endif

ifeq ($(CONFIG_RTL8814B), y)
v1 := _v1
ic := 8814b
endif

ifeq ($(v1), _v1)
d2all :=
else
d2all := y
endif

halmac-y +=		$(path_hm)/halmac_api.o
halmac-y +=		$(path_hm)/halmac_dbg.o

# Modify level 1 directory if needed
path_hm_d1 := $(path_hm_d1)$(v1)
halmac-y +=		$(path_hm_d1)/halmac_bb_rf_88xx$(v1).o \
			$(path_hm_d1)/halmac_cfg_wmac_88xx$(v1).o \
			$(path_hm_d1)/halmac_common_88xx$(v1).o \
			$(path_hm_d1)/halmac_efuse_88xx$(v1).o \
			$(path_hm_d1)/halmac_flash_88xx$(v1).o \
			$(path_hm_d1)/halmac_fw_88xx$(v1).o \
			$(path_hm_d1)/halmac_gpio_88xx$(v1).o \
			$(path_hm_d1)/halmac_init_88xx$(v1).o \
			$(path_hm_d1)/halmac_mimo_88xx$(v1).o
halmac-$(pci) += 	$(path_hm_d1)/halmac_pcie_88xx$(v1).o
halmac-$(sdio) +=	$(path_hm_d1)/halmac_sdio_88xx$(v1).o
halmac-$(usb) += 	$(path_hm_d1)/halmac_usb_88xx$(v1).o

# Level 2 directory
path_hm_d2 := $(path_hm_d1)/halmac_$(ic)
halmac-$(d2all) +=	$(path_hm_d2)/halmac_cfg_wmac_$(ic).o \
			$(path_hm_d2)/halmac_common_$(ic).o

halmac-y	+=	$(path_hm_d2)/halmac_gpio_$(ic).o \
			$(path_hm_d2)/halmac_init_$(ic).o \
			$(path_hm_d2)/halmac_phy_$(ic).o \
			$(path_hm_d2)/halmac_pwr_seq_$(ic).o
halmac-$(pci) += 	$(path_hm_d2)/halmac_pcie_$(ic).o
halmac-$(sdio) +=	$(path_hm_d2)/halmac_sdio_$(ic).o
halmac-$(usb) += 	$(path_hm_d2)/halmac_usb_$(ic).o

_HAL_INTFS_FILES +=	hal/hal_halmac.o
_HAL_INTFS_FILES +=	$(halmac-y)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               